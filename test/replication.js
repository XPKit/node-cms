/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS201: Simplify complex destructure assignments
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */
const CMS = require('../')
const express = require('express')
const chai = require('chai')
const _ = require('lodash')
const request = require('supertest')
const md5File = require('md5-file')
const should = chai.should()
const fs = require('fs-extra')
const Q = require('q')
const path = require('path')

const MASTER_HTTP_PORT = 4000
const SLAVE_HTTP_PORT = 5000
const MASTER_NET_PORT = 6000
const SLAVE_NET_PORT = 7000
const MASTER_URL = `http://localhost:${MASTER_HTTP_PORT}`
const SLAVE_URL = `http://localhost:${SLAVE_HTTP_PORT}`

let master = null
let slave = null
let article = null
let article2 = null

const remove = (...files) => {
  _.each(files, file => {
    fs.removeSync(file)
  })
}

const createArticle = (machine, content) => {
  return machine.request.post('/api/articles')
    .send(content)
    .expect(200)
    .then(({body}) => {
      return body
    })
}

const uploadArticleAttachment = (machine, articleId, filename, cb) => {
  return machine.request.post(`/api/articles/${articleId}/attachments`)
    .attach('file', `${__dirname}/${filename}`)
    .expect(200)
    .then(({body}) => {
      return body
    })
}

const compareChecksum = function (machine, articleId, attachment, filename) {
  return machine.request
    .get(`/api/articles/${articleId}/attachments/${attachment._id}`)
    .expect(200)
    .expect('Content-Type', attachment._contentType)
    .then(async ({body}) => {
      fs.writeFileSync(`${__dirname}/tmp`, body)
      let hex = await md5File(`${__dirname}/tmp`)
      hex.should.have.length.above(0)
      let origin = await md5File(`${__dirname}/${filename}`)
      hex.should.equal(origin)
    })
}

// create master node
before(async () => {
  let cms = new CMS({
    data: path.join(__dirname, 'master'),
    config: path.join(__dirname, 'master.json'),
    resources: path.join(__dirname, 'resources'),
    netPort: MASTER_NET_PORT
  })
  master = {
    cms,
    request: request(MASTER_URL)
  }
  cms.resource('articles', { type: 'normal' })
  await Q.ninvoke(cms, 'bootstrap')
  await Q.ninvoke(cms, 'allow', 'anonymous', 'articles')

  await Q.ninvoke(cms.express(), 'listen', MASTER_HTTP_PORT)
})

// create slave node

before(async () => {
  let cms = new CMS({
    data: path.join(__dirname, 'slave'),
    config: path.join(__dirname, 'slave.json'),
    resources: path.join(__dirname, 'resources'),
    netPort: SLAVE_NET_PORT
  })
  slave = {
    app: express(),
    cms,
    request: request(SLAVE_URL)
  }
  slave.cms.resource('articles', { type: 'normal' })
  await Q.ninvoke(slave.cms, 'bootstrap')
  await Q.ninvoke(slave.cms, 'allow', 'anonymous', 'articles')

  await Q.ninvoke(cms.express(), 'listen', SLAVE_HTTP_PORT)
})

// populate master with content

before(async () => {
  let record = await createArticle(master, {title: 'first'})
  article = record
  await uploadArticleAttachment(master, article._id, '_large.png')
  await uploadArticleAttachment(master, article._id, '_small.jpg')
  await createArticle(master, {title: 'second'})
  await createArticle(master, {title: 'third'})
})

// populate slave with content

before(async () => {
  let record = await createArticle(slave, {title: 'first'})
  article2 = record
  await uploadArticleAttachment(slave, record._id, '_medium.png')
  await createArticle(slave, {title: 'second'})
  await createArticle(slave, {title: 'third'})
})

// remove autogenerated files

after(async () => {
  await remove(
    path.join(__dirname, 'master'),
    path.join(__dirname, 'master.json'),
    path.join(__dirname, 'slave'),
    path.join(__dirname, 'slave.json'),
    path.join(__dirname, '_large_copy.png'),
    path.join(__dirname, 'tmp')
  )
})

it('should replicate from master to slaves', async () => {
  await Q.ninvoke(slave.cms, 'replicate', 'localhost', MASTER_NET_PORT, `${MASTER_URL}/api/`, 'articles')
})

// it 'should have index synced', (done) ->
//   master.cms.resource('articles').file.getIndex (index) ->
//     slave.cms.resource('articles').file.getIndex (index2) ->
//       index2.should.deep.equal index
//       do done

it('should have json content synced', async () => {
  let articles = await master.request.get('/api/articles?unpublished=true')
    .expect(200)

  let articles2 = await slave.request.get('/api/articles?unpublished=true')
    .expect(200)

  _.each(_.union(articles.body, articles2.body), item => delete item._local)
  articles2.body.should.deep.equal(articles.body)
})

it('should have binary content synced to slave', async () => {
  let {body} = await slave.request.get(`/api/articles/${article._id}`)
    .expect(200)
  const record = body
  const attachments = record._attachments
  attachments.should.have.length(2)
  await compareChecksum(slave, record._id, attachments[0], '_large.png')
  await compareChecksum(slave, record._id, attachments[1], '_small.jpg')
})

it('should have binary content synced to master', async () => {
  let {body} = await master.request.get(`/api/articles/${article2._id}`)
    .expect(200)

  should.exist(body)

  // slave file can't sync to master, add by kong
  // const record = body
  // const attachments = record._attachments
  // await compareChecksum(master, record._id, attachments[0], '_medium.png')
})

describe('Downstream & Upstream', () => {
  let masterRecord = null
  let slaveRecord = null
  let masterRecordUp = null
  let slaveRecordUp = null

  before(() => {
    master.cms.resource('downstream-collection',
      { acl: {'*': '1111'}, type: 'downstream' })
    master.cms.resource('upstream-collection',
      { acl: {'*': '1111'}, type: 'upstream' })
    slave.cms.resource('downstream-collection',
      { acl: {'*': '1111'}, type: 'downstream' })
    slave.cms.resource('upstream-collection',
      { acl: {'*': '1111'}, type: 'upstream' })
  })

  before(() => Q.ninvoke(master.cms, 'allow', 'anonymous', 'downstream-collection'))
  before(() => Q.ninvoke(slave.cms, 'allow', 'anonymous', 'downstream-collection'))
  before(() => Q.ninvoke(master.cms, 'allow', 'anonymous', 'upstream-collection'))
  before(() => Q.ninvoke(slave.cms, 'allow', 'anonymous', 'upstream-collection'))

  before(async () => {
    let {body} = await master.request
      .post('/api/downstream-collection')
      .send({ content: 'Master changes' })
      .expect(200)

    masterRecord = body
  })

  before(async () => {
    let {body} = await master.request
      .post('/api/upstream-collection')
      .send({ content: 'Master changes' })
      .expect(200)

    masterRecordUp = body
  })

  before(async () => {
    let {body} = await slave.request
      .post('/api/downstream-collection')
      .send({ content: 'Slave changes' })
      .expect(200)

    slaveRecord = body
  })

  before(async () => {
    let {body} = await slave.request
      .post('/api/upstream-collection')
      .send({ content: 'Slave changes' })
      .expect(200)

    slaveRecordUp = body
  })

  before(async () => {
    await Q.ninvoke(slave.cms, 'replicate', 'localhost', MASTER_NET_PORT, `${MASTER_URL}/api/`, 'downstream-collection')
    await Q.ninvoke(slave.cms, 'replicate', 'localhost', MASTER_NET_PORT, `${MASTER_URL}/api/`, 'upstream-collection')
  })

  it('should only pull changes from master (downstream)', async () => {
    let slaveApi = slave.cms.resource('downstream-collection').json
    let masterApi = master.cms.resource('downstream-collection').json
    let result
    result = await Q.ninvoke(slaveApi, 'find', slaveRecord._id)
    should.exist(result)
    result = await Q.ninvoke(slaveApi, 'find', masterRecord._id)
    should.exist(result)
    result = await Q.ninvoke(masterApi, 'find', masterRecord._id)
    should.exist(result)
    result = await Q.ninvoke(masterApi, 'find', masterRecord._id)
    should.exist(result)
  })

  return it('should only pull changes from slave (upstream)', async () => {
    let masterApi = master.cms.resource('upstream-collection').json
    let slaveApi = slave.cms.resource('upstream-collection').json
    let result
    result = await Q.ninvoke(masterApi, 'find', masterRecordUp._id)
    should.exist(result)
    result = await Q.ninvoke(masterApi, 'find', slaveRecordUp._id)
    should.exist(result)
    result = await Q.ninvoke(slaveApi, 'find', slaveRecordUp._id)
    should.exist(result)
    try {
      await Q.ninvoke(slaveApi, 'find', masterRecordUp._id)
      throw new Error('should return error')
    } catch (error) {
      should.exist(error)
    }
  })
})
