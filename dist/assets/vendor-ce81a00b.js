var _a;
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n) {
  if (n.__esModule)
    return n;
  var f2 = n.default;
  if (typeof f2 == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a.prototype = f2.prototype;
  } else
    a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k2) {
    var d = Object.getOwnPropertyDescriptor(n, k2);
    Object.defineProperty(a, k2, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k2];
      }
    });
  });
  return a;
}
var lodash = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
lodash.exports;
(function(module, exports) {
  (function() {
    var undefined$12;
    var VERSION = "4.17.21";
    var LARGE_ARRAY_SIZE = 200;
    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_MEMOIZE_SIZE = 500;
    var PLACEHOLDER = "__lodash_placeholder__";
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    var wrapFlags = [
      ["ary", WRAP_ARY_FLAG],
      ["bind", WRAP_BIND_FLAG],
      ["bindKey", WRAP_BIND_KEY_FLAG],
      ["curry", WRAP_CURRY_FLAG],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
      ["flip", WRAP_FLIP_FLAG],
      ["partial", WRAP_PARTIAL_FLAG],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
      ["rearg", WRAP_REARG_FLAG]
    ];
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName2 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
    var reTrimStart = /^\s+/;
    var reWhitespace = /\s/;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
    var reEscapeChar2 = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['’]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var deburredLetters = {
      // Latin-1 Supplement block.
      "À": "A",
      "Á": "A",
      "Â": "A",
      "Ã": "A",
      "Ä": "A",
      "Å": "A",
      "à": "a",
      "á": "a",
      "â": "a",
      "ã": "a",
      "ä": "a",
      "å": "a",
      "Ç": "C",
      "ç": "c",
      "Ð": "D",
      "ð": "d",
      "È": "E",
      "É": "E",
      "Ê": "E",
      "Ë": "E",
      "è": "e",
      "é": "e",
      "ê": "e",
      "ë": "e",
      "Ì": "I",
      "Í": "I",
      "Î": "I",
      "Ï": "I",
      "ì": "i",
      "í": "i",
      "î": "i",
      "ï": "i",
      "Ñ": "N",
      "ñ": "n",
      "Ò": "O",
      "Ó": "O",
      "Ô": "O",
      "Õ": "O",
      "Ö": "O",
      "Ø": "O",
      "ò": "o",
      "ó": "o",
      "ô": "o",
      "õ": "o",
      "ö": "o",
      "ø": "o",
      "Ù": "U",
      "Ú": "U",
      "Û": "U",
      "Ü": "U",
      "ù": "u",
      "ú": "u",
      "û": "u",
      "ü": "u",
      "Ý": "Y",
      "ý": "y",
      "ÿ": "y",
      "Æ": "Ae",
      "æ": "ae",
      "Þ": "Th",
      "þ": "th",
      "ß": "ss",
      // Latin Extended-A block.
      "Ā": "A",
      "Ă": "A",
      "Ą": "A",
      "ā": "a",
      "ă": "a",
      "ą": "a",
      "Ć": "C",
      "Ĉ": "C",
      "Ċ": "C",
      "Č": "C",
      "ć": "c",
      "ĉ": "c",
      "ċ": "c",
      "č": "c",
      "Ď": "D",
      "Đ": "D",
      "ď": "d",
      "đ": "d",
      "Ē": "E",
      "Ĕ": "E",
      "Ė": "E",
      "Ę": "E",
      "Ě": "E",
      "ē": "e",
      "ĕ": "e",
      "ė": "e",
      "ę": "e",
      "ě": "e",
      "Ĝ": "G",
      "Ğ": "G",
      "Ġ": "G",
      "Ģ": "G",
      "ĝ": "g",
      "ğ": "g",
      "ġ": "g",
      "ģ": "g",
      "Ĥ": "H",
      "Ħ": "H",
      "ĥ": "h",
      "ħ": "h",
      "Ĩ": "I",
      "Ī": "I",
      "Ĭ": "I",
      "Į": "I",
      "İ": "I",
      "ĩ": "i",
      "ī": "i",
      "ĭ": "i",
      "į": "i",
      "ı": "i",
      "Ĵ": "J",
      "ĵ": "j",
      "Ķ": "K",
      "ķ": "k",
      "ĸ": "k",
      "Ĺ": "L",
      "Ļ": "L",
      "Ľ": "L",
      "Ŀ": "L",
      "Ł": "L",
      "ĺ": "l",
      "ļ": "l",
      "ľ": "l",
      "ŀ": "l",
      "ł": "l",
      "Ń": "N",
      "Ņ": "N",
      "Ň": "N",
      "Ŋ": "N",
      "ń": "n",
      "ņ": "n",
      "ň": "n",
      "ŋ": "n",
      "Ō": "O",
      "Ŏ": "O",
      "Ő": "O",
      "ō": "o",
      "ŏ": "o",
      "ő": "o",
      "Ŕ": "R",
      "Ŗ": "R",
      "Ř": "R",
      "ŕ": "r",
      "ŗ": "r",
      "ř": "r",
      "Ś": "S",
      "Ŝ": "S",
      "Ş": "S",
      "Š": "S",
      "ś": "s",
      "ŝ": "s",
      "ş": "s",
      "š": "s",
      "Ţ": "T",
      "Ť": "T",
      "Ŧ": "T",
      "ţ": "t",
      "ť": "t",
      "ŧ": "t",
      "Ũ": "U",
      "Ū": "U",
      "Ŭ": "U",
      "Ů": "U",
      "Ű": "U",
      "Ų": "U",
      "ũ": "u",
      "ū": "u",
      "ŭ": "u",
      "ů": "u",
      "ű": "u",
      "ų": "u",
      "Ŵ": "W",
      "ŵ": "w",
      "Ŷ": "Y",
      "ŷ": "y",
      "Ÿ": "Y",
      "Ź": "Z",
      "Ż": "Z",
      "Ž": "Z",
      "ź": "z",
      "ż": "z",
      "ž": "z",
      "Ĳ": "IJ",
      "ĳ": "ij",
      "Œ": "Oe",
      "œ": "oe",
      "ŉ": "'n",
      "ſ": "s"
    };
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    };
    var stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    var freeParseFloat = parseFloat, freeParseInt = parseInt;
    var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root2 = freeGlobal || freeSelf || Function("return this")();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        var value = array[index2];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    function arrayEach(array, iteratee) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (iteratee(array[index2], index2, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEachRight(array, iteratee) {
      var length = array == null ? 0 : array.length;
      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEvery(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (!predicate(array[index2], index2, array)) {
          return false;
        }
      }
      return true;
    }
    function arrayFilter(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value = array[index2];
        if (predicate(value, index2, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator2) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (comparator2(value, array[index2])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array, iteratee) {
      var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index2 < length) {
        result[index2] = iteratee(array[index2], index2, array);
      }
      return result;
    }
    function arrayPush(array, values) {
      var index2 = -1, length = values.length, offset = array.length;
      while (++index2 < length) {
        array[offset + index2] = values[index2];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index2 = -1, length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[++index2];
      }
      while (++index2 < length) {
        accumulator = iteratee(accumulator, array[index2], index2, array);
      }
      return accumulator;
    }
    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
      var length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }
    function arraySome(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (predicate(array[index2], index2, array)) {
          return true;
        }
      }
      return false;
    }
    var asciiSize = baseProperty("length");
    function asciiToArray(string) {
      return string.split("");
    }
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      eachFunc(collection, function(value, key2, collection2) {
        if (predicate(value, key2, collection2)) {
          result = key2;
          return false;
        }
      });
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index2-- : ++index2 < length) {
        if (predicate(array[index2], index2, array)) {
          return index2;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    function baseIndexOfWith(array, value, fromIndex, comparator2) {
      var index2 = fromIndex - 1, length = array.length;
      while (++index2 < length) {
        if (comparator2(array[index2], value)) {
          return index2;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseMean(array, iteratee) {
      var length = array == null ? 0 : array.length;
      return length ? baseSum(array, iteratee) / length : NAN;
    }
    function baseProperty(key2) {
      return function(object) {
        return object == null ? undefined$12 : object[key2];
      };
    }
    function basePropertyOf(object) {
      return function(key2) {
        return object == null ? undefined$12 : object[key2];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index2, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
      });
      return accumulator;
    }
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    function baseSum(array, iteratee) {
      var result, index2 = -1, length = array.length;
      while (++index2 < length) {
        var current = iteratee(array[index2]);
        if (current !== undefined$12) {
          result = result === undefined$12 ? current : result + current;
        }
      }
      return result;
    }
    function baseTimes(n, iteratee) {
      var index2 = -1, result = Array(n);
      while (++index2 < n) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    function baseToPairs(object, props2) {
      return arrayMap(props2, function(key2) {
        return [key2, object[key2]];
      });
    }
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function baseValues(object, props2) {
      return arrayMap(props2, function(key2) {
        return object[key2];
      });
    }
    function cacheHas(cache, key2) {
      return cache.has(key2);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      var index2 = -1, length = strSymbols.length;
      while (++index2 < length && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
      }
      return index2;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      var index2 = strSymbols.length;
      while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
      }
      return index2;
    }
    function countHolders(array, placeholder) {
      var length = array.length, result = 0;
      while (length--) {
        if (array[length] === placeholder) {
          ++result;
        }
      }
      return result;
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    function getValue2(object, key2) {
      return object == null ? undefined$12 : object[key2];
    }
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    function iteratorToArray(iterator) {
      var data, result = [];
      while (!(data = iterator.next()).done) {
        result.push(data.value);
      }
      return result;
    }
    function mapToArray(map) {
      var index2 = -1, result = Array(map.size);
      map.forEach(function(value, key2) {
        result[++index2] = [key2, value];
      });
      return result;
    }
    function overArg(func, transform2) {
      return function(arg) {
        return func(transform2(arg));
      };
    }
    function replaceHolders(array, placeholder) {
      var index2 = -1, length = array.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value = array[index2];
        if (value === placeholder || value === PLACEHOLDER) {
          array[index2] = PLACEHOLDER;
          result[resIndex++] = index2;
        }
      }
      return result;
    }
    function setToArray(set2) {
      var index2 = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index2] = value;
      });
      return result;
    }
    function setToPairs(set2) {
      var index2 = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index2] = [value, value];
      });
      return result;
    }
    function strictIndexOf(array, value, fromIndex) {
      var index2 = fromIndex - 1, length = array.length;
      while (++index2 < length) {
        if (array[index2] === value) {
          return index2;
        }
      }
      return -1;
    }
    function strictLastIndexOf(array, value, fromIndex) {
      var index2 = fromIndex + 1;
      while (index2--) {
        if (array[index2] === value) {
          return index2;
        }
      }
      return index2;
    }
    function stringSize(string) {
      return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
    }
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    function trimmedEndIndex(string) {
      var index2 = string.length;
      while (index2-- && reWhitespace.test(string.charAt(index2))) {
      }
      return index2;
    }
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function unicodeSize(string) {
      var result = reUnicode.lastIndex = 0;
      while (reUnicode.test(string)) {
        ++result;
      }
      return result;
    }
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    var runInContext = function runInContext2(context) {
      context = context == null ? root2 : _2.defaults(root2.Object(), context, _2.pick(root2, contextProps));
      var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
      var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
      var coreJsData = context["__core-js_shared__"];
      var funcToString = funcProto.toString;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      var idCounter = 0;
      var maskSrcKey = function() {
        var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid2 ? "Symbol(src)_1." + uid2 : "";
      }();
      var nativeObjectToString = objectProto.toString;
      var objectCtorString = funcToString.call(Object2);
      var oldDash = root2._;
      var reIsNative = RegExp2(
        "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      var Buffer = moduleExports ? context.Buffer : undefined$12, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined$12, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined$12, symIterator = Symbol2 ? Symbol2.iterator : undefined$12, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined$12;
      var defineProperty = function() {
        try {
          var func = getNative(Object2, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {
        }
      }();
      var ctxClearTimeout = context.clearTimeout !== root2.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root2.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root2.setTimeout && context.setTimeout;
      var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined$12, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
      var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
      var metaMap = WeakMap2 && new WeakMap2();
      var realNames = {};
      var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
      var symbolProto = Symbol2 ? Symbol2.prototype : undefined$12, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$12, symbolToString = symbolProto ? symbolProto.toString : undefined$12;
      function lodash2(value) {
        if (isObjectLike(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper) {
            return value;
          }
          if (hasOwnProperty2.call(value, "__wrapped__")) {
            return wrapperClone(value);
          }
        }
        return new LodashWrapper(value);
      }
      var baseCreate = function() {
        function object() {
        }
        return function(proto) {
          if (!isObject2(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object.prototype = proto;
          var result2 = new object();
          object.prototype = undefined$12;
          return result2;
        };
      }();
      function baseLodash() {
      }
      function LodashWrapper(value, chainAll) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined$12;
      }
      lodash2.templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        "escape": reEscape,
        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        "evaluate": reEvaluate,
        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        "interpolate": reInterpolate,
        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        "variable": "",
        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        "imports": {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          "_": lodash2
        }
      };
      lodash2.prototype = baseLodash.prototype;
      lodash2.prototype.constructor = lodash2;
      LodashWrapper.prototype = baseCreate(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH;
        this.__views__ = [];
      }
      function lazyClone() {
        var result2 = new LazyWrapper(this.__wrapped__);
        result2.__actions__ = copyArray(this.__actions__);
        result2.__dir__ = this.__dir__;
        result2.__filtered__ = this.__filtered__;
        result2.__iteratees__ = copyArray(this.__iteratees__);
        result2.__takeCount__ = this.__takeCount__;
        result2.__views__ = copyArray(this.__views__);
        return result2;
      }
      function lazyReverse() {
        if (this.__filtered__) {
          var result2 = new LazyWrapper(this);
          result2.__dir__ = -1;
          result2.__filtered__ = true;
        } else {
          result2 = this.clone();
          result2.__dir__ *= -1;
        }
        return result2;
      }
      function lazyValue() {
        var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index2 = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length && takeCount == length) {
          return baseWrapperValue(array, this.__actions__);
        }
        var result2 = [];
        outer:
          while (length-- && resIndex < takeCount) {
            index2 += dir;
            var iterIndex = -1, value = array[index2];
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex], iteratee2 = data.iteratee, type2 = data.type, computed2 = iteratee2(value);
              if (type2 == LAZY_MAP_FLAG) {
                value = computed2;
              } else if (!computed2) {
                if (type2 == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result2[resIndex++] = value;
          }
        return result2;
      }
      LazyWrapper.prototype = baseCreate(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key2) {
        var result2 = this.has(key2) && delete this.__data__[key2];
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function hashGet(key2) {
        var data = this.__data__;
        if (nativeCreate) {
          var result2 = data[key2];
          return result2 === HASH_UNDEFINED ? undefined$12 : result2;
        }
        return hasOwnProperty2.call(data, key2) ? data[key2] : undefined$12;
      }
      function hashHas(key2) {
        var data = this.__data__;
        return nativeCreate ? data[key2] !== undefined$12 : hasOwnProperty2.call(data, key2);
      }
      function hashSet(key2, value) {
        var data = this.__data__;
        this.size += this.has(key2) ? 0 : 1;
        data[key2] = nativeCreate && value === undefined$12 ? HASH_UNDEFINED : value;
        return this;
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete(key2) {
        var data = this.__data__, index2 = assocIndexOf(data, key2);
        if (index2 < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index2 == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index2, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key2) {
        var data = this.__data__, index2 = assocIndexOf(data, key2);
        return index2 < 0 ? undefined$12 : data[index2][1];
      }
      function listCacheHas(key2) {
        return assocIndexOf(this.__data__, key2) > -1;
      }
      function listCacheSet(key2, value) {
        var data = this.__data__, index2 = assocIndexOf(data, key2);
        if (index2 < 0) {
          ++this.size;
          data.push([key2, value]);
        } else {
          data[index2][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash()
        };
      }
      function mapCacheDelete(key2) {
        var result2 = getMapData(this, key2)["delete"](key2);
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function mapCacheGet(key2) {
        return getMapData(this, key2).get(key2);
      }
      function mapCacheHas(key2) {
        return getMapData(this, key2).has(key2);
      }
      function mapCacheSet(key2, value) {
        var data = getMapData(this, key2), size3 = data.size;
        data.set(key2, value);
        this.size += data.size == size3 ? 0 : 1;
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function SetCache(values2) {
        var index2 = -1, length = values2 == null ? 0 : values2.length;
        this.__data__ = new MapCache();
        while (++index2 < length) {
          this.add(values2[index2]);
        }
      }
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key2) {
        var data = this.__data__, result2 = data["delete"](key2);
        this.size = data.size;
        return result2;
      }
      function stackGet(key2) {
        return this.__data__.get(key2);
      }
      function stackHas(key2) {
        return this.__data__.has(key2);
      }
      function stackSet(key2, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key2, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key2, value);
        this.size = data.size;
        return this;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer3(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
        for (var key2 in value) {
          if ((inherited || hasOwnProperty2.call(value, key2)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key2 == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key2 == "offset" || key2 == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || // Skip index properties.
          isIndex(key2, length)))) {
            result2.push(key2);
          }
        }
        return result2;
      }
      function arraySample(array) {
        var length = array.length;
        return length ? array[baseRandom(0, length - 1)] : undefined$12;
      }
      function arraySampleSize(array, n) {
        return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
      }
      function arrayShuffle(array) {
        return shuffleSelf(copyArray(array));
      }
      function assignMergeValue(object, key2, value) {
        if (value !== undefined$12 && !eq(object[key2], value) || value === undefined$12 && !(key2 in object)) {
          baseAssignValue(object, key2, value);
        }
      }
      function assignValue(object, key2, value) {
        var objValue = object[key2];
        if (!(hasOwnProperty2.call(object, key2) && eq(objValue, value)) || value === undefined$12 && !(key2 in object)) {
          baseAssignValue(object, key2, value);
        }
      }
      function assocIndexOf(array, key2) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key2)) {
            return length;
          }
        }
        return -1;
      }
      function baseAggregator(collection, setter, iteratee2, accumulator) {
        baseEach(collection, function(value, key2, collection2) {
          setter(accumulator, value, iteratee2(value), collection2);
        });
        return accumulator;
      }
      function baseAssign(object, source2) {
        return object && copyObject(source2, keys2(source2), object);
      }
      function baseAssignIn(object, source2) {
        return object && copyObject(source2, keysIn(source2), object);
      }
      function baseAssignValue(object, key2, value) {
        if (key2 == "__proto__" && defineProperty) {
          defineProperty(object, key2, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object[key2] = value;
        }
      }
      function baseAt(object, paths) {
        var index2 = -1, length = paths.length, result2 = Array2(length), skip = object == null;
        while (++index2 < length) {
          result2[index2] = skip ? undefined$12 : get2(object, paths[index2]);
        }
        return result2;
      }
      function baseClamp(number, lower, upper) {
        if (number === number) {
          if (upper !== undefined$12) {
            number = number <= upper ? number : upper;
          }
          if (lower !== undefined$12) {
            number = number >= lower ? number : lower;
          }
        }
        return number;
      }
      function baseClone(value, bitmask, customizer, key2, object, stack2) {
        var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result2 = object ? customizer(value, key2, object, stack2) : customizer(value);
        }
        if (result2 !== undefined$12) {
          return result2;
        }
        if (!isObject2(value)) {
          return value;
        }
        var isArr = isArray2(value);
        if (isArr) {
          result2 = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result2);
          }
        } else {
          var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer3(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag || tag == argsTag || isFunc && !object) {
            result2 = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value : {};
            }
            result2 = initCloneByTag(value, tag, isDeep);
          }
        }
        stack2 || (stack2 = new Stack());
        var stacked = stack2.get(value);
        if (stacked) {
          return stacked;
        }
        stack2.set(value, result2);
        if (isSet2(value)) {
          value.forEach(function(subValue) {
            result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack2));
          });
        } else if (isMap2(value)) {
          value.forEach(function(subValue, key3) {
            result2.set(key3, baseClone(subValue, bitmask, customizer, key3, value, stack2));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys2;
        var props2 = isArr ? undefined$12 : keysFunc(value);
        arrayEach(props2 || value, function(subValue, key3) {
          if (props2) {
            key3 = subValue;
            subValue = value[key3];
          }
          assignValue(result2, key3, baseClone(subValue, bitmask, customizer, key3, value, stack2));
        });
        return result2;
      }
      function baseConforms(source2) {
        var props2 = keys2(source2);
        return function(object) {
          return baseConformsTo(object, source2, props2);
        };
      }
      function baseConformsTo(object, source2, props2) {
        var length = props2.length;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (length--) {
          var key2 = props2[length], predicate = source2[key2], value = object[key2];
          if (value === undefined$12 && !(key2 in object) || !predicate(value)) {
            return false;
          }
        }
        return true;
      }
      function baseDelay(func, wait, args) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return setTimeout2(function() {
          func.apply(undefined$12, args);
        }, wait);
      }
      function baseDifference(array, values2, iteratee2, comparator2) {
        var index2 = -1, includes3 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
        if (!length) {
          return result2;
        }
        if (iteratee2) {
          values2 = arrayMap(values2, baseUnary(iteratee2));
        }
        if (comparator2) {
          includes3 = arrayIncludesWith;
          isCommon = false;
        } else if (values2.length >= LARGE_ARRAY_SIZE) {
          includes3 = cacheHas;
          isCommon = false;
          values2 = new SetCache(values2);
        }
        outer:
          while (++index2 < length) {
            var value = array[index2], computed2 = iteratee2 == null ? value : iteratee2(value);
            value = comparator2 || value !== 0 ? value : 0;
            if (isCommon && computed2 === computed2) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values2[valuesIndex] === computed2) {
                  continue outer;
                }
              }
              result2.push(value);
            } else if (!includes3(values2, computed2, comparator2)) {
              result2.push(value);
            }
          }
        return result2;
      }
      var baseEach = createBaseEach(baseForOwn);
      var baseEachRight = createBaseEach(baseForOwnRight, true);
      function baseEvery(collection, predicate) {
        var result2 = true;
        baseEach(collection, function(value, index2, collection2) {
          result2 = !!predicate(value, index2, collection2);
          return result2;
        });
        return result2;
      }
      function baseExtremum(array, iteratee2, comparator2) {
        var index2 = -1, length = array.length;
        while (++index2 < length) {
          var value = array[index2], current = iteratee2(value);
          if (current != null && (computed2 === undefined$12 ? current === current && !isSymbol2(current) : comparator2(current, computed2))) {
            var computed2 = current, result2 = value;
          }
        }
        return result2;
      }
      function baseFill(array, value, start, end) {
        var length = array.length;
        start = toInteger2(start);
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end === undefined$12 || end > length ? length : toInteger2(end);
        if (end < 0) {
          end += length;
        }
        end = start > end ? 0 : toLength(end);
        while (start < end) {
          array[start++] = value;
        }
        return array;
      }
      function baseFilter(collection, predicate) {
        var result2 = [];
        baseEach(collection, function(value, index2, collection2) {
          if (predicate(value, index2, collection2)) {
            result2.push(value);
          }
        });
        return result2;
      }
      function baseFlatten(array, depth, predicate, isStrict, result2) {
        var index2 = -1, length = array.length;
        predicate || (predicate = isFlattenable);
        result2 || (result2 = []);
        while (++index2 < length) {
          var value = array[index2];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result2);
            } else {
              arrayPush(result2, value);
            }
          } else if (!isStrict) {
            result2[result2.length] = value;
          }
        }
        return result2;
      }
      var baseFor = createBaseFor();
      var baseForRight = createBaseFor(true);
      function baseForOwn(object, iteratee2) {
        return object && baseFor(object, iteratee2, keys2);
      }
      function baseForOwnRight(object, iteratee2) {
        return object && baseForRight(object, iteratee2, keys2);
      }
      function baseFunctions(object, props2) {
        return arrayFilter(props2, function(key2) {
          return isFunction2(object[key2]);
        });
      }
      function baseGet(object, path) {
        path = castPath(path, object);
        var index2 = 0, length = path.length;
        while (object != null && index2 < length) {
          object = object[toKey(path[index2++])];
        }
        return index2 && index2 == length ? object : undefined$12;
      }
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result2 = keysFunc(object);
        return isArray2(object) ? result2 : arrayPush(result2, symbolsFunc(object));
      }
      function baseGetTag(value) {
        if (value == null) {
          return value === undefined$12 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString2(value);
      }
      function baseGt(value, other) {
        return value > other;
      }
      function baseHas(object, key2) {
        return object != null && hasOwnProperty2.call(object, key2);
      }
      function baseHasIn(object, key2) {
        return object != null && key2 in Object2(object);
      }
      function baseInRange(number, start, end) {
        return number >= nativeMin(start, end) && number < nativeMax(start, end);
      }
      function baseIntersection(arrays, iteratee2, comparator2) {
        var includes3 = comparator2 ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
        while (othIndex--) {
          var array = arrays[othIndex];
          if (othIndex && iteratee2) {
            array = arrayMap(array, baseUnary(iteratee2));
          }
          maxLength = nativeMin(array.length, maxLength);
          caches[othIndex] = !comparator2 && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined$12;
        }
        array = arrays[0];
        var index2 = -1, seen = caches[0];
        outer:
          while (++index2 < length && result2.length < maxLength) {
            var value = array[index2], computed2 = iteratee2 ? iteratee2(value) : value;
            value = comparator2 || value !== 0 ? value : 0;
            if (!(seen ? cacheHas(seen, computed2) : includes3(result2, computed2, comparator2))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if (!(cache ? cacheHas(cache, computed2) : includes3(arrays[othIndex], computed2, comparator2))) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed2);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseInverter(object, setter, iteratee2, accumulator) {
        baseForOwn(object, function(value, key2, object2) {
          setter(accumulator, iteratee2(value), key2, object2);
        });
        return accumulator;
      }
      function baseInvoke(object, path, args) {
        path = castPath(path, object);
        object = parent(object, path);
        var func = object == null ? object : object[toKey(last(path))];
        return func == null ? undefined$12 : apply(func, object, args);
      }
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      function baseIsArrayBuffer(value) {
        return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
      }
      function baseIsDate(value) {
        return isObjectLike(value) && baseGetTag(value) == dateTag;
      }
      function baseIsEqual(value, other, bitmask, customizer, stack2) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack2);
      }
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack2) {
        var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer3(object)) {
          if (!isBuffer3(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack2 || (stack2 = new Stack());
          return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack2);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack2 || (stack2 = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack2 || (stack2 = new Stack());
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack2);
      }
      function baseIsMap(value) {
        return isObjectLike(value) && getTag(value) == mapTag;
      }
      function baseIsMatch(object, source2, matchData, customizer) {
        var index2 = matchData.length, length = index2, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (index2--) {
          var data = matchData[index2];
          if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false;
          }
        }
        while (++index2 < length) {
          data = matchData[index2];
          var key2 = data[0], objValue = object[key2], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === undefined$12 && !(key2 in object)) {
              return false;
            }
          } else {
            var stack2 = new Stack();
            if (customizer) {
              var result2 = customizer(objValue, srcValue, key2, object, source2, stack2);
            }
            if (!(result2 === undefined$12 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack2) : result2)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative(value) {
        if (!isObject2(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function baseIsRegExp(value) {
        return isObjectLike(value) && baseGetTag(value) == regexpTag;
      }
      function baseIsSet(value) {
        return isObjectLike(value) && getTag(value) == setTag;
      }
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity;
        }
        if (typeof value == "object") {
          return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result2 = [];
        for (var key2 in Object2(object)) {
          if (hasOwnProperty2.call(object, key2) && key2 != "constructor") {
            result2.push(key2);
          }
        }
        return result2;
      }
      function baseKeysIn(object) {
        if (!isObject2(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result2 = [];
        for (var key2 in object) {
          if (!(key2 == "constructor" && (isProto || !hasOwnProperty2.call(object, key2)))) {
            result2.push(key2);
          }
        }
        return result2;
      }
      function baseLt(value, other) {
        return value < other;
      }
      function baseMap(collection, iteratee2) {
        var index2 = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value, key2, collection2) {
          result2[++index2] = iteratee2(value, key2, collection2);
        });
        return result2;
      }
      function baseMatches(source2) {
        var matchData = getMatchData(source2);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source2 || baseIsMatch(object, source2, matchData);
        };
      }
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object) {
          var objValue = get2(object, path);
          return objValue === undefined$12 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseMerge(object, source2, srcIndex, customizer, stack2) {
        if (object === source2) {
          return;
        }
        baseFor(source2, function(srcValue, key2) {
          stack2 || (stack2 = new Stack());
          if (isObject2(srcValue)) {
            baseMergeDeep(object, source2, key2, srcIndex, baseMerge, customizer, stack2);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key2), srcValue, key2 + "", object, source2, stack2) : undefined$12;
            if (newValue === undefined$12) {
              newValue = srcValue;
            }
            assignMergeValue(object, key2, newValue);
          }
        }, keysIn);
      }
      function baseMergeDeep(object, source2, key2, srcIndex, mergeFunc, customizer, stack2) {
        var objValue = safeGet(object, key2), srcValue = safeGet(source2, key2), stacked = stack2.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key2, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key2 + "", object, source2, stack2) : undefined$12;
        var isCommon = newValue === undefined$12;
        if (isCommon) {
          var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer3(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray2(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject2(objValue) || isFunction2(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack2.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack2);
          stack2["delete"](srcValue);
        }
        assignMergeValue(object, key2, newValue);
      }
      function baseNth(array, n) {
        var length = array.length;
        if (!length) {
          return;
        }
        n += n < 0 ? length : 0;
        return isIndex(n, length) ? array[n] : undefined$12;
      }
      function baseOrderBy(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap(iteratees, function(iteratee2) {
            if (isArray2(iteratee2)) {
              return function(value) {
                return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
              };
            }
            return iteratee2;
          });
        } else {
          iteratees = [identity];
        }
        var index2 = -1;
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        var result2 = baseMap(collection, function(value, key2, collection2) {
          var criteria = arrayMap(iteratees, function(iteratee2) {
            return iteratee2(value);
          });
          return { "criteria": criteria, "index": ++index2, "value": value };
        });
        return baseSortBy(result2, function(object, other) {
          return compareMultiple(object, other, orders);
        });
      }
      function basePick(object, paths) {
        return basePickBy(object, paths, function(value, path) {
          return hasIn(object, path);
        });
      }
      function basePickBy(object, paths, predicate) {
        var index2 = -1, length = paths.length, result2 = {};
        while (++index2 < length) {
          var path = paths[index2], value = baseGet(object, path);
          if (predicate(value, path)) {
            baseSet(result2, castPath(path, object), value);
          }
        }
        return result2;
      }
      function basePropertyDeep(path) {
        return function(object) {
          return baseGet(object, path);
        };
      }
      function basePullAll(array, values2, iteratee2, comparator2) {
        var indexOf3 = comparator2 ? baseIndexOfWith : baseIndexOf, index2 = -1, length = values2.length, seen = array;
        if (array === values2) {
          values2 = copyArray(values2);
        }
        if (iteratee2) {
          seen = arrayMap(array, baseUnary(iteratee2));
        }
        while (++index2 < length) {
          var fromIndex = 0, value = values2[index2], computed2 = iteratee2 ? iteratee2(value) : value;
          while ((fromIndex = indexOf3(seen, computed2, fromIndex, comparator2)) > -1) {
            if (seen !== array) {
              splice.call(seen, fromIndex, 1);
            }
            splice.call(array, fromIndex, 1);
          }
        }
        return array;
      }
      function basePullAt(array, indexes) {
        var length = array ? indexes.length : 0, lastIndex = length - 1;
        while (length--) {
          var index2 = indexes[length];
          if (length == lastIndex || index2 !== previous) {
            var previous = index2;
            if (isIndex(index2)) {
              splice.call(array, index2, 1);
            } else {
              baseUnset(array, index2);
            }
          }
        }
        return array;
      }
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }
      function baseRange(start, end, step, fromRight) {
        var index2 = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
        while (length--) {
          result2[fromRight ? length : ++index2] = start;
          start += step;
        }
        return result2;
      }
      function baseRepeat(string, n) {
        var result2 = "";
        if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
          return result2;
        }
        do {
          if (n % 2) {
            result2 += string;
          }
          n = nativeFloor(n / 2);
          if (n) {
            string += string;
          }
        } while (n);
        return result2;
      }
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity), func + "");
      }
      function baseSample(collection) {
        return arraySample(values(collection));
      }
      function baseSampleSize(collection, n) {
        var array = values(collection);
        return shuffleSelf(array, baseClamp(n, 0, array.length));
      }
      function baseSet(object, path, value, customizer) {
        if (!isObject2(object)) {
          return object;
        }
        path = castPath(path, object);
        var index2 = -1, length = path.length, lastIndex = length - 1, nested = object;
        while (nested != null && ++index2 < length) {
          var key2 = toKey(path[index2]), newValue = value;
          if (key2 === "__proto__" || key2 === "constructor" || key2 === "prototype") {
            return object;
          }
          if (index2 != lastIndex) {
            var objValue = nested[key2];
            newValue = customizer ? customizer(objValue, key2, nested) : undefined$12;
            if (newValue === undefined$12) {
              newValue = isObject2(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
            }
          }
          assignValue(nested, key2, newValue);
          nested = nested[key2];
        }
        return object;
      }
      var baseSetData = !metaMap ? identity : function(func, data) {
        metaMap.set(func, data);
        return func;
      };
      var baseSetToString = !defineProperty ? identity : function(func, string) {
        return defineProperty(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string),
          "writable": true
        });
      };
      function baseShuffle(collection) {
        return shuffleSelf(values(collection));
      }
      function baseSlice(array, start, end) {
        var index2 = -1, length = array.length;
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result2 = Array2(length);
        while (++index2 < length) {
          result2[index2] = array[index2 + start];
        }
        return result2;
      }
      function baseSome(collection, predicate) {
        var result2;
        baseEach(collection, function(value, index2, collection2) {
          result2 = predicate(value, index2, collection2);
          return !result2;
        });
        return !!result2;
      }
      function baseSortedIndex(array, value, retHighest) {
        var low = 0, high = array == null ? low : array.length;
        if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = low + high >>> 1, computed2 = array[mid];
            if (computed2 !== null && !isSymbol2(computed2) && (retHighest ? computed2 <= value : computed2 < value)) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array, value, identity, retHighest);
      }
      function baseSortedIndexBy(array, value, iteratee2, retHighest) {
        var low = 0, high = array == null ? 0 : array.length;
        if (high === 0) {
          return 0;
        }
        value = iteratee2(value);
        var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol2(value), valIsUndefined = value === undefined$12;
        while (low < high) {
          var mid = nativeFloor((low + high) / 2), computed2 = iteratee2(array[mid]), othIsDefined = computed2 !== undefined$12, othIsNull = computed2 === null, othIsReflexive = computed2 === computed2, othIsSymbol = isSymbol2(computed2);
          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? computed2 <= value : computed2 < value;
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin(high, MAX_ARRAY_INDEX);
      }
      function baseSortedUniq(array, iteratee2) {
        var index2 = -1, length = array.length, resIndex = 0, result2 = [];
        while (++index2 < length) {
          var value = array[index2], computed2 = iteratee2 ? iteratee2(value) : value;
          if (!index2 || !eq(computed2, seen)) {
            var seen = computed2;
            result2[resIndex++] = value === 0 ? 0 : value;
          }
        }
        return result2;
      }
      function baseToNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol2(value)) {
          return NAN;
        }
        return +value;
      }
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray2(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol2(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function baseUniq(array, iteratee2, comparator2) {
        var index2 = -1, includes3 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
        if (comparator2) {
          isCommon = false;
          includes3 = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set3 = iteratee2 ? null : createSet(array);
          if (set3) {
            return setToArray(set3);
          }
          isCommon = false;
          includes3 = cacheHas;
          seen = new SetCache();
        } else {
          seen = iteratee2 ? [] : result2;
        }
        outer:
          while (++index2 < length) {
            var value = array[index2], computed2 = iteratee2 ? iteratee2(value) : value;
            value = comparator2 || value !== 0 ? value : 0;
            if (isCommon && computed2 === computed2) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed2) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen.push(computed2);
              }
              result2.push(value);
            } else if (!includes3(seen, computed2, comparator2)) {
              if (seen !== result2) {
                seen.push(computed2);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseUnset(object, path) {
        path = castPath(path, object);
        object = parent(object, path);
        return object == null || delete object[toKey(last(path))];
      }
      function baseUpdate(object, path, updater, customizer) {
        return baseSet(object, path, updater(baseGet(object, path)), customizer);
      }
      function baseWhile(array, predicate, isDrop, fromRight) {
        var length = array.length, index2 = fromRight ? length : -1;
        while ((fromRight ? index2-- : ++index2 < length) && predicate(array[index2], index2, array)) {
        }
        return isDrop ? baseSlice(array, fromRight ? 0 : index2, fromRight ? index2 + 1 : length) : baseSlice(array, fromRight ? index2 + 1 : 0, fromRight ? length : index2);
      }
      function baseWrapperValue(value, actions) {
        var result2 = value;
        if (result2 instanceof LazyWrapper) {
          result2 = result2.value();
        }
        return arrayReduce(actions, function(result3, action) {
          return action.func.apply(action.thisArg, arrayPush([result3], action.args));
        }, result2);
      }
      function baseXor(arrays, iteratee2, comparator2) {
        var length = arrays.length;
        if (length < 2) {
          return length ? baseUniq(arrays[0]) : [];
        }
        var index2 = -1, result2 = Array2(length);
        while (++index2 < length) {
          var array = arrays[index2], othIndex = -1;
          while (++othIndex < length) {
            if (othIndex != index2) {
              result2[index2] = baseDifference(result2[index2] || array, arrays[othIndex], iteratee2, comparator2);
            }
          }
        }
        return baseUniq(baseFlatten(result2, 1), iteratee2, comparator2);
      }
      function baseZipObject(props2, values2, assignFunc) {
        var index2 = -1, length = props2.length, valsLength = values2.length, result2 = {};
        while (++index2 < length) {
          var value = index2 < valsLength ? values2[index2] : undefined$12;
          assignFunc(result2, props2[index2], value);
        }
        return result2;
      }
      function castArrayLikeObject(value) {
        return isArrayLikeObject(value) ? value : [];
      }
      function castFunction(value) {
        return typeof value == "function" ? value : identity;
      }
      function castPath(value, object) {
        if (isArray2(value)) {
          return value;
        }
        return isKey(value, object) ? [value] : stringToPath3(toString2(value));
      }
      var castRest = baseRest;
      function castSlice(array, start, end) {
        var length = array.length;
        end = end === undefined$12 ? length : end;
        return !start && end >= length ? array : baseSlice(array, start, end);
      }
      var clearTimeout2 = ctxClearTimeout || function(id) {
        return root2.clearTimeout(id);
      };
      function cloneBuffer(buffer2, isDeep) {
        if (isDeep) {
          return buffer2.slice();
        }
        var length = buffer2.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer2.constructor(length);
        buffer2.copy(result2);
        return result2;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
        return result2;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer2 = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
      }
      function cloneRegExp(regexp) {
        var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result2.lastIndex = regexp.lastIndex;
        return result2;
      }
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
      }
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== undefined$12, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol2(value);
          var othIsDefined = other !== undefined$12, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol2(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function compareMultiple(object, other, orders) {
        var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index2 < length) {
          var result2 = compareAscending(objCriteria[index2], othCriteria[index2]);
          if (result2) {
            if (index2 >= ordersLength) {
              return result2;
            }
            var order = orders[index2];
            return result2 * (order == "desc" ? -1 : 1);
          }
        }
        return object.index - other.index;
      }
      function composeArgs(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
        while (++leftIndex < leftLength) {
          result2[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[holders[argsIndex]] = args[argsIndex];
          }
        }
        while (rangeLength--) {
          result2[leftIndex++] = args[argsIndex++];
        }
        return result2;
      }
      function composeArgsRight(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
        while (++argsIndex < rangeLength) {
          result2[argsIndex] = args[argsIndex];
        }
        var offset = argsIndex;
        while (++rightIndex < rightLength) {
          result2[offset + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[offset + holders[holdersIndex]] = args[argsIndex++];
          }
        }
        return result2;
      }
      function copyArray(source2, array) {
        var index2 = -1, length = source2.length;
        array || (array = Array2(length));
        while (++index2 < length) {
          array[index2] = source2[index2];
        }
        return array;
      }
      function copyObject(source2, props2, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index2 = -1, length = props2.length;
        while (++index2 < length) {
          var key2 = props2[index2];
          var newValue = customizer ? customizer(object[key2], source2[key2], key2, object, source2) : undefined$12;
          if (newValue === undefined$12) {
            newValue = source2[key2];
          }
          if (isNew) {
            baseAssignValue(object, key2, newValue);
          } else {
            assignValue(object, key2, newValue);
          }
        }
        return object;
      }
      function copySymbols(source2, object) {
        return copyObject(source2, getSymbols(source2), object);
      }
      function copySymbolsIn(source2, object) {
        return copyObject(source2, getSymbolsIn(source2), object);
      }
      function createAggregator(setter, initializer) {
        return function(collection, iteratee2) {
          var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined$12, guard = length > 2 ? sources[2] : undefined$12;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined$12;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined$12 : customizer;
            length = 1;
          }
          object = Object2(object);
          while (++index2 < length) {
            var source2 = sources[index2];
            if (source2) {
              assigner(object, source2, index2, customizer);
            }
          }
          return object;
        });
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee2);
          }
          var length = collection.length, index2 = fromRight ? length : -1, iterable = Object2(collection);
          while (fromRight ? index2-- : ++index2 < length) {
            if (iteratee2(iterable[index2], index2, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      function createBaseFor(fromRight) {
        return function(object, iteratee2, keysFunc) {
          var index2 = -1, iterable = Object2(object), props2 = keysFunc(object), length = props2.length;
          while (length--) {
            var key2 = props2[fromRight ? length : ++index2];
            if (iteratee2(iterable[key2], key2, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
          return fn.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper;
      }
      function createCaseFirst(methodName) {
        return function(string) {
          string = toString2(string);
          var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined$12;
          var chr = strSymbols ? strSymbols[0] : string.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string) {
          return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
        };
      }
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor();
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
          return isObject2(result2) ? result2 : thisBinding;
        };
      }
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index2 = length, placeholder = getHolder(wrapper);
          while (index2--) {
            args[index2] = arguments[index2];
          }
          var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
          length -= holders.length;
          if (length < arity) {
            return createRecurry(
              func,
              bitmask,
              createHybrid,
              wrapper.placeholder,
              undefined$12,
              args,
              holders,
              undefined$12,
              undefined$12,
              arity - length
            );
          }
          var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
          return apply(fn, this, args);
        }
        return wrapper;
      }
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object2(collection);
          if (!isArrayLike(collection)) {
            var iteratee2 = getIteratee(predicate, 3);
            collection = keys2(collection);
            predicate = function(key2) {
              return iteratee2(iterable[key2], key2, iterable);
            };
          }
          var index2 = findIndexFunc(collection, predicate, fromIndex);
          return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : undefined$12;
        };
      }
      function createFlow(fromRight) {
        return flatRest(function(funcs) {
          var length = funcs.length, index2 = length, prereq = LodashWrapper.prototype.thru;
          if (fromRight) {
            funcs.reverse();
          }
          while (index2--) {
            var func = funcs[index2];
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (prereq && !wrapper && getFuncName(func) == "wrapper") {
              var wrapper = new LodashWrapper([], true);
            }
          }
          index2 = wrapper ? index2 : length;
          while (++index2 < length) {
            func = funcs[index2];
            var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined$12;
            if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
              wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
            } else {
              wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
            }
          }
          return function() {
            var args = arguments, value = args[0];
            if (wrapper && args.length == 1 && isArray2(value)) {
              return wrapper.plant(value).value();
            }
            var index3 = 0, result2 = length ? funcs[index3].apply(this, args) : value;
            while (++index3 < length) {
              result2 = funcs[index3].call(this, result2);
            }
            return result2;
          };
        });
      }
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$12 : createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index2 = length;
          while (index2--) {
            args[index2] = arguments[index2];
          }
          if (isCurried) {
            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
          }
          if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
          }
          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
          }
          length -= holdersCount;
          if (isCurried && length < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(
              func,
              bitmask,
              createHybrid,
              wrapper.placeholder,
              thisArg,
              args,
              newHolders,
              argPos,
              ary2,
              arity - length
            );
          }
          var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
          length = args.length;
          if (argPos) {
            args = reorder(args, argPos);
          } else if (isFlip && length > 1) {
            args.reverse();
          }
          if (isAry && ary2 < length) {
            args.length = ary2;
          }
          if (this && this !== root2 && this instanceof wrapper) {
            fn = Ctor || createCtor(fn);
          }
          return fn.apply(thisBinding, args);
        }
        return wrapper;
      }
      function createInverter(setter, toIteratee) {
        return function(object, iteratee2) {
          return baseInverter(object, setter, toIteratee(iteratee2), {});
        };
      }
      function createMathOperation(operator, defaultValue) {
        return function(value, other) {
          var result2;
          if (value === undefined$12 && other === undefined$12) {
            return defaultValue;
          }
          if (value !== undefined$12) {
            result2 = value;
          }
          if (other !== undefined$12) {
            if (result2 === undefined$12) {
              return other;
            }
            if (typeof value == "string" || typeof other == "string") {
              value = baseToString(value);
              other = baseToString(other);
            } else {
              value = baseToNumber(value);
              other = baseToNumber(other);
            }
            result2 = operator(value, other);
          }
          return result2;
        };
      }
      function createOver(arrayFunc) {
        return flatRest(function(iteratees) {
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          return baseRest(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply(iteratee2, thisArg, args);
            });
          });
        });
      }
      function createPadding(length, chars) {
        chars = chars === undefined$12 ? " " : baseToString(chars);
        var charsLength = chars.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars, length) : chars;
        }
        var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
        return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
      }
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }
          return apply(fn, isBind ? thisArg : this, args);
        }
        return wrapper;
      }
      function createRange2(fromRight) {
        return function(start, end, step) {
          if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
            end = step = undefined$12;
          }
          start = toFinite(start);
          if (end === undefined$12) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          step = step === undefined$12 ? start < end ? 1 : -1 : toFinite(step);
          return baseRange(start, end, step, fromRight);
        };
      }
      function createRelationalOperation(operator) {
        return function(value, other) {
          if (!(typeof value == "string" && typeof other == "string")) {
            value = toNumber2(value);
            other = toNumber2(other);
          }
          return operator(value, other);
        };
      }
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$12, newHoldersRight = isCurry ? undefined$12 : holders, newPartials = isCurry ? partials : undefined$12, newPartialsRight = isCurry ? undefined$12 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
          bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
        }
        var newData = [
          func,
          bitmask,
          thisArg,
          newPartials,
          newHolders,
          newPartialsRight,
          newHoldersRight,
          argPos,
          ary2,
          arity
        ];
        var result2 = wrapFunc.apply(undefined$12, newData);
        if (isLaziable(func)) {
          setData(result2, newData);
        }
        result2.placeholder = placeholder;
        return setWrapToString(result2, func, bitmask);
      }
      function createRound(methodName) {
        var func = Math2[methodName];
        return function(number, precision) {
          number = toNumber2(number);
          precision = precision == null ? 0 : nativeMin(toInteger2(precision), 292);
          if (precision && nativeIsFinite(number)) {
            var pair = (toString2(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
            pair = (toString2(value) + "e").split("e");
            return +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number);
        };
      }
      var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop2 : function(values2) {
        return new Set2(values2);
      };
      function createToPairs(keysFunc) {
        return function(object) {
          var tag = getTag(object);
          if (tag == mapTag) {
            return mapToArray(object);
          }
          if (tag == setTag) {
            return setToPairs(object);
          }
          return baseToPairs(object, keysFunc(object));
        };
      }
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var length = partials ? partials.length : 0;
        if (!length) {
          bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
          partials = holders = undefined$12;
        }
        ary2 = ary2 === undefined$12 ? ary2 : nativeMax(toInteger2(ary2), 0);
        arity = arity === undefined$12 ? arity : toInteger2(arity);
        length -= holders ? holders.length : 0;
        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined$12;
        }
        var data = isBindKey ? undefined$12 : getData(func);
        var newData = [
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity
        ];
        if (data) {
          mergeData(newData, data);
        }
        func = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === undefined$12 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
          bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
        }
        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
          var result2 = createBind(func, bitmask, thisArg);
        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
          result2 = createCurry(func, bitmask, arity);
        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
          result2 = createPartial(func, bitmask, thisArg, partials);
        } else {
          result2 = createHybrid.apply(undefined$12, newData);
        }
        var setter = data ? baseSetData : setData;
        return setWrapToString(setter(result2, newData), func, bitmask);
      }
      function customDefaultsAssignIn(objValue, srcValue, key2, object) {
        if (objValue === undefined$12 || eq(objValue, objectProto[key2]) && !hasOwnProperty2.call(object, key2)) {
          return srcValue;
        }
        return objValue;
      }
      function customDefaultsMerge(objValue, srcValue, key2, object, source2, stack2) {
        if (isObject2(objValue) && isObject2(srcValue)) {
          stack2.set(srcValue, objValue);
          baseMerge(objValue, srcValue, undefined$12, customDefaultsMerge, stack2);
          stack2["delete"](srcValue);
        }
        return objValue;
      }
      function customOmitClone(value) {
        return isPlainObject2(value) ? undefined$12 : value;
      }
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack2) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack2.get(array);
        var othStacked = stack2.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index2 = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$12;
        stack2.set(array, other);
        stack2.set(other, array);
        while (++index2 < arrLength) {
          var arrValue = array[index2], othValue = other[index2];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack2) : customizer(arrValue, othValue, index2, array, other, stack2);
          }
          if (compared !== undefined$12) {
            if (compared) {
              continue;
            }
            result2 = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
                return seen.push(othIndex);
              }
            })) {
              result2 = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
            result2 = false;
            break;
          }
        }
        stack2["delete"](array);
        stack2["delete"](other);
        return result2;
      }
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack2) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack2.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack2.set(object, other);
            var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack2);
            stack2["delete"](object);
            return result2;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack2) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index2 = objLength;
        while (index2--) {
          var key2 = objProps[index2];
          if (!(isPartial ? key2 in other : hasOwnProperty2.call(other, key2))) {
            return false;
          }
        }
        var objStacked = stack2.get(object);
        var othStacked = stack2.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result2 = true;
        stack2.set(object, other);
        stack2.set(other, object);
        var skipCtor = isPartial;
        while (++index2 < objLength) {
          key2 = objProps[index2];
          var objValue = object[key2], othValue = other[key2];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key2, other, object, stack2) : customizer(objValue, othValue, key2, object, other, stack2);
          }
          if (!(compared === undefined$12 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
            result2 = false;
            break;
          }
          skipCtor || (skipCtor = key2 == "constructor");
        }
        if (result2 && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result2 = false;
          }
        }
        stack2["delete"](object);
        stack2["delete"](other);
        return result2;
      }
      function flatRest(func) {
        return setToString(overRest(func, undefined$12, flatten), func + "");
      }
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys2, getSymbols);
      }
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }
      var getData = !metaMap ? noop2 : function(func) {
        return metaMap.get(func);
      };
      function getFuncName(func) {
        var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty2.call(realNames, result2) ? array.length : 0;
        while (length--) {
          var data = array[length], otherFunc = data.func;
          if (otherFunc == null || otherFunc == func) {
            return data.name;
          }
        }
        return result2;
      }
      function getHolder(func) {
        var object = hasOwnProperty2.call(lodash2, "placeholder") ? lodash2 : func;
        return object.placeholder;
      }
      function getIteratee() {
        var result2 = lodash2.iteratee || iteratee;
        result2 = result2 === iteratee ? baseIteratee : result2;
        return arguments.length ? result2(arguments[0], arguments[1]) : result2;
      }
      function getMapData(map2, key2) {
        var data = map2.__data__;
        return isKeyable(key2) ? data[typeof key2 == "string" ? "string" : "hash"] : data.map;
      }
      function getMatchData(object) {
        var result2 = keys2(object), length = result2.length;
        while (length--) {
          var key2 = result2[length], value = object[key2];
          result2[length] = [key2, value, isStrictComparable(value)];
        }
        return result2;
      }
      function getNative(object, key2) {
        var value = getValue2(object, key2);
        return baseIsNative(value) ? value : undefined$12;
      }
      function getRawTag(value) {
        var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = undefined$12;
          var unmasked = true;
        } catch (e) {
        }
        var result2 = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result2;
      }
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object2(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
        var result2 = [];
        while (object) {
          arrayPush(result2, getSymbols(object));
          object = getPrototype(object);
        }
        return result2;
      };
      var getTag = baseGetTag;
      if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
        getTag = function(value) {
          var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined$12, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result2;
        };
      }
      function getView(start, end, transforms) {
        var index2 = -1, length = transforms.length;
        while (++index2 < length) {
          var data = transforms[index2], size3 = data.size;
          switch (data.type) {
            case "drop":
              start += size3;
              break;
            case "dropRight":
              end -= size3;
              break;
            case "take":
              end = nativeMin(end, start + size3);
              break;
            case "takeRight":
              start = nativeMax(start, end - size3);
              break;
          }
        }
        return { "start": start, "end": end };
      }
      function getWrapDetails(source2) {
        var match2 = source2.match(reWrapDetails);
        return match2 ? match2[1].split(reSplitDetails) : [];
      }
      function hasPath(object, path, hasFunc) {
        path = castPath(path, object);
        var index2 = -1, length = path.length, result2 = false;
        while (++index2 < length) {
          var key2 = toKey(path[index2]);
          if (!(result2 = object != null && hasFunc(object, key2))) {
            break;
          }
          object = object[key2];
        }
        if (result2 || ++index2 != length) {
          return result2;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength(length) && isIndex(key2, length) && (isArray2(object) || isArguments(object));
      }
      function initCloneArray(array) {
        var length = array.length, result2 = new array.constructor(length);
        if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
          result2.index = array.index;
          result2.input = array.input;
        }
        return result2;
      }
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);
          case boolTag:
          case dateTag:
            return new Ctor(+object);
          case dataViewTag:
            return cloneDataView(object, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep);
          case mapTag:
            return new Ctor();
          case numberTag:
          case stringTag:
            return new Ctor(object);
          case regexpTag:
            return cloneRegExp(object);
          case setTag:
            return new Ctor();
          case symbolTag:
            return cloneSymbol(object);
        }
      }
      function insertWrapDetails(source2, details) {
        var length = details.length;
        if (!length) {
          return source2;
        }
        var lastIndex = length - 1;
        details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
        details = details.join(length > 2 ? ", " : " ");
        return source2.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
      }
      function isFlattenable(value) {
        return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function isIndex(value, length) {
        var type2 = typeof value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function isIterateeCall(value, index2, object) {
        if (!isObject2(object)) {
          return false;
        }
        var type2 = typeof index2;
        if (type2 == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type2 == "string" && index2 in object) {
          return eq(object[index2], value);
        }
        return false;
      }
      function isKey(value, object) {
        if (isArray2(value)) {
          return false;
        }
        var type2 = typeof value;
        if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol2(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
      }
      function isKeyable(value) {
        var type2 = typeof value;
        return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
      }
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash2[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func === other) {
          return true;
        }
        var data = getData(other);
        return !!data && func === data[0];
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var isMaskable = coreJsData ? isFunction2 : stubFalse;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      function isStrictComparable(value) {
        return value === value && !isObject2(value);
      }
      function matchesStrictComparable(key2, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key2] === srcValue && (srcValue !== undefined$12 || key2 in Object2(object));
        };
      }
      function memoizeCapped(func) {
        var result2 = memoize(func, function(key2) {
          if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
          }
          return key2;
        });
        var cache = result2.cache;
        return result2;
      }
      function mergeData(data, source2) {
        var bitmask = data[1], srcBitmask = source2[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source2[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source2[7].length <= source2[8] && bitmask == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo)) {
          return data;
        }
        if (srcBitmask & WRAP_BIND_FLAG) {
          data[2] = source2[2];
          newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
        }
        var value = source2[3];
        if (value) {
          var partials = data[3];
          data[3] = partials ? composeArgs(partials, value, source2[4]) : value;
          data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source2[4];
        }
        value = source2[5];
        if (value) {
          partials = data[5];
          data[5] = partials ? composeArgsRight(partials, value, source2[6]) : value;
          data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source2[6];
        }
        value = source2[7];
        if (value) {
          data[7] = value;
        }
        if (srcBitmask & WRAP_ARY_FLAG) {
          data[8] = data[8] == null ? source2[8] : nativeMin(data[8], source2[8]);
        }
        if (data[9] == null) {
          data[9] = source2[9];
        }
        data[0] = source2[0];
        data[1] = newBitmask;
        return data;
      }
      function nativeKeysIn(object) {
        var result2 = [];
        if (object != null) {
          for (var key2 in Object2(object)) {
            result2.push(key2);
          }
        }
        return result2;
      }
      function objectToString2(value) {
        return nativeObjectToString.call(value);
      }
      function overRest(func, start, transform3) {
        start = nativeMax(start === undefined$12 ? func.length - 1 : start, 0);
        return function() {
          var args = arguments, index2 = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
          while (++index2 < length) {
            array[index2] = args[start + index2];
          }
          index2 = -1;
          var otherArgs = Array2(start + 1);
          while (++index2 < start) {
            otherArgs[index2] = args[index2];
          }
          otherArgs[start] = transform3(array);
          return apply(func, this, otherArgs);
        };
      }
      function parent(object, path) {
        return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
      }
      function reorder(array, indexes) {
        var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
        while (length--) {
          var index2 = indexes[length];
          array[length] = isIndex(index2, arrLength) ? oldArray[index2] : undefined$12;
        }
        return array;
      }
      function safeGet(object, key2) {
        if (key2 === "constructor" && typeof object[key2] === "function") {
          return;
        }
        if (key2 == "__proto__") {
          return;
        }
        return object[key2];
      }
      var setData = shortOut(baseSetData);
      var setTimeout2 = ctxSetTimeout || function(func, wait) {
        return root2.setTimeout(func, wait);
      };
      var setToString = shortOut(baseSetToString);
      function setWrapToString(wrapper, reference, bitmask) {
        var source2 = reference + "";
        return setToString(wrapper, insertWrapDetails(source2, updateWrapDetails(getWrapDetails(source2), bitmask)));
      }
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(undefined$12, arguments);
        };
      }
      function shuffleSelf(array, size3) {
        var index2 = -1, length = array.length, lastIndex = length - 1;
        size3 = size3 === undefined$12 ? length : size3;
        while (++index2 < size3) {
          var rand = baseRandom(index2, lastIndex), value = array[rand];
          array[rand] = array[index2];
          array[index2] = value;
        }
        array.length = size3;
        return array;
      }
      var stringToPath3 = memoizeCapped(function(string) {
        var result2 = [];
        if (string.charCodeAt(0) === 46) {
          result2.push("");
        }
        string.replace(rePropName2, function(match2, number, quote2, subString) {
          result2.push(quote2 ? subString.replace(reEscapeChar2, "$1") : number || match2);
        });
        return result2;
      });
      function toKey(value) {
        if (typeof value == "string" || isSymbol2(value)) {
          return value;
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      function updateWrapDetails(details, bitmask) {
        arrayEach(wrapFlags, function(pair) {
          var value = "_." + pair[0];
          if (bitmask & pair[1] && !arrayIncludes(details, value)) {
            details.push(value);
          }
        });
        return details.sort();
      }
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) {
          return wrapper.clone();
        }
        var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        result2.__actions__ = copyArray(wrapper.__actions__);
        result2.__index__ = wrapper.__index__;
        result2.__values__ = wrapper.__values__;
        return result2;
      }
      function chunk2(array, size3, guard) {
        if (guard ? isIterateeCall(array, size3, guard) : size3 === undefined$12) {
          size3 = 1;
        } else {
          size3 = nativeMax(toInteger2(size3), 0);
        }
        var length = array == null ? 0 : array.length;
        if (!length || size3 < 1) {
          return [];
        }
        var index2 = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size3));
        while (index2 < length) {
          result2[resIndex++] = baseSlice(array, index2, index2 += size3);
        }
        return result2;
      }
      function compact3(array) {
        var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
        while (++index2 < length) {
          var value = array[index2];
          if (value) {
            result2[resIndex++] = value;
          }
        }
        return result2;
      }
      function concat() {
        var length = arguments.length;
        if (!length) {
          return [];
        }
        var args = Array2(length - 1), array = arguments[0], index2 = length;
        while (index2--) {
          args[index2 - 1] = arguments[index2];
        }
        return arrayPush(isArray2(array) ? copyArray(array) : [array], baseFlatten(args, 1));
      }
      var difference = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
      });
      var differenceBy = baseRest(function(array, values2) {
        var iteratee2 = last(values2);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$12;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
      });
      var differenceWith = baseRest(function(array, values2) {
        var comparator2 = last(values2);
        if (isArrayLikeObject(comparator2)) {
          comparator2 = undefined$12;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined$12, comparator2) : [];
      });
      function drop3(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined$12 ? 1 : toInteger2(n);
        return baseSlice(array, n < 0 ? 0 : n, length);
      }
      function dropRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined$12 ? 1 : toInteger2(n);
        n = length - n;
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      function dropRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
      }
      function dropWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
      }
      function fill(array, value, start, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
          start = 0;
          end = length;
        }
        return baseFill(array, value, start, end);
      }
      function findIndex2(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = fromIndex == null ? 0 : toInteger2(fromIndex);
        if (index2 < 0) {
          index2 = nativeMax(length + index2, 0);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index2);
      }
      function findLastIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = length - 1;
        if (fromIndex !== undefined$12) {
          index2 = toInteger2(fromIndex);
          index2 = fromIndex < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index2, true);
      }
      function flatten(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, 1) : [];
      }
      function flattenDeep(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, INFINITY) : [];
      }
      function flattenDepth(array, depth) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        depth = depth === undefined$12 ? 1 : toInteger2(depth);
        return baseFlatten(array, depth);
      }
      function fromPairs(pairs) {
        var index2 = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
        while (++index2 < length) {
          var pair = pairs[index2];
          result2[pair[0]] = pair[1];
        }
        return result2;
      }
      function head(array) {
        return array && array.length ? array[0] : undefined$12;
      }
      function indexOf2(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = fromIndex == null ? 0 : toInteger2(fromIndex);
        if (index2 < 0) {
          index2 = nativeMax(length + index2, 0);
        }
        return baseIndexOf(array, value, index2);
      }
      function initial(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 0, -1) : [];
      }
      var intersection = baseRest(function(arrays) {
        var mapped = arrayMap(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      });
      var intersectionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        if (iteratee2 === last(mapped)) {
          iteratee2 = undefined$12;
        } else {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
      });
      var intersectionWith = baseRest(function(arrays) {
        var comparator2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        comparator2 = typeof comparator2 == "function" ? comparator2 : undefined$12;
        if (comparator2) {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$12, comparator2) : [];
      });
      function join(array, separator) {
        return array == null ? "" : nativeJoin.call(array, separator);
      }
      function last(array) {
        var length = array == null ? 0 : array.length;
        return length ? array[length - 1] : undefined$12;
      }
      function lastIndexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = length;
        if (fromIndex !== undefined$12) {
          index2 = toInteger2(fromIndex);
          index2 = index2 < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
        }
        return value === value ? strictLastIndexOf(array, value, index2) : baseFindIndex(array, baseIsNaN, index2, true);
      }
      function nth(array, n) {
        return array && array.length ? baseNth(array, toInteger2(n)) : undefined$12;
      }
      var pull = baseRest(pullAll);
      function pullAll(array, values2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
      }
      function pullAllBy(array, values2, iteratee2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
      }
      function pullAllWith(array, values2, comparator2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined$12, comparator2) : array;
      }
      var pullAt = flatRest(function(array, indexes) {
        var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
        basePullAt(array, arrayMap(indexes, function(index2) {
          return isIndex(index2, length) ? +index2 : index2;
        }).sort(compareAscending));
        return result2;
      });
      function remove2(array, predicate) {
        var result2 = [];
        if (!(array && array.length)) {
          return result2;
        }
        var index2 = -1, indexes = [], length = array.length;
        predicate = getIteratee(predicate, 3);
        while (++index2 < length) {
          var value = array[index2];
          if (predicate(value, index2, array)) {
            result2.push(value);
            indexes.push(index2);
          }
        }
        basePullAt(array, indexes);
        return result2;
      }
      function reverse(array) {
        return array == null ? array : nativeReverse.call(array);
      }
      function slice(array, start, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
          start = 0;
          end = length;
        } else {
          start = start == null ? 0 : toInteger2(start);
          end = end === undefined$12 ? length : toInteger2(end);
        }
        return baseSlice(array, start, end);
      }
      function sortedIndex(array, value) {
        return baseSortedIndex(array, value);
      }
      function sortedIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
      }
      function sortedIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index2 = baseSortedIndex(array, value);
          if (index2 < length && eq(array[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function sortedLastIndex(array, value) {
        return baseSortedIndex(array, value, true);
      }
      function sortedLastIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
      }
      function sortedLastIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index2 = baseSortedIndex(array, value, true) - 1;
          if (eq(array[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function sortedUniq(array) {
        return array && array.length ? baseSortedUniq(array) : [];
      }
      function sortedUniqBy(array, iteratee2) {
        return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function tail(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 1, length) : [];
      }
      function take(array, n, guard) {
        if (!(array && array.length)) {
          return [];
        }
        n = guard || n === undefined$12 ? 1 : toInteger2(n);
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      function takeRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined$12 ? 1 : toInteger2(n);
        n = length - n;
        return baseSlice(array, n < 0 ? 0 : n, length);
      }
      function takeRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
      }
      function takeWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
      }
      var union = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });
      var unionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$12;
        }
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
      });
      var unionWith = baseRest(function(arrays) {
        var comparator2 = last(arrays);
        comparator2 = typeof comparator2 == "function" ? comparator2 : undefined$12;
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$12, comparator2);
      });
      function uniq(array) {
        return array && array.length ? baseUniq(array) : [];
      }
      function uniqBy(array, iteratee2) {
        return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function uniqWith(array, comparator2) {
        comparator2 = typeof comparator2 == "function" ? comparator2 : undefined$12;
        return array && array.length ? baseUniq(array, undefined$12, comparator2) : [];
      }
      function unzip(array) {
        if (!(array && array.length)) {
          return [];
        }
        var length = 0;
        array = arrayFilter(array, function(group) {
          if (isArrayLikeObject(group)) {
            length = nativeMax(group.length, length);
            return true;
          }
        });
        return baseTimes(length, function(index2) {
          return arrayMap(array, baseProperty(index2));
        });
      }
      function unzipWith(array, iteratee2) {
        if (!(array && array.length)) {
          return [];
        }
        var result2 = unzip(array);
        if (iteratee2 == null) {
          return result2;
        }
        return arrayMap(result2, function(group) {
          return apply(iteratee2, undefined$12, group);
        });
      }
      var without = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
      });
      var xor = baseRest(function(arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject));
      });
      var xorBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$12;
        }
        return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
      });
      var xorWith = baseRest(function(arrays) {
        var comparator2 = last(arrays);
        comparator2 = typeof comparator2 == "function" ? comparator2 : undefined$12;
        return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$12, comparator2);
      });
      var zip = baseRest(unzip);
      function zipObject(props2, values2) {
        return baseZipObject(props2 || [], values2 || [], assignValue);
      }
      function zipObjectDeep(props2, values2) {
        return baseZipObject(props2 || [], values2 || [], baseSet);
      }
      var zipWith = baseRest(function(arrays) {
        var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined$12;
        iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$12;
        return unzipWith(arrays, iteratee2);
      });
      function chain(value) {
        var result2 = lodash2(value);
        result2.__chain__ = true;
        return result2;
      }
      function tap(value, interceptor) {
        interceptor(value);
        return value;
      }
      function thru(value, interceptor) {
        return interceptor(value);
      }
      var wrapperAt = flatRest(function(paths) {
        var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
          return baseAt(object, paths);
        };
        if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
          return this.thru(interceptor);
        }
        value = value.slice(start, +start + (length ? 1 : 0));
        value.__actions__.push({
          "func": thru,
          "args": [interceptor],
          "thisArg": undefined$12
        });
        return new LodashWrapper(value, this.__chain__).thru(function(array) {
          if (length && !array.length) {
            array.push(undefined$12);
          }
          return array;
        });
      });
      function wrapperChain() {
        return chain(this);
      }
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      function wrapperNext() {
        if (this.__values__ === undefined$12) {
          this.__values__ = toArray2(this.value());
        }
        var done = this.__index__ >= this.__values__.length, value = done ? undefined$12 : this.__values__[this.__index__++];
        return { "done": done, "value": value };
      }
      function wrapperToIterator() {
        return this;
      }
      function wrapperPlant(value) {
        var result2, parent2 = this;
        while (parent2 instanceof baseLodash) {
          var clone3 = wrapperClone(parent2);
          clone3.__index__ = 0;
          clone3.__values__ = undefined$12;
          if (result2) {
            previous.__wrapped__ = clone3;
          } else {
            result2 = clone3;
          }
          var previous = clone3;
          parent2 = parent2.__wrapped__;
        }
        previous.__wrapped__ = value;
        return result2;
      }
      function wrapperReverse() {
        var value = this.__wrapped__;
        if (value instanceof LazyWrapper) {
          var wrapped = value;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({
            "func": thru,
            "args": [reverse],
            "thisArg": undefined$12
          });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse);
      }
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      var countBy = createAggregator(function(result2, value, key2) {
        if (hasOwnProperty2.call(result2, key2)) {
          ++result2[key2];
        } else {
          baseAssignValue(result2, key2, 1);
        }
      });
      function every(collection, predicate, guard) {
        var func = isArray2(collection) ? arrayEvery : baseEvery;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$12;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      function filter(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }
      var find2 = createFind(findIndex2);
      var findLast = createFind(findLastIndex);
      function flatMap(collection, iteratee2) {
        return baseFlatten(map(collection, iteratee2), 1);
      }
      function flatMapDeep(collection, iteratee2) {
        return baseFlatten(map(collection, iteratee2), INFINITY);
      }
      function flatMapDepth(collection, iteratee2, depth) {
        depth = depth === undefined$12 ? 1 : toInteger2(depth);
        return baseFlatten(map(collection, iteratee2), depth);
      }
      function forEach3(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEach : baseEach;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function forEachRight(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee2, 3));
      }
      var groupBy = createAggregator(function(result2, value, key2) {
        if (hasOwnProperty2.call(result2, key2)) {
          result2[key2].push(value);
        } else {
          baseAssignValue(result2, key2, [value]);
        }
      });
      function includes2(collection, value, fromIndex, guard) {
        collection = isArrayLike(collection) ? collection : values(collection);
        fromIndex = fromIndex && !guard ? toInteger2(fromIndex) : 0;
        var length = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax(length + fromIndex, 0);
        }
        return isString2(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
      }
      var invokeMap = baseRest(function(collection, path, args) {
        var index2 = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value) {
          result2[++index2] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
        });
        return result2;
      });
      var keyBy = createAggregator(function(result2, value, key2) {
        baseAssignValue(result2, key2, value);
      });
      function map(collection, iteratee2) {
        var func = isArray2(collection) ? arrayMap : baseMap;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function orderBy(collection, iteratees, orders, guard) {
        if (collection == null) {
          return [];
        }
        if (!isArray2(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard ? undefined$12 : orders;
        if (!isArray2(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection, iteratees, orders);
      }
      var partition = createAggregator(function(result2, value, key2) {
        result2[key2 ? 0 : 1].push(value);
      }, function() {
        return [[], []];
      });
      function reduce(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
      }
      function reduceRight(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }
      function reject(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter : baseFilter;
        return func(collection, negate(getIteratee(predicate, 3)));
      }
      function sample(collection) {
        var func = isArray2(collection) ? arraySample : baseSample;
        return func(collection);
      }
      function sampleSize(collection, n, guard) {
        if (guard ? isIterateeCall(collection, n, guard) : n === undefined$12) {
          n = 1;
        } else {
          n = toInteger2(n);
        }
        var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n);
      }
      function shuffle(collection) {
        var func = isArray2(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }
      function size2(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike(collection)) {
          return isString2(collection) ? stringSize(collection) : collection.length;
        }
        var tag = getTag(collection);
        if (tag == mapTag || tag == setTag) {
          return collection.size;
        }
        return baseKeys(collection).length;
      }
      function some(collection, predicate, guard) {
        var func = isArray2(collection) ? arraySome : baseSome;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$12;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      var sortBy = baseRest(function(collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length = iteratees.length;
        if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      });
      var now = ctxNow || function() {
        return root2.Date.now();
      };
      function after(n, func) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger2(n);
        return function() {
          if (--n < 1) {
            return func.apply(this, arguments);
          }
        };
      }
      function ary(func, n, guard) {
        n = guard ? undefined$12 : n;
        n = func && n == null ? func.length : n;
        return createWrap(func, WRAP_ARY_FLAG, undefined$12, undefined$12, undefined$12, undefined$12, n);
      }
      function before(n, func) {
        var result2;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger2(n);
        return function() {
          if (--n > 0) {
            result2 = func.apply(this, arguments);
          }
          if (n <= 1) {
            func = undefined$12;
          }
          return result2;
        };
      }
      var bind4 = baseRest(function(func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind4));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      });
      var bindKey = baseRest(function(object, key2, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key2, bitmask, object, partials, holders);
      });
      function curry(func, arity, guard) {
        arity = guard ? undefined$12 : arity;
        var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$12, undefined$12, undefined$12, undefined$12, undefined$12, arity);
        result2.placeholder = curry.placeholder;
        return result2;
      }
      function curryRight(func, arity, guard) {
        arity = guard ? undefined$12 : arity;
        var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$12, undefined$12, undefined$12, undefined$12, undefined$12, arity);
        result2.placeholder = curryRight.placeholder;
        return result2;
      }
      function debounce(func, wait, options) {
        var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        wait = toNumber2(wait) || 0;
        if (isObject2(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber2(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = undefined$12;
          lastInvokeTime = time;
          result2 = func.apply(thisArg, args);
          return result2;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout2(timerExpired, wait);
          return leading ? invokeFunc(time) : result2;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === undefined$12 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout2(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = undefined$12;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined$12;
          return result2;
        }
        function cancel() {
          if (timerId !== undefined$12) {
            clearTimeout2(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined$12;
        }
        function flush() {
          return timerId === undefined$12 ? result2 : trailingEdge(now());
        }
        function debounced() {
          var time = now(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === undefined$12) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout2(timerId);
              timerId = setTimeout2(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined$12) {
            timerId = setTimeout2(timerExpired, wait);
          }
          return result2;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      var defer = baseRest(function(func, args) {
        return baseDelay(func, 1, args);
      });
      var delay = baseRest(function(func, wait, args) {
        return baseDelay(func, toNumber2(wait) || 0, args);
      });
      function flip(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key2 = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key2)) {
            return cache.get(key2);
          }
          var result2 = func.apply(this, args);
          memoized.cache = cache.set(key2, result2) || cache;
          return result2;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      function negate(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      function once(func) {
        return before(2, func);
      }
      var overArgs = castRest(function(func, transforms) {
        transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest(function(args) {
          var index2 = -1, length = nativeMin(args.length, funcsLength);
          while (++index2 < length) {
            args[index2] = transforms[index2].call(this, args[index2]);
          }
          return apply(func, this, args);
        });
      });
      var partial = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined$12, partials, holders);
      });
      var partialRight = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$12, partials, holders);
      });
      var rearg = flatRest(function(func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined$12, undefined$12, undefined$12, indexes);
      });
      function rest(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start === undefined$12 ? start : toInteger2(start);
        return baseRest(func, start);
      }
      function spread2(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start == null ? 0 : nativeMax(toInteger2(start), 0);
        return baseRest(function(args) {
          var array = args[start], otherArgs = castSlice(args, 0, start);
          if (array) {
            arrayPush(otherArgs, array);
          }
          return apply(func, this, otherArgs);
        });
      }
      function throttle2(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        if (isObject2(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce(func, wait, {
          "leading": leading,
          "maxWait": wait,
          "trailing": trailing
        });
      }
      function unary(func) {
        return ary(func, 1);
      }
      function wrap(value, wrapper) {
        return partial(castFunction(wrapper), value);
      }
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray2(value) ? value : [value];
      }
      function clone2(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      function cloneWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$12;
        return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
      }
      function cloneDeep(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      function cloneDeepWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$12;
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
      }
      function conformsTo(object, source2) {
        return source2 == null || baseConformsTo(object, source2, keys2(source2));
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var gt2 = createRelationalOperation(baseGt);
      var gte = createRelationalOperation(function(value, other) {
        return value >= other;
      });
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      var isArray2 = Array2.isArray;
      var isArrayBuffer2 = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction2(value);
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      function isBoolean2(value) {
        return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
      }
      var isBuffer3 = nativeIsBuffer || stubFalse;
      var isDate2 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
      function isElement2(value) {
        return isObjectLike(value) && value.nodeType === 1 && !isPlainObject2(value);
      }
      function isEmpty(value) {
        if (value == null) {
          return true;
        }
        if (isArrayLike(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer3(value) || isTypedArray(value) || isArguments(value))) {
          return !value.length;
        }
        var tag = getTag(value);
        if (tag == mapTag || tag == setTag) {
          return !value.size;
        }
        if (isPrototype(value)) {
          return !baseKeys(value).length;
        }
        for (var key2 in value) {
          if (hasOwnProperty2.call(value, key2)) {
            return false;
          }
        }
        return true;
      }
      function isEqual2(value, other) {
        return baseIsEqual(value, other);
      }
      function isEqualWith(value, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$12;
        var result2 = customizer ? customizer(value, other) : undefined$12;
        return result2 === undefined$12 ? baseIsEqual(value, other, undefined$12, customizer) : !!result2;
      }
      function isError2(value) {
        if (!isObjectLike(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject2(value);
      }
      function isFinite2(value) {
        return typeof value == "number" && nativeIsFinite(value);
      }
      function isFunction2(value) {
        if (!isObject2(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      function isInteger(value) {
        return typeof value == "number" && value == toInteger2(value);
      }
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isObject2(value) {
        var type2 = typeof value;
        return value != null && (type2 == "object" || type2 == "function");
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var isMap2 = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      function isMatch(object, source2) {
        return object === source2 || baseIsMatch(object, source2, getMatchData(source2));
      }
      function isMatchWith(object, source2, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$12;
        return baseIsMatch(object, source2, getMatchData(source2), customizer);
      }
      function isNaN2(value) {
        return isNumber2(value) && value != +value;
      }
      function isNative(value) {
        if (isMaskable(value)) {
          throw new Error2(CORE_ERROR_TEXT);
        }
        return baseIsNative(value);
      }
      function isNull(value) {
        return value === null;
      }
      function isNil(value) {
        return value == null;
      }
      function isNumber2(value) {
        return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
      }
      function isPlainObject2(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
          return false;
        }
        var proto = getPrototype(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      var isRegExp3 = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value) {
        return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
      }
      var isSet2 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      function isString2(value) {
        return typeof value == "string" || !isArray2(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
      }
      function isSymbol2(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
      }
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function isUndefined2(value) {
        return value === undefined$12;
      }
      function isWeakMap2(value) {
        return isObjectLike(value) && getTag(value) == weakMapTag;
      }
      function isWeakSet2(value) {
        return isObjectLike(value) && baseGetTag(value) == weakSetTag;
      }
      var lt2 = createRelationalOperation(baseLt);
      var lte = createRelationalOperation(function(value, other) {
        return value <= other;
      });
      function toArray2(value) {
        if (!value) {
          return [];
        }
        if (isArrayLike(value)) {
          return isString2(value) ? stringToArray(value) : copyArray(value);
        }
        if (symIterator && value[symIterator]) {
          return iteratorToArray(value[symIterator]());
        }
        var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
        return func(value);
      }
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber2(value);
        if (value === INFINITY || value === -INFINITY) {
          var sign2 = value < 0 ? -1 : 1;
          return sign2 * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger2(value) {
        var result2 = toFinite(value), remainder = result2 % 1;
        return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
      }
      function toLength(value) {
        return value ? baseClamp(toInteger2(value), 0, MAX_ARRAY_LENGTH) : 0;
      }
      function toNumber2(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol2(value)) {
          return NAN;
        }
        if (isObject2(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject2(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function toSafeInteger(value) {
        return value ? baseClamp(toInteger2(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
      }
      function toString2(value) {
        return value == null ? "" : baseToString(value);
      }
      var assign2 = createAssigner(function(object, source2) {
        if (isPrototype(source2) || isArrayLike(source2)) {
          copyObject(source2, keys2(source2), object);
          return;
        }
        for (var key2 in source2) {
          if (hasOwnProperty2.call(source2, key2)) {
            assignValue(object, key2, source2[key2]);
          }
        }
      });
      var assignIn = createAssigner(function(object, source2) {
        copyObject(source2, keysIn(source2), object);
      });
      var assignInWith = createAssigner(function(object, source2, srcIndex, customizer) {
        copyObject(source2, keysIn(source2), object, customizer);
      });
      var assignWith = createAssigner(function(object, source2, srcIndex, customizer) {
        copyObject(source2, keys2(source2), object, customizer);
      });
      var at2 = flatRest(baseAt);
      function create2(prototype, properties) {
        var result2 = baseCreate(prototype);
        return properties == null ? result2 : baseAssign(result2, properties);
      }
      var defaults2 = baseRest(function(object, sources) {
        object = Object2(object);
        var index2 = -1;
        var length = sources.length;
        var guard = length > 2 ? sources[2] : undefined$12;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          length = 1;
        }
        while (++index2 < length) {
          var source2 = sources[index2];
          var props2 = keysIn(source2);
          var propsIndex = -1;
          var propsLength = props2.length;
          while (++propsIndex < propsLength) {
            var key2 = props2[propsIndex];
            var value = object[key2];
            if (value === undefined$12 || eq(value, objectProto[key2]) && !hasOwnProperty2.call(object, key2)) {
              object[key2] = source2[key2];
            }
          }
        }
        return object;
      });
      var defaultsDeep = baseRest(function(args) {
        args.push(undefined$12, customDefaultsMerge);
        return apply(mergeWith, undefined$12, args);
      });
      function findKey2(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
      }
      function findLastKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
      }
      function forIn(object, iteratee2) {
        return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forInRight(object, iteratee2) {
        return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forOwn(object, iteratee2) {
        return object && baseForOwn(object, getIteratee(iteratee2, 3));
      }
      function forOwnRight(object, iteratee2) {
        return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
      }
      function functions(object) {
        return object == null ? [] : baseFunctions(object, keys2(object));
      }
      function functionsIn(object) {
        return object == null ? [] : baseFunctions(object, keysIn(object));
      }
      function get2(object, path, defaultValue) {
        var result2 = object == null ? undefined$12 : baseGet(object, path);
        return result2 === undefined$12 ? defaultValue : result2;
      }
      function has2(object, path) {
        return object != null && hasPath(object, path, baseHas);
      }
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }
      var invert = createInverter(function(result2, value, key2) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        result2[value] = key2;
      }, constant(identity));
      var invertBy = createInverter(function(result2, value, key2) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        if (hasOwnProperty2.call(result2, value)) {
          result2[value].push(key2);
        } else {
          result2[value] = [key2];
        }
      }, getIteratee);
      var invoke = baseRest(baseInvoke);
      function keys2(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      function mapKeys(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key2, object2) {
          baseAssignValue(result2, iteratee2(value, key2, object2), value);
        });
        return result2;
      }
      function mapValues(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key2, object2) {
          baseAssignValue(result2, key2, iteratee2(value, key2, object2));
        });
        return result2;
      }
      var merge3 = createAssigner(function(object, source2, srcIndex) {
        baseMerge(object, source2, srcIndex);
      });
      var mergeWith = createAssigner(function(object, source2, srcIndex, customizer) {
        baseMerge(object, source2, srcIndex, customizer);
      });
      var omit2 = flatRest(function(object, paths) {
        var result2 = {};
        if (object == null) {
          return result2;
        }
        var isDeep = false;
        paths = arrayMap(paths, function(path) {
          path = castPath(path, object);
          isDeep || (isDeep = path.length > 1);
          return path;
        });
        copyObject(object, getAllKeysIn(object), result2);
        if (isDeep) {
          result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
        }
        var length = paths.length;
        while (length--) {
          baseUnset(result2, paths[length]);
        }
        return result2;
      });
      function omitBy(object, predicate) {
        return pickBy(object, negate(getIteratee(predicate)));
      }
      var pick2 = flatRest(function(object, paths) {
        return object == null ? {} : basePick(object, paths);
      });
      function pickBy(object, predicate) {
        if (object == null) {
          return {};
        }
        var props2 = arrayMap(getAllKeysIn(object), function(prop) {
          return [prop];
        });
        predicate = getIteratee(predicate);
        return basePickBy(object, props2, function(value, path) {
          return predicate(value, path[0]);
        });
      }
      function result(object, path, defaultValue) {
        path = castPath(path, object);
        var index2 = -1, length = path.length;
        if (!length) {
          length = 1;
          object = undefined$12;
        }
        while (++index2 < length) {
          var value = object == null ? undefined$12 : object[toKey(path[index2])];
          if (value === undefined$12) {
            index2 = length;
            value = defaultValue;
          }
          object = isFunction2(value) ? value.call(object) : value;
        }
        return object;
      }
      function set2(object, path, value) {
        return object == null ? object : baseSet(object, path, value);
      }
      function setWith(object, path, value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$12;
        return object == null ? object : baseSet(object, path, value, customizer);
      }
      var toPairs = createToPairs(keys2);
      var toPairsIn = createToPairs(keysIn);
      function transform2(object, iteratee2, accumulator) {
        var isArr = isArray2(object), isArrLike = isArr || isBuffer3(object) || isTypedArray(object);
        iteratee2 = getIteratee(iteratee2, 4);
        if (accumulator == null) {
          var Ctor = object && object.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor() : [];
          } else if (isObject2(object)) {
            accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach : baseForOwn)(object, function(value, index2, object2) {
          return iteratee2(accumulator, value, index2, object2);
        });
        return accumulator;
      }
      function unset(object, path) {
        return object == null ? true : baseUnset(object, path);
      }
      function update(object, path, updater) {
        return object == null ? object : baseUpdate(object, path, castFunction(updater));
      }
      function updateWith(object, path, updater, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$12;
        return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
      }
      function values(object) {
        return object == null ? [] : baseValues(object, keys2(object));
      }
      function valuesIn(object) {
        return object == null ? [] : baseValues(object, keysIn(object));
      }
      function clamp2(number, lower, upper) {
        if (upper === undefined$12) {
          upper = lower;
          lower = undefined$12;
        }
        if (upper !== undefined$12) {
          upper = toNumber2(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower !== undefined$12) {
          lower = toNumber2(lower);
          lower = lower === lower ? lower : 0;
        }
        return baseClamp(toNumber2(number), lower, upper);
      }
      function inRange(number, start, end) {
        start = toFinite(start);
        if (end === undefined$12) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        number = toNumber2(number);
        return baseInRange(number, start, end);
      }
      function random(lower, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
          upper = floating = undefined$12;
        }
        if (floating === undefined$12) {
          if (typeof upper == "boolean") {
            floating = upper;
            upper = undefined$12;
          } else if (typeof lower == "boolean") {
            floating = lower;
            lower = undefined$12;
          }
        }
        if (lower === undefined$12 && upper === undefined$12) {
          lower = 0;
          upper = 1;
        } else {
          lower = toFinite(lower);
          if (upper === undefined$12) {
            upper = lower;
            lower = 0;
          } else {
            upper = toFinite(upper);
          }
        }
        if (lower > upper) {
          var temp = lower;
          lower = upper;
          upper = temp;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
        }
        return baseRandom(lower, upper);
      }
      var camelCase = createCompounder(function(result2, word, index2) {
        word = word.toLowerCase();
        return result2 + (index2 ? capitalize2(word) : word);
      });
      function capitalize2(string) {
        return upperFirst(toString2(string).toLowerCase());
      }
      function deburr(string) {
        string = toString2(string);
        return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      function endsWith(string, target, position) {
        string = toString2(string);
        target = baseToString(target);
        var length = string.length;
        position = position === undefined$12 ? length : baseClamp(toInteger2(position), 0, length);
        var end = position;
        position -= target.length;
        return position >= 0 && string.slice(position, end) == target;
      }
      function escape2(string) {
        string = toString2(string);
        return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
      }
      function escapeRegExp(string) {
        string = toString2(string);
        return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
      }
      var kebabCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? "-" : "") + word.toLowerCase();
      });
      var lowerCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + word.toLowerCase();
      });
      var lowerFirst = createCaseFirst("toLowerCase");
      function pad(string, length, chars) {
        string = toString2(string);
        length = toInteger2(length);
        var strLength = length ? stringSize(string) : 0;
        if (!length || strLength >= length) {
          return string;
        }
        var mid = (length - strLength) / 2;
        return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
      }
      function padEnd2(string, length, chars) {
        string = toString2(string);
        length = toInteger2(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
      }
      function padStart2(string, length, chars) {
        string = toString2(string);
        length = toInteger2(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
      }
      function parseInt2(string, radix, guard) {
        if (guard || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        return nativeParseInt(toString2(string).replace(reTrimStart, ""), radix || 0);
      }
      function repeat2(string, n, guard) {
        if (guard ? isIterateeCall(string, n, guard) : n === undefined$12) {
          n = 1;
        } else {
          n = toInteger2(n);
        }
        return baseRepeat(toString2(string), n);
      }
      function replace2() {
        var args = arguments, string = toString2(args[0]);
        return args.length < 3 ? string : string.replace(args[1], args[2]);
      }
      var snakeCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? "_" : "") + word.toLowerCase();
      });
      function split(string, separator, limit) {
        if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
          separator = limit = undefined$12;
        }
        limit = limit === undefined$12 ? MAX_ARRAY_LENGTH : limit >>> 0;
        if (!limit) {
          return [];
        }
        string = toString2(string);
        if (string && (typeof separator == "string" || separator != null && !isRegExp3(separator))) {
          separator = baseToString(separator);
          if (!separator && hasUnicode(string)) {
            return castSlice(stringToArray(string), 0, limit);
          }
        }
        return string.split(separator, limit);
      }
      var startCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + upperFirst(word);
      });
      function startsWith(string, target, position) {
        string = toString2(string);
        position = position == null ? 0 : baseClamp(toInteger2(position), 0, string.length);
        target = baseToString(target);
        return string.slice(position, position + target.length) == target;
      }
      function template(string, options, guard) {
        var settings = lodash2.templateSettings;
        if (guard && isIterateeCall(string, options, guard)) {
          options = undefined$12;
        }
        string = toString2(string);
        options = assignInWith({}, options, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys2(imports), importsValues = baseValues(imports, importsKeys);
        var isEscaping, isEvaluating, index2 = 0, interpolate = options.interpolate || reNoMatch, source2 = "__p += '";
        var reDelimiters = RegExp2(
          (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
          "g"
        );
        var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
        string.replace(reDelimiters, function(match2, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source2 += string.slice(index2, offset).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source2 += "' +\n__e(" + escapeValue + ") +\n'";
          }
          if (evaluateValue) {
            isEvaluating = true;
            source2 += "';\n" + evaluateValue + ";\n__p += '";
          }
          if (interpolateValue) {
            source2 += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }
          index2 = offset + match2.length;
          return match2;
        });
        source2 += "';\n";
        var variable = hasOwnProperty2.call(options, "variable") && options.variable;
        if (!variable) {
          source2 = "with (obj) {\n" + source2 + "\n}\n";
        } else if (reForbiddenIdentifierChars.test(variable)) {
          throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
        }
        source2 = (isEvaluating ? source2.replace(reEmptyStringLeading, "") : source2).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
        source2 = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source2 + "return __p\n}";
        var result2 = attempt(function() {
          return Function2(importsKeys, sourceURL + "return " + source2).apply(undefined$12, importsValues);
        });
        result2.source = source2;
        if (isError2(result2)) {
          throw result2;
        }
        return result2;
      }
      function toLower(value) {
        return toString2(value).toLowerCase();
      }
      function toUpper(value) {
        return toString2(value).toUpperCase();
      }
      function trim2(string, chars, guard) {
        string = toString2(string);
        if (string && (guard || chars === undefined$12)) {
          return baseTrim(string);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start, end).join("");
      }
      function trimEnd(string, chars, guard) {
        string = toString2(string);
        if (string && (guard || chars === undefined$12)) {
          return string.slice(0, trimmedEndIndex(string) + 1);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
        return castSlice(strSymbols, 0, end).join("");
      }
      function trimStart(string, chars, guard) {
        string = toString2(string);
        if (string && (guard || chars === undefined$12)) {
          return string.replace(reTrimStart, "");
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
        return castSlice(strSymbols, start).join("");
      }
      function truncate(string, options) {
        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject2(options)) {
          var separator = "separator" in options ? options.separator : separator;
          length = "length" in options ? toInteger2(options.length) : length;
          omission = "omission" in options ? baseToString(options.omission) : omission;
        }
        string = toString2(string);
        var strLength = string.length;
        if (hasUnicode(string)) {
          var strSymbols = stringToArray(string);
          strLength = strSymbols.length;
        }
        if (length >= strLength) {
          return string;
        }
        var end = length - stringSize(omission);
        if (end < 1) {
          return omission;
        }
        var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
        if (separator === undefined$12) {
          return result2 + omission;
        }
        if (strSymbols) {
          end += result2.length - end;
        }
        if (isRegExp3(separator)) {
          if (string.slice(end).search(separator)) {
            var match2, substring = result2;
            if (!separator.global) {
              separator = RegExp2(separator.source, toString2(reFlags.exec(separator)) + "g");
            }
            separator.lastIndex = 0;
            while (match2 = separator.exec(substring)) {
              var newEnd = match2.index;
            }
            result2 = result2.slice(0, newEnd === undefined$12 ? end : newEnd);
          }
        } else if (string.indexOf(baseToString(separator), end) != end) {
          var index2 = result2.lastIndexOf(separator);
          if (index2 > -1) {
            result2 = result2.slice(0, index2);
          }
        }
        return result2 + omission;
      }
      function unescape2(string) {
        string = toString2(string);
        return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
      }
      var upperCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + word.toUpperCase();
      });
      var upperFirst = createCaseFirst("toUpperCase");
      function words(string, pattern, guard) {
        string = toString2(string);
        pattern = guard ? undefined$12 : pattern;
        if (pattern === undefined$12) {
          return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
        }
        return string.match(pattern) || [];
      }
      var attempt = baseRest(function(func, args) {
        try {
          return apply(func, undefined$12, args);
        } catch (e) {
          return isError2(e) ? e : new Error2(e);
        }
      });
      var bindAll = flatRest(function(object, methodNames) {
        arrayEach(methodNames, function(key2) {
          key2 = toKey(key2);
          baseAssignValue(object, key2, bind4(object[key2], object));
        });
        return object;
      });
      function cond(pairs) {
        var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
        pairs = !length ? [] : arrayMap(pairs, function(pair) {
          if (typeof pair[1] != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return [toIteratee(pair[0]), pair[1]];
        });
        return baseRest(function(args) {
          var index2 = -1;
          while (++index2 < length) {
            var pair = pairs[index2];
            if (apply(pair[0], this, args)) {
              return apply(pair[1], this, args);
            }
          }
        });
      }
      function conforms(source2) {
        return baseConforms(baseClone(source2, CLONE_DEEP_FLAG));
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      function defaultTo(value, defaultValue) {
        return value == null || value !== value ? defaultValue : value;
      }
      var flow = createFlow();
      var flowRight = createFlow(true);
      function identity(value) {
        return value;
      }
      function iteratee(func) {
        return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
      }
      function matches2(source2) {
        return baseMatches(baseClone(source2, CLONE_DEEP_FLAG));
      }
      function matchesProperty(path, srcValue) {
        return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
      }
      var method = baseRest(function(path, args) {
        return function(object) {
          return baseInvoke(object, path, args);
        };
      });
      var methodOf = baseRest(function(object, args) {
        return function(path) {
          return baseInvoke(object, path, args);
        };
      });
      function mixin(object, source2, options) {
        var props2 = keys2(source2), methodNames = baseFunctions(source2, props2);
        if (options == null && !(isObject2(source2) && (methodNames.length || !props2.length))) {
          options = source2;
          source2 = object;
          object = this;
          methodNames = baseFunctions(source2, keys2(source2));
        }
        var chain2 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction2(object);
        arrayEach(methodNames, function(methodName) {
          var func = source2[methodName];
          object[methodName] = func;
          if (isFunc) {
            object.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain2 || chainAll) {
                var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                actions.push({ "func": func, "args": arguments, "thisArg": object });
                result2.__chain__ = chainAll;
                return result2;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            };
          }
        });
        return object;
      }
      function noConflict() {
        if (root2._ === this) {
          root2._ = oldDash;
        }
        return this;
      }
      function noop2() {
      }
      function nthArg(n) {
        n = toInteger2(n);
        return baseRest(function(args) {
          return baseNth(args, n);
        });
      }
      var over = createOver(arrayMap);
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome);
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      function propertyOf(object) {
        return function(path) {
          return object == null ? undefined$12 : baseGet(object, path);
        };
      }
      var range = createRange2();
      var rangeRight = createRange2(true);
      function stubArray() {
        return [];
      }
      function stubFalse() {
        return false;
      }
      function stubObject() {
        return {};
      }
      function stubString() {
        return "";
      }
      function stubTrue() {
        return true;
      }
      function times(n, iteratee2) {
        n = toInteger2(n);
        if (n < 1 || n > MAX_SAFE_INTEGER) {
          return [];
        }
        var index2 = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
        iteratee2 = getIteratee(iteratee2);
        n -= MAX_ARRAY_LENGTH;
        var result2 = baseTimes(length, iteratee2);
        while (++index2 < n) {
          iteratee2(index2);
        }
        return result2;
      }
      function toPath(value) {
        if (isArray2(value)) {
          return arrayMap(value, toKey);
        }
        return isSymbol2(value) ? [value] : copyArray(stringToPath3(toString2(value)));
      }
      function uniqueId(prefix) {
        var id = ++idCounter;
        return toString2(prefix) + id;
      }
      var add2 = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0);
      var ceil = createRound("ceil");
      var divide = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1);
      var floor2 = createRound("floor");
      function max2(array) {
        return array && array.length ? baseExtremum(array, identity, baseGt) : undefined$12;
      }
      function maxBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined$12;
      }
      function mean(array) {
        return baseMean(array, identity);
      }
      function meanBy(array, iteratee2) {
        return baseMean(array, getIteratee(iteratee2, 2));
      }
      function min(array) {
        return array && array.length ? baseExtremum(array, identity, baseLt) : undefined$12;
      }
      function minBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined$12;
      }
      var multiply = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var round = createRound("round");
      var subtract = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum(array) {
        return array && array.length ? baseSum(array, identity) : 0;
      }
      function sumBy(array, iteratee2) {
        return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
      }
      lodash2.after = after;
      lodash2.ary = ary;
      lodash2.assign = assign2;
      lodash2.assignIn = assignIn;
      lodash2.assignInWith = assignInWith;
      lodash2.assignWith = assignWith;
      lodash2.at = at2;
      lodash2.before = before;
      lodash2.bind = bind4;
      lodash2.bindAll = bindAll;
      lodash2.bindKey = bindKey;
      lodash2.castArray = castArray;
      lodash2.chain = chain;
      lodash2.chunk = chunk2;
      lodash2.compact = compact3;
      lodash2.concat = concat;
      lodash2.cond = cond;
      lodash2.conforms = conforms;
      lodash2.constant = constant;
      lodash2.countBy = countBy;
      lodash2.create = create2;
      lodash2.curry = curry;
      lodash2.curryRight = curryRight;
      lodash2.debounce = debounce;
      lodash2.defaults = defaults2;
      lodash2.defaultsDeep = defaultsDeep;
      lodash2.defer = defer;
      lodash2.delay = delay;
      lodash2.difference = difference;
      lodash2.differenceBy = differenceBy;
      lodash2.differenceWith = differenceWith;
      lodash2.drop = drop3;
      lodash2.dropRight = dropRight;
      lodash2.dropRightWhile = dropRightWhile;
      lodash2.dropWhile = dropWhile;
      lodash2.fill = fill;
      lodash2.filter = filter;
      lodash2.flatMap = flatMap;
      lodash2.flatMapDeep = flatMapDeep;
      lodash2.flatMapDepth = flatMapDepth;
      lodash2.flatten = flatten;
      lodash2.flattenDeep = flattenDeep;
      lodash2.flattenDepth = flattenDepth;
      lodash2.flip = flip;
      lodash2.flow = flow;
      lodash2.flowRight = flowRight;
      lodash2.fromPairs = fromPairs;
      lodash2.functions = functions;
      lodash2.functionsIn = functionsIn;
      lodash2.groupBy = groupBy;
      lodash2.initial = initial;
      lodash2.intersection = intersection;
      lodash2.intersectionBy = intersectionBy;
      lodash2.intersectionWith = intersectionWith;
      lodash2.invert = invert;
      lodash2.invertBy = invertBy;
      lodash2.invokeMap = invokeMap;
      lodash2.iteratee = iteratee;
      lodash2.keyBy = keyBy;
      lodash2.keys = keys2;
      lodash2.keysIn = keysIn;
      lodash2.map = map;
      lodash2.mapKeys = mapKeys;
      lodash2.mapValues = mapValues;
      lodash2.matches = matches2;
      lodash2.matchesProperty = matchesProperty;
      lodash2.memoize = memoize;
      lodash2.merge = merge3;
      lodash2.mergeWith = mergeWith;
      lodash2.method = method;
      lodash2.methodOf = methodOf;
      lodash2.mixin = mixin;
      lodash2.negate = negate;
      lodash2.nthArg = nthArg;
      lodash2.omit = omit2;
      lodash2.omitBy = omitBy;
      lodash2.once = once;
      lodash2.orderBy = orderBy;
      lodash2.over = over;
      lodash2.overArgs = overArgs;
      lodash2.overEvery = overEvery;
      lodash2.overSome = overSome;
      lodash2.partial = partial;
      lodash2.partialRight = partialRight;
      lodash2.partition = partition;
      lodash2.pick = pick2;
      lodash2.pickBy = pickBy;
      lodash2.property = property;
      lodash2.propertyOf = propertyOf;
      lodash2.pull = pull;
      lodash2.pullAll = pullAll;
      lodash2.pullAllBy = pullAllBy;
      lodash2.pullAllWith = pullAllWith;
      lodash2.pullAt = pullAt;
      lodash2.range = range;
      lodash2.rangeRight = rangeRight;
      lodash2.rearg = rearg;
      lodash2.reject = reject;
      lodash2.remove = remove2;
      lodash2.rest = rest;
      lodash2.reverse = reverse;
      lodash2.sampleSize = sampleSize;
      lodash2.set = set2;
      lodash2.setWith = setWith;
      lodash2.shuffle = shuffle;
      lodash2.slice = slice;
      lodash2.sortBy = sortBy;
      lodash2.sortedUniq = sortedUniq;
      lodash2.sortedUniqBy = sortedUniqBy;
      lodash2.split = split;
      lodash2.spread = spread2;
      lodash2.tail = tail;
      lodash2.take = take;
      lodash2.takeRight = takeRight;
      lodash2.takeRightWhile = takeRightWhile;
      lodash2.takeWhile = takeWhile;
      lodash2.tap = tap;
      lodash2.throttle = throttle2;
      lodash2.thru = thru;
      lodash2.toArray = toArray2;
      lodash2.toPairs = toPairs;
      lodash2.toPairsIn = toPairsIn;
      lodash2.toPath = toPath;
      lodash2.toPlainObject = toPlainObject;
      lodash2.transform = transform2;
      lodash2.unary = unary;
      lodash2.union = union;
      lodash2.unionBy = unionBy;
      lodash2.unionWith = unionWith;
      lodash2.uniq = uniq;
      lodash2.uniqBy = uniqBy;
      lodash2.uniqWith = uniqWith;
      lodash2.unset = unset;
      lodash2.unzip = unzip;
      lodash2.unzipWith = unzipWith;
      lodash2.update = update;
      lodash2.updateWith = updateWith;
      lodash2.values = values;
      lodash2.valuesIn = valuesIn;
      lodash2.without = without;
      lodash2.words = words;
      lodash2.wrap = wrap;
      lodash2.xor = xor;
      lodash2.xorBy = xorBy;
      lodash2.xorWith = xorWith;
      lodash2.zip = zip;
      lodash2.zipObject = zipObject;
      lodash2.zipObjectDeep = zipObjectDeep;
      lodash2.zipWith = zipWith;
      lodash2.entries = toPairs;
      lodash2.entriesIn = toPairsIn;
      lodash2.extend = assignIn;
      lodash2.extendWith = assignInWith;
      mixin(lodash2, lodash2);
      lodash2.add = add2;
      lodash2.attempt = attempt;
      lodash2.camelCase = camelCase;
      lodash2.capitalize = capitalize2;
      lodash2.ceil = ceil;
      lodash2.clamp = clamp2;
      lodash2.clone = clone2;
      lodash2.cloneDeep = cloneDeep;
      lodash2.cloneDeepWith = cloneDeepWith;
      lodash2.cloneWith = cloneWith;
      lodash2.conformsTo = conformsTo;
      lodash2.deburr = deburr;
      lodash2.defaultTo = defaultTo;
      lodash2.divide = divide;
      lodash2.endsWith = endsWith;
      lodash2.eq = eq;
      lodash2.escape = escape2;
      lodash2.escapeRegExp = escapeRegExp;
      lodash2.every = every;
      lodash2.find = find2;
      lodash2.findIndex = findIndex2;
      lodash2.findKey = findKey2;
      lodash2.findLast = findLast;
      lodash2.findLastIndex = findLastIndex;
      lodash2.findLastKey = findLastKey;
      lodash2.floor = floor2;
      lodash2.forEach = forEach3;
      lodash2.forEachRight = forEachRight;
      lodash2.forIn = forIn;
      lodash2.forInRight = forInRight;
      lodash2.forOwn = forOwn;
      lodash2.forOwnRight = forOwnRight;
      lodash2.get = get2;
      lodash2.gt = gt2;
      lodash2.gte = gte;
      lodash2.has = has2;
      lodash2.hasIn = hasIn;
      lodash2.head = head;
      lodash2.identity = identity;
      lodash2.includes = includes2;
      lodash2.indexOf = indexOf2;
      lodash2.inRange = inRange;
      lodash2.invoke = invoke;
      lodash2.isArguments = isArguments;
      lodash2.isArray = isArray2;
      lodash2.isArrayBuffer = isArrayBuffer2;
      lodash2.isArrayLike = isArrayLike;
      lodash2.isArrayLikeObject = isArrayLikeObject;
      lodash2.isBoolean = isBoolean2;
      lodash2.isBuffer = isBuffer3;
      lodash2.isDate = isDate2;
      lodash2.isElement = isElement2;
      lodash2.isEmpty = isEmpty;
      lodash2.isEqual = isEqual2;
      lodash2.isEqualWith = isEqualWith;
      lodash2.isError = isError2;
      lodash2.isFinite = isFinite2;
      lodash2.isFunction = isFunction2;
      lodash2.isInteger = isInteger;
      lodash2.isLength = isLength;
      lodash2.isMap = isMap2;
      lodash2.isMatch = isMatch;
      lodash2.isMatchWith = isMatchWith;
      lodash2.isNaN = isNaN2;
      lodash2.isNative = isNative;
      lodash2.isNil = isNil;
      lodash2.isNull = isNull;
      lodash2.isNumber = isNumber2;
      lodash2.isObject = isObject2;
      lodash2.isObjectLike = isObjectLike;
      lodash2.isPlainObject = isPlainObject2;
      lodash2.isRegExp = isRegExp3;
      lodash2.isSafeInteger = isSafeInteger;
      lodash2.isSet = isSet2;
      lodash2.isString = isString2;
      lodash2.isSymbol = isSymbol2;
      lodash2.isTypedArray = isTypedArray;
      lodash2.isUndefined = isUndefined2;
      lodash2.isWeakMap = isWeakMap2;
      lodash2.isWeakSet = isWeakSet2;
      lodash2.join = join;
      lodash2.kebabCase = kebabCase;
      lodash2.last = last;
      lodash2.lastIndexOf = lastIndexOf;
      lodash2.lowerCase = lowerCase;
      lodash2.lowerFirst = lowerFirst;
      lodash2.lt = lt2;
      lodash2.lte = lte;
      lodash2.max = max2;
      lodash2.maxBy = maxBy;
      lodash2.mean = mean;
      lodash2.meanBy = meanBy;
      lodash2.min = min;
      lodash2.minBy = minBy;
      lodash2.stubArray = stubArray;
      lodash2.stubFalse = stubFalse;
      lodash2.stubObject = stubObject;
      lodash2.stubString = stubString;
      lodash2.stubTrue = stubTrue;
      lodash2.multiply = multiply;
      lodash2.nth = nth;
      lodash2.noConflict = noConflict;
      lodash2.noop = noop2;
      lodash2.now = now;
      lodash2.pad = pad;
      lodash2.padEnd = padEnd2;
      lodash2.padStart = padStart2;
      lodash2.parseInt = parseInt2;
      lodash2.random = random;
      lodash2.reduce = reduce;
      lodash2.reduceRight = reduceRight;
      lodash2.repeat = repeat2;
      lodash2.replace = replace2;
      lodash2.result = result;
      lodash2.round = round;
      lodash2.runInContext = runInContext2;
      lodash2.sample = sample;
      lodash2.size = size2;
      lodash2.snakeCase = snakeCase;
      lodash2.some = some;
      lodash2.sortedIndex = sortedIndex;
      lodash2.sortedIndexBy = sortedIndexBy;
      lodash2.sortedIndexOf = sortedIndexOf;
      lodash2.sortedLastIndex = sortedLastIndex;
      lodash2.sortedLastIndexBy = sortedLastIndexBy;
      lodash2.sortedLastIndexOf = sortedLastIndexOf;
      lodash2.startCase = startCase;
      lodash2.startsWith = startsWith;
      lodash2.subtract = subtract;
      lodash2.sum = sum;
      lodash2.sumBy = sumBy;
      lodash2.template = template;
      lodash2.times = times;
      lodash2.toFinite = toFinite;
      lodash2.toInteger = toInteger2;
      lodash2.toLength = toLength;
      lodash2.toLower = toLower;
      lodash2.toNumber = toNumber2;
      lodash2.toSafeInteger = toSafeInteger;
      lodash2.toString = toString2;
      lodash2.toUpper = toUpper;
      lodash2.trim = trim2;
      lodash2.trimEnd = trimEnd;
      lodash2.trimStart = trimStart;
      lodash2.truncate = truncate;
      lodash2.unescape = unescape2;
      lodash2.uniqueId = uniqueId;
      lodash2.upperCase = upperCase;
      lodash2.upperFirst = upperFirst;
      lodash2.each = forEach3;
      lodash2.eachRight = forEachRight;
      lodash2.first = head;
      mixin(lodash2, function() {
        var source2 = {};
        baseForOwn(lodash2, function(func, methodName) {
          if (!hasOwnProperty2.call(lodash2.prototype, methodName)) {
            source2[methodName] = func;
          }
        });
        return source2;
      }(), { "chain": false });
      lodash2.VERSION = VERSION;
      arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash2[methodName].placeholder = lodash2;
      });
      arrayEach(["drop", "take"], function(methodName, index2) {
        LazyWrapper.prototype[methodName] = function(n) {
          n = n === undefined$12 ? 1 : nativeMax(toInteger2(n), 0);
          var result2 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
          if (result2.__filtered__) {
            result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
          } else {
            result2.__views__.push({
              "size": nativeMin(n, MAX_ARRAY_LENGTH),
              "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
            });
          }
          return result2;
        };
        LazyWrapper.prototype[methodName + "Right"] = function(n) {
          return this.reverse()[methodName](n).reverse();
        };
      });
      arrayEach(["filter", "map", "takeWhile"], function(methodName, index2) {
        var type2 = index2 + 1, isFilter = type2 == LAZY_FILTER_FLAG || type2 == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result2 = this.clone();
          result2.__iteratees__.push({
            "iteratee": getIteratee(iteratee2, 3),
            "type": type2
          });
          result2.__filtered__ = result2.__filtered__ || isFilter;
          return result2;
        };
      });
      arrayEach(["head", "last"], function(methodName, index2) {
        var takeName = "take" + (index2 ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach(["initial", "tail"], function(methodName, index2) {
        var dropName = "drop" + (index2 ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });
      LazyWrapper.prototype.compact = function() {
        return this.filter(identity);
      };
      LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      };
      LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      };
      LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
        if (typeof path == "function") {
          return new LazyWrapper(this);
        }
        return this.map(function(value) {
          return baseInvoke(value, path, args);
        });
      });
      LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate(getIteratee(predicate)));
      };
      LazyWrapper.prototype.slice = function(start, end) {
        start = toInteger2(start);
        var result2 = this;
        if (result2.__filtered__ && (start > 0 || end < 0)) {
          return new LazyWrapper(result2);
        }
        if (start < 0) {
          result2 = result2.takeRight(-start);
        } else if (start) {
          result2 = result2.drop(start);
        }
        if (end !== undefined$12) {
          end = toInteger2(end);
          result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
        }
        return result2;
      };
      LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };
      LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH);
      };
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        if (!lodashFunc) {
          return;
        }
        lodash2.prototype[methodName] = function() {
          var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy2 = isLazy || isArray2(value);
          var interceptor = function(value2) {
            var result3 = lodashFunc.apply(lodash2, arrayPush([value2], args));
            return isTaker && chainAll ? result3[0] : result3;
          };
          if (useLazy2 && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
            isLazy = useLazy2 = false;
          }
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy2) {
            value = onlyLazy ? value : new LazyWrapper(this);
            var result2 = func.apply(value, args);
            result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined$12 });
            return new LodashWrapper(result2, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func.apply(this, args);
          }
          result2 = this.thru(interceptor);
          return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
        };
      });
      arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash2.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value = this.value();
            return func.apply(isArray2(value) ? value : [], args);
          }
          return this[chainName](function(value2) {
            return func.apply(isArray2(value2) ? value2 : [], args);
          });
        };
      });
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash2[methodName];
        if (lodashFunc) {
          var key2 = lodashFunc.name + "";
          if (!hasOwnProperty2.call(realNames, key2)) {
            realNames[key2] = [];
          }
          realNames[key2].push({ "name": methodName, "func": lodashFunc });
        }
      });
      realNames[createHybrid(undefined$12, WRAP_BIND_KEY_FLAG).name] = [{
        "name": "wrapper",
        "func": undefined$12
      }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash2.prototype.at = wrapperAt;
      lodash2.prototype.chain = wrapperChain;
      lodash2.prototype.commit = wrapperCommit;
      lodash2.prototype.next = wrapperNext;
      lodash2.prototype.plant = wrapperPlant;
      lodash2.prototype.reverse = wrapperReverse;
      lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
      lodash2.prototype.first = lodash2.prototype.head;
      if (symIterator) {
        lodash2.prototype[symIterator] = wrapperToIterator;
      }
      return lodash2;
    };
    var _2 = runInContext();
    if (freeModule) {
      (freeModule.exports = _2)._ = _2;
      freeExports._ = _2;
    } else {
      root2._ = _2;
    }
  }).call(commonjsGlobal);
})(lodash, lodash.exports);
var lodashExports = lodash.exports;
const _$1 = /* @__PURE__ */ getDefaultExportFromCjs(lodashExports);
function makeMap(str, expectsLowerCase) {
  const map = /* @__PURE__ */ Object.create(null);
  const list = str.split(",");
  for (let i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];
}
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const onRE$1 = /^on[^a-z]/;
const isOn$1 = (key2) => onRE$1.test(key2);
const isModelListener = (key2) => key2.startsWith("onUpdate:");
const extend$2 = Object.assign;
const remove = (arr, el) => {
  const i = arr.indexOf(el);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty$1 = Object.prototype.hasOwnProperty;
const hasOwn$2 = (val, key2) => hasOwnProperty$1.call(val, key2);
const isArray$6 = Array.isArray;
const isMap$1 = (val) => toTypeString(val) === "[object Map]";
const isSet$1 = (val) => toTypeString(val) === "[object Set]";
const isDate$2 = (val) => toTypeString(val) === "[object Date]";
const isRegExp$2 = (val) => toTypeString(val) === "[object RegExp]";
const isFunction$1 = (val) => typeof val === "function";
const isString$2 = (val) => typeof val === "string";
const isSymbol$1 = (val) => typeof val === "symbol";
const isObject$2 = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return (isObject$2(val) || isFunction$1(val)) && isFunction$1(val.then) && isFunction$1(val.catch);
};
const objectToString$1 = Object.prototype.toString;
const toTypeString = (value) => objectToString$1.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key2) => isString$2(key2) && key2 !== "NaN" && key2[0] !== "-" && "" + parseInt(key2, 10) === key2;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_2, c2) => c2 ? c2.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
const capitalize = cacheStringFunction((str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
const toHandlerKey = cacheStringFunction((str) => {
  const s = str ? `on${capitalize(str)}` : ``;
  return s;
});
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](arg);
  }
};
const def = (obj, key2, value) => {
  Object.defineProperty(obj, key2, {
    configurable: true,
    enumerable: false,
    value
  });
};
const looseToNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
const toNumber = (val) => {
  const n = isString$2(val) ? Number(val) : NaN;
  return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
const GLOBALS_ALLOWED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console";
const isGloballyAllowed = /* @__PURE__ */ makeMap(GLOBALS_ALLOWED);
function normalizeStyle(value) {
  if (isArray$6(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString$2(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key2 in normalized) {
          res[key2] = normalized[key2];
        }
      }
    }
    return res;
  } else if (isString$2(value) || isObject$2(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString$2(value)) {
    res = value;
  } else if (isArray$6(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$2(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
function normalizeProps(props2) {
  if (!props2)
    return null;
  let { class: klass, style: style3 } = props2;
  if (klass && !isString$2(klass)) {
    props2.class = normalizeClass(klass);
  }
  if (style3) {
    props2.style = normalizeStyle(style3);
  }
  return props2;
}
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
function looseCompareArrays(a, b2) {
  if (a.length !== b2.length)
    return false;
  let equal = true;
  for (let i = 0; equal && i < a.length; i++) {
    equal = looseEqual(a[i], b2[i]);
  }
  return equal;
}
function looseEqual(a, b2) {
  if (a === b2)
    return true;
  let aValidType = isDate$2(a);
  let bValidType = isDate$2(b2);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b2.getTime() : false;
  }
  aValidType = isSymbol$1(a);
  bValidType = isSymbol$1(b2);
  if (aValidType || bValidType) {
    return a === b2;
  }
  aValidType = isArray$6(a);
  bValidType = isArray$6(b2);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a, b2) : false;
  }
  aValidType = isObject$2(a);
  bValidType = isObject$2(b2);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a).length;
    const bKeysCount = Object.keys(b2).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key2 in a) {
      const aHasKey = a.hasOwnProperty(key2);
      const bHasKey = b2.hasOwnProperty(key2);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key2], b2[key2])) {
        return false;
      }
    }
  }
  return String(a) === String(b2);
}
function looseIndexOf(arr, val) {
  return arr.findIndex((item) => looseEqual(item, val));
}
const toDisplayString = (val) => {
  return isString$2(val) ? val : val == null ? "" : isArray$6(val) || isObject$2(val) && (val.toString === objectToString$1 || !isFunction$1(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (val && val.__v_isRef) {
    return replacer(_key, val.value);
  } else if (isMap$1(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key2, val2]) => {
        entries[`${key2} =>`] = val2;
        return entries;
      }, {})
    };
  } else if (isSet$1(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()]
    };
  } else if (isObject$2(val) && !isArray$6(val) && !isPlainObject(val)) {
    return String(val);
  }
  return val;
};
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    this._active = true;
    this.effects = [];
    this.cleanups = [];
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
    }
  }
  get active() {
    return this._active;
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    activeEffectScope = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this._active) {
      let i, l;
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop();
      }
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]();
      }
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true);
        }
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
      this._active = false;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
function recordEffectScope(effect2, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect2);
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  }
}
const createDep = (effects) => {
  const dep = new Set(effects);
  dep.w = 0;
  dep.n = 0;
  return dep;
};
const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
const newTracked = (dep) => (dep.n & trackOpBit) > 0;
const initDepMarkers = ({ deps }) => {
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].w |= trackOpBit;
    }
  }
};
const finalizeDepMarkers = (effect2) => {
  const { deps } = effect2;
  if (deps.length) {
    let ptr = 0;
    for (let i = 0; i < deps.length; i++) {
      const dep = deps[i];
      if (wasTracked(dep) && !newTracked(dep)) {
        dep.delete(effect2);
      } else {
        deps[ptr++] = dep;
      }
      dep.w &= ~trackOpBit;
      dep.n &= ~trackOpBit;
    }
    deps.length = ptr;
  }
};
const targetMap = /* @__PURE__ */ new WeakMap();
let effectTrackDepth = 0;
let trackOpBit = 1;
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol("");
const MAP_KEY_ITERATE_KEY = Symbol("");
class ReactiveEffect {
  constructor(fn, scheduler = null, scope) {
    this.fn = fn;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    this.parent = void 0;
    recordEffectScope(this, scope);
  }
  run() {
    if (!this.active) {
      return this.fn();
    }
    let parent = activeEffect;
    let lastShouldTrack = shouldTrack;
    while (parent) {
      if (parent === this) {
        return;
      }
      parent = parent.parent;
    }
    try {
      this.parent = activeEffect;
      activeEffect = this;
      shouldTrack = true;
      trackOpBit = 1 << ++effectTrackDepth;
      if (effectTrackDepth <= maxMarkerBits) {
        initDepMarkers(this);
      } else {
        cleanupEffect(this);
      }
      return this.fn();
    } finally {
      if (effectTrackDepth <= maxMarkerBits) {
        finalizeDepMarkers(this);
      }
      trackOpBit = 1 << --effectTrackDepth;
      activeEffect = this.parent;
      shouldTrack = lastShouldTrack;
      this.parent = void 0;
      if (this.deferStop) {
        this.stop();
      }
    }
  }
  stop() {
    if (activeEffect === this) {
      this.deferStop = true;
    } else if (this.active) {
      cleanupEffect(this);
      if (this.onStop) {
        this.onStop();
      }
      this.active = false;
    }
  }
}
function cleanupEffect(effect2) {
  const { deps } = effect2;
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].delete(effect2);
    }
    deps.length = 0;
  }
}
function effect(fn, options) {
  if (fn.effect instanceof ReactiveEffect) {
    fn = fn.effect.fn;
  }
  const _effect = new ReactiveEffect(fn);
  if (options) {
    extend$2(_effect, options);
    if (options.scope)
      recordEffectScope(_effect, options.scope);
  }
  if (!options || !options.lazy) {
    _effect.run();
  }
  const runner = _effect.run.bind(_effect);
  runner.effect = _effect;
  return runner;
}
function stop(runner) {
  runner.effect.stop();
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function track(target, type2, key2) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key2);
    if (!dep) {
      depsMap.set(key2, dep = createDep());
    }
    trackEffects(dep);
  }
}
function trackEffects(dep, debuggerEventExtraInfo) {
  let shouldTrack2 = false;
  if (effectTrackDepth <= maxMarkerBits) {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit;
      shouldTrack2 = !wasTracked(dep);
    }
  } else {
    shouldTrack2 = !dep.has(activeEffect);
  }
  if (shouldTrack2) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
  }
}
function trigger(target, type2, key2, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type2 === "clear") {
    deps = [...depsMap.values()];
  } else if (key2 === "length" && isArray$6(target)) {
    const newLength = Number(newValue);
    depsMap.forEach((dep, key22) => {
      if (key22 === "length" || key22 >= newLength) {
        deps.push(dep);
      }
    });
  } else {
    if (key2 !== void 0) {
      deps.push(depsMap.get(key2));
    }
    switch (type2) {
      case "add":
        if (!isArray$6(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap$1(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key2)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray$6(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap$1(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap$1(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  if (deps.length === 1) {
    if (deps[0]) {
      {
        triggerEffects(deps[0]);
      }
    }
  } else {
    const effects = [];
    for (const dep of deps) {
      if (dep) {
        effects.push(...dep);
      }
    }
    {
      triggerEffects(createDep(effects));
    }
  }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
  const effects = isArray$6(dep) ? dep : [...dep];
  for (const effect2 of effects) {
    if (effect2.computed) {
      triggerEffect(effect2);
    }
  }
  for (const effect2 of effects) {
    if (!effect2.computed) {
      triggerEffect(effect2);
    }
  }
}
function triggerEffect(effect2, debuggerEventExtraInfo) {
  if (effect2 !== activeEffect || effect2.allowRecurse) {
    if (effect2.scheduler) {
      effect2.scheduler();
    } else {
      effect2.run();
    }
  }
}
function getDepFromReactive(object, key2) {
  var _a2;
  return (_a2 = targetMap.get(object)) == null ? void 0 : _a2.get(key2);
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key2) => key2 !== "arguments" && key2 !== "caller").map((key2) => Symbol[key2]).filter(isSymbol$1)
);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key2) => {
    instrumentations[key2] = function(...args) {
      const arr = toRaw(this);
      for (let i = 0, l = this.length; i < l; i++) {
        track(arr, "get", i + "");
      }
      const res = arr[key2](...args);
      if (res === -1 || res === false) {
        return arr[key2](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key2) => {
    instrumentations[key2] = function(...args) {
      pauseTracking();
      const res = toRaw(this)[key2].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function hasOwnProperty(key2) {
  const obj = toRaw(this);
  track(obj, "has", key2);
  return obj.hasOwnProperty(key2);
}
class BaseReactiveHandler {
  constructor(_isReadonly = false, _shallow = false) {
    this._isReadonly = _isReadonly;
    this._shallow = _shallow;
  }
  get(target, key2, receiver) {
    const isReadonly2 = this._isReadonly, shallow = this._shallow;
    if (key2 === "__v_isReactive") {
      return !isReadonly2;
    } else if (key2 === "__v_isReadonly") {
      return isReadonly2;
    } else if (key2 === "__v_isShallow") {
      return shallow;
    } else if (key2 === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }
    const targetIsArray = isArray$6(target);
    if (!isReadonly2) {
      if (targetIsArray && hasOwn$2(arrayInstrumentations, key2)) {
        return Reflect.get(arrayInstrumentations, key2, receiver);
      }
      if (key2 === "hasOwnProperty") {
        return hasOwnProperty;
      }
    }
    const res = Reflect.get(target, key2, receiver);
    if (isSymbol$1(key2) ? builtInSymbols.has(key2) : isNonTrackableKeys(key2)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key2);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key2) ? res : res.value;
    }
    if (isObject$2(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  }
}
class MutableReactiveHandler extends BaseReactiveHandler {
  constructor(shallow = false) {
    super(false, shallow);
  }
  set(target, key2, value, receiver) {
    let oldValue = target[key2];
    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
      return false;
    }
    if (!this._shallow) {
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArray$6(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey = isArray$6(target) && isIntegerKey(key2) ? Number(key2) < target.length : hasOwn$2(target, key2);
    const result = Reflect.set(target, key2, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key2, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key2, value);
      }
    }
    return result;
  }
  deleteProperty(target, key2) {
    const hadKey = hasOwn$2(target, key2);
    target[key2];
    const result = Reflect.deleteProperty(target, key2);
    if (result && hadKey) {
      trigger(target, "delete", key2, void 0);
    }
    return result;
  }
  has(target, key2) {
    const result = Reflect.has(target, key2);
    if (!isSymbol$1(key2) || !builtInSymbols.has(key2)) {
      track(target, "has", key2);
    }
    return result;
  }
  ownKeys(target) {
    track(
      target,
      "iterate",
      isArray$6(target) ? "length" : ITERATE_KEY
    );
    return Reflect.ownKeys(target);
  }
}
class ReadonlyReactiveHandler extends BaseReactiveHandler {
  constructor(shallow = false) {
    super(true, shallow);
  }
  set(target, key2) {
    return true;
  }
  deleteProperty(target, key2) {
    return true;
  }
}
const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(
  true
);
const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
const toShallow = (value) => value;
const getProto$1 = (v2) => Reflect.getPrototypeOf(v2);
function get(target, key2, isReadonly2 = false, isShallow2 = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key2);
  if (!isReadonly2) {
    if (hasChanged(key2, rawKey)) {
      track(rawTarget, "get", key2);
    }
    track(rawTarget, "get", rawKey);
  }
  const { has: has2 } = getProto$1(rawTarget);
  const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key2)) {
    return wrap(target.get(key2));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key2);
  }
}
function has$5(key2, isReadonly2 = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key2);
  if (!isReadonly2) {
    if (hasChanged(key2, rawKey)) {
      track(rawTarget, "has", key2);
    }
    track(rawTarget, "has", rawKey);
  }
  return key2 === rawKey ? target.has(key2) : target.has(key2) || target.has(rawKey);
}
function size(target, isReadonly2 = false) {
  target = target["__v_raw"];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto$1(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}
function set(key2, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto$1(target);
  let hadKey = has2.call(target, key2);
  if (!hadKey) {
    key2 = toRaw(key2);
    hadKey = has2.call(target, key2);
  }
  const oldValue = get2.call(target, key2);
  target.set(key2, value);
  if (!hadKey) {
    trigger(target, "add", key2, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target, "set", key2, value);
  }
  return this;
}
function deleteEntry(key2) {
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto$1(target);
  let hadKey = has2.call(target, key2);
  if (!hadKey) {
    key2 = toRaw(key2);
    hadKey = has2.call(target, key2);
  }
  get2 ? get2.call(target, key2) : void 0;
  const result = target.delete(key2);
  if (hadKey) {
    trigger(target, "delete", key2, void 0);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach3(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key2) => {
      return callback.call(thisArg, wrap(value), wrap(key2), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap$1(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return {
      // iterator protocol
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type2) {
  return function(...args) {
    return type2 === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key2) {
      return get(this, key2);
    },
    get size() {
      return size(this);
    },
    has: has$5,
    add,
    set,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key2) {
      return get(this, key2, false, true);
    },
    get size() {
      return size(this);
    },
    has: has$5,
    add,
    set,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key2) {
      return get(this, key2, true);
    },
    get size() {
      return size(this, true);
    },
    has(key2) {
      return has$5.call(this, key2, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key2) {
      return get(this, key2, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key2) {
      return has$5.call(this, key2, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(
      method,
      false,
      false
    );
    readonlyInstrumentations2[method] = createIterableMethod(
      method,
      true,
      false
    );
    shallowInstrumentations2[method] = createIterableMethod(
      method,
      false,
      true
    );
    shallowReadonlyInstrumentations2[method] = createIterableMethod(
      method,
      true,
      true
    );
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [
  mutableInstrumentations,
  readonlyInstrumentations,
  shallowInstrumentations,
  shallowReadonlyInstrumentations
] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key2, receiver) => {
    if (key2 === "__v_isReactive") {
      return !isReadonly2;
    } else if (key2 === "__v_isReadonly") {
      return isReadonly2;
    } else if (key2 === "__v_raw") {
      return target;
    }
    return Reflect.get(
      hasOwn$2(instrumentations, key2) && key2 in target ? instrumentations : target,
      key2,
      receiver
    );
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
function shallowReactive(target) {
  return createReactiveObject(
    target,
    false,
    shallowReactiveHandlers,
    shallowCollectionHandlers,
    shallowReactiveMap
  );
}
function readonly(target) {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
function shallowReadonly(target) {
  return createReactiveObject(
    target,
    true,
    shallowReadonlyHandlers,
    shallowReadonlyCollectionHandlers,
    shallowReadonlyMap
  );
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$2(target)) {
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(
    target,
    targetType === 2 ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  def(value, "__v_skip", true);
  return value;
}
const toReactive = (value) => isObject$2(value) ? reactive(value) : value;
const toReadonly = (value) => isObject$2(value) ? readonly(value) : value;
function trackRefValue(ref2) {
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    {
      trackEffects(ref2.dep || (ref2.dep = createDep()));
    }
  }
}
function triggerRefValue(ref2, newVal) {
  ref2 = toRaw(ref2);
  const dep = ref2.dep;
  if (dep) {
    {
      triggerEffects(dep);
    }
  }
}
function isRef(r) {
  return !!(r && r.__v_isRef === true);
}
function ref(value) {
  return createRef(value, false);
}
function shallowRef(value) {
  return createRef(value, true);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, __v_isShallow) {
    this.__v_isShallow = __v_isShallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = __v_isShallow ? value : toRaw(value);
    this._value = __v_isShallow ? value : toReactive(value);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
    newVal = useDirectValue ? newVal : toRaw(newVal);
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue = newVal;
      this._value = useDirectValue ? newVal : toReactive(newVal);
      triggerRefValue(this);
    }
  }
}
function triggerRef(ref2) {
  triggerRefValue(ref2);
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
function toValue(source2) {
  return isFunction$1(source2) ? source2() : unref(source2);
}
const shallowUnwrapHandlers = {
  get: (target, key2, receiver) => unref(Reflect.get(target, key2, receiver)),
  set: (target, key2, value, receiver) => {
    const oldValue = target[key2];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key2, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class CustomRefImpl {
  constructor(factory) {
    this.dep = void 0;
    this.__v_isRef = true;
    const { get: get2, set: set2 } = factory(
      () => trackRefValue(this),
      () => triggerRefValue(this)
    );
    this._get = get2;
    this._set = set2;
  }
  get value() {
    return this._get();
  }
  set value(newVal) {
    this._set(newVal);
  }
}
function customRef(factory) {
  return new CustomRefImpl(factory);
}
function toRefs(object) {
  const ret = isArray$6(object) ? new Array(object.length) : {};
  for (const key2 in object) {
    ret[key2] = propertyToRef(object, key2);
  }
  return ret;
}
class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this.__v_isRef = true;
  }
  get value() {
    const val = this._object[this._key];
    return val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
  get dep() {
    return getDepFromReactive(toRaw(this._object), this._key);
  }
}
class GetterRefImpl {
  constructor(_getter) {
    this._getter = _getter;
    this.__v_isRef = true;
    this.__v_isReadonly = true;
  }
  get value() {
    return this._getter();
  }
}
function toRef(source2, key2, defaultValue) {
  if (isRef(source2)) {
    return source2;
  } else if (isFunction$1(source2)) {
    return new GetterRefImpl(source2);
  } else if (isObject$2(source2) && arguments.length > 1) {
    return propertyToRef(source2, key2, defaultValue);
  } else {
    return ref(source2);
  }
}
function propertyToRef(source2, key2, defaultValue) {
  const val = source2[key2];
  return isRef(val) ? val : new ObjectRefImpl(source2, key2, defaultValue);
}
class ComputedRefImpl {
  constructor(getter, _setter, isReadonly2, isSSR) {
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this["__v_isReadonly"] = false;
    this._dirty = true;
    this.effect = new ReactiveEffect(getter, () => {
      if (!this._dirty) {
        this._dirty = true;
        triggerRefValue(this);
      }
    });
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this["__v_isReadonly"] = isReadonly2;
  }
  get value() {
    const self2 = toRaw(this);
    trackRefValue(self2);
    if (self2._dirty || !self2._cacheable) {
      self2._dirty = false;
      self2._value = self2.effect.run();
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
}
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = isFunction$1(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = NOOP;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  return cRef;
}
function warn(msg, ...args) {
  return;
}
function assertNumber(val, type2) {
  return;
}
function callWithErrorHandling(fn, instance, type2, args) {
  let res;
  try {
    res = args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type2);
  }
  return res;
}
function callWithAsyncErrorHandling(fn, instance, type2, args) {
  if (isFunction$1(fn)) {
    const res = callWithErrorHandling(fn, instance, type2, args);
    if (res && isPromise(res)) {
      res.catch((err) => {
        handleError(err, instance, type2);
      });
    }
    return res;
  }
  const values = [];
  for (let i = 0; i < fn.length; i++) {
    values.push(callWithAsyncErrorHandling(fn[i], instance, type2, args));
  }
  return values;
}
function handleError(err, instance, type2, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = type2;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling(
        appErrorHandler,
        null,
        10,
        [err, exposedInstance, errorInfo]
      );
      return;
    }
  }
  logError(err, type2, contextVNode, throwInDev);
}
function logError(err, type2, contextVNode, throwInDev = true) {
  {
    console.error(err);
  }
}
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
function nextTick(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
function findInsertionIndex(id) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJobId = getId(queue[middle]);
    middleJobId < id ? start = middle + 1 : end = middle;
  }
  return start;
}
function queueJob(job) {
  if (!queue.length || !queue.includes(
    job,
    isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
  )) {
    if (job.id == null) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function invalidateJob(job) {
  const i = queue.indexOf(job);
  if (i > flushIndex) {
    queue.splice(i, 1);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray$6(cb)) {
    if (!activePostFlushCbs || !activePostFlushCbs.includes(
      cb,
      cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex
    )) {
      pendingPostFlushCbs.push(cb);
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(seen, i = isFlushing ? flushIndex + 1 : 0) {
  for (; i < queue.length; i++) {
    const cb = queue[i];
    if (cb && cb.pre) {
      queue.splice(i, 1);
      i--;
      cb();
    }
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)];
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    activePostFlushCbs.sort((a, b2) => getId(a) - getId(b2));
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? Infinity : job.id;
const comparator = (a, b2) => {
  const diff = getId(a) - getId(b2);
  if (diff === 0) {
    if (a.pre && !b2.pre)
      return -1;
    if (b2.pre && !a.pre)
      return 1;
  }
  return diff;
};
function flushJobs(seen) {
  isFlushPending = false;
  isFlushing = true;
  queue.sort(comparator);
  const check = NOOP;
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && job.active !== false) {
        if (false)
          ;
        callWithErrorHandling(job, null, 14);
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs();
    isFlushing = false;
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs();
    }
  }
}
let devtools;
let buffer$1 = [];
function setDevtoolsHook(hook, target) {
  var _a2, _b;
  devtools = hook;
  if (devtools) {
    devtools.enabled = true;
    buffer$1.forEach(({ event, args }) => devtools.emit(event, ...args));
    buffer$1 = [];
  } else if (
    // handle late devtools injection - only do this if we are in an actual
    // browser environment to avoid the timer handle stalling test runner exit
    // (#4815)
    typeof window !== "undefined" && // some envs mock window but not fully
    window.HTMLElement && // also exclude jsdom
    !((_b = (_a2 = window.navigator) == null ? void 0 : _a2.userAgent) == null ? void 0 : _b.includes("jsdom"))
  ) {
    const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
    replay.push((newHook) => {
      setDevtoolsHook(newHook, target);
    });
    setTimeout(() => {
      if (!devtools) {
        target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
        buffer$1 = [];
      }
    }, 3e3);
  } else {
    buffer$1 = [];
  }
}
function emit(instance, event, ...rawArgs) {
  if (instance.isUnmounted)
    return;
  const props2 = instance.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modelArg = isModelListener2 && event.slice(7);
  if (modelArg && modelArg in props2) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number, trim: trim2 } = props2[modifiersKey] || EMPTY_OBJ;
    if (trim2) {
      args = rawArgs.map((a) => isString$2(a) ? a.trim() : a);
    }
    if (number) {
      args = rawArgs.map(looseToNumber);
    }
  }
  let handlerName;
  let handler = props2[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
  props2[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props2[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(
      handler,
      instance,
      6,
      args
    );
  }
  const onceHandler = props2[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(
      onceHandler,
      instance,
      6,
      args
    );
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.emitsCache;
  const cached = cache.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction$1(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend$2(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$2(comp)) {
      cache.set(comp, null);
    }
    return null;
  }
  if (isArray$6(raw)) {
    raw.forEach((key2) => normalized[key2] = null);
  } else {
    extend$2(normalized, raw);
  }
  if (isObject$2(comp)) {
    cache.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key2) {
  if (!options || !isOn$1(key2)) {
    return false;
  }
  key2 = key2.slice(2).replace(/Once$/, "");
  return hasOwn$2(options, key2[0].toLowerCase() + key2.slice(1)) || hasOwn$2(options, hyphenate(key2)) || hasOwn$2(options, key2);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function pushScopeId(id) {
  currentScopeId = id;
}
function popScopeId() {
  currentScopeId = null;
}
const withScopeId = (_id) => withCtx;
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx)
    return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance) {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    props: props2,
    propsOptions: [propsOptions],
    slots,
    attrs,
    emit: emit2,
    render: render2,
    renderCache,
    data,
    setupState,
    ctx,
    inheritAttrs
  } = instance;
  let result;
  let fallthroughAttrs;
  const prev = setCurrentRenderingInstance(instance);
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      result = normalizeVNode(
        render2.call(
          proxyToUse,
          proxyToUse,
          renderCache,
          props2,
          setupState,
          data,
          ctx
        )
      );
      fallthroughAttrs = attrs;
    } else {
      const render22 = Component;
      if (false)
        ;
      result = normalizeVNode(
        render22.length > 1 ? render22(
          props2,
          false ? {
            get attrs() {
              markAttrsAccessed();
              return attrs;
            },
            slots,
            emit: emit2
          } : { attrs, slots, emit: emit2 }
        ) : render22(
          props2,
          null
          /* we know it doesn't need it */
        )
      );
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root2 = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys2 = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root2;
    if (keys2.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys2.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(
            fallthroughAttrs,
            propsOptions
          );
        }
        root2 = cloneVNode(root2, fallthroughAttrs);
      }
    }
  }
  if (vnode.dirs) {
    root2 = cloneVNode(root2);
    root2.dirs = root2.dirs ? root2.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    root2.transition = vnode.transition;
  }
  {
    result = root2;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
function filterSingleRoot(children) {
  let singleRoot;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (isVNode(child)) {
      if (child.type !== Comment || child.children === "v-if") {
        if (singleRoot) {
          return;
        } else {
          singleRoot = child;
        }
      }
    } else {
      return;
    }
  }
  return singleRoot;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key2 in attrs) {
    if (key2 === "class" || key2 === "style" || isOn$1(key2)) {
      (res || (res = {}))[key2] = attrs[key2];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props2) => {
  const res = {};
  for (const key2 in attrs) {
    if (!isModelListener(key2) || !(key2.slice(9) in props2)) {
      res[key2] = attrs[key2];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i = 0; i < dynamicProps.length; i++) {
        const key2 = dynamicProps[i];
        if (nextProps[key2] !== prevProps[key2] && !isEmitListener(emits, key2)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key2 = nextKeys[i];
    if (nextProps[key2] !== prevProps[key2] && !isEmitListener(emitsOptions, key2)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent && parent.subTree === vnode) {
    (vnode = parent.vnode).el = el;
    parent = parent.parent;
  }
}
const isSuspense = (type2) => type2.__isSuspense;
const SuspenseImpl = {
  name: "Suspense",
  // In order to make Suspense tree-shakable, we need to avoid importing it
  // directly in the renderer. The renderer checks for the __isSuspense flag
  // on a vnode's type and calls the `process` method, passing in renderer
  // internals.
  __isSuspense: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
    if (n1 == null) {
      mountSuspense(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized,
        rendererInternals
      );
    } else {
      patchSuspense(
        n1,
        n2,
        container,
        anchor,
        parentComponent,
        isSVG,
        slotScopeIds,
        optimized,
        rendererInternals
      );
    }
  },
  hydrate: hydrateSuspense,
  create: createSuspenseBoundary,
  normalize: normalizeSuspenseChildren
};
const Suspense = SuspenseImpl;
function triggerEvent(vnode, name) {
  const eventListener = vnode.props && vnode.props[name];
  if (isFunction$1(eventListener)) {
    eventListener();
  }
}
function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
  const {
    p: patch,
    o: { createElement }
  } = rendererInternals;
  const hiddenContainer = createElement("div");
  const suspense = vnode.suspense = createSuspenseBoundary(
    vnode,
    parentSuspense,
    parentComponent,
    container,
    hiddenContainer,
    anchor,
    isSVG,
    slotScopeIds,
    optimized,
    rendererInternals
  );
  patch(
    null,
    suspense.pendingBranch = vnode.ssContent,
    hiddenContainer,
    null,
    parentComponent,
    suspense,
    isSVG,
    slotScopeIds
  );
  if (suspense.deps > 0) {
    triggerEvent(vnode, "onPending");
    triggerEvent(vnode, "onFallback");
    patch(
      null,
      vnode.ssFallback,
      container,
      anchor,
      parentComponent,
      null,
      // fallback tree will not have suspense context
      isSVG,
      slotScopeIds
    );
    setActiveBranch(suspense, vnode.ssFallback);
  } else {
    suspense.resolve(false, true);
  }
}
function patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {
  const suspense = n2.suspense = n1.suspense;
  suspense.vnode = n2;
  n2.el = n1.el;
  const newBranch = n2.ssContent;
  const newFallback = n2.ssFallback;
  const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
  if (pendingBranch) {
    suspense.pendingBranch = newBranch;
    if (isSameVNodeType(newBranch, pendingBranch)) {
      patch(
        pendingBranch,
        newBranch,
        suspense.hiddenContainer,
        null,
        parentComponent,
        suspense,
        isSVG,
        slotScopeIds,
        optimized
      );
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else if (isInFallback) {
        patch(
          activeBranch,
          newFallback,
          container,
          anchor,
          parentComponent,
          null,
          // fallback tree will not have suspense context
          isSVG,
          slotScopeIds,
          optimized
        );
        setActiveBranch(suspense, newFallback);
      }
    } else {
      suspense.pendingId++;
      if (isHydrating) {
        suspense.isHydrating = false;
        suspense.activeBranch = pendingBranch;
      } else {
        unmount(pendingBranch, parentComponent, suspense);
      }
      suspense.deps = 0;
      suspense.effects.length = 0;
      suspense.hiddenContainer = createElement("div");
      if (isInFallback) {
        patch(
          null,
          newBranch,
          suspense.hiddenContainer,
          null,
          parentComponent,
          suspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        if (suspense.deps <= 0) {
          suspense.resolve();
        } else {
          patch(
            activeBranch,
            newFallback,
            container,
            anchor,
            parentComponent,
            null,
            // fallback tree will not have suspense context
            isSVG,
            slotScopeIds,
            optimized
          );
          setActiveBranch(suspense, newFallback);
        }
      } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
        patch(
          activeBranch,
          newBranch,
          container,
          anchor,
          parentComponent,
          suspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        suspense.resolve(true);
      } else {
        patch(
          null,
          newBranch,
          suspense.hiddenContainer,
          null,
          parentComponent,
          suspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        if (suspense.deps <= 0) {
          suspense.resolve();
        }
      }
    }
  } else {
    if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
      patch(
        activeBranch,
        newBranch,
        container,
        anchor,
        parentComponent,
        suspense,
        isSVG,
        slotScopeIds,
        optimized
      );
      setActiveBranch(suspense, newBranch);
    } else {
      triggerEvent(n2, "onPending");
      suspense.pendingBranch = newBranch;
      suspense.pendingId++;
      patch(
        null,
        newBranch,
        suspense.hiddenContainer,
        null,
        parentComponent,
        suspense,
        isSVG,
        slotScopeIds,
        optimized
      );
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else {
        const { timeout, pendingId } = suspense;
        if (timeout > 0) {
          setTimeout(() => {
            if (suspense.pendingId === pendingId) {
              suspense.fallback(newFallback);
            }
          }, timeout);
        } else if (timeout === 0) {
          suspense.fallback(newFallback);
        }
      }
    }
  }
}
function createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
  const {
    p: patch,
    m: move,
    um: unmount,
    n: next,
    o: { parentNode, remove: remove2 }
  } = rendererInternals;
  let parentSuspenseId;
  const isSuspensible = isVNodeSuspensible(vnode);
  if (isSuspensible) {
    if (parentSuspense == null ? void 0 : parentSuspense.pendingBranch) {
      parentSuspenseId = parentSuspense.pendingId;
      parentSuspense.deps++;
    }
  }
  const timeout = vnode.props ? toNumber(vnode.props.timeout) : void 0;
  const suspense = {
    vnode,
    parent: parentSuspense,
    parentComponent,
    isSVG,
    container,
    hiddenContainer,
    anchor,
    deps: 0,
    pendingId: 0,
    timeout: typeof timeout === "number" ? timeout : -1,
    activeBranch: null,
    pendingBranch: null,
    isInFallback: true,
    isHydrating,
    isUnmounted: false,
    effects: [],
    resolve(resume = false, sync = false) {
      const {
        vnode: vnode2,
        activeBranch,
        pendingBranch,
        pendingId,
        effects,
        parentComponent: parentComponent2,
        container: container2
      } = suspense;
      if (suspense.isHydrating) {
        suspense.isHydrating = false;
      } else if (!resume) {
        const delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
        if (delayEnter) {
          activeBranch.transition.afterLeave = () => {
            if (pendingId === suspense.pendingId) {
              move(pendingBranch, container2, anchor2, 0);
            }
          };
        }
        let { anchor: anchor2 } = suspense;
        if (activeBranch) {
          anchor2 = next(activeBranch);
          unmount(activeBranch, parentComponent2, suspense, true);
        }
        if (!delayEnter) {
          move(pendingBranch, container2, anchor2, 0);
        }
      }
      setActiveBranch(suspense, pendingBranch);
      suspense.pendingBranch = null;
      suspense.isInFallback = false;
      let parent = suspense.parent;
      let hasUnresolvedAncestor = false;
      while (parent) {
        if (parent.pendingBranch) {
          parent.effects.push(...effects);
          hasUnresolvedAncestor = true;
          break;
        }
        parent = parent.parent;
      }
      if (!hasUnresolvedAncestor) {
        queuePostFlushCb(effects);
      }
      suspense.effects = [];
      if (isSuspensible) {
        if (parentSuspense && parentSuspense.pendingBranch && parentSuspenseId === parentSuspense.pendingId) {
          parentSuspense.deps--;
          if (parentSuspense.deps === 0 && !sync) {
            parentSuspense.resolve();
          }
        }
      }
      triggerEvent(vnode2, "onResolve");
    },
    fallback(fallbackVNode) {
      if (!suspense.pendingBranch) {
        return;
      }
      const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, isSVG: isSVG2 } = suspense;
      triggerEvent(vnode2, "onFallback");
      const anchor2 = next(activeBranch);
      const mountFallback = () => {
        if (!suspense.isInFallback) {
          return;
        }
        patch(
          null,
          fallbackVNode,
          container2,
          anchor2,
          parentComponent2,
          null,
          // fallback tree will not have suspense context
          isSVG2,
          slotScopeIds,
          optimized
        );
        setActiveBranch(suspense, fallbackVNode);
      };
      const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
      if (delayEnter) {
        activeBranch.transition.afterLeave = mountFallback;
      }
      suspense.isInFallback = true;
      unmount(
        activeBranch,
        parentComponent2,
        null,
        // no suspense so unmount hooks fire now
        true
        // shouldRemove
      );
      if (!delayEnter) {
        mountFallback();
      }
    },
    move(container2, anchor2, type2) {
      suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type2);
      suspense.container = container2;
    },
    next() {
      return suspense.activeBranch && next(suspense.activeBranch);
    },
    registerDep(instance, setupRenderEffect) {
      const isInPendingSuspense = !!suspense.pendingBranch;
      if (isInPendingSuspense) {
        suspense.deps++;
      }
      const hydratedEl = instance.vnode.el;
      instance.asyncDep.catch((err) => {
        handleError(err, instance, 0);
      }).then((asyncSetupResult) => {
        if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
          return;
        }
        instance.asyncResolved = true;
        const { vnode: vnode2 } = instance;
        handleSetupResult(instance, asyncSetupResult, false);
        if (hydratedEl) {
          vnode2.el = hydratedEl;
        }
        const placeholder = !hydratedEl && instance.subTree.el;
        setupRenderEffect(
          instance,
          vnode2,
          // component may have been moved before resolve.
          // if this is not a hydration, instance.subTree will be the comment
          // placeholder.
          parentNode(hydratedEl || instance.subTree.el),
          // anchor will not be used if this is hydration, so only need to
          // consider the comment placeholder case.
          hydratedEl ? null : next(instance.subTree),
          suspense,
          isSVG,
          optimized
        );
        if (placeholder) {
          remove2(placeholder);
        }
        updateHOCHostEl(instance, vnode2.el);
        if (isInPendingSuspense && --suspense.deps === 0) {
          suspense.resolve();
        }
      });
    },
    unmount(parentSuspense2, doRemove) {
      suspense.isUnmounted = true;
      if (suspense.activeBranch) {
        unmount(
          suspense.activeBranch,
          parentComponent,
          parentSuspense2,
          doRemove
        );
      }
      if (suspense.pendingBranch) {
        unmount(
          suspense.pendingBranch,
          parentComponent,
          parentSuspense2,
          doRemove
        );
      }
    }
  };
  return suspense;
}
function hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {
  const suspense = vnode.suspense = createSuspenseBoundary(
    vnode,
    parentSuspense,
    parentComponent,
    node.parentNode,
    document.createElement("div"),
    null,
    isSVG,
    slotScopeIds,
    optimized,
    rendererInternals,
    true
    /* hydrating */
  );
  const result = hydrateNode(
    node,
    suspense.pendingBranch = vnode.ssContent,
    parentComponent,
    suspense,
    slotScopeIds,
    optimized
  );
  if (suspense.deps === 0) {
    suspense.resolve(false, true);
  }
  return result;
}
function normalizeSuspenseChildren(vnode) {
  const { shapeFlag, children } = vnode;
  const isSlotChildren = shapeFlag & 32;
  vnode.ssContent = normalizeSuspenseSlot(
    isSlotChildren ? children.default : children
  );
  vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
}
function normalizeSuspenseSlot(s) {
  let block2;
  if (isFunction$1(s)) {
    const trackBlock = isBlockTreeEnabled && s._c;
    if (trackBlock) {
      s._d = false;
      openBlock();
    }
    s = s();
    if (trackBlock) {
      s._d = true;
      block2 = currentBlock;
      closeBlock();
    }
  }
  if (isArray$6(s)) {
    const singleChild = filterSingleRoot(s);
    s = singleChild;
  }
  s = normalizeVNode(s);
  if (block2 && !s.dynamicChildren) {
    s.dynamicChildren = block2.filter((c2) => c2 !== s);
  }
  return s;
}
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray$6(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
function setActiveBranch(suspense, branch) {
  suspense.activeBranch = branch;
  const { vnode, parentComponent } = suspense;
  const el = vnode.el = branch.el;
  if (parentComponent && parentComponent.subTree === vnode) {
    parentComponent.vnode.el = el;
    updateHOCHostEl(parentComponent, el);
  }
}
function isVNodeSuspensible(vnode) {
  var _a2;
  return ((_a2 = vnode.props) == null ? void 0 : _a2.suspensible) != null && vnode.props.suspensible !== false;
}
function watchEffect(effect2, options) {
  return doWatch(effect2, null, options);
}
function watchPostEffect(effect2, options) {
  return doWatch(
    effect2,
    null,
    { flush: "post" }
  );
}
function watchSyncEffect(effect2, options) {
  return doWatch(
    effect2,
    null,
    { flush: "sync" }
  );
}
const INITIAL_WATCHER_VALUE = {};
function watch(source2, cb, options) {
  return doWatch(source2, cb, options);
}
function doWatch(source2, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
  var _a2;
  const instance = getCurrentScope() === ((_a2 = currentInstance) == null ? void 0 : _a2.scope) ? currentInstance : null;
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source2)) {
    getter = () => source2.value;
    forceTrigger = isShallow(source2);
  } else if (isReactive(source2)) {
    getter = () => source2;
    deep = true;
  } else if (isArray$6(source2)) {
    isMultiSource = true;
    forceTrigger = source2.some((s) => isReactive(s) || isShallow(s));
    getter = () => source2.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return traverse(s);
      } else if (isFunction$1(s)) {
        return callWithErrorHandling(s, instance, 2);
      } else
        ;
    });
  } else if (isFunction$1(source2)) {
    if (cb) {
      getter = () => callWithErrorHandling(source2, instance, 2);
    } else {
      getter = () => {
        if (instance && instance.isUnmounted) {
          return;
        }
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(
          source2,
          instance,
          3,
          [onCleanup]
        );
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn) => {
    cleanup = effect2.onStop = () => {
      callWithErrorHandling(fn, instance, 4);
    };
  };
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    onCleanup = NOOP;
    if (!cb) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling(cb, instance, 3, [
        getter(),
        isMultiSource ? [] : void 0,
        onCleanup
      ]);
    }
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else {
      return NOOP;
    }
  }
  let oldValue = isMultiSource ? new Array(source2.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect2.active) {
      return;
    }
    if (cb) {
      const newValue = effect2.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v2, i) => hasChanged(v2, oldValue[i])) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb, instance, 3, [
          newValue,
          // pass undefined as the old value when it's changed for the first time
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect2.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else if (flush === "post") {
    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
  } else {
    job.pre = true;
    if (instance)
      job.id = instance.uid;
    scheduler = () => queueJob(job);
  }
  const effect2 = new ReactiveEffect(getter, scheduler);
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect2.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect(
      effect2.run.bind(effect2),
      instance && instance.suspense
    );
  } else {
    effect2.run();
  }
  const unwatch = () => {
    effect2.stop();
    if (instance && instance.scope) {
      remove(instance.scope.effects, effect2);
    }
  };
  if (ssrCleanup)
    ssrCleanup.push(unwatch);
  return unwatch;
}
function instanceWatch(source2, value, options) {
  const publicThis = this.proxy;
  const getter = isString$2(source2) ? source2.includes(".") ? createPathGetter(publicThis, source2) : () => publicThis[source2] : source2.bind(publicThis, publicThis);
  let cb;
  if (isFunction$1(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const cur = currentInstance;
  setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  if (cur) {
    setCurrentInstance(cur);
  } else {
    unsetCurrentInstance();
  }
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}
function traverse(value, seen) {
  if (!isObject$2(value) || value["__v_skip"]) {
    return value;
  }
  seen = seen || /* @__PURE__ */ new Set();
  if (seen.has(value)) {
    return value;
  }
  seen.add(value);
  if (isRef(value)) {
    traverse(value.value, seen);
  } else if (isArray$6(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], seen);
    }
  } else if (isSet$1(value) || isMap$1(value)) {
    value.forEach((v2) => {
      traverse(v2, seen);
    });
  } else if (isPlainObject(value)) {
    for (const key2 in value) {
      traverse(value[key2], seen);
    }
  }
  return value;
}
function withDirectives(vnode, directives2) {
  const internalInstance = currentRenderingInstance;
  if (internalInstance === null) {
    return vnode;
  }
  const instance = getExposeProxy(internalInstance) || internalInstance.proxy;
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i = 0; i < directives2.length; i++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives2[i];
    if (dir) {
      if (isFunction$1(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse(value);
      }
      bindings.push({
        dir,
        instance,
        value,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i];
    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
const leaveCbKey = Symbol("_leaveCb");
const enterCbKey$1 = Symbol("_enterCb");
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionPropsValidators = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: TransitionHookValidator,
  onEnter: TransitionHookValidator,
  onAfterEnter: TransitionHookValidator,
  onEnterCancelled: TransitionHookValidator,
  // leave
  onBeforeLeave: TransitionHookValidator,
  onLeave: TransitionHookValidator,
  onAfterLeave: TransitionHookValidator,
  onLeaveCancelled: TransitionHookValidator,
  // appear
  onBeforeAppear: TransitionHookValidator,
  onAppear: TransitionHookValidator,
  onAfterAppear: TransitionHookValidator,
  onAppearCancelled: TransitionHookValidator
};
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: BaseTransitionPropsValidators,
  setup(props2, { slots }) {
    const instance = getCurrentInstance$1();
    const state = useTransitionState();
    let prevTransitionKey;
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      let child = children[0];
      if (children.length > 1) {
        for (const c2 of children) {
          if (c2.type !== Comment) {
            child = c2;
            break;
          }
        }
      }
      const rawProps = toRaw(props2);
      const { mode } = rawProps;
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getKeepAliveChild(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      const enterHooks = resolveTransitionHooks(
        innerChild,
        rawProps,
        state,
        instance
      );
      setTransitionHooks(innerChild, enterHooks);
      const oldChild = instance.subTree;
      const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
      let transitionKeyChanged = false;
      const { getTransitionKey } = innerChild.type;
      if (getTransitionKey) {
        const key2 = getTransitionKey();
        if (prevTransitionKey === void 0) {
          prevTransitionKey = key2;
        } else if (key2 !== prevTransitionKey) {
          prevTransitionKey = key2;
          transitionKeyChanged = true;
        }
      }
      if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
        const leavingHooks = resolveTransitionHooks(
          oldInnerChild,
          rawProps,
          state,
          instance
        );
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in") {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            if (instance.update.active !== false) {
              instance.update();
            }
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(
              state,
              oldInnerChild
            );
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el[leaveCbKey] = () => {
              earlyRemove();
              el[leaveCbKey] = void 0;
              delete enterHooks.delayedLeave;
            };
            enterHooks.delayedLeave = delayedLeave;
          };
        }
      }
      return child;
    };
  }
};
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props2, state, instance) {
  const {
    appear,
    mode,
    persisted = false,
    onBeforeEnter,
    onEnter,
    onAfterEnter,
    onEnterCancelled,
    onBeforeLeave,
    onLeave,
    onAfterLeave,
    onLeaveCancelled,
    onBeforeAppear,
    onAppear,
    onAfterAppear,
    onAppearCancelled
  } = props2;
  const key2 = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook2 = (hook, args) => {
    hook && callWithAsyncErrorHandling(
      hook,
      instance,
      9,
      args
    );
  };
  const callAsyncHook = (hook, args) => {
    const done = args[1];
    callHook2(hook, args);
    if (isArray$6(hook)) {
      if (hook.every((hook2) => hook2.length <= 1))
        done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks = {
    mode,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el[leaveCbKey]) {
        el[leaveCbKey](
          true
          /* cancelled */
        );
      }
      const leavingVNode = leavingVNodesCache[key2];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
        leavingVNode.el[leaveCbKey]();
      }
      callHook2(hook, [el]);
    },
    enter(el) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el[enterCbKey$1] = (cancelled) => {
        if (called)
          return;
        called = true;
        if (cancelled) {
          callHook2(cancelHook, [el]);
        } else {
          callHook2(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el[enterCbKey$1] = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el, done]);
      } else {
        done();
      }
    },
    leave(el, remove2) {
      const key22 = String(vnode.key);
      if (el[enterCbKey$1]) {
        el[enterCbKey$1](
          true
          /* cancelled */
        );
      }
      if (state.isUnmounting) {
        return remove2();
      }
      callHook2(onBeforeLeave, [el]);
      let called = false;
      const done = el[leaveCbKey] = (cancelled) => {
        if (called)
          return;
        called = true;
        remove2();
        if (cancelled) {
          callHook2(onLeaveCancelled, [el]);
        } else {
          callHook2(onAfterLeave, [el]);
        }
        el[leaveCbKey] = void 0;
        if (leavingVNodesCache[key22] === vnode) {
          delete leavingVNodesCache[key22];
        }
      };
      leavingVNodesCache[key22] = vnode;
      if (onLeave) {
        callAsyncHook(onLeave, [el, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      return resolveTransitionHooks(vnode2, props2, state, instance);
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getKeepAliveChild(vnode) {
  return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i = 0; i < children.length; i++) {
    let child = children[i];
    const key2 = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
    if (child.type === Fragment) {
      if (child.patchFlag & 128)
        keyedFragmentCount++;
      ret = ret.concat(
        getTransitionRawChildren(child.children, keepComment, key2)
      );
    } else if (keepComment || child.type !== Comment) {
      ret.push(key2 != null ? cloneVNode(child, { key: key2 }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i = 0; i < ret.length; i++) {
      ret[i].patchFlag = -2;
    }
  }
  return ret;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineComponent$1(options, extraOptions) {
  return isFunction$1(options) ? (
    // #8326: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => extend$2({ name: options.name }, extraOptions, { setup: options }))()
  ) : options;
}
const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineAsyncComponent(source2) {
  if (isFunction$1(source2)) {
    source2 = { loader: source2 };
  }
  const {
    loader,
    loadingComponent,
    errorComponent,
    delay = 200,
    timeout,
    // undefined = never times out
    suspensible = true,
    onError: userOnError
  } = source2;
  let pendingRequest = null;
  let resolvedComp;
  let retries = 0;
  const retry = () => {
    retries++;
    pendingRequest = null;
    return load();
  };
  const load = () => {
    let thisRequest;
    return pendingRequest || (thisRequest = pendingRequest = loader().catch((err) => {
      err = err instanceof Error ? err : new Error(String(err));
      if (userOnError) {
        return new Promise((resolve2, reject) => {
          const userRetry = () => resolve2(retry());
          const userFail = () => reject(err);
          userOnError(err, userRetry, userFail, retries + 1);
        });
      } else {
        throw err;
      }
    }).then((comp) => {
      if (thisRequest !== pendingRequest && pendingRequest) {
        return pendingRequest;
      }
      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
        comp = comp.default;
      }
      resolvedComp = comp;
      return comp;
    }));
  };
  return /* @__PURE__ */ defineComponent$1({
    name: "AsyncComponentWrapper",
    __asyncLoader: load,
    get __asyncResolved() {
      return resolvedComp;
    },
    setup() {
      const instance = currentInstance;
      if (resolvedComp) {
        return () => createInnerComp(resolvedComp, instance);
      }
      const onError = (err) => {
        pendingRequest = null;
        handleError(
          err,
          instance,
          13,
          !errorComponent
          /* do not throw in dev if user provided error component */
        );
      };
      if (suspensible && instance.suspense || isInSSRComponentSetup) {
        return load().then((comp) => {
          return () => createInnerComp(comp, instance);
        }).catch((err) => {
          onError(err);
          return () => errorComponent ? createVNode(errorComponent, {
            error: err
          }) : null;
        });
      }
      const loaded = ref(false);
      const error = ref();
      const delayed = ref(!!delay);
      if (delay) {
        setTimeout(() => {
          delayed.value = false;
        }, delay);
      }
      if (timeout != null) {
        setTimeout(() => {
          if (!loaded.value && !error.value) {
            const err = new Error(
              `Async component timed out after ${timeout}ms.`
            );
            onError(err);
            error.value = err;
          }
        }, timeout);
      }
      load().then(() => {
        loaded.value = true;
        if (instance.parent && isKeepAlive(instance.parent.vnode)) {
          queueJob(instance.parent.update);
        }
      }).catch((err) => {
        onError(err);
        error.value = err;
      });
      return () => {
        if (loaded.value && resolvedComp) {
          return createInnerComp(resolvedComp, instance);
        } else if (error.value && errorComponent) {
          return createVNode(errorComponent, {
            error: error.value
          });
        } else if (loadingComponent && !delayed.value) {
          return createVNode(loadingComponent);
        }
      };
    }
  });
}
function createInnerComp(comp, parent) {
  const { ref: ref2, props: props2, children, ce: ce2 } = parent.vnode;
  const vnode = createVNode(comp, props2, children);
  vnode.ref = ref2;
  vnode.ce = ce2;
  delete parent.vnode.ce;
  return vnode;
}
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
const KeepAliveImpl = {
  name: `KeepAlive`,
  // Marker for special handling inside the renderer. We are not using a ===
  // check directly on KeepAlive in the renderer, because importing it directly
  // would prevent it from being tree-shaken.
  __isKeepAlive: true,
  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },
  setup(props2, { slots }) {
    const instance = getCurrentInstance$1();
    const sharedContext = instance.ctx;
    if (!sharedContext.renderer) {
      return () => {
        const children = slots.default && slots.default();
        return children && children.length === 1 ? children[0] : children;
      };
    }
    const cache = /* @__PURE__ */ new Map();
    const keys2 = /* @__PURE__ */ new Set();
    let current = null;
    const parentSuspense = instance.suspense;
    const {
      renderer: {
        p: patch,
        m: move,
        um: _unmount,
        o: { createElement }
      }
    } = sharedContext;
    const storageContainer = createElement("div");
    sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {
      const instance2 = vnode.component;
      move(vnode, container, anchor, 0, parentSuspense);
      patch(
        instance2.vnode,
        vnode,
        container,
        anchor,
        instance2,
        parentSuspense,
        isSVG,
        vnode.slotScopeIds,
        optimized
      );
      queuePostRenderEffect(() => {
        instance2.isDeactivated = false;
        if (instance2.a) {
          invokeArrayFns(instance2.a);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
      }, parentSuspense);
    };
    sharedContext.deactivate = (vnode) => {
      const instance2 = vnode.component;
      move(vnode, storageContainer, null, 1, parentSuspense);
      queuePostRenderEffect(() => {
        if (instance2.da) {
          invokeArrayFns(instance2.da);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
        instance2.isDeactivated = true;
      }, parentSuspense);
    };
    function unmount(vnode) {
      resetShapeFlag(vnode);
      _unmount(vnode, instance, parentSuspense, true);
    }
    function pruneCache(filter) {
      cache.forEach((vnode, key2) => {
        const name = getComponentName(vnode.type);
        if (name && (!filter || !filter(name))) {
          pruneCacheEntry(key2);
        }
      });
    }
    function pruneCacheEntry(key2) {
      const cached = cache.get(key2);
      if (!current || !isSameVNodeType(cached, current)) {
        unmount(cached);
      } else if (current) {
        resetShapeFlag(current);
      }
      cache.delete(key2);
      keys2.delete(key2);
    }
    watch(
      () => [props2.include, props2.exclude],
      ([include, exclude]) => {
        include && pruneCache((name) => matches$1(include, name));
        exclude && pruneCache((name) => !matches$1(exclude, name));
      },
      // prune post-render after `current` has been updated
      { flush: "post", deep: true }
    );
    let pendingCacheKey = null;
    const cacheSubtree = () => {
      if (pendingCacheKey != null) {
        cache.set(pendingCacheKey, getInnerChild(instance.subTree));
      }
    };
    onMounted(cacheSubtree);
    onUpdated(cacheSubtree);
    onBeforeUnmount(() => {
      cache.forEach((cached) => {
        const { subTree, suspense } = instance;
        const vnode = getInnerChild(subTree);
        if (cached.type === vnode.type && cached.key === vnode.key) {
          resetShapeFlag(vnode);
          const da = vnode.component.da;
          da && queuePostRenderEffect(da, suspense);
          return;
        }
        unmount(cached);
      });
    });
    return () => {
      pendingCacheKey = null;
      if (!slots.default) {
        return null;
      }
      const children = slots.default();
      const rawVNode = children[0];
      if (children.length > 1) {
        current = null;
        return children;
      } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
        current = null;
        return rawVNode;
      }
      let vnode = getInnerChild(rawVNode);
      const comp = vnode.type;
      const name = getComponentName(
        isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp
      );
      const { include, exclude, max: max2 } = props2;
      if (include && (!name || !matches$1(include, name)) || exclude && name && matches$1(exclude, name)) {
        current = vnode;
        return rawVNode;
      }
      const key2 = vnode.key == null ? comp : vnode.key;
      const cachedVNode = cache.get(key2);
      if (vnode.el) {
        vnode = cloneVNode(vnode);
        if (rawVNode.shapeFlag & 128) {
          rawVNode.ssContent = vnode;
        }
      }
      pendingCacheKey = key2;
      if (cachedVNode) {
        vnode.el = cachedVNode.el;
        vnode.component = cachedVNode.component;
        if (vnode.transition) {
          setTransitionHooks(vnode, vnode.transition);
        }
        vnode.shapeFlag |= 512;
        keys2.delete(key2);
        keys2.add(key2);
      } else {
        keys2.add(key2);
        if (max2 && keys2.size > parseInt(max2, 10)) {
          pruneCacheEntry(keys2.values().next().value);
        }
      }
      vnode.shapeFlag |= 256;
      current = vnode;
      return isSuspense(rawVNode.type) ? rawVNode : vnode;
    };
  }
};
const KeepAlive = KeepAliveImpl;
function matches$1(pattern, name) {
  if (isArray$6(pattern)) {
    return pattern.some((p2) => matches$1(p2, name));
  } else if (isString$2(pattern)) {
    return pattern.split(",").includes(name);
  } else if (isRegExp$2(pattern)) {
    return pattern.test(name);
  }
  return false;
}
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type2, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type2, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type2, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type2, target, keepAliveRoot) {
  const injected = injectHook(
    type2,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    remove(keepAliveRoot[type2], injected);
  }, target);
}
function resetShapeFlag(vnode) {
  vnode.shapeFlag &= ~256;
  vnode.shapeFlag &= ~512;
}
function getInnerChild(vnode) {
  return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
}
function injectHook(type2, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type2] || (target[type2] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      if (target.isUnmounted) {
        return;
      }
      pauseTracking();
      setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type2, args);
      unsetCurrentInstance();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => (
  // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
  (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target)
);
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook(
  "rtg"
);
const onRenderTracked = createHook(
  "rtc"
);
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
const COMPONENTS = "components";
const DIRECTIVES = "directives";
function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveDynamicComponent(component) {
  if (isString$2(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveDirective(name) {
  return resolveAsset(DIRECTIVES, name);
}
function resolveAsset(type2, name, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    if (type2 === COMPONENTS) {
      const selfName = getComponentName(
        Component,
        false
        /* do not include inferred name to avoid breaking existing code */
      );
      if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
        return Component;
      }
    }
    const res = (
      // local registration
      // check instance[type] first which is resolved for options API
      resolve(instance[type2] || Component[type2], name) || // global registration
      resolve(instance.appContext[type2], name)
    );
    if (!res && maybeSelfReference) {
      return Component;
    }
    return res;
  }
}
function resolve(registry, name) {
  return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
}
function renderList(source2, renderItem, cache, index2) {
  let ret;
  const cached = cache && cache[index2];
  if (isArray$6(source2) || isString$2(source2)) {
    ret = new Array(source2.length);
    for (let i = 0, l = source2.length; i < l; i++) {
      ret[i] = renderItem(source2[i], i, void 0, cached && cached[i]);
    }
  } else if (typeof source2 === "number") {
    ret = new Array(source2);
    for (let i = 0; i < source2; i++) {
      ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
    }
  } else if (isObject$2(source2)) {
    if (source2[Symbol.iterator]) {
      ret = Array.from(
        source2,
        (item, i) => renderItem(item, i, void 0, cached && cached[i])
      );
    } else {
      const keys2 = Object.keys(source2);
      ret = new Array(keys2.length);
      for (let i = 0, l = keys2.length; i < l; i++) {
        const key2 = keys2[i];
        ret[i] = renderItem(source2[key2], key2, i, cached && cached[i]);
      }
    }
  } else {
    ret = [];
  }
  if (cache) {
    cache[index2] = ret;
  }
  return ret;
}
function createSlots(slots, dynamicSlots) {
  for (let i = 0; i < dynamicSlots.length; i++) {
    const slot = dynamicSlots[i];
    if (isArray$6(slot)) {
      for (let j2 = 0; j2 < slot.length; j2++) {
        slots[slot[j2].name] = slot[j2].fn;
      }
    } else if (slot) {
      slots[slot.name] = slot.key ? (...args) => {
        const res = slot.fn(...args);
        if (res)
          res.key = slot.key;
        return res;
      } : slot.fn;
    }
  }
  return slots;
}
function renderSlot(slots, name, props2 = {}, fallback, noSlotted) {
  if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
    if (name !== "default")
      props2.name = name;
    return createVNode("slot", props2, fallback && fallback());
  }
  let slot = slots[name];
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props2));
  const rendered = createBlock(
    Fragment,
    {
      key: props2.key || // slot content array of a dynamic conditional slot may have a branch
      // key attached in the `createSlots` helper, respect that
      validSlotContent && validSlotContent.key || `_${name}`
    },
    validSlotContent || (fallback ? fallback() : []),
    validSlotContent && slots._ === 1 ? 64 : -2
  );
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode(child))
      return true;
    if (child.type === Comment)
      return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
function toHandlers(obj, preserveCaseIfNecessary) {
  const ret = {};
  for (const key2 in obj) {
    ret[preserveCaseIfNecessary && /[A-Z]/.test(key2) ? `on:${key2}` : toHandlerKey(key2)] = obj[key2];
  }
  return ret;
}
const getPublicInstance = (i) => {
  if (!i)
    return null;
  if (isStatefulComponent(i))
    return getExposeProxy(i) || i.proxy;
  return getPublicInstance(i.parent);
};
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ extend$2(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) => i.props,
    $attrs: (i) => i.attrs,
    $slots: (i) => i.slots,
    $refs: (i) => i.refs,
    $parent: (i) => getPublicInstance(i.parent),
    $root: (i) => getPublicInstance(i.root),
    $emit: (i) => i.emit,
    $options: (i) => resolveMergedOptions(i),
    $forceUpdate: (i) => i.f || (i.f = () => queueJob(i.update)),
    $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
    $watch: (i) => instanceWatch.bind(i)
  })
);
const hasSetupBinding = (state, key2) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn$2(state, key2);
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key2) {
    const { ctx, setupState, data, props: props2, accessCache, type: type2, appContext } = instance;
    let normalizedProps;
    if (key2[0] !== "$") {
      const n = accessCache[key2];
      if (n !== void 0) {
        switch (n) {
          case 1:
            return setupState[key2];
          case 2:
            return data[key2];
          case 4:
            return ctx[key2];
          case 3:
            return props2[key2];
        }
      } else if (hasSetupBinding(setupState, key2)) {
        accessCache[key2] = 1;
        return setupState[key2];
      } else if (data !== EMPTY_OBJ && hasOwn$2(data, key2)) {
        accessCache[key2] = 2;
        return data[key2];
      } else if (
        // only cache other properties when instance has declared (thus stable)
        // props
        (normalizedProps = instance.propsOptions[0]) && hasOwn$2(normalizedProps, key2)
      ) {
        accessCache[key2] = 3;
        return props2[key2];
      } else if (ctx !== EMPTY_OBJ && hasOwn$2(ctx, key2)) {
        accessCache[key2] = 4;
        return ctx[key2];
      } else if (shouldCacheAccess) {
        accessCache[key2] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key2];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key2 === "$attrs") {
        track(instance, "get", key2);
      }
      return publicGetter(instance);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type2.__cssModules) && (cssModule = cssModule[key2])
    ) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn$2(ctx, key2)) {
      accessCache[key2] = 4;
      return ctx[key2];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, hasOwn$2(globalProperties, key2)
    ) {
      {
        return globalProperties[key2];
      }
    } else
      ;
  },
  set({ _: instance }, key2, value) {
    const { data, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key2)) {
      setupState[key2] = value;
      return true;
    } else if (data !== EMPTY_OBJ && hasOwn$2(data, key2)) {
      data[key2] = value;
      return true;
    } else if (hasOwn$2(instance.props, key2)) {
      return false;
    }
    if (key2[0] === "$" && key2.slice(1) in instance) {
      return false;
    } else {
      {
        ctx[key2] = value;
      }
    }
    return true;
  },
  has({
    _: { data, setupState, accessCache, ctx, appContext, propsOptions }
  }, key2) {
    let normalizedProps;
    return !!accessCache[key2] || data !== EMPTY_OBJ && hasOwn$2(data, key2) || hasSetupBinding(setupState, key2) || (normalizedProps = propsOptions[0]) && hasOwn$2(normalizedProps, key2) || hasOwn$2(ctx, key2) || hasOwn$2(publicPropertiesMap, key2) || hasOwn$2(appContext.config.globalProperties, key2);
  },
  defineProperty(target, key2, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key2] = 0;
    } else if (hasOwn$2(descriptor, "value")) {
      this.set(target, key2, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key2, descriptor);
  }
};
const RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ extend$2(
  {},
  PublicInstanceProxyHandlers,
  {
    get(target, key2) {
      if (key2 === Symbol.unscopables) {
        return;
      }
      return PublicInstanceProxyHandlers.get(target, key2, target);
    },
    has(_2, key2) {
      const has2 = key2[0] !== "_" && !isGloballyAllowed(key2);
      return has2;
    }
  }
);
function defineProps() {
  return null;
}
function defineEmits() {
  return null;
}
function defineExpose(exposed) {
}
function defineOptions(options) {
}
function defineSlots() {
  return null;
}
function defineModel() {
}
function withDefaults(props2, defaults2) {
  return null;
}
function useSlots() {
  return getContext().slots;
}
function useAttrs() {
  return getContext().attrs;
}
function useModel(props2, name, options) {
  const i = getCurrentInstance$1();
  if (options && options.local) {
    const proxy = ref(props2[name]);
    watch(
      () => props2[name],
      (v2) => proxy.value = v2
    );
    watch(proxy, (value) => {
      if (value !== props2[name]) {
        i.emit(`update:${name}`, value);
      }
    });
    return proxy;
  } else {
    return {
      __v_isRef: true,
      get value() {
        return props2[name];
      },
      set value(value) {
        i.emit(`update:${name}`, value);
      }
    };
  }
}
function getContext() {
  const i = getCurrentInstance$1();
  return i.setupContext || (i.setupContext = createSetupContext(i));
}
function normalizePropsOrEmits(props2) {
  return isArray$6(props2) ? props2.reduce(
    (normalized, p2) => (normalized[p2] = null, normalized),
    {}
  ) : props2;
}
function mergeDefaults(raw, defaults2) {
  const props2 = normalizePropsOrEmits(raw);
  for (const key2 in defaults2) {
    if (key2.startsWith("__skip"))
      continue;
    let opt = props2[key2];
    if (opt) {
      if (isArray$6(opt) || isFunction$1(opt)) {
        opt = props2[key2] = { type: opt, default: defaults2[key2] };
      } else {
        opt.default = defaults2[key2];
      }
    } else if (opt === null) {
      opt = props2[key2] = { default: defaults2[key2] };
    } else
      ;
    if (opt && defaults2[`__skip_${key2}`]) {
      opt.skipFactory = true;
    }
  }
  return props2;
}
function mergeModels(a, b2) {
  if (!a || !b2)
    return a || b2;
  if (isArray$6(a) && isArray$6(b2))
    return a.concat(b2);
  return extend$2({}, normalizePropsOrEmits(a), normalizePropsOrEmits(b2));
}
function createPropsRestProxy(props2, excludedKeys) {
  const ret = {};
  for (const key2 in props2) {
    if (!excludedKeys.includes(key2)) {
      Object.defineProperty(ret, key2, {
        enumerable: true,
        get: () => props2[key2]
      });
    }
  }
  return ret;
}
function withAsyncContext(getAwaitable) {
  const ctx = getCurrentInstance$1();
  let awaitable = getAwaitable();
  unsetCurrentInstance();
  if (isPromise(awaitable)) {
    awaitable = awaitable.catch((e) => {
      setCurrentInstance(ctx);
      throw e;
    });
  }
  return [awaitable, () => setCurrentInstance(ctx)];
}
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook$1(options.beforeCreate, instance, "bc");
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount: beforeMount2,
    mounted: mounted2,
    beforeUpdate,
    updated: updated2,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted: unmounted2,
    render: render2,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components: components2,
    directives: directives2,
    filters
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }
  if (methods) {
    for (const key2 in methods) {
      const methodHandler = methods[key2];
      if (isFunction$1(methodHandler)) {
        {
          ctx[key2] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data = dataOptions.call(publicThis, publicThis);
    if (!isObject$2(data))
      ;
    else {
      instance.data = reactive(data);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key2 in computedOptions) {
      const opt = computedOptions[key2];
      const get2 = isFunction$1(opt) ? opt.bind(publicThis, publicThis) : isFunction$1(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set2 = !isFunction$1(opt) && isFunction$1(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c2 = computed({
        get: get2,
        set: set2
      });
      Object.defineProperty(ctx, key2, {
        enumerable: true,
        configurable: true,
        get: () => c2.value,
        set: (v2) => c2.value = v2
      });
    }
  }
  if (watchOptions) {
    for (const key2 in watchOptions) {
      createWatcher(watchOptions[key2], ctx, publicThis, key2);
    }
  }
  if (provideOptions) {
    const provides = isFunction$1(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key2) => {
      provide(key2, provides[key2]);
    });
  }
  if (created) {
    callHook$1(created, instance, "c");
  }
  function registerLifecycleHook(register, hook) {
    if (isArray$6(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount2);
  registerLifecycleHook(onMounted, mounted2);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated2);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted2);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray$6(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key2) => {
        Object.defineProperty(exposed, key2, {
          get: () => publicThis[key2],
          set: (val) => publicThis[key2] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render2 && instance.render === NOOP) {
    instance.render = render2;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components2)
    instance.components = components2;
  if (directives2)
    instance.directives = directives2;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
  if (isArray$6(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key2 in injectOptions) {
    const opt = injectOptions[key2];
    let injected;
    if (isObject$2(opt)) {
      if ("default" in opt) {
        injected = inject$1(
          opt.from || key2,
          opt.default,
          true
          /* treat default function as factory */
        );
      } else {
        injected = inject$1(opt.from || key2);
      }
    } else {
      injected = inject$1(opt);
    }
    if (isRef(injected)) {
      Object.defineProperty(ctx, key2, {
        enumerable: true,
        configurable: true,
        get: () => injected.value,
        set: (v2) => injected.value = v2
      });
    } else {
      ctx[key2] = injected;
    }
  }
}
function callHook$1(hook, instance, type2) {
  callWithAsyncErrorHandling(
    isArray$6(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
    instance,
    type2
  );
}
function createWatcher(raw, ctx, publicThis, key2) {
  const getter = key2.includes(".") ? createPathGetter(publicThis, key2) : () => publicThis[key2];
  if (isString$2(raw)) {
    const handler = ctx[raw];
    if (isFunction$1(handler)) {
      watch(getter, handler);
    }
  } else if (isFunction$1(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if (isObject$2(raw)) {
    if (isArray$6(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key2));
    } else {
      const handler = isFunction$1(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction$1(handler)) {
        watch(getter, handler, raw);
      }
    }
  } else
    ;
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const {
    mixins: globalMixins,
    optionsCache: cache,
    config: { optionMergeStrategies }
  } = instance.appContext;
  const cached = cache.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach(
        (m) => mergeOptions$1(resolved, m, optionMergeStrategies, true)
      );
    }
    mergeOptions$1(resolved, base, optionMergeStrategies);
  }
  if (isObject$2(base)) {
    cache.set(base, resolved);
  }
  return resolved;
}
function mergeOptions$1(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions$1(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach(
      (m) => mergeOptions$1(to, m, strats, true)
    );
  }
  for (const key2 in from) {
    if (asMixin && key2 === "expose")
      ;
    else {
      const strat = internalOptionMergeStrats[key2] || strats && strats[key2];
      to[key2] = strat ? strat(to[key2], from[key2]) : from[key2];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return extend$2(
      isFunction$1(to) ? to.call(this, this) : to,
      isFunction$1(from) ? from.call(this, this) : from
    );
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray$6(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? extend$2(/* @__PURE__ */ Object.create(null), to, from) : from;
}
function mergeEmitsOrPropsOptions(to, from) {
  if (to) {
    if (isArray$6(to) && isArray$6(from)) {
      return [.../* @__PURE__ */ new Set([...to, ...from])];
    }
    return extend$2(
      /* @__PURE__ */ Object.create(null),
      normalizePropsOrEmits(to),
      normalizePropsOrEmits(from != null ? from : {})
    );
  } else {
    return from;
  }
}
function mergeWatchOptions(to, from) {
  if (!to)
    return from;
  if (!from)
    return to;
  const merged = extend$2(/* @__PURE__ */ Object.create(null), to);
  for (const key2 in from) {
    merged[key2] = mergeAsArray(to[key2], from[key2]);
  }
  return merged;
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render2, hydrate2) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction$1(rootComponent)) {
      rootComponent = extend$2({}, rootComponent);
    }
    if (rootProps != null && !isObject$2(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new WeakSet();
    let isMounted = false;
    const app = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version: version$2,
      get config() {
        return context.config;
      },
      set config(v2) {
      },
      use(plugin2, ...options) {
        if (installedPlugins.has(plugin2))
          ;
        else if (plugin2 && isFunction$1(plugin2.install)) {
          installedPlugins.add(plugin2);
          plugin2.install(app, ...options);
        } else if (isFunction$1(plugin2)) {
          installedPlugins.add(plugin2);
          plugin2(app, ...options);
        } else
          ;
        return app;
      },
      mixin(mixin) {
        {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          }
        }
        return app;
      },
      component(name, component) {
        if (!component) {
          return context.components[name];
        }
        context.components[name] = component;
        return app;
      },
      directive(name, directive2) {
        if (!directive2) {
          return context.directives[name];
        }
        context.directives[name] = directive2;
        return app;
      },
      mount(rootContainer, isHydrate, isSVG) {
        if (!isMounted) {
          const vnode = createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (isHydrate && hydrate2) {
            hydrate2(vnode, rootContainer);
          } else {
            render2(vnode, rootContainer, isSVG);
          }
          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;
          return getExposeProxy(vnode.component) || vnode.component.proxy;
        }
      },
      unmount() {
        if (isMounted) {
          render2(null, app._container);
          delete app._container.__vue_app__;
        }
      },
      provide(key2, value) {
        context.provides[key2] = value;
        return app;
      },
      runWithContext(fn) {
        currentApp = app;
        try {
          return fn();
        } finally {
          currentApp = null;
        }
      }
    };
    return app;
  };
}
let currentApp = null;
function provide(key2, value) {
  if (!currentInstance)
    ;
  else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key2] = value;
  }
}
function inject$1(key2, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance || currentApp) {
    const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
    if (provides && key2 in provides) {
      return provides[key2];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction$1(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
    } else
      ;
  }
}
function hasInjectionContext() {
  return !!(currentInstance || currentRenderingInstance || currentApp);
}
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props2 = {};
  const attrs = {};
  def(attrs, InternalObjectKey, 1);
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props2, attrs);
  for (const key2 in instance.propsOptions[0]) {
    if (!(key2 in props2)) {
      props2[key2] = void 0;
    }
  }
  if (isStateful) {
    instance.props = isSSR ? props2 : shallowReactive(props2);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props2;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const {
    props: props2,
    attrs,
    vnode: { patchFlag }
  } = instance;
  const rawCurrentProps = toRaw(props2);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key2 = propsToUpdate[i];
        if (isEmitListener(instance.emitsOptions, key2)) {
          continue;
        }
        const value = rawProps[key2];
        if (options) {
          if (hasOwn$2(attrs, key2)) {
            if (value !== attrs[key2]) {
              attrs[key2] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key2);
            props2[camelizedKey] = resolvePropValue(
              options,
              rawCurrentProps,
              camelizedKey,
              value,
              instance,
              false
              /* isAbsent */
            );
          }
        } else {
          if (value !== attrs[key2]) {
            attrs[key2] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props2, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key2 in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !hasOwn$2(rawProps, key2) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = hyphenate(key2)) === key2 || !hasOwn$2(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key2] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props2[key2] = resolvePropValue(
              options,
              rawCurrentProps,
              key2,
              void 0,
              instance,
              true
              /* isAbsent */
            );
          }
        } else {
          delete props2[key2];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key2 in attrs) {
        if (!rawProps || !hasOwn$2(rawProps, key2) && true) {
          delete attrs[key2];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance, "set", "$attrs");
  }
}
function setFullProps(instance, rawProps, props2, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key2 in rawProps) {
      if (isReservedProp(key2)) {
        continue;
      }
      const value = rawProps[key2];
      let camelKey;
      if (options && hasOwn$2(options, camelKey = camelize(key2))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props2[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key2)) {
        if (!(key2 in attrs) || value !== attrs[key2]) {
          attrs[key2] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props2);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key2 = needCastKeys[i];
      props2[key2] = resolvePropValue(
        options,
        rawCurrentProps,
        key2,
        castValues[key2],
        instance,
        !hasOwn$2(castValues, key2)
      );
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props2, key2, value, instance, isAbsent) {
  const opt = options[key2];
  if (opt != null) {
    const hasDefault = hasOwn$2(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && !opt.skipFactory && isFunction$1(defaultValue)) {
        const { propsDefaults } = instance;
        if (key2 in propsDefaults) {
          value = propsDefaults[key2];
        } else {
          setCurrentInstance(instance);
          value = propsDefaults[key2] = defaultValue.call(
            null,
            props2
          );
          unsetCurrentInstance();
        }
      } else {
        value = defaultValue;
      }
    }
    if (opt[
      0
      /* shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[
        1
        /* shouldCastTrue */
      ] && (value === "" || value === hyphenate(key2))) {
        value = true;
      }
    }
  }
  return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.propsCache;
  const cached = cache.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction$1(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props2, keys2] = normalizePropsOptions(raw2, appContext, true);
      extend$2(normalized, props2);
      if (keys2)
        needCastKeys.push(...keys2);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$2(comp)) {
      cache.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray$6(raw)) {
    for (let i = 0; i < raw.length; i++) {
      const normalizedKey = camelize(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key2 in raw) {
      const normalizedKey = camelize(key2);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key2];
        const prop = normalized[normalizedKey] = isArray$6(opt) || isFunction$1(opt) ? { type: opt } : extend$2({}, opt);
        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[
            0
            /* shouldCast */
          ] = booleanIndex > -1;
          prop[
            1
            /* shouldCastTrue */
          ] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn$2(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject$2(comp)) {
    cache.set(comp, res);
  }
  return res;
}
function validatePropName(key2) {
  if (key2[0] !== "$") {
    return true;
  }
  return false;
}
function getType(ctor) {
  const match2 = ctor && ctor.toString().match(/^\s*(function|class) (\w+)/);
  return match2 ? match2[2] : ctor === null ? "null" : "";
}
function isSameType(a, b2) {
  return getType(a) === getType(b2);
}
function getTypeIndex(type2, expectedTypes) {
  if (isArray$6(expectedTypes)) {
    return expectedTypes.findIndex((t) => isSameType(t, type2));
  } else if (isFunction$1(expectedTypes)) {
    return isSameType(expectedTypes, type2) ? 0 : -1;
  }
  return -1;
}
const isInternalKey = (key2) => key2[0] === "_" || key2 === "$stable";
const normalizeSlotValue = (value) => isArray$6(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot$1 = (key2, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (false)
      ;
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key2 in rawSlots) {
    if (isInternalKey(key2))
      continue;
    const value = rawSlots[key2];
    if (isFunction$1(value)) {
      slots[key2] = normalizeSlot$1(key2, value, ctx);
    } else if (value != null) {
      const normalized = normalizeSlotValue(value);
      slots[key2] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
  if (instance.vnode.shapeFlag & 32) {
    const type2 = children._;
    if (type2) {
      instance.slots = toRaw(children);
      def(children, "_", type2);
    } else {
      normalizeObjectSlots(
        children,
        instance.slots = {}
      );
    }
  } else {
    instance.slots = {};
    if (children) {
      normalizeVNodeSlots(instance, children);
    }
  }
  def(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type2 = children._;
    if (type2) {
      if (optimized && type2 === 1) {
        needDeletionCheck = false;
      } else {
        extend$2(slots, children);
        if (!optimized && type2 === 1) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key2 in slots) {
      if (!isInternalKey(key2) && deletionComparisonTarget[key2] == null) {
        delete slots[key2];
      }
    }
  }
};
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray$6(rawRef)) {
    rawRef.forEach(
      (r, i) => setRef(
        r,
        oldRawRef && (isArray$6(oldRawRef) ? oldRawRef[i] : oldRawRef),
        parentSuspense,
        vnode,
        isUnmount
      )
    );
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref2 } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref2) {
    if (isString$2(oldRef)) {
      refs[oldRef] = null;
      if (hasOwn$2(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction$1(ref2)) {
    callWithErrorHandling(ref2, owner, 12, [value, refs]);
  } else {
    const _isString = isString$2(ref2);
    const _isRef = isRef(ref2);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? hasOwn$2(setupState, ref2) ? setupState[ref2] : refs[ref2] : ref2.value;
          if (isUnmount) {
            isArray$6(existing) && remove(existing, refValue);
          } else {
            if (!isArray$6(existing)) {
              if (_isString) {
                refs[ref2] = [refValue];
                if (hasOwn$2(setupState, ref2)) {
                  setupState[ref2] = refs[ref2];
                }
              } else {
                ref2.value = [refValue];
                if (rawRef.k)
                  refs[rawRef.k] = ref2.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref2] = value;
          if (hasOwn$2(setupState, ref2)) {
            setupState[ref2] = value;
          }
        } else if (_isRef) {
          ref2.value = value;
          if (rawRef.k)
            refs[rawRef.k] = value;
        } else
          ;
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    }
  }
}
let hasMismatch = false;
const isSVGContainer = (container) => /svg/.test(container.namespaceURI) && container.tagName !== "foreignObject";
const isComment = (node) => node.nodeType === 8;
function createHydrationFunctions(rendererInternals) {
  const {
    mt: mountComponent,
    p: patch,
    o: {
      patchProp: patchProp2,
      createText,
      nextSibling,
      parentNode,
      remove: remove2,
      insert,
      createComment
    }
  } = rendererInternals;
  const hydrate2 = (vnode, container) => {
    if (!container.hasChildNodes()) {
      patch(null, vnode, container);
      flushPostFlushCbs();
      container._vnode = vnode;
      return;
    }
    hasMismatch = false;
    hydrateNode(container.firstChild, vnode, null, null, null);
    flushPostFlushCbs();
    container._vnode = vnode;
    if (hasMismatch && true) {
      console.error(`Hydration completed but contains mismatches.`);
    }
  };
  const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
    const isFragmentStart = isComment(node) && node.data === "[";
    const onMismatch = () => handleMismatch(
      node,
      vnode,
      parentComponent,
      parentSuspense,
      slotScopeIds,
      isFragmentStart
    );
    const { type: type2, ref: ref2, shapeFlag, patchFlag } = vnode;
    let domType = node.nodeType;
    vnode.el = node;
    if (patchFlag === -2) {
      optimized = false;
      vnode.dynamicChildren = null;
    }
    let nextNode = null;
    switch (type2) {
      case Text:
        if (domType !== 3) {
          if (vnode.children === "") {
            insert(vnode.el = createText(""), parentNode(node), node);
            nextNode = node;
          } else {
            nextNode = onMismatch();
          }
        } else {
          if (node.data !== vnode.children) {
            hasMismatch = true;
            node.data = vnode.children;
          }
          nextNode = nextSibling(node);
        }
        break;
      case Comment:
        if (domType !== 8 || isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = nextSibling(node);
        }
        break;
      case Static:
        if (isFragmentStart) {
          node = nextSibling(node);
          domType = node.nodeType;
        }
        if (domType === 1 || domType === 3) {
          nextNode = node;
          const needToAdoptContent = !vnode.children.length;
          for (let i = 0; i < vnode.staticCount; i++) {
            if (needToAdoptContent)
              vnode.children += nextNode.nodeType === 1 ? nextNode.outerHTML : nextNode.data;
            if (i === vnode.staticCount - 1) {
              vnode.anchor = nextNode;
            }
            nextNode = nextSibling(nextNode);
          }
          return isFragmentStart ? nextSibling(nextNode) : nextNode;
        } else {
          onMismatch();
        }
        break;
      case Fragment:
        if (!isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = hydrateFragment(
            node,
            vnode,
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          );
        }
        break;
      default:
        if (shapeFlag & 1) {
          if (domType !== 1 || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) {
            nextNode = onMismatch();
          } else {
            nextNode = hydrateElement(
              node,
              vnode,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
          }
        } else if (shapeFlag & 6) {
          vnode.slotScopeIds = slotScopeIds;
          const container = parentNode(node);
          mountComponent(
            vnode,
            container,
            null,
            parentComponent,
            parentSuspense,
            isSVGContainer(container),
            optimized
          );
          nextNode = isFragmentStart ? locateClosingAsyncAnchor(node) : nextSibling(node);
          if (nextNode && isComment(nextNode) && nextNode.data === "teleport end") {
            nextNode = nextSibling(nextNode);
          }
          if (isAsyncWrapper(vnode)) {
            let subTree;
            if (isFragmentStart) {
              subTree = createVNode(Fragment);
              subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
            } else {
              subTree = node.nodeType === 3 ? createTextVNode("") : createVNode("div");
            }
            subTree.el = node;
            vnode.component.subTree = subTree;
          }
        } else if (shapeFlag & 64) {
          if (domType !== 8) {
            nextNode = onMismatch();
          } else {
            nextNode = vnode.type.hydrate(
              node,
              vnode,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized,
              rendererInternals,
              hydrateChildren
            );
          }
        } else if (shapeFlag & 128) {
          nextNode = vnode.type.hydrate(
            node,
            vnode,
            parentComponent,
            parentSuspense,
            isSVGContainer(parentNode(node)),
            slotScopeIds,
            optimized,
            rendererInternals,
            hydrateNode
          );
        } else
          ;
    }
    if (ref2 != null) {
      setRef(ref2, null, parentSuspense, vnode);
    }
    return nextNode;
  };
  const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!vnode.dynamicChildren;
    const { type: type2, props: props2, patchFlag, shapeFlag, dirs } = vnode;
    const forcePatchValue = type2 === "input" && dirs || type2 === "option";
    if (forcePatchValue || patchFlag !== -1) {
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      if (props2) {
        if (forcePatchValue || !optimized || patchFlag & (16 | 32)) {
          for (const key2 in props2) {
            if (forcePatchValue && key2.endsWith("value") || isOn$1(key2) && !isReservedProp(key2)) {
              patchProp2(
                el,
                key2,
                null,
                props2[key2],
                false,
                void 0,
                parentComponent
              );
            }
          }
        } else if (props2.onClick) {
          patchProp2(
            el,
            "onClick",
            null,
            props2.onClick,
            false,
            void 0,
            parentComponent
          );
        }
      }
      let vnodeHooks;
      if (vnodeHooks = props2 && props2.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHooks, parentComponent, vnode);
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      if ((vnodeHooks = props2 && props2.onVnodeMounted) || dirs) {
        queueEffectWithSuspense(() => {
          vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
      if (shapeFlag & 16 && // skip if element has innerHTML / textContent
      !(props2 && (props2.innerHTML || props2.textContent))) {
        let next = hydrateChildren(
          el.firstChild,
          vnode,
          el,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
        while (next) {
          hasMismatch = true;
          const cur = next;
          next = next.nextSibling;
          remove2(cur);
        }
      } else if (shapeFlag & 8) {
        if (el.textContent !== vnode.children) {
          hasMismatch = true;
          el.textContent = vnode.children;
        }
      }
    }
    return el.nextSibling;
  };
  const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!parentVNode.dynamicChildren;
    const children = parentVNode.children;
    const l = children.length;
    for (let i = 0; i < l; i++) {
      const vnode = optimized ? children[i] : children[i] = normalizeVNode(children[i]);
      if (node) {
        node = hydrateNode(
          node,
          vnode,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      } else if (vnode.type === Text && !vnode.children) {
        continue;
      } else {
        hasMismatch = true;
        patch(
          null,
          vnode,
          container,
          null,
          parentComponent,
          parentSuspense,
          isSVGContainer(container),
          slotScopeIds
        );
      }
    }
    return node;
  };
  const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    const { slotScopeIds: fragmentSlotScopeIds } = vnode;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    const container = parentNode(node);
    const next = hydrateChildren(
      nextSibling(node),
      vnode,
      container,
      parentComponent,
      parentSuspense,
      slotScopeIds,
      optimized
    );
    if (next && isComment(next) && next.data === "]") {
      return nextSibling(vnode.anchor = next);
    } else {
      hasMismatch = true;
      insert(vnode.anchor = createComment(`]`), container, next);
      return next;
    }
  };
  const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {
    hasMismatch = true;
    vnode.el = null;
    if (isFragment) {
      const end = locateClosingAsyncAnchor(node);
      while (true) {
        const next2 = nextSibling(node);
        if (next2 && next2 !== end) {
          remove2(next2);
        } else {
          break;
        }
      }
    }
    const next = nextSibling(node);
    const container = parentNode(node);
    remove2(node);
    patch(
      null,
      vnode,
      container,
      next,
      parentComponent,
      parentSuspense,
      isSVGContainer(container),
      slotScopeIds
    );
    return next;
  };
  const locateClosingAsyncAnchor = (node) => {
    let match2 = 0;
    while (node) {
      node = nextSibling(node);
      if (node && isComment(node)) {
        if (node.data === "[")
          match2++;
        if (node.data === "]") {
          if (match2 === 0) {
            return nextSibling(node);
          } else {
            match2--;
          }
        }
      }
    }
    return node;
  };
  return [hydrate2, hydrateNode];
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function createHydrationRenderer(options) {
  return baseCreateRenderer(options, createHydrationFunctions);
}
function baseCreateRenderer(options, createHydrationFns) {
  const target = getGlobalThis();
  target.__VUE__ = true;
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = NOOP,
    insertStaticContent: hostInsertStaticContent
  } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type: type2, ref: ref2, shapeFlag } = n2;
    switch (type2) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, isSVG);
        }
        break;
      case Fragment:
        processFragment(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        break;
      default:
        if (shapeFlag & 1) {
          processElement(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 6) {
          processComponent(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 64) {
          type2.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (shapeFlag & 128) {
          type2.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized,
            internals
          );
        } else
          ;
    }
    if (ref2 != null && parentComponent) {
      setRef(ref2, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateText(n2.children),
        container,
        anchor
      );
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateComment(n2.children || ""),
        container,
        anchor
      );
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, isSVG) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(
      n2.children,
      container,
      anchor,
      isSVG,
      n2.el,
      n2.anchor
    );
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    isSVG = isSVG || n2.type === "svg";
    if (n1 == null) {
      mountElement(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    } else {
      patchElement(
        n1,
        n2,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { type: type2, props: props2, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(
      vnode.type,
      isSVG,
      props2 && props2.is,
      props2
    );
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(
        vnode.children,
        el,
        null,
        parentComponent,
        parentSuspense,
        isSVG && type2 !== "foreignObject",
        slotScopeIds,
        optimized
      );
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props2) {
      for (const key2 in props2) {
        if (key2 !== "value" && !isReservedProp(key2)) {
          hostPatchProp(
            el,
            key2,
            null,
            props2[key2],
            isSVG,
            vnode.children,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        }
      }
      if ("value" in props2) {
        hostPatchProp(el, "value", null, props2.value);
      }
      if (vnodeHook = props2.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props2 && props2.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el, slotScopeIds[i]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(
          el,
          parentVNode,
          parentVNode.scopeId,
          parentVNode.slotScopeIds,
          parentComponent.parent
        );
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
    for (let i = start; i < children.length; i++) {
      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(
        null,
        child,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    const areChildrenSVG = isSVG && n2.type !== "foreignObject";
    if (dynamicChildren) {
      patchBlockChildren(
        n1.dynamicChildren,
        dynamicChildren,
        el,
        parentComponent,
        parentSuspense,
        areChildrenSVG,
        slotScopeIds
      );
    } else if (!optimized) {
      patchChildren(
        n1,
        n2,
        el,
        null,
        parentComponent,
        parentSuspense,
        areChildrenSVG,
        slotScopeIds,
        false
      );
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(
          el,
          n2,
          oldProps,
          newProps,
          parentComponent,
          parentSuspense,
          isSVG
        );
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, isSVG);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key2 = propsToUpdate[i];
            const prev = oldProps[key2];
            const next = newProps[key2];
            if (next !== prev || key2 === "value") {
              hostPatchProp(
                el,
                key2,
                prev,
                next,
                isSVG,
                n1.children,
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(
        el,
        n2,
        oldProps,
        newProps,
        parentComponent,
        parentSuspense,
        isSVG
      );
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
    for (let i = 0; i < newChildren.length; i++) {
      const oldVNode = oldChildren[i];
      const newVNode = newChildren[i];
      const container = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
        oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fallbackContainer
        )
      );
      patch(
        oldVNode,
        newVNode,
        container,
        null,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        true
      );
    }
  };
  const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key2 in oldProps) {
          if (!isReservedProp(key2) && !(key2 in newProps)) {
            hostPatchProp(
              el,
              key2,
              oldProps[key2],
              null,
              isSVG,
              vnode.children,
              parentComponent,
              parentSuspense,
              unmountChildren
            );
          }
        }
      }
      for (const key2 in newProps) {
        if (isReservedProp(key2))
          continue;
        const next = newProps[key2];
        const prev = oldProps[key2];
        if (next !== prev && key2 !== "value") {
          hostPatchProp(
            el,
            key2,
            prev,
            next,
            isSVG,
            vnode.children,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(
        n2.children,
        container,
        fragmentEndAnchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          container,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds
        );
        if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n2.key != null || parentComponent && n2 === parentComponent.subTree
        ) {
          traverseStaticChildren(
            n1,
            n2,
            true
            /* shallow */
          );
        }
      } else {
        patchChildren(
          n1,
          n2,
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(
          n2,
          container,
          anchor,
          isSVG,
          optimized
        );
      } else {
        mountComponent(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          optimized
        );
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
    const instance = initialVNode.component = createComponentInstance(
      initialVNode,
      parentComponent,
      parentSuspense
    );
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      setupComponent(instance);
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
      return;
    }
    setupRenderEffect(
      instance,
      initialVNode,
      container,
      anchor,
      parentSuspense,
      isSVG,
      optimized
    );
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n2, optimized);
        return;
      } else {
        instance.next = n2;
        invalidateJob(instance.update);
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props: props2 } = initialVNode;
        const { bm, m, parent } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props2 && props2.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            instance.subTree = renderComponentRoot(instance);
            hydrateNode(
              el,
              instance.subTree,
              instance,
              parentSuspense,
              null
            );
          };
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(
              // note: we are moving the render call into an async callback,
              // which means it won't track dependencies - but it's ok because
              // a server-rendered async wrapper is already in resolved state
              // and it will never need to change.
              () => !instance.isUnmounted && hydrateSubTree()
            );
          } else {
            hydrateSubTree();
          }
        } else {
          const subTree = instance.subTree = renderComponentRoot(instance);
          patch(
            null,
            subTree,
            container,
            anchor,
            instance,
            parentSuspense,
            isSVG
          );
          initialVNode.el = subTree.el;
        }
        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props2 && props2.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
            parentSuspense
          );
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u, parent, vnode } = instance;
        let originNext = next;
        let vnodeHook;
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        const nextTree = renderComponentRoot(instance);
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          isSVG
        );
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, next, vnode),
            parentSuspense
          );
        }
      }
    };
    const effect2 = instance.effect = new ReactiveEffect(
      componentUpdateFn,
      () => queueJob(update),
      instance.scope
      // track it in component's effect scope
    );
    const update = instance.update = () => effect2.run();
    update.id = instance.uid;
    toggleRecurse(instance, true);
    update();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs();
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i;
    for (i = 0; i < commonLength; i++) {
      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(
        c1[i],
        nextChild,
        container,
        null,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    }
    if (oldLength > newLength) {
      unmountChildren(
        c1,
        parentComponent,
        parentSuspense,
        true,
        false,
        commonLength
      );
    } else {
      mountChildren(
        c2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized,
        commonLength
      );
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i <= e1 && i <= e2) {
      const n1 = c1[i];
      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      i++;
    }
    while (i <= e1 && i <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i > e1) {
      if (i <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i <= e2) {
          patch(
            null,
            c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
          i++;
        }
      }
    } else if (i > e2) {
      while (i <= e1) {
        unmount(c1[i], parentComponent, parentSuspense, true);
        i++;
      }
    } else {
      const s1 = i;
      const s2 = i;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i = s2; i <= e2; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      let j2;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved2 = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i = 0; i < toBePatched; i++)
        newIndexToOldIndexMap[i] = 0;
      for (i = s1; i <= e1; i++) {
        const prevChild = c1[i];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex2;
        if (prevChild.key != null) {
          newIndex2 = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j2 = s2; j2 <= e2; j2++) {
            if (newIndexToOldIndexMap[j2 - s2] === 0 && isSameVNodeType(prevChild, c2[j2])) {
              newIndex2 = j2;
              break;
            }
          }
        }
        if (newIndex2 === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex2 - s2] = i + 1;
          if (newIndex2 >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex2;
          } else {
            moved2 = true;
          }
          patch(
            prevChild,
            c2[newIndex2],
            container,
            null,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
          patched++;
        }
      }
      const increasingNewIndexSequence = moved2 ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j2 = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s2 + i;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i] === 0) {
          patch(
            null,
            nextChild,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else if (moved2) {
          if (j2 < 0 || i !== increasingNewIndexSequence[j2]) {
            move(nextChild, container, anchor, 2);
          } else {
            j2--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type: type2, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type2.move(vnode, container, anchor, internals);
      return;
    }
    if (type2 === Fragment) {
      hostInsert(el, container, anchor);
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type2 === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove22 = () => hostInsert(el, container, anchor);
        const performLeave = () => {
          leave(el, () => {
            remove22();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove22, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const {
      type: type2,
      props: props2,
      ref: ref2,
      children,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs
    } = vnode;
    if (ref2 != null) {
      setRef(ref2, null, parentSuspense, vnode, true);
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props2 && props2.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(
          vnode,
          parentComponent,
          parentSuspense,
          optimized,
          internals,
          doRemove
        );
      } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (type2 !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(
          dynamicChildren,
          parentComponent,
          parentSuspense,
          false,
          true
        );
      } else if (type2 === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props2 && props2.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type: type2, el, anchor, transition } = vnode;
    if (type2 === Fragment) {
      {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type2 === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    const { bum, scope, update, subTree, um } = instance;
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (update) {
      update.active = false;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i = start; i < children.length; i++) {
      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    return hostNextSibling(vnode.anchor || vnode.el);
  };
  const render2 = (vnode, container, isSVG) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(container._vnode || null, vnode, container, null, null, null, isSVG);
    }
    flushPreFlushCbs();
    flushPostFlushCbs();
    container._vnode = vnode;
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate2;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate2, hydrateNode] = createHydrationFns(
      internals
    );
  }
  return {
    render: render2,
    hydrate: hydrate2,
    createApp: createAppAPI(render2, hydrate2)
  };
}
function toggleRecurse({ effect: effect2, update }, allowed) {
  effect2.allowRecurse = update.allowRecurse = allowed;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray$6(ch1) && isArray$6(ch2)) {
    for (let i = 0; i < ch1.length; i++) {
      const c1 = ch1[i];
      let c2 = ch2[i];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i] = cloneIfMounted(ch2[i]);
          c2.el = c1.el;
        }
        if (!shallow)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i, j2, u, v2, c2;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j2 = result[result.length - 1];
      if (arr[j2] < arrI) {
        p2[i] = j2;
        result.push(i);
        continue;
      }
      u = 0;
      v2 = result.length - 1;
      while (u < v2) {
        c2 = u + v2 >> 1;
        if (arr[result[c2]] < arrI) {
          u = c2 + 1;
        } else {
          v2 = c2;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p2[i] = result[u - 1];
        }
        result[u] = i;
      }
    }
  }
  u = result.length;
  v2 = result[u - 1];
  while (u-- > 0) {
    result[u] = v2;
    v2 = p2[v2];
  }
  return result;
}
const isTeleport = (type2) => type2.__isTeleport;
const isTeleportDisabled = (props2) => props2 && (props2.disabled || props2.disabled === "");
const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
const resolveTarget = (props2, select) => {
  const targetSelector = props2 && props2.to;
  if (isString$2(targetSelector)) {
    if (!select) {
      return null;
    } else {
      const target = select(targetSelector);
      return target;
    }
  } else {
    return targetSelector;
  }
};
const TeleportImpl = {
  __isTeleport: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
    const {
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      o: { insert, querySelector, createText, createComment }
    } = internals;
    const disabled = isTeleportDisabled(n2.props);
    let { shapeFlag, children, dynamicChildren } = n2;
    if (n1 == null) {
      const placeholder = n2.el = createText("");
      const mainAnchor = n2.anchor = createText("");
      insert(placeholder, container, anchor);
      insert(mainAnchor, container, anchor);
      const target = n2.target = resolveTarget(n2.props, querySelector);
      const targetAnchor = n2.targetAnchor = createText("");
      if (target) {
        insert(targetAnchor, target);
        isSVG = isSVG || isTargetSVG(target);
      }
      const mount2 = (container2, anchor2) => {
        if (shapeFlag & 16) {
          mountChildren(
            children,
            container2,
            anchor2,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        }
      };
      if (disabled) {
        mount2(container, mainAnchor);
      } else if (target) {
        mount2(target, targetAnchor);
      }
    } else {
      n2.el = n1.el;
      const mainAnchor = n2.anchor = n1.anchor;
      const target = n2.target = n1.target;
      const targetAnchor = n2.targetAnchor = n1.targetAnchor;
      const wasDisabled = isTeleportDisabled(n1.props);
      const currentContainer = wasDisabled ? container : target;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      isSVG = isSVG || isTargetSVG(target);
      if (dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          currentContainer,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds
        );
        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(
          n1,
          n2,
          currentContainer,
          currentAnchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          false
        );
      }
      if (disabled) {
        if (!wasDisabled) {
          moveTeleport(
            n2,
            container,
            mainAnchor,
            internals,
            1
          );
        } else {
          if (n2.props && n1.props && n2.props.to !== n1.props.to) {
            n2.props.to = n1.props.to;
          }
        }
      } else {
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          const nextTarget = n2.target = resolveTarget(
            n2.props,
            querySelector
          );
          if (nextTarget) {
            moveTeleport(
              n2,
              nextTarget,
              null,
              internals,
              0
            );
          }
        } else if (wasDisabled) {
          moveTeleport(
            n2,
            target,
            targetAnchor,
            internals,
            1
          );
        }
      }
    }
    updateCssVars(n2);
  },
  remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
    const { shapeFlag, children, anchor, targetAnchor, target, props: props2 } = vnode;
    if (target) {
      hostRemove(targetAnchor);
    }
    doRemove && hostRemove(anchor);
    if (shapeFlag & 16) {
      const shouldRemove = doRemove || !isTeleportDisabled(props2);
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        unmount(
          child,
          parentComponent,
          parentSuspense,
          shouldRemove,
          !!child.dynamicChildren
        );
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
  if (moveType === 0) {
    insert(vnode.targetAnchor, container, parentAnchor);
  }
  const { el, anchor, shapeFlag, children, props: props2 } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert(el, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props2)) {
    if (shapeFlag & 16) {
      for (let i = 0; i < children.length; i++) {
        move(
          children[i],
          container,
          parentAnchor,
          2
        );
      }
    }
  }
  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
  o: { nextSibling, parentNode, querySelector }
}, hydrateChildren) {
  const target = vnode.target = resolveTarget(
    vnode.props,
    querySelector
  );
  if (target) {
    const targetNode = target._lpa || target.firstChild;
    if (vnode.shapeFlag & 16) {
      if (isTeleportDisabled(vnode.props)) {
        vnode.anchor = hydrateChildren(
          nextSibling(node),
          vnode,
          parentNode(node),
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
        vnode.targetAnchor = targetNode;
      } else {
        vnode.anchor = nextSibling(node);
        let targetAnchor = targetNode;
        while (targetAnchor) {
          targetAnchor = nextSibling(targetAnchor);
          if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
            vnode.targetAnchor = targetAnchor;
            target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
            break;
          }
        }
        hydrateChildren(
          targetNode,
          vnode,
          target,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      }
    }
    updateCssVars(vnode);
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
function updateCssVars(vnode) {
  const ctx = vnode.ctx;
  if (ctx && ctx.ut) {
    let node = vnode.children[0].el;
    while (node && node !== vnode.targetAnchor) {
      if (node.nodeType === 1)
        node.setAttribute("data-v-owner", ctx.uid);
      node = node.nextSibling;
    }
    ctx.ut();
  }
}
const Fragment = Symbol.for("v-fgt");
const Text = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value) {
  isBlockTreeEnabled += value;
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type2, props2, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(
    createBaseVNode(
      type2,
      props2,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      true
      /* isBlock */
    )
  );
}
function createBlock(type2, props2, children, patchFlag, dynamicProps) {
  return setupBlock(
    createVNode(
      type2,
      props2,
      children,
      patchFlag,
      dynamicProps,
      true
      /* isBlock: prevent a block from tracking itself */
    )
  );
}
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
function transformVNodeArgs(transformer) {
}
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key: key2 }) => key2 != null ? key2 : null;
const normalizeRef = ({
  ref: ref2,
  ref_key,
  ref_for
}) => {
  if (typeof ref2 === "number") {
    ref2 = "" + ref2;
  }
  return ref2 != null ? isString$2(ref2) || isRef(ref2) || isFunction$1(ref2) ? { i: currentRenderingInstance, r: ref2, k: ref_key, f: !!ref_for } : ref2 : null;
};
function createBaseVNode(type2, props2 = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type2 === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type: type2,
    props: props2,
    key: props2 && normalizeKey(props2),
    ref: props2 && normalizeRef(props2),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type2.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString$2(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type2, props2 = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type2 || type2 === NULL_DYNAMIC_COMPONENT) {
    type2 = Comment;
  }
  if (isVNode(type2)) {
    const cloned = cloneVNode(
      type2,
      props2,
      true
      /* mergeRef: true */
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type2)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag |= -2;
    return cloned;
  }
  if (isClassComponent(type2)) {
    type2 = type2.__vccOpts;
  }
  if (props2) {
    props2 = guardReactiveProps(props2);
    let { class: klass, style: style3 } = props2;
    if (klass && !isString$2(klass)) {
      props2.class = normalizeClass(klass);
    }
    if (isObject$2(style3)) {
      if (isProxy(style3) && !isArray$6(style3)) {
        style3 = extend$2({}, style3);
      }
      props2.style = normalizeStyle(style3);
    }
  }
  const shapeFlag = isString$2(type2) ? 1 : isSuspense(type2) ? 128 : isTeleport(type2) ? 64 : isObject$2(type2) ? 4 : isFunction$1(type2) ? 2 : 0;
  return createBaseVNode(
    type2,
    props2,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  );
}
function guardReactiveProps(props2) {
  if (!props2)
    return null;
  return isProxy(props2) || InternalObjectKey in props2 ? extend$2({}, props2) : props2;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
  const { props: props2, ref: ref2, patchFlag, children } = vnode;
  const mergedProps = extraProps ? mergeProps(props2 || {}, extraProps) : props2;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref2 ? isArray$6(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref2,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition: vnode.transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createStaticVNode(content, numberOfNodes) {
  const vnode = createVNode(Static, null, content);
  vnode.staticCount = numberOfNodes;
  return vnode;
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray$6(child)) {
    return createVNode(
      Fragment,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (typeof child === "object") {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type2 = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray$6(children)) {
    type2 = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type2 = 32;
      const slotFlag = children._;
      if (!slotFlag && !(InternalObjectKey in children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction$1(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type2 = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type2 = 16;
      children = [createTextVNode(children)];
    } else {
      type2 = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type2;
}
function mergeProps(...args) {
  const ret = {};
  for (let i = 0; i < args.length; i++) {
    const toMerge = args[i];
    for (const key2 in toMerge) {
      if (key2 === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key2 === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn$1(key2)) {
        const existing = ret[key2];
        const incoming = toMerge[key2];
        if (incoming && existing !== incoming && !(isArray$6(existing) && existing.includes(incoming))) {
          ret[key2] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key2 !== "") {
        ret[key2] = toMerge[key2];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid$2 = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type2 = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid$2++,
    vnode,
    type: type2,
    parent,
    appContext,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    scope: new EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type2, appContext),
    emitsOptions: normalizeEmitsOptions(type2, appContext),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type2.inheritAttrs,
    // state
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    attrsProxy: null,
    slotsProxy: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance$1 = () => currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let globalCurrentInstanceSetters;
let settersKey = "__VUE_INSTANCE_SETTERS__";
{
  if (!(globalCurrentInstanceSetters = getGlobalThis()[settersKey])) {
    globalCurrentInstanceSetters = getGlobalThis()[settersKey] = [];
  }
  globalCurrentInstanceSetters.push((i) => currentInstance = i);
  internalSetCurrentInstance = (instance) => {
    if (globalCurrentInstanceSetters.length > 1) {
      globalCurrentInstanceSetters.forEach((s) => s(instance));
    } else {
      globalCurrentInstanceSetters[0](instance);
    }
  };
}
const setCurrentInstance = (instance) => {
  internalSetCurrentInstance(instance);
  instance.scope.on();
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
};
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
  isInSSRComponentSetup = isSSR;
  const { props: props2, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props2, isStateful, isSSR);
  initSlots(instance, children);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isInSSRComponentSetup = false;
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
  const { setup } = Component;
  if (setup) {
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling(
      setup,
      instance,
      0,
      [instance.props, setupContext]
    );
    resetTracking();
    unsetCurrentInstance();
    if (isPromise(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e) => {
          handleError(e, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction$1(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject$2(setupResult)) {
    instance.setupState = proxyRefs(setupResult);
  } else
    ;
  finishComponentSetup(instance, isSSR);
}
let compile$1;
let installWithProxy;
function registerRuntimeCompiler(_compile) {
  compile$1 = _compile;
  installWithProxy = (i) => {
    if (i.render._rc) {
      i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
    }
  };
}
const isRuntimeOnly = () => !compile$1;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile$1 && !Component.render) {
      const template = Component.template || resolveMergedOptions(instance).template;
      if (template) {
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend$2(
          extend$2(
            {
              isCustomElement,
              delimiters
            },
            compilerOptions
          ),
          componentCompilerOptions
        );
        Component.render = compile$1(template, finalCompilerOptions);
      }
    }
    instance.render = Component.render || NOOP;
    if (installWithProxy) {
      installWithProxy(instance);
    }
  }
  {
    setCurrentInstance(instance);
    pauseTracking();
    try {
      applyOptions(instance);
    } finally {
      resetTracking();
      unsetCurrentInstance();
    }
  }
}
function getAttrsProxy(instance) {
  return instance.attrsProxy || (instance.attrsProxy = new Proxy(
    instance.attrs,
    {
      get(target, key2) {
        track(instance, "get", "$attrs");
        return target[key2];
      }
    }
  ));
}
function createSetupContext(instance) {
  const expose = (exposed) => {
    instance.exposed = exposed || {};
  };
  {
    return {
      get attrs() {
        return getAttrsProxy(instance);
      },
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getExposeProxy(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key2) {
        if (key2 in target) {
          return target[key2];
        } else if (key2 in publicPropertiesMap) {
          return publicPropertiesMap[key2](instance);
        }
      },
      has(target, key2) {
        return key2 in target || key2 in publicPropertiesMap;
      }
    }));
  }
}
function getComponentName(Component, includeInferred = true) {
  return isFunction$1(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function isClassComponent(value) {
  return isFunction$1(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions) => {
  return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
};
function h(type2, propsOrChildren, children) {
  const l = arguments.length;
  if (l === 2) {
    if (isObject$2(propsOrChildren) && !isArray$6(propsOrChildren)) {
      if (isVNode(propsOrChildren)) {
        return createVNode(type2, null, [propsOrChildren]);
      }
      return createVNode(type2, propsOrChildren);
    } else {
      return createVNode(type2, null, propsOrChildren);
    }
  } else {
    if (l > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l === 3 && isVNode(children)) {
      children = [children];
    }
    return createVNode(type2, propsOrChildren, children);
  }
}
const ssrContextKey = Symbol.for("v-scx");
const useSSRContext = () => {
  {
    const ctx = inject$1(ssrContextKey);
    return ctx;
  }
};
function initCustomFormatter() {
  {
    return;
  }
}
function withMemo(memo, render2, cache, index2) {
  const cached = cache[index2];
  if (cached && isMemoSame(cached, memo)) {
    return cached;
  }
  const ret = render2();
  ret.memo = memo.slice();
  return cache[index2] = ret;
}
function isMemoSame(cached, memo) {
  const prev = cached.memo;
  if (prev.length != memo.length) {
    return false;
  }
  for (let i = 0; i < prev.length; i++) {
    if (hasChanged(prev[i], memo[i])) {
      return false;
    }
  }
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(cached);
  }
  return true;
}
const version$2 = "3.3.6";
const _ssrUtils = {
  createComponentInstance,
  setupComponent,
  renderComponentRoot,
  setCurrentRenderingInstance,
  isVNode,
  normalizeVNode
};
const ssrUtils = _ssrUtils;
const resolveFilter = null;
const compatUtils = null;
const svgNS = "http://www.w3.org/2000/svg";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, isSVG, is2, props2) => {
    const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is2 ? { is: is2 } : void 0);
    if (tag === "select" && props2 && props2.multiple != null) {
      el.setAttribute("multiple", props2.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id) {
    el.setAttribute(id, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content, parent, anchor, isSVG, start, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling))
          break;
      }
    } else {
      templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
      const template = templateContainer.content;
      if (isSVG) {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      // first
      before ? before.nextSibling : parent.firstChild,
      // last
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
const TRANSITION = "transition";
const ANIMATION = "animation";
const vtcKey = Symbol("_vtc");
const Transition = (props2, { slots }) => h(BaseTransition, resolveTransitionProps(props2), slots);
Transition.displayName = "Transition";
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
const TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend$2(
  {},
  BaseTransitionPropsValidators,
  DOMTransitionPropsValidators
);
const callHook = (hook, args = []) => {
  if (isArray$6(hook)) {
    hook.forEach((h2) => h2(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = (hook) => {
  return hook ? isArray$6(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key2 in rawProps) {
    if (!(key2 in DOMTransitionPropsValidators)) {
      baseProps[key2] = rawProps[key2];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const {
    name = "v",
    type: type2,
    duration,
    enterFromClass = `${name}-enter-from`,
    enterActiveClass = `${name}-enter-active`,
    enterToClass = `${name}-enter-to`,
    appearFromClass = enterFromClass,
    appearActiveClass = enterActiveClass,
    appearToClass = enterToClass,
    leaveFromClass = `${name}-leave-from`,
    leaveActiveClass = `${name}-leave-active`,
    leaveToClass = `${name}-leave-to`
  } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const {
    onBeforeEnter,
    onEnter,
    onEnterCancelled,
    onLeave,
    onLeaveCancelled,
    onBeforeAppear = onBeforeEnter,
    onAppear = onEnter,
    onAppearCancelled = onEnterCancelled
  } = baseProps;
  const finishEnter = (el, isAppear, done) => {
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el, done) => {
    el._isLeaving = false;
    removeTransitionClass(el, leaveFromClass);
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el, done) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve2 = () => finishEnter(el, isAppear, done);
      callHook(hook, [el, resolve2]);
      nextFrame(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type2, enterDuration, resolve2);
        }
      });
    };
  };
  return extend$2(baseProps, {
    onBeforeEnter(el) {
      callHook(onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      callHook(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done) {
      el._isLeaving = true;
      const resolve2 = () => finishLeave(el, done);
      addTransitionClass(el, leaveFromClass);
      forceReflow();
      addTransitionClass(el, leaveActiveClass);
      nextFrame(() => {
        if (!el._isLeaving) {
          return;
        }
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el, type2, leaveDuration, resolve2);
        }
      });
      callHook(onLeave, [el, resolve2]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false);
      callHook(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true);
      callHook(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      callHook(onLeaveCancelled, [el]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if (isObject$2(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n = NumberOf(duration);
    return [n, n];
  }
}
function NumberOf(val) {
  const res = toNumber(val);
  return res;
}
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c2) => c2 && el.classList.add(c2));
  (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c2) => c2 && el.classList.remove(c2));
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el[vtcKey] = void 0;
    }
  }
}
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
  const id = el._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id === el._endId) {
      resolve2();
    }
  };
  if (explicitTimeout) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type: type2, timeout, propCount } = getTransitionInfo(el, expectedType);
  if (!type2) {
    return resolve2();
  }
  const endEvent = type2 + "end";
  let ended = 0;
  const end = () => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e) => {
    if (e.target === el && ++ended >= propCount) {
      end();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
  const styles = window.getComputedStyle(el);
  const getStyleProperties = (key2) => (styles[key2] || "").split(", ");
  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type2 = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type2 = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type2 = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type2 = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type2 ? type2 === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type2 === TRANSITION && /\b(transform|all)(,|$)/.test(
    getStyleProperties(`${TRANSITION}Property`).toString()
  );
  return {
    type: type2,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
}
function toMs(s) {
  if (s === "auto")
    return 0;
  return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}
function patchClass(el, value, isSVG) {
  const transitionClasses = el[vtcKey];
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}
const vShowOldKey = Symbol("_vod");
const vShow = {
  beforeMount(el, { value }, { transition }) {
    el[vShowOldKey] = el.style.display === "none" ? "" : el.style.display;
    if (transition && value) {
      transition.beforeEnter(el);
    } else {
      setDisplay(el, value);
    }
  },
  mounted(el, { value }, { transition }) {
    if (transition && value) {
      transition.enter(el);
    }
  },
  updated(el, { value, oldValue }, { transition }) {
    if (!value === !oldValue)
      return;
    if (transition) {
      if (value) {
        transition.beforeEnter(el);
        setDisplay(el, true);
        transition.enter(el);
      } else {
        transition.leave(el, () => {
          setDisplay(el, false);
        });
      }
    } else {
      setDisplay(el, value);
    }
  },
  beforeUnmount(el, { value }) {
    setDisplay(el, value);
  }
};
function setDisplay(el, value) {
  el.style.display = value ? el[vShowOldKey] : "none";
}
function initVShowForSSR() {
  vShow.getSSRProps = ({ value }) => {
    if (!value) {
      return { style: { display: "none" } };
    }
  };
}
function patchStyle(el, prev, next) {
  const style3 = el.style;
  const isCssString = isString$2(next);
  if (next && !isCssString) {
    if (prev && !isString$2(prev)) {
      for (const key2 in prev) {
        if (next[key2] == null) {
          setStyle(style3, key2, "");
        }
      }
    }
    for (const key2 in next) {
      setStyle(style3, key2, next[key2]);
    }
  } else {
    const currentDisplay = style3.display;
    if (isCssString) {
      if (prev !== next) {
        style3.cssText = next;
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
    if (vShowOldKey in el) {
      style3.display = currentDisplay;
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style3, name, val) {
  if (isArray$6(val)) {
    val.forEach((v2) => setStyle(style3, name, v2));
  } else {
    if (val == null)
      val = "";
    if (name.startsWith("--")) {
      style3.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style3, name);
      if (importantRE.test(val)) {
        style3.setProperty(
          hyphenate(prefixed),
          val.replace(importantRE, ""),
          "important"
        );
      } else {
        style3[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style3, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize(rawName);
  if (name !== "filter" && name in style3) {
    return prefixCache[rawName] = name;
  }
  name = capitalize(name);
  for (let i = 0; i < prefixes.length; i++) {
    const prefixed = prefixes[i] + name;
    if (prefixed in style3) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key2, value, isSVG, instance) {
  if (isSVG && key2.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key2.slice(6, key2.length));
    } else {
      el.setAttributeNS(xlinkNS, key2, value);
    }
  } else {
    const isBoolean2 = isSpecialBooleanAttr(key2);
    if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
      el.removeAttribute(key2);
    } else {
      el.setAttribute(key2, isBoolean2 ? "" : value);
    }
  }
}
function patchDOMProp(el, key2, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key2 === "innerHTML" || key2 === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el[key2] = value == null ? "" : value;
    return;
  }
  const tag = el.tagName;
  if (key2 === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
  !tag.includes("-")) {
    el._value = value;
    const oldValue = tag === "OPTION" ? el.getAttribute("value") : el.value;
    const newValue = value == null ? "" : value;
    if (oldValue !== newValue) {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key2);
    }
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type2 = typeof el[key2];
    if (type2 === "boolean") {
      value = includeBooleanAttr(value);
    } else if (value == null && type2 === "string") {
      value = "";
      needRemove = true;
    } else if (type2 === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el[key2] = value;
  } catch (e) {
  }
  needRemove && el.removeAttribute(key2);
}
function addEventListener(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
const veiKey = Symbol("_vei");
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el[veiKey] || (el[veiKey] = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(nextValue, instance);
      addEventListener(el, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m;
    while (m = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m[0].length);
      options[m[0].toLowerCase()] = true;
    }
  }
  const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
  return [event, options];
}
let cachedNow = 0;
const p$1 = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p$1.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
  const invoker = (e) => {
    if (!e._vts) {
      e._vts = Date.now();
    } else if (e._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(
      patchStopImmediatePropagation(e, invoker.value),
      instance,
      5,
      [e]
    );
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e, value) {
  if (isArray$6(value)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value.map((fn) => (e2) => !e2._stopped && fn && fn(e2));
  } else {
    return value;
  }
}
const nativeOnRE = /^on[a-z]/;
const patchProp = (el, key2, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  if (key2 === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key2 === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn$1(key2)) {
    if (!isModelListener(key2)) {
      patchEvent(el, key2, prevValue, nextValue, parentComponent);
    }
  } else if (key2[0] === "." ? (key2 = key2.slice(1), true) : key2[0] === "^" ? (key2 = key2.slice(1), false) : shouldSetAsProp(el, key2, nextValue, isSVG)) {
    patchDOMProp(
      el,
      key2,
      nextValue,
      prevChildren,
      parentComponent,
      parentSuspense,
      unmountChildren
    );
  } else {
    if (key2 === "true-value") {
      el._trueValue = nextValue;
    } else if (key2 === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key2, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key2, value, isSVG) {
  if (isSVG) {
    if (key2 === "innerHTML" || key2 === "textContent") {
      return true;
    }
    if (key2 in el && nativeOnRE.test(key2) && isFunction$1(value)) {
      return true;
    }
    return false;
  }
  if (key2 === "spellcheck" || key2 === "draggable" || key2 === "translate") {
    return false;
  }
  if (key2 === "form") {
    return false;
  }
  if (key2 === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key2 === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (nativeOnRE.test(key2) && isString$2(value)) {
    return false;
  }
  return key2 in el;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineCustomElement(options, hydrate2) {
  const Comp = /* @__PURE__ */ defineComponent$1(options);
  class VueCustomElement extends VueElement {
    constructor(initialProps) {
      super(Comp, initialProps, hydrate2);
    }
  }
  VueCustomElement.def = Comp;
  return VueCustomElement;
}
/*! #__NO_SIDE_EFFECTS__ */
const defineSSRCustomElement = /* @__NO_SIDE_EFFECTS__ */ (options) => {
  return /* @__PURE__ */ defineCustomElement(options, hydrate);
};
const BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
};
class VueElement extends BaseClass {
  constructor(_def, _props = {}, hydrate2) {
    super();
    this._def = _def;
    this._props = _props;
    this._instance = null;
    this._connected = false;
    this._resolved = false;
    this._numberProps = null;
    this._ob = null;
    if (this.shadowRoot && hydrate2) {
      hydrate2(this._createVNode(), this.shadowRoot);
    } else {
      this.attachShadow({ mode: "open" });
      if (!this._def.__asyncLoader) {
        this._resolveProps(this._def);
      }
    }
  }
  connectedCallback() {
    this._connected = true;
    if (!this._instance) {
      if (this._resolved) {
        this._update();
      } else {
        this._resolveDef();
      }
    }
  }
  disconnectedCallback() {
    this._connected = false;
    if (this._ob) {
      this._ob.disconnect();
      this._ob = null;
    }
    nextTick(() => {
      if (!this._connected) {
        render$3(null, this.shadowRoot);
        this._instance = null;
      }
    });
  }
  /**
   * resolve inner component definition (handle possible async component)
   */
  _resolveDef() {
    this._resolved = true;
    for (let i = 0; i < this.attributes.length; i++) {
      this._setAttr(this.attributes[i].name);
    }
    this._ob = new MutationObserver((mutations) => {
      for (const m of mutations) {
        this._setAttr(m.attributeName);
      }
    });
    this._ob.observe(this, { attributes: true });
    const resolve2 = (def2, isAsync = false) => {
      const { props: props2, styles } = def2;
      let numberProps;
      if (props2 && !isArray$6(props2)) {
        for (const key2 in props2) {
          const opt = props2[key2];
          if (opt === Number || opt && opt.type === Number) {
            if (key2 in this._props) {
              this._props[key2] = toNumber(this._props[key2]);
            }
            (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[camelize(key2)] = true;
          }
        }
      }
      this._numberProps = numberProps;
      if (isAsync) {
        this._resolveProps(def2);
      }
      this._applyStyles(styles);
      this._update();
    };
    const asyncDef = this._def.__asyncLoader;
    if (asyncDef) {
      asyncDef().then((def2) => resolve2(def2, true));
    } else {
      resolve2(this._def);
    }
  }
  _resolveProps(def2) {
    const { props: props2 } = def2;
    const declaredPropKeys = isArray$6(props2) ? props2 : Object.keys(props2 || {});
    for (const key2 of Object.keys(this)) {
      if (key2[0] !== "_" && declaredPropKeys.includes(key2)) {
        this._setProp(key2, this[key2], true, false);
      }
    }
    for (const key2 of declaredPropKeys.map(camelize)) {
      Object.defineProperty(this, key2, {
        get() {
          return this._getProp(key2);
        },
        set(val) {
          this._setProp(key2, val);
        }
      });
    }
  }
  _setAttr(key2) {
    let value = this.getAttribute(key2);
    const camelKey = camelize(key2);
    if (this._numberProps && this._numberProps[camelKey]) {
      value = toNumber(value);
    }
    this._setProp(camelKey, value, false);
  }
  /**
   * @internal
   */
  _getProp(key2) {
    return this._props[key2];
  }
  /**
   * @internal
   */
  _setProp(key2, val, shouldReflect = true, shouldUpdate = true) {
    if (val !== this._props[key2]) {
      this._props[key2] = val;
      if (shouldUpdate && this._instance) {
        this._update();
      }
      if (shouldReflect) {
        if (val === true) {
          this.setAttribute(hyphenate(key2), "");
        } else if (typeof val === "string" || typeof val === "number") {
          this.setAttribute(hyphenate(key2), val + "");
        } else if (!val) {
          this.removeAttribute(hyphenate(key2));
        }
      }
    }
  }
  _update() {
    render$3(this._createVNode(), this.shadowRoot);
  }
  _createVNode() {
    const vnode = createVNode(this._def, extend$2({}, this._props));
    if (!this._instance) {
      vnode.ce = (instance) => {
        this._instance = instance;
        instance.isCE = true;
        const dispatch = (event, args) => {
          this.dispatchEvent(
            new CustomEvent(event, {
              detail: args
            })
          );
        };
        instance.emit = (event, ...args) => {
          dispatch(event, args);
          if (hyphenate(event) !== event) {
            dispatch(hyphenate(event), args);
          }
        };
        let parent = this;
        while (parent = parent && (parent.parentNode || parent.host)) {
          if (parent instanceof VueElement) {
            instance.parent = parent._instance;
            instance.provides = parent._instance.provides;
            break;
          }
        }
      };
    }
    return vnode;
  }
  _applyStyles(styles) {
    if (styles) {
      styles.forEach((css2) => {
        const s = document.createElement("style");
        s.textContent = css2;
        this.shadowRoot.appendChild(s);
      });
    }
  }
}
function useCssModule(name = "$style") {
  {
    const instance = getCurrentInstance$1();
    if (!instance) {
      return EMPTY_OBJ;
    }
    const modules = instance.type.__cssModules;
    if (!modules) {
      return EMPTY_OBJ;
    }
    const mod = modules[name];
    if (!mod) {
      return EMPTY_OBJ;
    }
    return mod;
  }
}
function useCssVars(getter) {
  const instance = getCurrentInstance$1();
  if (!instance) {
    return;
  }
  const updateTeleports = instance.ut = (vars = getter(instance.proxy)) => {
    Array.from(
      document.querySelectorAll(`[data-v-owner="${instance.uid}"]`)
    ).forEach((node) => setVarsOnNode(node, vars));
  };
  const setVars = () => {
    const vars = getter(instance.proxy);
    setVarsOnVNode(instance.subTree, vars);
    updateTeleports(vars);
  };
  watchPostEffect(setVars);
  onMounted(() => {
    const ob = new MutationObserver(setVars);
    ob.observe(instance.subTree.el.parentNode, { childList: true });
    onUnmounted(() => ob.disconnect());
  });
}
function setVarsOnVNode(vnode, vars) {
  if (vnode.shapeFlag & 128) {
    const suspense = vnode.suspense;
    vnode = suspense.activeBranch;
    if (suspense.pendingBranch && !suspense.isHydrating) {
      suspense.effects.push(() => {
        setVarsOnVNode(suspense.activeBranch, vars);
      });
    }
  }
  while (vnode.component) {
    vnode = vnode.component.subTree;
  }
  if (vnode.shapeFlag & 1 && vnode.el) {
    setVarsOnNode(vnode.el, vars);
  } else if (vnode.type === Fragment) {
    vnode.children.forEach((c2) => setVarsOnVNode(c2, vars));
  } else if (vnode.type === Static) {
    let { el, anchor } = vnode;
    while (el) {
      setVarsOnNode(el, vars);
      if (el === anchor)
        break;
      el = el.nextSibling;
    }
  }
}
function setVarsOnNode(el, vars) {
  if (el.nodeType === 1) {
    const style3 = el.style;
    for (const key2 in vars) {
      style3.setProperty(`--${key2}`, vars[key2]);
    }
  }
}
const positionMap = /* @__PURE__ */ new WeakMap();
const newPositionMap = /* @__PURE__ */ new WeakMap();
const moveCbKey = Symbol("_moveCb");
const enterCbKey = Symbol("_enterCb");
const TransitionGroupImpl = {
  name: "TransitionGroup",
  props: /* @__PURE__ */ extend$2({}, TransitionPropsValidators, {
    tag: String,
    moveClass: String
  }),
  setup(props2, { slots }) {
    const instance = getCurrentInstance$1();
    const state = useTransitionState();
    let prevChildren;
    let children;
    onUpdated(() => {
      if (!prevChildren.length) {
        return;
      }
      const moveClass = props2.moveClass || `${props2.name || "v"}-move`;
      if (!hasCSSTransform(
        prevChildren[0].el,
        instance.vnode.el,
        moveClass
      )) {
        return;
      }
      prevChildren.forEach(callPendingCbs);
      prevChildren.forEach(recordPosition);
      const movedChildren = prevChildren.filter(applyTranslation);
      forceReflow();
      movedChildren.forEach((c2) => {
        const el = c2.el;
        const style3 = el.style;
        addTransitionClass(el, moveClass);
        style3.transform = style3.webkitTransform = style3.transitionDuration = "";
        const cb = el[moveCbKey] = (e) => {
          if (e && e.target !== el) {
            return;
          }
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener("transitionend", cb);
            el[moveCbKey] = null;
            removeTransitionClass(el, moveClass);
          }
        };
        el.addEventListener("transitionend", cb);
      });
    });
    return () => {
      const rawProps = toRaw(props2);
      const cssTransitionProps = resolveTransitionProps(rawProps);
      let tag = rawProps.tag || Fragment;
      prevChildren = children;
      children = slots.default ? getTransitionRawChildren(slots.default()) : [];
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (child.key != null) {
          setTransitionHooks(
            child,
            resolveTransitionHooks(child, cssTransitionProps, state, instance)
          );
        }
      }
      if (prevChildren) {
        for (let i = 0; i < prevChildren.length; i++) {
          const child = prevChildren[i];
          setTransitionHooks(
            child,
            resolveTransitionHooks(child, cssTransitionProps, state, instance)
          );
          positionMap.set(child, child.el.getBoundingClientRect());
        }
      }
      return createVNode(tag, null, children);
    };
  }
};
const removeMode = (props2) => delete props2.mode;
/* @__PURE__ */ removeMode(TransitionGroupImpl.props);
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c2) {
  const el = c2.el;
  if (el[moveCbKey]) {
    el[moveCbKey]();
  }
  if (el[enterCbKey]) {
    el[enterCbKey]();
  }
}
function recordPosition(c2) {
  newPositionMap.set(c2, c2.el.getBoundingClientRect());
}
function applyTranslation(c2) {
  const oldPos = positionMap.get(c2);
  const newPos = newPositionMap.get(c2);
  const dx = oldPos.left - newPos.left;
  const dy = oldPos.top - newPos.top;
  if (dx || dy) {
    const s = c2.el.style;
    s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
    s.transitionDuration = "0s";
    return c2;
  }
}
function hasCSSTransform(el, root2, moveClass) {
  const clone2 = el.cloneNode();
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.forEach((cls) => {
      cls.split(/\s+/).forEach((c2) => c2 && clone2.classList.remove(c2));
    });
  }
  moveClass.split(/\s+/).forEach((c2) => c2 && clone2.classList.add(c2));
  clone2.style.display = "none";
  const container = root2.nodeType === 1 ? root2 : root2.parentNode;
  container.appendChild(clone2);
  const { hasTransform } = getTransitionInfo(clone2);
  container.removeChild(clone2);
  return hasTransform;
}
const getModelAssigner = (vnode) => {
  const fn = vnode.props["onUpdate:modelValue"] || false;
  return isArray$6(fn) ? (value) => invokeArrayFns(fn, value) : fn;
};
function onCompositionStart(e) {
  e.target.composing = true;
}
function onCompositionEnd(e) {
  const target = e.target;
  if (target.composing) {
    target.composing = false;
    target.dispatchEvent(new Event("input"));
  }
}
const assignKey = Symbol("_assign");
const vModelText = {
  created(el, { modifiers: { lazy, trim: trim2, number } }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    const castToNumber = number || vnode.props && vnode.props.type === "number";
    addEventListener(el, lazy ? "change" : "input", (e) => {
      if (e.target.composing)
        return;
      let domValue = el.value;
      if (trim2) {
        domValue = domValue.trim();
      }
      if (castToNumber) {
        domValue = looseToNumber(domValue);
      }
      el[assignKey](domValue);
    });
    if (trim2) {
      addEventListener(el, "change", () => {
        el.value = el.value.trim();
      });
    }
    if (!lazy) {
      addEventListener(el, "compositionstart", onCompositionStart);
      addEventListener(el, "compositionend", onCompositionEnd);
      addEventListener(el, "change", onCompositionEnd);
    }
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(el, { value }) {
    el.value = value == null ? "" : value;
  },
  beforeUpdate(el, { value, modifiers: { lazy, trim: trim2, number } }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    if (el.composing)
      return;
    if (document.activeElement === el && el.type !== "range") {
      if (lazy) {
        return;
      }
      if (trim2 && el.value.trim() === value) {
        return;
      }
      if ((number || el.type === "number") && looseToNumber(el.value) === value) {
        return;
      }
    }
    const newValue = value == null ? "" : value;
    if (el.value !== newValue) {
      el.value = newValue;
    }
  }
};
const vModelCheckbox = {
  // #4096 array checkboxes need to be deep traversed
  deep: true,
  created(el, _2, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    addEventListener(el, "change", () => {
      const modelValue = el._modelValue;
      const elementValue = getValue(el);
      const checked = el.checked;
      const assign2 = el[assignKey];
      if (isArray$6(modelValue)) {
        const index2 = looseIndexOf(modelValue, elementValue);
        const found = index2 !== -1;
        if (checked && !found) {
          assign2(modelValue.concat(elementValue));
        } else if (!checked && found) {
          const filtered = [...modelValue];
          filtered.splice(index2, 1);
          assign2(filtered);
        }
      } else if (isSet$1(modelValue)) {
        const cloned = new Set(modelValue);
        if (checked) {
          cloned.add(elementValue);
        } else {
          cloned.delete(elementValue);
        }
        assign2(cloned);
      } else {
        assign2(getCheckboxValue(el, checked));
      }
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: setChecked,
  beforeUpdate(el, binding, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    setChecked(el, binding, vnode);
  }
};
function setChecked(el, { value, oldValue }, vnode) {
  el._modelValue = value;
  if (isArray$6(value)) {
    el.checked = looseIndexOf(value, vnode.props.value) > -1;
  } else if (isSet$1(value)) {
    el.checked = value.has(vnode.props.value);
  } else if (value !== oldValue) {
    el.checked = looseEqual(value, getCheckboxValue(el, true));
  }
}
const vModelRadio = {
  created(el, { value }, vnode) {
    el.checked = looseEqual(value, vnode.props.value);
    el[assignKey] = getModelAssigner(vnode);
    addEventListener(el, "change", () => {
      el[assignKey](getValue(el));
    });
  },
  beforeUpdate(el, { value, oldValue }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    if (value !== oldValue) {
      el.checked = looseEqual(value, vnode.props.value);
    }
  }
};
const vModelSelect = {
  // <select multiple> value need to be deep traversed
  deep: true,
  created(el, { value, modifiers: { number } }, vnode) {
    const isSetModel = isSet$1(value);
    addEventListener(el, "change", () => {
      const selectedVal = Array.prototype.filter.call(el.options, (o) => o.selected).map(
        (o) => number ? looseToNumber(getValue(o)) : getValue(o)
      );
      el[assignKey](
        el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]
      );
    });
    el[assignKey] = getModelAssigner(vnode);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(el, { value }) {
    setSelected(el, value);
  },
  beforeUpdate(el, _binding, vnode) {
    el[assignKey] = getModelAssigner(vnode);
  },
  updated(el, { value }) {
    setSelected(el, value);
  }
};
function setSelected(el, value) {
  const isMultiple = el.multiple;
  if (isMultiple && !isArray$6(value) && !isSet$1(value)) {
    return;
  }
  for (let i = 0, l = el.options.length; i < l; i++) {
    const option2 = el.options[i];
    const optionValue = getValue(option2);
    if (isMultiple) {
      if (isArray$6(value)) {
        option2.selected = looseIndexOf(value, optionValue) > -1;
      } else {
        option2.selected = value.has(optionValue);
      }
    } else {
      if (looseEqual(getValue(option2), value)) {
        if (el.selectedIndex !== i)
          el.selectedIndex = i;
        return;
      }
    }
  }
  if (!isMultiple && el.selectedIndex !== -1) {
    el.selectedIndex = -1;
  }
}
function getValue(el) {
  return "_value" in el ? el._value : el.value;
}
function getCheckboxValue(el, checked) {
  const key2 = checked ? "_trueValue" : "_falseValue";
  return key2 in el ? el[key2] : checked;
}
const vModelDynamic = {
  created(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "created");
  },
  mounted(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "mounted");
  },
  beforeUpdate(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
  },
  updated(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "updated");
  }
};
function resolveDynamicModel(tagName, type2) {
  switch (tagName) {
    case "SELECT":
      return vModelSelect;
    case "TEXTAREA":
      return vModelText;
    default:
      switch (type2) {
        case "checkbox":
          return vModelCheckbox;
        case "radio":
          return vModelRadio;
        default:
          return vModelText;
      }
  }
}
function callModelHook(el, binding, vnode, prevVNode, hook) {
  const modelToUse = resolveDynamicModel(
    el.tagName,
    vnode.props && vnode.props.type
  );
  const fn = modelToUse[hook];
  fn && fn(el, binding, vnode, prevVNode);
}
function initVModelForSSR() {
  vModelText.getSSRProps = ({ value }) => ({ value });
  vModelRadio.getSSRProps = ({ value }, vnode) => {
    if (vnode.props && looseEqual(vnode.props.value, value)) {
      return { checked: true };
    }
  };
  vModelCheckbox.getSSRProps = ({ value }, vnode) => {
    if (isArray$6(value)) {
      if (vnode.props && looseIndexOf(value, vnode.props.value) > -1) {
        return { checked: true };
      }
    } else if (isSet$1(value)) {
      if (vnode.props && value.has(vnode.props.value)) {
        return { checked: true };
      }
    } else if (value) {
      return { checked: true };
    }
  };
  vModelDynamic.getSSRProps = (binding, vnode) => {
    if (typeof vnode.type !== "string") {
      return;
    }
    const modelToUse = resolveDynamicModel(
      // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
      vnode.type.toUpperCase(),
      vnode.props && vnode.props.type
    );
    if (modelToUse.getSSRProps) {
      return modelToUse.getSSRProps(binding, vnode);
    }
  };
}
const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: (e) => e.stopPropagation(),
  prevent: (e) => e.preventDefault(),
  self: (e) => e.target !== e.currentTarget,
  ctrl: (e) => !e.ctrlKey,
  shift: (e) => !e.shiftKey,
  alt: (e) => !e.altKey,
  meta: (e) => !e.metaKey,
  left: (e) => "button" in e && e.button !== 0,
  middle: (e) => "button" in e && e.button !== 1,
  right: (e) => "button" in e && e.button !== 2,
  exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
};
const withModifiers = (fn, modifiers) => {
  return (event, ...args) => {
    for (let i = 0; i < modifiers.length; i++) {
      const guard = modifierGuards[modifiers[i]];
      if (guard && guard(event, modifiers))
        return;
    }
    return fn(event, ...args);
  };
};
const keyNames = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
};
const withKeys = (fn, modifiers) => {
  return (event) => {
    if (!("key" in event)) {
      return;
    }
    const eventKey = hyphenate(event.key);
    if (modifiers.some((k2) => k2 === eventKey || keyNames[k2] === eventKey)) {
      return fn(event);
    }
  };
};
const rendererOptions = /* @__PURE__ */ extend$2({ patchProp }, nodeOps);
let renderer;
let enabledHydration = false;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
function ensureHydrationRenderer() {
  renderer = enabledHydration ? renderer : createHydrationRenderer(rendererOptions);
  enabledHydration = true;
  return renderer;
}
const render$3 = (...args) => {
  ensureRenderer().render(...args);
};
const hydrate = (...args) => {
  ensureHydrationRenderer().hydrate(...args);
};
const createApp = (...args) => {
  const app = ensureRenderer().createApp(...args);
  const { mount: mount2 } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container)
      return;
    const component = app._component;
    if (!isFunction$1(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    container.innerHTML = "";
    const proxy = mount2(container, false, container instanceof SVGElement);
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app;
};
const createSSRApp = (...args) => {
  const app = ensureHydrationRenderer().createApp(...args);
  const { mount: mount2 } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (container) {
      return mount2(container, true, container instanceof SVGElement);
    }
  };
  return app;
};
function normalizeContainer(container) {
  if (isString$2(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}
let ssrDirectiveInitialized = false;
const initDirectivesForSSR = () => {
  if (!ssrDirectiveInitialized) {
    ssrDirectiveInitialized = true;
    initVModelForSSR();
    initVShowForSSR();
  }
};
const compile = () => {
};
const vue_runtime_esmBundler = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BaseTransition,
  BaseTransitionPropsValidators,
  Comment,
  EffectScope,
  Fragment,
  KeepAlive,
  ReactiveEffect,
  Static,
  Suspense,
  Teleport,
  Text,
  Transition,
  TransitionGroup,
  VueElement,
  assertNumber,
  callWithAsyncErrorHandling,
  callWithErrorHandling,
  camelize,
  capitalize,
  cloneVNode,
  compatUtils,
  compile,
  computed,
  createApp,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createElementVNode: createBaseVNode,
  createHydrationRenderer,
  createPropsRestProxy,
  createRenderer,
  createSSRApp,
  createSlots,
  createStaticVNode,
  createTextVNode,
  createVNode,
  customRef,
  defineAsyncComponent,
  defineComponent: defineComponent$1,
  defineCustomElement,
  defineEmits,
  defineExpose,
  defineModel,
  defineOptions,
  defineProps,
  defineSSRCustomElement,
  defineSlots,
  get devtools() {
    return devtools;
  },
  effect,
  effectScope,
  getCurrentInstance: getCurrentInstance$1,
  getCurrentScope,
  getTransitionRawChildren,
  guardReactiveProps,
  h,
  handleError,
  hasInjectionContext,
  hydrate,
  initCustomFormatter,
  initDirectivesForSSR,
  inject: inject$1,
  isMemoSame,
  isProxy,
  isReactive,
  isReadonly,
  isRef,
  isRuntimeOnly,
  isShallow,
  isVNode,
  markRaw,
  mergeDefaults,
  mergeModels,
  mergeProps,
  nextTick,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  onActivated,
  onBeforeMount,
  onBeforeUnmount,
  onBeforeUpdate,
  onDeactivated,
  onErrorCaptured,
  onMounted,
  onRenderTracked,
  onRenderTriggered,
  onScopeDispose,
  onServerPrefetch,
  onUnmounted,
  onUpdated,
  openBlock,
  popScopeId,
  provide,
  proxyRefs,
  pushScopeId,
  queuePostFlushCb,
  reactive,
  readonly,
  ref,
  registerRuntimeCompiler,
  render: render$3,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDirective,
  resolveDynamicComponent,
  resolveFilter,
  resolveTransitionHooks,
  setBlockTracking,
  setDevtoolsHook,
  setTransitionHooks,
  shallowReactive,
  shallowReadonly,
  shallowRef,
  ssrContextKey,
  ssrUtils,
  stop,
  toDisplayString,
  toHandlerKey,
  toHandlers,
  toRaw,
  toRef,
  toRefs,
  toValue,
  transformVNodeArgs,
  triggerRef,
  unref,
  useAttrs,
  useCssModule,
  useCssVars,
  useModel,
  useSSRContext,
  useSlots,
  useTransitionState,
  vModelCheckbox,
  vModelDynamic,
  vModelRadio,
  vModelSelect,
  vModelText,
  vShow,
  version: version$2,
  warn,
  watch,
  watchEffect,
  watchPostEffect,
  watchSyncEffect,
  withAsyncContext,
  withCtx,
  withDefaults,
  withDirectives,
  withKeys,
  withMemo,
  withModifiers,
  withScopeId
}, Symbol.toStringTag, { value: "Module" }));
/*!
  * vue-router v4.2.5
  * (c) 2023 Eduardo San Martin Morote
  * @license MIT
  */
const isBrowser = typeof window !== "undefined";
function isESModule(obj) {
  return obj.__esModule || obj[Symbol.toStringTag] === "Module";
}
const assign$2 = Object.assign;
function applyToParams(fn, params) {
  const newParams = {};
  for (const key2 in params) {
    const value = params[key2];
    newParams[key2] = isArray$5(value) ? value.map(fn) : fn(value);
  }
  return newParams;
}
const noop$1 = () => {
};
const isArray$5 = Array.isArray;
const TRAILING_SLASH_RE = /\/$/;
const removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, "");
function parseURL(parseQuery2, location2, currentLocation = "/") {
  let path, query = {}, searchString = "", hash = "";
  const hashPos = location2.indexOf("#");
  let searchPos = location2.indexOf("?");
  if (hashPos < searchPos && hashPos >= 0) {
    searchPos = -1;
  }
  if (searchPos > -1) {
    path = location2.slice(0, searchPos);
    searchString = location2.slice(searchPos + 1, hashPos > -1 ? hashPos : location2.length);
    query = parseQuery2(searchString);
  }
  if (hashPos > -1) {
    path = path || location2.slice(0, hashPos);
    hash = location2.slice(hashPos, location2.length);
  }
  path = resolveRelativePath(path != null ? path : location2, currentLocation);
  return {
    fullPath: path + (searchString && "?") + searchString + hash,
    path,
    query,
    hash
  };
}
function stringifyURL(stringifyQuery2, location2) {
  const query = location2.query ? stringifyQuery2(location2.query) : "";
  return location2.path + (query && "?") + query + (location2.hash || "");
}
function stripBase(pathname, base) {
  if (!base || !pathname.toLowerCase().startsWith(base.toLowerCase()))
    return pathname;
  return pathname.slice(base.length) || "/";
}
function isSameRouteLocation(stringifyQuery2, a, b2) {
  const aLastIndex = a.matched.length - 1;
  const bLastIndex = b2.matched.length - 1;
  return aLastIndex > -1 && aLastIndex === bLastIndex && isSameRouteRecord(a.matched[aLastIndex], b2.matched[bLastIndex]) && isSameRouteLocationParams(a.params, b2.params) && stringifyQuery2(a.query) === stringifyQuery2(b2.query) && a.hash === b2.hash;
}
function isSameRouteRecord(a, b2) {
  return (a.aliasOf || a) === (b2.aliasOf || b2);
}
function isSameRouteLocationParams(a, b2) {
  if (Object.keys(a).length !== Object.keys(b2).length)
    return false;
  for (const key2 in a) {
    if (!isSameRouteLocationParamsValue(a[key2], b2[key2]))
      return false;
  }
  return true;
}
function isSameRouteLocationParamsValue(a, b2) {
  return isArray$5(a) ? isEquivalentArray(a, b2) : isArray$5(b2) ? isEquivalentArray(b2, a) : a === b2;
}
function isEquivalentArray(a, b2) {
  return isArray$5(b2) ? a.length === b2.length && a.every((value, i) => value === b2[i]) : a.length === 1 && a[0] === b2;
}
function resolveRelativePath(to, from) {
  if (to.startsWith("/"))
    return to;
  if (!to)
    return from;
  const fromSegments = from.split("/");
  const toSegments = to.split("/");
  const lastToSegment = toSegments[toSegments.length - 1];
  if (lastToSegment === ".." || lastToSegment === ".") {
    toSegments.push("");
  }
  let position = fromSegments.length - 1;
  let toPosition;
  let segment;
  for (toPosition = 0; toPosition < toSegments.length; toPosition++) {
    segment = toSegments[toPosition];
    if (segment === ".")
      continue;
    if (segment === "..") {
      if (position > 1)
        position--;
    } else
      break;
  }
  return fromSegments.slice(0, position).join("/") + "/" + toSegments.slice(toPosition - (toPosition === toSegments.length ? 1 : 0)).join("/");
}
var NavigationType;
(function(NavigationType2) {
  NavigationType2["pop"] = "pop";
  NavigationType2["push"] = "push";
})(NavigationType || (NavigationType = {}));
var NavigationDirection;
(function(NavigationDirection2) {
  NavigationDirection2["back"] = "back";
  NavigationDirection2["forward"] = "forward";
  NavigationDirection2["unknown"] = "";
})(NavigationDirection || (NavigationDirection = {}));
function normalizeBase(base) {
  if (!base) {
    if (isBrowser) {
      const baseEl = document.querySelector("base");
      base = baseEl && baseEl.getAttribute("href") || "/";
      base = base.replace(/^\w+:\/\/[^\/]+/, "");
    } else {
      base = "/";
    }
  }
  if (base[0] !== "/" && base[0] !== "#")
    base = "/" + base;
  return removeTrailingSlash(base);
}
const BEFORE_HASH_RE = /^[^#]+#/;
function createHref(base, location2) {
  return base.replace(BEFORE_HASH_RE, "#") + location2;
}
function getElementPosition(el, offset) {
  const docRect = document.documentElement.getBoundingClientRect();
  const elRect = el.getBoundingClientRect();
  return {
    behavior: offset.behavior,
    left: elRect.left - docRect.left - (offset.left || 0),
    top: elRect.top - docRect.top - (offset.top || 0)
  };
}
const computeScrollPosition = () => ({
  left: window.pageXOffset,
  top: window.pageYOffset
});
function scrollToPosition(position) {
  let scrollToOptions;
  if ("el" in position) {
    const positionEl = position.el;
    const isIdSelector = typeof positionEl === "string" && positionEl.startsWith("#");
    const el = typeof positionEl === "string" ? isIdSelector ? document.getElementById(positionEl.slice(1)) : document.querySelector(positionEl) : positionEl;
    if (!el) {
      return;
    }
    scrollToOptions = getElementPosition(el, position);
  } else {
    scrollToOptions = position;
  }
  if ("scrollBehavior" in document.documentElement.style)
    window.scrollTo(scrollToOptions);
  else {
    window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.pageXOffset, scrollToOptions.top != null ? scrollToOptions.top : window.pageYOffset);
  }
}
function getScrollKey(path, delta2) {
  const position = history.state ? history.state.position - delta2 : -1;
  return position + path;
}
const scrollPositions = /* @__PURE__ */ new Map();
function saveScrollPosition(key2, scrollPosition) {
  scrollPositions.set(key2, scrollPosition);
}
function getSavedScrollPosition(key2) {
  const scroll3 = scrollPositions.get(key2);
  scrollPositions.delete(key2);
  return scroll3;
}
let createBaseLocation = () => location.protocol + "//" + location.host;
function createCurrentLocation(base, location2) {
  const { pathname, search, hash } = location2;
  const hashPos = base.indexOf("#");
  if (hashPos > -1) {
    let slicePos = hash.includes(base.slice(hashPos)) ? base.slice(hashPos).length : 1;
    let pathFromHash = hash.slice(slicePos);
    if (pathFromHash[0] !== "/")
      pathFromHash = "/" + pathFromHash;
    return stripBase(pathFromHash, "");
  }
  const path = stripBase(pathname, base);
  return path + search + hash;
}
function useHistoryListeners(base, historyState, currentLocation, replace2) {
  let listeners = [];
  let teardowns = [];
  let pauseState = null;
  const popStateHandler = ({ state }) => {
    const to = createCurrentLocation(base, location);
    const from = currentLocation.value;
    const fromState = historyState.value;
    let delta2 = 0;
    if (state) {
      currentLocation.value = to;
      historyState.value = state;
      if (pauseState && pauseState === from) {
        pauseState = null;
        return;
      }
      delta2 = fromState ? state.position - fromState.position : 0;
    } else {
      replace2(to);
    }
    listeners.forEach((listener) => {
      listener(currentLocation.value, from, {
        delta: delta2,
        type: NavigationType.pop,
        direction: delta2 ? delta2 > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown
      });
    });
  };
  function pauseListeners() {
    pauseState = currentLocation.value;
  }
  function listen(callback) {
    listeners.push(callback);
    const teardown = () => {
      const index2 = listeners.indexOf(callback);
      if (index2 > -1)
        listeners.splice(index2, 1);
    };
    teardowns.push(teardown);
    return teardown;
  }
  function beforeUnloadListener() {
    const { history: history2 } = window;
    if (!history2.state)
      return;
    history2.replaceState(assign$2({}, history2.state, { scroll: computeScrollPosition() }), "");
  }
  function destroy2() {
    for (const teardown of teardowns)
      teardown();
    teardowns = [];
    window.removeEventListener("popstate", popStateHandler);
    window.removeEventListener("beforeunload", beforeUnloadListener);
  }
  window.addEventListener("popstate", popStateHandler);
  window.addEventListener("beforeunload", beforeUnloadListener, {
    passive: true
  });
  return {
    pauseListeners,
    listen,
    destroy: destroy2
  };
}
function buildState(back, current, forward, replaced = false, computeScroll = false) {
  return {
    back,
    current,
    forward,
    replaced,
    position: window.history.length,
    scroll: computeScroll ? computeScrollPosition() : null
  };
}
function useHistoryStateNavigation(base) {
  const { history: history2, location: location2 } = window;
  const currentLocation = {
    value: createCurrentLocation(base, location2)
  };
  const historyState = { value: history2.state };
  if (!historyState.value) {
    changeLocation(currentLocation.value, {
      back: null,
      current: currentLocation.value,
      forward: null,
      // the length is off by one, we need to decrease it
      position: history2.length - 1,
      replaced: true,
      // don't add a scroll as the user may have an anchor, and we want
      // scrollBehavior to be triggered without a saved position
      scroll: null
    }, true);
  }
  function changeLocation(to, state, replace3) {
    const hashIndex = base.indexOf("#");
    const url = hashIndex > -1 ? (location2.host && document.querySelector("base") ? base : base.slice(hashIndex)) + to : createBaseLocation() + base + to;
    try {
      history2[replace3 ? "replaceState" : "pushState"](state, "", url);
      historyState.value = state;
    } catch (err) {
      {
        console.error(err);
      }
      location2[replace3 ? "replace" : "assign"](url);
    }
  }
  function replace2(to, data) {
    const state = assign$2({}, history2.state, buildState(
      historyState.value.back,
      // keep back and forward entries but override current position
      to,
      historyState.value.forward,
      true
    ), data, { position: historyState.value.position });
    changeLocation(to, state, true);
    currentLocation.value = to;
  }
  function push2(to, data) {
    const currentState = assign$2(
      {},
      // use current history state to gracefully handle a wrong call to
      // history.replaceState
      // https://github.com/vuejs/router/issues/366
      historyState.value,
      history2.state,
      {
        forward: to,
        scroll: computeScrollPosition()
      }
    );
    changeLocation(currentState.current, currentState, true);
    const state = assign$2({}, buildState(currentLocation.value, to, null), { position: currentState.position + 1 }, data);
    changeLocation(to, state, false);
    currentLocation.value = to;
  }
  return {
    location: currentLocation,
    state: historyState,
    push: push2,
    replace: replace2
  };
}
function createWebHistory(base) {
  base = normalizeBase(base);
  const historyNavigation = useHistoryStateNavigation(base);
  const historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);
  function go(delta2, triggerListeners = true) {
    if (!triggerListeners)
      historyListeners.pauseListeners();
    history.go(delta2);
  }
  const routerHistory = assign$2({
    // it's overridden right after
    location: "",
    base,
    go,
    createHref: createHref.bind(null, base)
  }, historyNavigation, historyListeners);
  Object.defineProperty(routerHistory, "location", {
    enumerable: true,
    get: () => historyNavigation.location.value
  });
  Object.defineProperty(routerHistory, "state", {
    enumerable: true,
    get: () => historyNavigation.state.value
  });
  return routerHistory;
}
function createWebHashHistory(base) {
  base = location.host ? base || location.pathname + location.search : "";
  if (!base.includes("#"))
    base += "#";
  return createWebHistory(base);
}
function isRouteLocation(route) {
  return typeof route === "string" || route && typeof route === "object";
}
function isRouteName(name) {
  return typeof name === "string" || typeof name === "symbol";
}
const START_LOCATION_NORMALIZED = {
  path: "/",
  name: void 0,
  params: {},
  query: {},
  hash: "",
  fullPath: "/",
  matched: [],
  meta: {},
  redirectedFrom: void 0
};
const NavigationFailureSymbol = Symbol("");
var NavigationFailureType;
(function(NavigationFailureType2) {
  NavigationFailureType2[NavigationFailureType2["aborted"] = 4] = "aborted";
  NavigationFailureType2[NavigationFailureType2["cancelled"] = 8] = "cancelled";
  NavigationFailureType2[NavigationFailureType2["duplicated"] = 16] = "duplicated";
})(NavigationFailureType || (NavigationFailureType = {}));
function createRouterError(type2, params) {
  {
    return assign$2(new Error(), {
      type: type2,
      [NavigationFailureSymbol]: true
    }, params);
  }
}
function isNavigationFailure(error, type2) {
  return error instanceof Error && NavigationFailureSymbol in error && (type2 == null || !!(error.type & type2));
}
const BASE_PARAM_PATTERN = "[^/]+?";
const BASE_PATH_PARSER_OPTIONS = {
  sensitive: false,
  strict: false,
  start: true,
  end: true
};
const REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
function tokensToParser(segments, extraOptions) {
  const options = assign$2({}, BASE_PATH_PARSER_OPTIONS, extraOptions);
  const score = [];
  let pattern = options.start ? "^" : "";
  const keys2 = [];
  for (const segment of segments) {
    const segmentScores = segment.length ? [] : [
      90
      /* PathScore.Root */
    ];
    if (options.strict && !segment.length)
      pattern += "/";
    for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {
      const token2 = segment[tokenIndex];
      let subSegmentScore = 40 + (options.sensitive ? 0.25 : 0);
      if (token2.type === 0) {
        if (!tokenIndex)
          pattern += "/";
        pattern += token2.value.replace(REGEX_CHARS_RE, "\\$&");
        subSegmentScore += 40;
      } else if (token2.type === 1) {
        const { value, repeatable, optional, regexp } = token2;
        keys2.push({
          name: value,
          repeatable,
          optional
        });
        const re3 = regexp ? regexp : BASE_PARAM_PATTERN;
        if (re3 !== BASE_PARAM_PATTERN) {
          subSegmentScore += 10;
          try {
            new RegExp(`(${re3})`);
          } catch (err) {
            throw new Error(`Invalid custom RegExp for param "${value}" (${re3}): ` + err.message);
          }
        }
        let subPattern = repeatable ? `((?:${re3})(?:/(?:${re3}))*)` : `(${re3})`;
        if (!tokenIndex)
          subPattern = // avoid an optional / if there are more segments e.g. /:p?-static
          // or /:p?-:p2
          optional && segment.length < 2 ? `(?:/${subPattern})` : "/" + subPattern;
        if (optional)
          subPattern += "?";
        pattern += subPattern;
        subSegmentScore += 20;
        if (optional)
          subSegmentScore += -8;
        if (repeatable)
          subSegmentScore += -20;
        if (re3 === ".*")
          subSegmentScore += -50;
      }
      segmentScores.push(subSegmentScore);
    }
    score.push(segmentScores);
  }
  if (options.strict && options.end) {
    const i = score.length - 1;
    score[i][score[i].length - 1] += 0.7000000000000001;
  }
  if (!options.strict)
    pattern += "/?";
  if (options.end)
    pattern += "$";
  else if (options.strict)
    pattern += "(?:/|$)";
  const re2 = new RegExp(pattern, options.sensitive ? "" : "i");
  function parse3(path) {
    const match2 = path.match(re2);
    const params = {};
    if (!match2)
      return null;
    for (let i = 1; i < match2.length; i++) {
      const value = match2[i] || "";
      const key2 = keys2[i - 1];
      params[key2.name] = value && key2.repeatable ? value.split("/") : value;
    }
    return params;
  }
  function stringify4(params) {
    let path = "";
    let avoidDuplicatedSlash = false;
    for (const segment of segments) {
      if (!avoidDuplicatedSlash || !path.endsWith("/"))
        path += "/";
      avoidDuplicatedSlash = false;
      for (const token2 of segment) {
        if (token2.type === 0) {
          path += token2.value;
        } else if (token2.type === 1) {
          const { value, repeatable, optional } = token2;
          const param = value in params ? params[value] : "";
          if (isArray$5(param) && !repeatable) {
            throw new Error(`Provided param "${value}" is an array but it is not repeatable (* or + modifiers)`);
          }
          const text = isArray$5(param) ? param.join("/") : param;
          if (!text) {
            if (optional) {
              if (segment.length < 2) {
                if (path.endsWith("/"))
                  path = path.slice(0, -1);
                else
                  avoidDuplicatedSlash = true;
              }
            } else
              throw new Error(`Missing required param "${value}"`);
          }
          path += text;
        }
      }
    }
    return path || "/";
  }
  return {
    re: re2,
    score,
    keys: keys2,
    parse: parse3,
    stringify: stringify4
  };
}
function compareScoreArray(a, b2) {
  let i = 0;
  while (i < a.length && i < b2.length) {
    const diff = b2[i] - a[i];
    if (diff)
      return diff;
    i++;
  }
  if (a.length < b2.length) {
    return a.length === 1 && a[0] === 40 + 40 ? -1 : 1;
  } else if (a.length > b2.length) {
    return b2.length === 1 && b2[0] === 40 + 40 ? 1 : -1;
  }
  return 0;
}
function comparePathParserScore(a, b2) {
  let i = 0;
  const aScore = a.score;
  const bScore = b2.score;
  while (i < aScore.length && i < bScore.length) {
    const comp = compareScoreArray(aScore[i], bScore[i]);
    if (comp)
      return comp;
    i++;
  }
  if (Math.abs(bScore.length - aScore.length) === 1) {
    if (isLastScoreNegative(aScore))
      return 1;
    if (isLastScoreNegative(bScore))
      return -1;
  }
  return bScore.length - aScore.length;
}
function isLastScoreNegative(score) {
  const last = score[score.length - 1];
  return score.length > 0 && last[last.length - 1] < 0;
}
const ROOT_TOKEN = {
  type: 0,
  value: ""
};
const VALID_PARAM_RE = /[a-zA-Z0-9_]/;
function tokenizePath(path) {
  if (!path)
    return [[]];
  if (path === "/")
    return [[ROOT_TOKEN]];
  if (!path.startsWith("/")) {
    throw new Error(`Invalid path "${path}"`);
  }
  function crash(message) {
    throw new Error(`ERR (${state})/"${buffer2}": ${message}`);
  }
  let state = 0;
  let previousState = state;
  const tokens = [];
  let segment;
  function finalizeSegment() {
    if (segment)
      tokens.push(segment);
    segment = [];
  }
  let i = 0;
  let char;
  let buffer2 = "";
  let customRe = "";
  function consumeBuffer() {
    if (!buffer2)
      return;
    if (state === 0) {
      segment.push({
        type: 0,
        value: buffer2
      });
    } else if (state === 1 || state === 2 || state === 3) {
      if (segment.length > 1 && (char === "*" || char === "+"))
        crash(`A repeatable param (${buffer2}) must be alone in its segment. eg: '/:ids+.`);
      segment.push({
        type: 1,
        value: buffer2,
        regexp: customRe,
        repeatable: char === "*" || char === "+",
        optional: char === "*" || char === "?"
      });
    } else {
      crash("Invalid state to consume buffer");
    }
    buffer2 = "";
  }
  function addCharToBuffer() {
    buffer2 += char;
  }
  while (i < path.length) {
    char = path[i++];
    if (char === "\\" && state !== 2) {
      previousState = state;
      state = 4;
      continue;
    }
    switch (state) {
      case 0:
        if (char === "/") {
          if (buffer2) {
            consumeBuffer();
          }
          finalizeSegment();
        } else if (char === ":") {
          consumeBuffer();
          state = 1;
        } else {
          addCharToBuffer();
        }
        break;
      case 4:
        addCharToBuffer();
        state = previousState;
        break;
      case 1:
        if (char === "(") {
          state = 2;
        } else if (VALID_PARAM_RE.test(char)) {
          addCharToBuffer();
        } else {
          consumeBuffer();
          state = 0;
          if (char !== "*" && char !== "?" && char !== "+")
            i--;
        }
        break;
      case 2:
        if (char === ")") {
          if (customRe[customRe.length - 1] == "\\")
            customRe = customRe.slice(0, -1) + char;
          else
            state = 3;
        } else {
          customRe += char;
        }
        break;
      case 3:
        consumeBuffer();
        state = 0;
        if (char !== "*" && char !== "?" && char !== "+")
          i--;
        customRe = "";
        break;
      default:
        crash("Unknown state");
        break;
    }
  }
  if (state === 2)
    crash(`Unfinished custom RegExp for param "${buffer2}"`);
  consumeBuffer();
  finalizeSegment();
  return tokens;
}
function createRouteRecordMatcher(record, parent, options) {
  const parser = tokensToParser(tokenizePath(record.path), options);
  const matcher = assign$2(parser, {
    record,
    parent,
    // these needs to be populated by the parent
    children: [],
    alias: []
  });
  if (parent) {
    if (!matcher.record.aliasOf === !parent.record.aliasOf)
      parent.children.push(matcher);
  }
  return matcher;
}
function createRouterMatcher(routes, globalOptions) {
  const matchers = [];
  const matcherMap = /* @__PURE__ */ new Map();
  globalOptions = mergeOptions({ strict: false, end: true, sensitive: false }, globalOptions);
  function getRecordMatcher(name) {
    return matcherMap.get(name);
  }
  function addRoute(record, parent, originalRecord) {
    const isRootAdd = !originalRecord;
    const mainNormalizedRecord = normalizeRouteRecord(record);
    mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;
    const options = mergeOptions(globalOptions, record);
    const normalizedRecords = [
      mainNormalizedRecord
    ];
    if ("alias" in record) {
      const aliases2 = typeof record.alias === "string" ? [record.alias] : record.alias;
      for (const alias of aliases2) {
        normalizedRecords.push(assign$2({}, mainNormalizedRecord, {
          // this allows us to hold a copy of the `components` option
          // so that async components cache is hold on the original record
          components: originalRecord ? originalRecord.record.components : mainNormalizedRecord.components,
          path: alias,
          // we might be the child of an alias
          aliasOf: originalRecord ? originalRecord.record : mainNormalizedRecord
          // the aliases are always of the same kind as the original since they
          // are defined on the same record
        }));
      }
    }
    let matcher;
    let originalMatcher;
    for (const normalizedRecord of normalizedRecords) {
      const { path } = normalizedRecord;
      if (parent && path[0] !== "/") {
        const parentPath = parent.record.path;
        const connectingSlash = parentPath[parentPath.length - 1] === "/" ? "" : "/";
        normalizedRecord.path = parent.record.path + (path && connectingSlash + path);
      }
      matcher = createRouteRecordMatcher(normalizedRecord, parent, options);
      if (originalRecord) {
        originalRecord.alias.push(matcher);
      } else {
        originalMatcher = originalMatcher || matcher;
        if (originalMatcher !== matcher)
          originalMatcher.alias.push(matcher);
        if (isRootAdd && record.name && !isAliasRecord(matcher))
          removeRoute(record.name);
      }
      if (mainNormalizedRecord.children) {
        const children = mainNormalizedRecord.children;
        for (let i = 0; i < children.length; i++) {
          addRoute(children[i], matcher, originalRecord && originalRecord.children[i]);
        }
      }
      originalRecord = originalRecord || matcher;
      if (matcher.record.components && Object.keys(matcher.record.components).length || matcher.record.name || matcher.record.redirect) {
        insertMatcher(matcher);
      }
    }
    return originalMatcher ? () => {
      removeRoute(originalMatcher);
    } : noop$1;
  }
  function removeRoute(matcherRef) {
    if (isRouteName(matcherRef)) {
      const matcher = matcherMap.get(matcherRef);
      if (matcher) {
        matcherMap.delete(matcherRef);
        matchers.splice(matchers.indexOf(matcher), 1);
        matcher.children.forEach(removeRoute);
        matcher.alias.forEach(removeRoute);
      }
    } else {
      const index2 = matchers.indexOf(matcherRef);
      if (index2 > -1) {
        matchers.splice(index2, 1);
        if (matcherRef.record.name)
          matcherMap.delete(matcherRef.record.name);
        matcherRef.children.forEach(removeRoute);
        matcherRef.alias.forEach(removeRoute);
      }
    }
  }
  function getRoutes() {
    return matchers;
  }
  function insertMatcher(matcher) {
    let i = 0;
    while (i < matchers.length && comparePathParserScore(matcher, matchers[i]) >= 0 && // Adding children with empty path should still appear before the parent
    // https://github.com/vuejs/router/issues/1124
    (matcher.record.path !== matchers[i].record.path || !isRecordChildOf(matcher, matchers[i])))
      i++;
    matchers.splice(i, 0, matcher);
    if (matcher.record.name && !isAliasRecord(matcher))
      matcherMap.set(matcher.record.name, matcher);
  }
  function resolve2(location2, currentLocation) {
    let matcher;
    let params = {};
    let path;
    let name;
    if ("name" in location2 && location2.name) {
      matcher = matcherMap.get(location2.name);
      if (!matcher)
        throw createRouterError(1, {
          location: location2
        });
      name = matcher.record.name;
      params = assign$2(
        // paramsFromLocation is a new object
        paramsFromLocation(
          currentLocation.params,
          // only keep params that exist in the resolved location
          // TODO: only keep optional params coming from a parent record
          matcher.keys.filter((k2) => !k2.optional).map((k2) => k2.name)
        ),
        // discard any existing params in the current location that do not exist here
        // #1497 this ensures better active/exact matching
        location2.params && paramsFromLocation(location2.params, matcher.keys.map((k2) => k2.name))
      );
      path = matcher.stringify(params);
    } else if ("path" in location2) {
      path = location2.path;
      matcher = matchers.find((m) => m.re.test(path));
      if (matcher) {
        params = matcher.parse(path);
        name = matcher.record.name;
      }
    } else {
      matcher = currentLocation.name ? matcherMap.get(currentLocation.name) : matchers.find((m) => m.re.test(currentLocation.path));
      if (!matcher)
        throw createRouterError(1, {
          location: location2,
          currentLocation
        });
      name = matcher.record.name;
      params = assign$2({}, currentLocation.params, location2.params);
      path = matcher.stringify(params);
    }
    const matched = [];
    let parentMatcher = matcher;
    while (parentMatcher) {
      matched.unshift(parentMatcher.record);
      parentMatcher = parentMatcher.parent;
    }
    return {
      name,
      path,
      params,
      matched,
      meta: mergeMetaFields(matched)
    };
  }
  routes.forEach((route) => addRoute(route));
  return { addRoute, resolve: resolve2, removeRoute, getRoutes, getRecordMatcher };
}
function paramsFromLocation(params, keys2) {
  const newParams = {};
  for (const key2 of keys2) {
    if (key2 in params)
      newParams[key2] = params[key2];
  }
  return newParams;
}
function normalizeRouteRecord(record) {
  return {
    path: record.path,
    redirect: record.redirect,
    name: record.name,
    meta: record.meta || {},
    aliasOf: void 0,
    beforeEnter: record.beforeEnter,
    props: normalizeRecordProps(record),
    children: record.children || [],
    instances: {},
    leaveGuards: /* @__PURE__ */ new Set(),
    updateGuards: /* @__PURE__ */ new Set(),
    enterCallbacks: {},
    components: "components" in record ? record.components || null : record.component && { default: record.component }
  };
}
function normalizeRecordProps(record) {
  const propsObject = {};
  const props2 = record.props || false;
  if ("component" in record) {
    propsObject.default = props2;
  } else {
    for (const name in record.components)
      propsObject[name] = typeof props2 === "object" ? props2[name] : props2;
  }
  return propsObject;
}
function isAliasRecord(record) {
  while (record) {
    if (record.record.aliasOf)
      return true;
    record = record.parent;
  }
  return false;
}
function mergeMetaFields(matched) {
  return matched.reduce((meta, record) => assign$2(meta, record.meta), {});
}
function mergeOptions(defaults2, partialOptions) {
  const options = {};
  for (const key2 in defaults2) {
    options[key2] = key2 in partialOptions ? partialOptions[key2] : defaults2[key2];
  }
  return options;
}
function isRecordChildOf(record, parent) {
  return parent.children.some((child) => child === record || isRecordChildOf(record, child));
}
const HASH_RE = /#/g;
const AMPERSAND_RE = /&/g;
const SLASH_RE = /\//g;
const EQUAL_RE = /=/g;
const IM_RE = /\?/g;
const PLUS_RE = /\+/g;
const ENC_BRACKET_OPEN_RE = /%5B/g;
const ENC_BRACKET_CLOSE_RE = /%5D/g;
const ENC_CARET_RE = /%5E/g;
const ENC_BACKTICK_RE = /%60/g;
const ENC_CURLY_OPEN_RE = /%7B/g;
const ENC_PIPE_RE = /%7C/g;
const ENC_CURLY_CLOSE_RE = /%7D/g;
const ENC_SPACE_RE = /%20/g;
function commonEncode(text) {
  return encodeURI("" + text).replace(ENC_PIPE_RE, "|").replace(ENC_BRACKET_OPEN_RE, "[").replace(ENC_BRACKET_CLOSE_RE, "]");
}
function encodeHash(text) {
  return commonEncode(text).replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
function encodeQueryValue(text) {
  return commonEncode(text).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
function encodeQueryKey(text) {
  return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
}
function encodePath(text) {
  return commonEncode(text).replace(HASH_RE, "%23").replace(IM_RE, "%3F");
}
function encodeParam(text) {
  return text == null ? "" : encodePath(text).replace(SLASH_RE, "%2F");
}
function decode$1(text) {
  try {
    return decodeURIComponent("" + text);
  } catch (err) {
  }
  return "" + text;
}
function parseQuery(search) {
  const query = {};
  if (search === "" || search === "?")
    return query;
  const hasLeadingIM = search[0] === "?";
  const searchParams = (hasLeadingIM ? search.slice(1) : search).split("&");
  for (let i = 0; i < searchParams.length; ++i) {
    const searchParam = searchParams[i].replace(PLUS_RE, " ");
    const eqPos = searchParam.indexOf("=");
    const key2 = decode$1(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));
    const value = eqPos < 0 ? null : decode$1(searchParam.slice(eqPos + 1));
    if (key2 in query) {
      let currentValue = query[key2];
      if (!isArray$5(currentValue)) {
        currentValue = query[key2] = [currentValue];
      }
      currentValue.push(value);
    } else {
      query[key2] = value;
    }
  }
  return query;
}
function stringifyQuery(query) {
  let search = "";
  for (let key2 in query) {
    const value = query[key2];
    key2 = encodeQueryKey(key2);
    if (value == null) {
      if (value !== void 0) {
        search += (search.length ? "&" : "") + key2;
      }
      continue;
    }
    const values = isArray$5(value) ? value.map((v2) => v2 && encodeQueryValue(v2)) : [value && encodeQueryValue(value)];
    values.forEach((value2) => {
      if (value2 !== void 0) {
        search += (search.length ? "&" : "") + key2;
        if (value2 != null)
          search += "=" + value2;
      }
    });
  }
  return search;
}
function normalizeQuery(query) {
  const normalizedQuery = {};
  for (const key2 in query) {
    const value = query[key2];
    if (value !== void 0) {
      normalizedQuery[key2] = isArray$5(value) ? value.map((v2) => v2 == null ? null : "" + v2) : value == null ? value : "" + value;
    }
  }
  return normalizedQuery;
}
const matchedRouteKey = Symbol("");
const viewDepthKey = Symbol("");
const routerKey = Symbol("");
const routeLocationKey = Symbol("");
const routerViewLocationKey = Symbol("");
function useCallbacks() {
  let handlers2 = [];
  function add2(handler) {
    handlers2.push(handler);
    return () => {
      const i = handlers2.indexOf(handler);
      if (i > -1)
        handlers2.splice(i, 1);
    };
  }
  function reset() {
    handlers2 = [];
  }
  return {
    add: add2,
    list: () => handlers2.slice(),
    reset
  };
}
function guardToPromiseFn(guard, to, from, record, name) {
  const enterCallbackArray = record && // name is defined if record is because of the function overload
  (record.enterCallbacks[name] = record.enterCallbacks[name] || []);
  return () => new Promise((resolve2, reject) => {
    const next = (valid) => {
      if (valid === false) {
        reject(createRouterError(4, {
          from,
          to
        }));
      } else if (valid instanceof Error) {
        reject(valid);
      } else if (isRouteLocation(valid)) {
        reject(createRouterError(2, {
          from: to,
          to: valid
        }));
      } else {
        if (enterCallbackArray && // since enterCallbackArray is truthy, both record and name also are
        record.enterCallbacks[name] === enterCallbackArray && typeof valid === "function") {
          enterCallbackArray.push(valid);
        }
        resolve2();
      }
    };
    const guardReturn = guard.call(record && record.instances[name], to, from, next);
    let guardCall = Promise.resolve(guardReturn);
    if (guard.length < 3)
      guardCall = guardCall.then(next);
    guardCall.catch((err) => reject(err));
  });
}
function extractComponentsGuards(matched, guardType, to, from) {
  const guards = [];
  for (const record of matched) {
    for (const name in record.components) {
      let rawComponent = record.components[name];
      if (guardType !== "beforeRouteEnter" && !record.instances[name])
        continue;
      if (isRouteComponent(rawComponent)) {
        const options = rawComponent.__vccOpts || rawComponent;
        const guard = options[guardType];
        guard && guards.push(guardToPromiseFn(guard, to, from, record, name));
      } else {
        let componentPromise = rawComponent();
        guards.push(() => componentPromise.then((resolved) => {
          if (!resolved)
            return Promise.reject(new Error(`Couldn't resolve component "${name}" at "${record.path}"`));
          const resolvedComponent = isESModule(resolved) ? resolved.default : resolved;
          record.components[name] = resolvedComponent;
          const options = resolvedComponent.__vccOpts || resolvedComponent;
          const guard = options[guardType];
          return guard && guardToPromiseFn(guard, to, from, record, name)();
        }));
      }
    }
  }
  return guards;
}
function isRouteComponent(component) {
  return typeof component === "object" || "displayName" in component || "props" in component || "__vccOpts" in component;
}
function useLink$1(props2) {
  const router = inject$1(routerKey);
  const currentRoute = inject$1(routeLocationKey);
  const route = computed(() => router.resolve(unref(props2.to)));
  const activeRecordIndex = computed(() => {
    const { matched } = route.value;
    const { length } = matched;
    const routeMatched = matched[length - 1];
    const currentMatched = currentRoute.matched;
    if (!routeMatched || !currentMatched.length)
      return -1;
    const index2 = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));
    if (index2 > -1)
      return index2;
    const parentRecordPath = getOriginalPath(matched[length - 2]);
    return (
      // we are dealing with nested routes
      length > 1 && // if the parent and matched route have the same path, this link is
      // referring to the empty child. Or we currently are on a different
      // child of the same parent
      getOriginalPath(routeMatched) === parentRecordPath && // avoid comparing the child with its parent
      currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2])) : index2
    );
  });
  const isActive = computed(() => activeRecordIndex.value > -1 && includesParams(currentRoute.params, route.value.params));
  const isExactActive = computed(() => activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route.value.params));
  function navigate(e = {}) {
    if (guardEvent(e)) {
      return router[unref(props2.replace) ? "replace" : "push"](
        unref(props2.to)
        // avoid uncaught errors are they are logged anyway
      ).catch(noop$1);
    }
    return Promise.resolve();
  }
  return {
    route,
    href: computed(() => route.value.href),
    isActive,
    isExactActive,
    navigate
  };
}
const RouterLinkImpl = /* @__PURE__ */ defineComponent$1({
  name: "RouterLink",
  compatConfig: { MODE: 3 },
  props: {
    to: {
      type: [String, Object],
      required: true
    },
    replace: Boolean,
    activeClass: String,
    // inactiveClass: String,
    exactActiveClass: String,
    custom: Boolean,
    ariaCurrentValue: {
      type: String,
      default: "page"
    }
  },
  useLink: useLink$1,
  setup(props2, { slots }) {
    const link = reactive(useLink$1(props2));
    const { options } = inject$1(routerKey);
    const elClass = computed(() => ({
      [getLinkClass(props2.activeClass, options.linkActiveClass, "router-link-active")]: link.isActive,
      // [getLinkClass(
      //   props.inactiveClass,
      //   options.linkInactiveClass,
      //   'router-link-inactive'
      // )]: !link.isExactActive,
      [getLinkClass(props2.exactActiveClass, options.linkExactActiveClass, "router-link-exact-active")]: link.isExactActive
    }));
    return () => {
      const children = slots.default && slots.default(link);
      return props2.custom ? children : h("a", {
        "aria-current": link.isExactActive ? props2.ariaCurrentValue : null,
        href: link.href,
        // this would override user added attrs but Vue will still add
        // the listener, so we end up triggering both
        onClick: link.navigate,
        class: elClass.value
      }, children);
    };
  }
});
const RouterLink = RouterLinkImpl;
function guardEvent(e) {
  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)
    return;
  if (e.defaultPrevented)
    return;
  if (e.button !== void 0 && e.button !== 0)
    return;
  if (e.currentTarget && e.currentTarget.getAttribute) {
    const target = e.currentTarget.getAttribute("target");
    if (/\b_blank\b/i.test(target))
      return;
  }
  if (e.preventDefault)
    e.preventDefault();
  return true;
}
function includesParams(outer, inner) {
  for (const key2 in inner) {
    const innerValue = inner[key2];
    const outerValue = outer[key2];
    if (typeof innerValue === "string") {
      if (innerValue !== outerValue)
        return false;
    } else {
      if (!isArray$5(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value, i) => value !== outerValue[i]))
        return false;
    }
  }
  return true;
}
function getOriginalPath(record) {
  return record ? record.aliasOf ? record.aliasOf.path : record.path : "";
}
const getLinkClass = (propClass, globalClass, defaultClass) => propClass != null ? propClass : globalClass != null ? globalClass : defaultClass;
const RouterViewImpl = /* @__PURE__ */ defineComponent$1({
  name: "RouterView",
  // #674 we manually inherit them
  inheritAttrs: false,
  props: {
    name: {
      type: String,
      default: "default"
    },
    route: Object
  },
  // Better compat for @vue/compat users
  // https://github.com/vuejs/router/issues/1315
  compatConfig: { MODE: 3 },
  setup(props2, { attrs, slots }) {
    const injectedRoute = inject$1(routerViewLocationKey);
    const routeToDisplay = computed(() => props2.route || injectedRoute.value);
    const injectedDepth = inject$1(viewDepthKey, 0);
    const depth = computed(() => {
      let initialDepth = unref(injectedDepth);
      const { matched } = routeToDisplay.value;
      let matchedRoute;
      while ((matchedRoute = matched[initialDepth]) && !matchedRoute.components) {
        initialDepth++;
      }
      return initialDepth;
    });
    const matchedRouteRef = computed(() => routeToDisplay.value.matched[depth.value]);
    provide(viewDepthKey, computed(() => depth.value + 1));
    provide(matchedRouteKey, matchedRouteRef);
    provide(routerViewLocationKey, routeToDisplay);
    const viewRef = ref();
    watch(() => [viewRef.value, matchedRouteRef.value, props2.name], ([instance, to, name], [oldInstance, from, oldName]) => {
      if (to) {
        to.instances[name] = instance;
        if (from && from !== to && instance && instance === oldInstance) {
          if (!to.leaveGuards.size) {
            to.leaveGuards = from.leaveGuards;
          }
          if (!to.updateGuards.size) {
            to.updateGuards = from.updateGuards;
          }
        }
      }
      if (instance && to && // if there is no instance but to and from are the same this might be
      // the first visit
      (!from || !isSameRouteRecord(to, from) || !oldInstance)) {
        (to.enterCallbacks[name] || []).forEach((callback) => callback(instance));
      }
    }, { flush: "post" });
    return () => {
      const route = routeToDisplay.value;
      const currentName = props2.name;
      const matchedRoute = matchedRouteRef.value;
      const ViewComponent = matchedRoute && matchedRoute.components[currentName];
      if (!ViewComponent) {
        return normalizeSlot(slots.default, { Component: ViewComponent, route });
      }
      const routePropsOption = matchedRoute.props[currentName];
      const routeProps = routePropsOption ? routePropsOption === true ? route.params : typeof routePropsOption === "function" ? routePropsOption(route) : routePropsOption : null;
      const onVnodeUnmounted = (vnode) => {
        if (vnode.component.isUnmounted) {
          matchedRoute.instances[currentName] = null;
        }
      };
      const component = h(ViewComponent, assign$2({}, routeProps, attrs, {
        onVnodeUnmounted,
        ref: viewRef
      }));
      return (
        // pass the vnode to the slot as a prop.
        // h and <component :is="..."> both accept vnodes
        normalizeSlot(slots.default, { Component: component, route }) || component
      );
    };
  }
});
function normalizeSlot(slot, data) {
  if (!slot)
    return null;
  const slotContent = slot(data);
  return slotContent.length === 1 ? slotContent[0] : slotContent;
}
const RouterView = RouterViewImpl;
function createRouter(options) {
  const matcher = createRouterMatcher(options.routes, options);
  const parseQuery$1 = options.parseQuery || parseQuery;
  const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;
  const routerHistory = options.history;
  const beforeGuards = useCallbacks();
  const beforeResolveGuards = useCallbacks();
  const afterGuards = useCallbacks();
  const currentRoute = shallowRef(START_LOCATION_NORMALIZED);
  let pendingLocation = START_LOCATION_NORMALIZED;
  if (isBrowser && options.scrollBehavior && "scrollRestoration" in history) {
    history.scrollRestoration = "manual";
  }
  const normalizeParams = applyToParams.bind(null, (paramValue) => "" + paramValue);
  const encodeParams = applyToParams.bind(null, encodeParam);
  const decodeParams = (
    // @ts-expect-error: intentionally avoid the type check
    applyToParams.bind(null, decode$1)
  );
  function addRoute(parentOrRoute, route) {
    let parent;
    let record;
    if (isRouteName(parentOrRoute)) {
      parent = matcher.getRecordMatcher(parentOrRoute);
      record = route;
    } else {
      record = parentOrRoute;
    }
    return matcher.addRoute(record, parent);
  }
  function removeRoute(name) {
    const recordMatcher = matcher.getRecordMatcher(name);
    if (recordMatcher) {
      matcher.removeRoute(recordMatcher);
    }
  }
  function getRoutes() {
    return matcher.getRoutes().map((routeMatcher) => routeMatcher.record);
  }
  function hasRoute(name) {
    return !!matcher.getRecordMatcher(name);
  }
  function resolve2(rawLocation, currentLocation) {
    currentLocation = assign$2({}, currentLocation || currentRoute.value);
    if (typeof rawLocation === "string") {
      const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);
      const matchedRoute2 = matcher.resolve({ path: locationNormalized.path }, currentLocation);
      const href2 = routerHistory.createHref(locationNormalized.fullPath);
      return assign$2(locationNormalized, matchedRoute2, {
        params: decodeParams(matchedRoute2.params),
        hash: decode$1(locationNormalized.hash),
        redirectedFrom: void 0,
        href: href2
      });
    }
    let matcherLocation;
    if ("path" in rawLocation) {
      matcherLocation = assign$2({}, rawLocation, {
        path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path
      });
    } else {
      const targetParams = assign$2({}, rawLocation.params);
      for (const key2 in targetParams) {
        if (targetParams[key2] == null) {
          delete targetParams[key2];
        }
      }
      matcherLocation = assign$2({}, rawLocation, {
        params: encodeParams(targetParams)
      });
      currentLocation.params = encodeParams(currentLocation.params);
    }
    const matchedRoute = matcher.resolve(matcherLocation, currentLocation);
    const hash = rawLocation.hash || "";
    matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));
    const fullPath = stringifyURL(stringifyQuery$1, assign$2({}, rawLocation, {
      hash: encodeHash(hash),
      path: matchedRoute.path
    }));
    const href = routerHistory.createHref(fullPath);
    return assign$2({
      fullPath,
      // keep the hash encoded so fullPath is effectively path + encodedQuery +
      // hash
      hash,
      query: (
        // if the user is using a custom query lib like qs, we might have
        // nested objects, so we keep the query as is, meaning it can contain
        // numbers at `$route.query`, but at the point, the user will have to
        // use their own type anyway.
        // https://github.com/vuejs/router/issues/328#issuecomment-649481567
        stringifyQuery$1 === stringifyQuery ? normalizeQuery(rawLocation.query) : rawLocation.query || {}
      )
    }, matchedRoute, {
      redirectedFrom: void 0,
      href
    });
  }
  function locationAsObject(to) {
    return typeof to === "string" ? parseURL(parseQuery$1, to, currentRoute.value.path) : assign$2({}, to);
  }
  function checkCanceledNavigation(to, from) {
    if (pendingLocation !== to) {
      return createRouterError(8, {
        from,
        to
      });
    }
  }
  function push2(to) {
    return pushWithRedirect(to);
  }
  function replace2(to) {
    return push2(assign$2(locationAsObject(to), { replace: true }));
  }
  function handleRedirectRecord(to) {
    const lastMatched = to.matched[to.matched.length - 1];
    if (lastMatched && lastMatched.redirect) {
      const { redirect } = lastMatched;
      let newTargetLocation = typeof redirect === "function" ? redirect(to) : redirect;
      if (typeof newTargetLocation === "string") {
        newTargetLocation = newTargetLocation.includes("?") || newTargetLocation.includes("#") ? newTargetLocation = locationAsObject(newTargetLocation) : (
          // force empty params
          { path: newTargetLocation }
        );
        newTargetLocation.params = {};
      }
      return assign$2({
        query: to.query,
        hash: to.hash,
        // avoid transferring params if the redirect has a path
        params: "path" in newTargetLocation ? {} : to.params
      }, newTargetLocation);
    }
  }
  function pushWithRedirect(to, redirectedFrom) {
    const targetLocation = pendingLocation = resolve2(to);
    const from = currentRoute.value;
    const data = to.state;
    const force = to.force;
    const replace3 = to.replace === true;
    const shouldRedirect = handleRedirectRecord(targetLocation);
    if (shouldRedirect)
      return pushWithRedirect(
        assign$2(locationAsObject(shouldRedirect), {
          state: typeof shouldRedirect === "object" ? assign$2({}, data, shouldRedirect.state) : data,
          force,
          replace: replace3
        }),
        // keep original redirectedFrom if it exists
        redirectedFrom || targetLocation
      );
    const toLocation = targetLocation;
    toLocation.redirectedFrom = redirectedFrom;
    let failure;
    if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {
      failure = createRouterError(16, { to: toLocation, from });
      handleScroll(
        from,
        from,
        // this is a push, the only way for it to be triggered from a
        // history.listen is with a redirect, which makes it become a push
        true,
        // This cannot be the first navigation because the initial location
        // cannot be manually navigated to
        false
      );
    }
    return (failure ? Promise.resolve(failure) : navigate(toLocation, from)).catch((error) => isNavigationFailure(error) ? (
      // navigation redirects still mark the router as ready
      isNavigationFailure(
        error,
        2
        /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
      ) ? error : markAsReady(error)
    ) : (
      // reject any unknown error
      triggerError(error, toLocation, from)
    )).then((failure2) => {
      if (failure2) {
        if (isNavigationFailure(
          failure2,
          2
          /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
        )) {
          return pushWithRedirect(
            // keep options
            assign$2({
              // preserve an existing replacement but allow the redirect to override it
              replace: replace3
            }, locationAsObject(failure2.to), {
              state: typeof failure2.to === "object" ? assign$2({}, data, failure2.to.state) : data,
              force
            }),
            // preserve the original redirectedFrom if any
            redirectedFrom || toLocation
          );
        }
      } else {
        failure2 = finalizeNavigation(toLocation, from, true, replace3, data);
      }
      triggerAfterEach(toLocation, from, failure2);
      return failure2;
    });
  }
  function checkCanceledNavigationAndReject(to, from) {
    const error = checkCanceledNavigation(to, from);
    return error ? Promise.reject(error) : Promise.resolve();
  }
  function runWithContext(fn) {
    const app = installedApps.values().next().value;
    return app && typeof app.runWithContext === "function" ? app.runWithContext(fn) : fn();
  }
  function navigate(to, from) {
    let guards;
    const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from);
    guards = extractComponentsGuards(leavingRecords.reverse(), "beforeRouteLeave", to, from);
    for (const record of leavingRecords) {
      record.leaveGuards.forEach((guard) => {
        guards.push(guardToPromiseFn(guard, to, from));
      });
    }
    const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);
    guards.push(canceledNavigationCheck);
    return runGuardQueue(guards).then(() => {
      guards = [];
      for (const guard of beforeGuards.list()) {
        guards.push(guardToPromiseFn(guard, to, from));
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = extractComponentsGuards(updatingRecords, "beforeRouteUpdate", to, from);
      for (const record of updatingRecords) {
        record.updateGuards.forEach((guard) => {
          guards.push(guardToPromiseFn(guard, to, from));
        });
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = [];
      for (const record of enteringRecords) {
        if (record.beforeEnter) {
          if (isArray$5(record.beforeEnter)) {
            for (const beforeEnter of record.beforeEnter)
              guards.push(guardToPromiseFn(beforeEnter, to, from));
          } else {
            guards.push(guardToPromiseFn(record.beforeEnter, to, from));
          }
        }
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      to.matched.forEach((record) => record.enterCallbacks = {});
      guards = extractComponentsGuards(enteringRecords, "beforeRouteEnter", to, from);
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = [];
      for (const guard of beforeResolveGuards.list()) {
        guards.push(guardToPromiseFn(guard, to, from));
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).catch((err) => isNavigationFailure(
      err,
      8
      /* ErrorTypes.NAVIGATION_CANCELLED */
    ) ? err : Promise.reject(err));
  }
  function triggerAfterEach(to, from, failure) {
    afterGuards.list().forEach((guard) => runWithContext(() => guard(to, from, failure)));
  }
  function finalizeNavigation(toLocation, from, isPush, replace3, data) {
    const error = checkCanceledNavigation(toLocation, from);
    if (error)
      return error;
    const isFirstNavigation = from === START_LOCATION_NORMALIZED;
    const state = !isBrowser ? {} : history.state;
    if (isPush) {
      if (replace3 || isFirstNavigation)
        routerHistory.replace(toLocation.fullPath, assign$2({
          scroll: isFirstNavigation && state && state.scroll
        }, data));
      else
        routerHistory.push(toLocation.fullPath, data);
    }
    currentRoute.value = toLocation;
    handleScroll(toLocation, from, isPush, isFirstNavigation);
    markAsReady();
  }
  let removeHistoryListener;
  function setupListeners() {
    if (removeHistoryListener)
      return;
    removeHistoryListener = routerHistory.listen((to, _from, info) => {
      if (!router.listening)
        return;
      const toLocation = resolve2(to);
      const shouldRedirect = handleRedirectRecord(toLocation);
      if (shouldRedirect) {
        pushWithRedirect(assign$2(shouldRedirect, { replace: true }), toLocation).catch(noop$1);
        return;
      }
      pendingLocation = toLocation;
      const from = currentRoute.value;
      if (isBrowser) {
        saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());
      }
      navigate(toLocation, from).catch((error) => {
        if (isNavigationFailure(
          error,
          4 | 8
          /* ErrorTypes.NAVIGATION_CANCELLED */
        )) {
          return error;
        }
        if (isNavigationFailure(
          error,
          2
          /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
        )) {
          pushWithRedirect(
            error.to,
            toLocation
            // avoid an uncaught rejection, let push call triggerError
          ).then((failure) => {
            if (isNavigationFailure(
              failure,
              4 | 16
              /* ErrorTypes.NAVIGATION_DUPLICATED */
            ) && !info.delta && info.type === NavigationType.pop) {
              routerHistory.go(-1, false);
            }
          }).catch(noop$1);
          return Promise.reject();
        }
        if (info.delta) {
          routerHistory.go(-info.delta, false);
        }
        return triggerError(error, toLocation, from);
      }).then((failure) => {
        failure = failure || finalizeNavigation(
          // after navigation, all matched components are resolved
          toLocation,
          from,
          false
        );
        if (failure) {
          if (info.delta && // a new navigation has been triggered, so we do not want to revert, that will change the current history
          // entry while a different route is displayed
          !isNavigationFailure(
            failure,
            8
            /* ErrorTypes.NAVIGATION_CANCELLED */
          )) {
            routerHistory.go(-info.delta, false);
          } else if (info.type === NavigationType.pop && isNavigationFailure(
            failure,
            4 | 16
            /* ErrorTypes.NAVIGATION_DUPLICATED */
          )) {
            routerHistory.go(-1, false);
          }
        }
        triggerAfterEach(toLocation, from, failure);
      }).catch(noop$1);
    });
  }
  let readyHandlers = useCallbacks();
  let errorListeners = useCallbacks();
  let ready;
  function triggerError(error, to, from) {
    markAsReady(error);
    const list = errorListeners.list();
    if (list.length) {
      list.forEach((handler) => handler(error, to, from));
    } else {
      console.error(error);
    }
    return Promise.reject(error);
  }
  function isReady() {
    if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)
      return Promise.resolve();
    return new Promise((resolve3, reject) => {
      readyHandlers.add([resolve3, reject]);
    });
  }
  function markAsReady(err) {
    if (!ready) {
      ready = !err;
      setupListeners();
      readyHandlers.list().forEach(([resolve3, reject]) => err ? reject(err) : resolve3());
      readyHandlers.reset();
    }
    return err;
  }
  function handleScroll(to, from, isPush, isFirstNavigation) {
    const { scrollBehavior } = options;
    if (!isBrowser || !scrollBehavior)
      return Promise.resolve();
    const scrollPosition = !isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0)) || (isFirstNavigation || !isPush) && history.state && history.state.scroll || null;
    return nextTick().then(() => scrollBehavior(to, from, scrollPosition)).then((position) => position && scrollToPosition(position)).catch((err) => triggerError(err, to, from));
  }
  const go = (delta2) => routerHistory.go(delta2);
  let started;
  const installedApps = /* @__PURE__ */ new Set();
  const router = {
    currentRoute,
    listening: true,
    addRoute,
    removeRoute,
    hasRoute,
    getRoutes,
    resolve: resolve2,
    options,
    push: push2,
    replace: replace2,
    go,
    back: () => go(-1),
    forward: () => go(1),
    beforeEach: beforeGuards.add,
    beforeResolve: beforeResolveGuards.add,
    afterEach: afterGuards.add,
    onError: errorListeners.add,
    isReady,
    install(app) {
      const router2 = this;
      app.component("RouterLink", RouterLink);
      app.component("RouterView", RouterView);
      app.config.globalProperties.$router = router2;
      Object.defineProperty(app.config.globalProperties, "$route", {
        enumerable: true,
        get: () => unref(currentRoute)
      });
      if (isBrowser && // used for the initial navigation client side to avoid pushing
      // multiple times when the router is used in multiple apps
      !started && currentRoute.value === START_LOCATION_NORMALIZED) {
        started = true;
        push2(routerHistory.location).catch((err) => {
        });
      }
      const reactiveRoute = {};
      for (const key2 in START_LOCATION_NORMALIZED) {
        Object.defineProperty(reactiveRoute, key2, {
          get: () => currentRoute.value[key2],
          enumerable: true
        });
      }
      app.provide(routerKey, router2);
      app.provide(routeLocationKey, shallowReactive(reactiveRoute));
      app.provide(routerViewLocationKey, currentRoute);
      const unmountApp = app.unmount;
      installedApps.add(app);
      app.unmount = function() {
        installedApps.delete(app);
        if (installedApps.size < 1) {
          pendingLocation = START_LOCATION_NORMALIZED;
          removeHistoryListener && removeHistoryListener();
          removeHistoryListener = null;
          currentRoute.value = START_LOCATION_NORMALIZED;
          started = false;
          ready = false;
        }
        unmountApp();
      };
    }
  };
  function runGuardQueue(guards) {
    return guards.reduce((promise, guard) => promise.then(() => runWithContext(guard)), Promise.resolve());
  }
  return router;
}
function extractChangingRecords(to, from) {
  const leavingRecords = [];
  const updatingRecords = [];
  const enteringRecords = [];
  const len = Math.max(from.matched.length, to.matched.length);
  for (let i = 0; i < len; i++) {
    const recordFrom = from.matched[i];
    if (recordFrom) {
      if (to.matched.find((record) => isSameRouteRecord(record, recordFrom)))
        updatingRecords.push(recordFrom);
      else
        leavingRecords.push(recordFrom);
    }
    const recordTo = to.matched[i];
    if (recordTo) {
      if (!from.matched.find((record) => isSameRouteRecord(record, recordTo))) {
        enteringRecords.push(recordTo);
      }
    }
  }
  return [leavingRecords, updatingRecords, enteringRecords];
}
var dist = { exports: {} };
(function(module, exports) {
  !function(e, t) {
    module.exports = t();
  }("undefined" != typeof self ? self : commonjsGlobal, function() {
    return function(e) {
      function t(r) {
        if (n[r])
          return n[r].exports;
        var o = n[r] = { i: r, l: false, exports: {} };
        return e[r].call(o.exports, o, o.exports, t), o.l = true, o.exports;
      }
      var n = {};
      return t.m = e, t.c = n, t.d = function(e2, n2, r) {
        t.o(e2, n2) || Object.defineProperty(e2, n2, { configurable: false, enumerable: true, get: r });
      }, t.n = function(e2) {
        var n2 = e2 && e2.__esModule ? function() {
          return e2.default;
        } : function() {
          return e2;
        };
        return t.d(n2, "a", n2), n2;
      }, t.o = function(e2, t2) {
        return Object.prototype.hasOwnProperty.call(e2, t2);
      }, t.p = "../dist/", t(t.s = 0);
    }([function(e, t, n) {
      (function(r) {
        function o(e2) {
          if (Array.isArray(e2)) {
            for (var t2 = 0, n2 = Array(e2.length); t2 < e2.length; t2++)
              n2[t2] = e2[t2];
            return n2;
          }
          return Array.from(e2);
        }
        var c2;
        n(2), n(3);
        var i = {}, u = {}, a = [], l = [], s = false, f2 = function(e2) {
          return e2 = "string" == typeof e2 ? JSON.parse(e2.replace(/\'/gi, '"')) : e2, e2 instanceof Array ? { "": e2 } : e2;
        }, p2 = function(e2, t2, n2, r2) {
          var o2 = true === n2.modifiers.push, c3 = true === n2.modifiers.avoid, i2 = true == !n2.modifiers.focus, u2 = true === n2.modifiers.once, l2 = true === n2.modifiers.propagte;
          c3 ? (a = a.filter(function(e3) {
            return !e3 === t2;
          }), a.push(t2)) : (v2({ b: e2, push: o2, once: u2, focus: i2, propagte: l2, el: r2.el }), console.log("doing fixed mapping"));
        }, d = function(e2, t2) {
          for (var n2 in e2) {
            var r2 = i.encodeKey(e2[n2]), o2 = u[r2].el.indexOf(t2);
            u[r2].el.length > 1 && o2 > -1 ? u[r2].el.splice(o2, 1) : delete u[r2];
          }
        };
        i.install = function(e2, t2) {
          l = [].concat(o(t2 && t2.prevent ? t2.prevent : [])), console.log("installing..."), e2.directive("shortkey", { beforeMount: function(e3, t3, n2) {
            var r2 = f2(t3.value);
            p2(r2, e3, t3, n2);
          }, updated: function(e3, t3, n2) {
            var r2 = f2(t3.oldValue);
            d(r2, e3);
            var o2 = f2(t3.value);
            p2(o2, e3, t3, n2);
          }, unmounted: function(e3, t3) {
            var n2 = f2(t3.value);
            d(n2, e3);
          } });
        }, i.decodeKey = function(e2) {
          return y2(e2);
        }, i.encodeKey = function(e2) {
          var t2 = {};
          t2.shiftKey = e2.includes("shift"), t2.ctrlKey = e2.includes("ctrl"), t2.metaKey = e2.includes("meta"), t2.altKey = e2.includes("alt");
          var n2 = y2(t2);
          return n2 += e2.filter(function(e3) {
            return !["shift", "ctrl", "meta", "alt"].includes(e3);
          }).join("");
        };
        var y2 = function(e2) {
          var t2 = "";
          return ("Shift" === e2.key || e2.shiftKey) && (t2 += "shift"), ("Control" === e2.key || e2.ctrlKey) && (t2 += "ctrl"), ("Meta" === e2.key || e2.metaKey) && (t2 += "meta"), ("Alt" === e2.key || e2.altKey) && (t2 += "alt"), "ArrowUp" === e2.key && (t2 += "arrowup"), "ArrowLeft" === e2.key && (t2 += "arrowleft"), "ArrowRight" === e2.key && (t2 += "arrowright"), "ArrowDown" === e2.key && (t2 += "arrowdown"), "AltGraph" === e2.key && (t2 += "altgraph"), "Escape" === e2.key && (t2 += "esc"), "Enter" === e2.key && (t2 += "enter"), "Tab" === e2.key && (t2 += "tab"), " " === e2.key && (t2 += "space"), "PageUp" === e2.key && (t2 += "pageup"), "PageDown" === e2.key && (t2 += "pagedown"), "Home" === e2.key && (t2 += "home"), "End" === e2.key && (t2 += "end"), "Delete" === e2.key && (t2 += "del"), "Backspace" === e2.key && (t2 += "backspace"), "Insert" === e2.key && (t2 += "insert"), "NumLock" === e2.key && (t2 += "numlock"), "CapsLock" === e2.key && (t2 += "capslock"), "Pause" === e2.key && (t2 += "pause"), "ContextMenu" === e2.key && (t2 += "contextmenu"), "ScrollLock" === e2.key && (t2 += "scrolllock"), "BrowserHome" === e2.key && (t2 += "browserhome"), "MediaSelect" === e2.key && (t2 += "mediaselect"), (e2.key && " " !== e2.key && 1 === e2.key.length || /F\d{1,2}|\//g.test(e2.key)) && (t2 += e2.key.toLowerCase()), t2;
        }, h2 = function(e2) {
          var t2 = new CustomEvent("shortkey", { bubbles: false });
          u[e2].key && (t2.srcKey = u[e2].key);
          var n2 = u[e2].el;
          console.log(u), console.log("pKey:", e2), console.log(n2), u[e2].propagte ? n2.forEach(function(e3) {
            return e3.dispatchEvent(t2);
          }) : n2[n2.length - 1].dispatchEvent(t2);
        };
        i.keyDown = function(e2) {
          (!u[e2].once && !u[e2].push || u[e2].push && !s) && h2(e2);
        }, r && Object({ NODE_ENV: "production" }) && function() {
          document.addEventListener("keydown", function(e2) {
            var t2 = i.decodeKey(e2);
            if (m(t2)) {
              if (u[t2].propagte || (e2.preventDefault(), e2.stopPropagation()), u[t2].focus)
                i.keyDown(t2), s = true;
              else if (!s) {
                var n2 = u[t2].el;
                n2[n2.length - 1].focus(), s = true;
              }
            }
          }, true), document.addEventListener("keyup", function(e2) {
            var t2 = i.decodeKey(e2);
            m(t2) && (u[t2].propagte || (e2.preventDefault(), e2.stopPropagation()), (u[t2].once || u[t2].push) && h2(t2)), s = false;
          }, true);
        }();
        var v2 = function(e2) {
          var t2 = e2.b, n2 = e2.push, r2 = e2.once, o2 = e2.focus, c3 = e2.propagte, a2 = e2.el;
          for (var l2 in t2) {
            var s2 = i.encodeKey(t2[l2]), f3 = u[s2] && u[s2].el ? u[s2].el : [], p3 = u[s2] && u[s2].propagte;
            f3.push(a2), u[s2] = { push: n2, once: r2, focus: o2, key: l2, propagte: p3 || c3, el: f3 };
          }
        }, m = function(e2) {
          var t2 = !!a.find(function(e3) {
            return e3 === document.activeElement;
          }), n2 = !!l.find(function(e3) {
            return document.activeElement && document.activeElement.matches(e3);
          });
          return !!u[e2] && !(t2 || n2);
        };
        void 0 !== e && e.exports ? e.exports = i : void 0 !== (c2 = (function() {
          return i;
        }).call(t, n, t, e)) && (e.exports = c2);
      }).call(t, n(1));
    }, function(e, t) {
      function n() {
        throw new Error("setTimeout has not been defined");
      }
      function r() {
        throw new Error("clearTimeout has not been defined");
      }
      function o(e2) {
        if (s === setTimeout)
          return setTimeout(e2, 0);
        if ((s === n || !s) && setTimeout)
          return s = setTimeout, setTimeout(e2, 0);
        try {
          return s(e2, 0);
        } catch (t2) {
          try {
            return s.call(null, e2, 0);
          } catch (t3) {
            return s.call(this, e2, 0);
          }
        }
      }
      function c2(e2) {
        if (f2 === clearTimeout)
          return clearTimeout(e2);
        if ((f2 === r || !f2) && clearTimeout)
          return f2 = clearTimeout, clearTimeout(e2);
        try {
          return f2(e2);
        } catch (t2) {
          try {
            return f2.call(null, e2);
          } catch (t3) {
            return f2.call(this, e2);
          }
        }
      }
      function i() {
        h2 && d && (h2 = false, d.length ? y2 = d.concat(y2) : v2 = -1, y2.length && u());
      }
      function u() {
        if (!h2) {
          var e2 = o(i);
          h2 = true;
          for (var t2 = y2.length; t2; ) {
            for (d = y2, y2 = []; ++v2 < t2; )
              d && d[v2].run();
            v2 = -1, t2 = y2.length;
          }
          d = null, h2 = false, c2(e2);
        }
      }
      function a(e2, t2) {
        this.fun = e2, this.array = t2;
      }
      function l() {
      }
      var s, f2, p2 = e.exports = {};
      !function() {
        try {
          s = "function" == typeof setTimeout ? setTimeout : n;
        } catch (e2) {
          s = n;
        }
        try {
          f2 = "function" == typeof clearTimeout ? clearTimeout : r;
        } catch (e2) {
          f2 = r;
        }
      }();
      var d, y2 = [], h2 = false, v2 = -1;
      p2.nextTick = function(e2) {
        var t2 = new Array(arguments.length - 1);
        if (arguments.length > 1)
          for (var n2 = 1; n2 < arguments.length; n2++)
            t2[n2 - 1] = arguments[n2];
        y2.push(new a(e2, t2)), 1 !== y2.length || h2 || o(u);
      }, a.prototype.run = function() {
        this.fun.apply(null, this.array);
      }, p2.title = "browser", p2.browser = true, p2.env = {}, p2.argv = [], p2.version = "", p2.versions = {}, p2.on = l, p2.addListener = l, p2.once = l, p2.off = l, p2.removeListener = l, p2.removeAllListeners = l, p2.emit = l, p2.prependListener = l, p2.prependOnceListener = l, p2.listeners = function(e2) {
        return [];
      }, p2.binding = function(e2) {
        throw new Error("process.binding is not supported");
      }, p2.cwd = function() {
        return "/";
      }, p2.chdir = function(e2) {
        throw new Error("process.chdir is not supported");
      }, p2.umask = function() {
        return 0;
      };
    }, function(e, t) {
      Element.prototype.matches || (Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector);
    }, function(e, t) {
      !function() {
        if ("undefined" != typeof window)
          try {
            var e2 = new window.CustomEvent("test", { cancelable: true });
            if (e2.preventDefault(), true !== e2.defaultPrevented)
              throw new Error("Could not prevent default");
          } catch (e3) {
            var t2 = function(e4, t3) {
              var n, r;
              return t3 = t3 || {}, t3.bubbles = !!t3.bubbles, t3.cancelable = !!t3.cancelable, n = document.createEvent("CustomEvent"), n.initCustomEvent(e4, t3.bubbles, t3.cancelable, t3.detail), r = n.preventDefault, n.preventDefault = function() {
                r.call(this);
                try {
                  Object.defineProperty(this, "defaultPrevented", { get: function() {
                    return true;
                  } });
                } catch (e5) {
                  this.defaultPrevented = true;
                }
              }, n;
            };
            t2.prototype = window.Event.prototype, window.CustomEvent = t2;
          }
      }();
    }]);
  });
})(dist);
var distExports = dist.exports;
const VueShortkey = /* @__PURE__ */ getDefaultExportFromCjs(distExports);
function _typeof$3(obj) {
  "@babel/helpers - typeof";
  return _typeof$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$3(obj);
}
function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }
  var number = Number(dirtyNumber);
  if (isNaN(number)) {
    return number;
  }
  return number < 0 ? Math.ceil(number) : Math.floor(number);
}
function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + " argument" + (required > 1 ? "s" : "") + " required, but only " + args.length + " present");
  }
}
function toDate(argument) {
  requiredArgs(1, arguments);
  var argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || _typeof$3(argument) === "object" && argStr === "[object Date]") {
    return new Date(argument.getTime());
  } else if (typeof argument === "number" || argStr === "[object Number]") {
    return new Date(argument);
  } else {
    if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments");
      console.warn(new Error().stack);
    }
    return /* @__PURE__ */ new Date(NaN);
  }
}
var defaultOptions = {};
function getDefaultOptions() {
  return defaultOptions;
}
function getTimezoneOffsetInMilliseconds(date2) {
  var utcDate = new Date(Date.UTC(date2.getFullYear(), date2.getMonth(), date2.getDate(), date2.getHours(), date2.getMinutes(), date2.getSeconds(), date2.getMilliseconds()));
  utcDate.setUTCFullYear(date2.getFullYear());
  return date2.getTime() - utcDate.getTime();
}
function compareAsc(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var diff = dateLeft.getTime() - dateRight.getTime();
  if (diff < 0) {
    return -1;
  } else if (diff > 0) {
    return 1;
  } else {
    return diff;
  }
}
var millisecondsInMinute = 6e4;
var millisecondsInHour = 36e5;
function differenceInCalendarMonths(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var yearDiff = dateLeft.getFullYear() - dateRight.getFullYear();
  var monthDiff = dateLeft.getMonth() - dateRight.getMonth();
  return yearDiff * 12 + monthDiff;
}
function differenceInMilliseconds(dateLeft, dateRight) {
  requiredArgs(2, arguments);
  return toDate(dateLeft).getTime() - toDate(dateRight).getTime();
}
var roundingMap = {
  ceil: Math.ceil,
  round: Math.round,
  floor: Math.floor,
  trunc: function trunc(value) {
    return value < 0 ? Math.ceil(value) : Math.floor(value);
  }
};
var defaultRoundingMethod = "trunc";
function getRoundingMethod(method) {
  return method ? roundingMap[method] : roundingMap[defaultRoundingMethod];
}
function endOfDay$1(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  date2.setHours(23, 59, 59, 999);
  return date2;
}
function endOfMonth$1(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  var month = date2.getMonth();
  date2.setFullYear(date2.getFullYear(), month + 1, 0);
  date2.setHours(23, 59, 59, 999);
  return date2;
}
function isLastDayOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  return endOfDay$1(date2).getTime() === endOfMonth$1(date2).getTime();
}
function differenceInMonths(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var sign2 = compareAsc(dateLeft, dateRight);
  var difference = Math.abs(differenceInCalendarMonths(dateLeft, dateRight));
  var result;
  if (difference < 1) {
    result = 0;
  } else {
    if (dateLeft.getMonth() === 1 && dateLeft.getDate() > 27) {
      dateLeft.setDate(30);
    }
    dateLeft.setMonth(dateLeft.getMonth() - sign2 * difference);
    var isLastMonthNotFull = compareAsc(dateLeft, dateRight) === -sign2;
    if (isLastDayOfMonth(toDate(dirtyDateLeft)) && difference === 1 && compareAsc(dirtyDateLeft, dateRight) === 1) {
      isLastMonthNotFull = false;
    }
    result = sign2 * (difference - Number(isLastMonthNotFull));
  }
  return result === 0 ? 0 : result;
}
function differenceInSeconds(dateLeft, dateRight, options) {
  requiredArgs(2, arguments);
  var diff = differenceInMilliseconds(dateLeft, dateRight) / 1e3;
  return getRoundingMethod(options === null || options === void 0 ? void 0 : options.roundingMethod)(diff);
}
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
var formatDistance$1 = function formatDistance(token2, count, options) {
  var result;
  var tokenValue = formatDistanceLocale[token2];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
};
var formatDistance$2 = formatDistance$1;
function buildFormatLongFn(args) {
  return function() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var width = options.width ? String(options.width) : args.defaultWidth;
    var format2 = args.formats[width] || args.formats[args.defaultWidth];
    return format2;
  };
}
var dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};
var formatLong$1 = formatLong;
var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
var formatRelative = function formatRelative2(token2, _date, _baseDate, _options) {
  return formatRelativeLocale[token2];
};
var formatRelative$1 = formatRelative;
function buildLocalizeFn(args) {
  return function(dirtyIndex, options) {
    var context = options !== null && options !== void 0 && options.context ? String(options.context) : "standalone";
    var valuesArray;
    if (context === "formatting" && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;
      var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }
    var index2 = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
    return valuesArray[index2];
  };
}
var eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
var quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
var monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
};
var dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
};
var dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
var ordinalNumber = function ordinalNumber2(dirtyNumber, _options) {
  var number = Number(dirtyNumber);
  var rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + "st";
      case 2:
        return number + "nd";
      case 3:
        return number + "rd";
    }
  }
  return number + "th";
};
var localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: function argumentCallback(quarter) {
      return quarter - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};
var localize$1 = localize;
function buildMatchFn(args) {
  return function(string) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var width = options.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var key2 = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    }) : findKey(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    });
    var value;
    value = args.valueCallback ? args.valueCallback(key2) : key2;
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}
function findKey(object, predicate) {
  for (var key2 in object) {
    if (object.hasOwnProperty(key2) && predicate(object[key2])) {
      return key2;
    }
  }
  return void 0;
}
function findIndex(array, predicate) {
  for (var key2 = 0; key2 < array.length; key2++) {
    if (predicate(array[key2])) {
      return key2;
    }
  }
  return void 0;
}
function buildMatchPatternFn(args) {
  return function(string) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var matchResult = string.match(args.matchPattern);
    if (!matchResult)
      return null;
    var matchedString = matchResult[0];
    var parseResult = string.match(args.parsePattern);
    if (!parseResult)
      return null;
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}
var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function valueCallback(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: function valueCallback2(index2) {
      return index2 + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};
var match$1 = match;
var locale = {
  code: "en-US",
  formatDistance: formatDistance$2,
  formatLong: formatLong$1,
  formatRelative: formatRelative$1,
  localize: localize$1,
  match: match$1,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
var defaultLocale = locale;
function assign$1(target, object) {
  if (target == null) {
    throw new TypeError("assign requires that input parameter not be null or undefined");
  }
  for (var property in object) {
    if (Object.prototype.hasOwnProperty.call(object, property)) {
      target[property] = object[property];
    }
  }
  return target;
}
function cloneObject(object) {
  return assign$1({}, object);
}
var MINUTES_IN_DAY$1 = 1440;
var MINUTES_IN_ALMOST_TWO_DAYS = 2520;
var MINUTES_IN_MONTH$1 = 43200;
var MINUTES_IN_TWO_MONTHS = 86400;
function formatDistance2(dirtyDate, dirtyBaseDate, options) {
  var _ref, _options$locale;
  requiredArgs(2, arguments);
  var defaultOptions2 = getDefaultOptions();
  var locale2 = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions2.locale) !== null && _ref !== void 0 ? _ref : defaultLocale;
  if (!locale2.formatDistance) {
    throw new RangeError("locale must contain formatDistance property");
  }
  var comparison = compareAsc(dirtyDate, dirtyBaseDate);
  if (isNaN(comparison)) {
    throw new RangeError("Invalid time value");
  }
  var localizeOptions = assign$1(cloneObject(options), {
    addSuffix: Boolean(options === null || options === void 0 ? void 0 : options.addSuffix),
    comparison
  });
  var dateLeft;
  var dateRight;
  if (comparison > 0) {
    dateLeft = toDate(dirtyBaseDate);
    dateRight = toDate(dirtyDate);
  } else {
    dateLeft = toDate(dirtyDate);
    dateRight = toDate(dirtyBaseDate);
  }
  var seconds = differenceInSeconds(dateRight, dateLeft);
  var offsetInSeconds = (getTimezoneOffsetInMilliseconds(dateRight) - getTimezoneOffsetInMilliseconds(dateLeft)) / 1e3;
  var minutes = Math.round((seconds - offsetInSeconds) / 60);
  var months;
  if (minutes < 2) {
    if (options !== null && options !== void 0 && options.includeSeconds) {
      if (seconds < 5) {
        return locale2.formatDistance("lessThanXSeconds", 5, localizeOptions);
      } else if (seconds < 10) {
        return locale2.formatDistance("lessThanXSeconds", 10, localizeOptions);
      } else if (seconds < 20) {
        return locale2.formatDistance("lessThanXSeconds", 20, localizeOptions);
      } else if (seconds < 40) {
        return locale2.formatDistance("halfAMinute", 0, localizeOptions);
      } else if (seconds < 60) {
        return locale2.formatDistance("lessThanXMinutes", 1, localizeOptions);
      } else {
        return locale2.formatDistance("xMinutes", 1, localizeOptions);
      }
    } else {
      if (minutes === 0) {
        return locale2.formatDistance("lessThanXMinutes", 1, localizeOptions);
      } else {
        return locale2.formatDistance("xMinutes", minutes, localizeOptions);
      }
    }
  } else if (minutes < 45) {
    return locale2.formatDistance("xMinutes", minutes, localizeOptions);
  } else if (minutes < 90) {
    return locale2.formatDistance("aboutXHours", 1, localizeOptions);
  } else if (minutes < MINUTES_IN_DAY$1) {
    var hours = Math.round(minutes / 60);
    return locale2.formatDistance("aboutXHours", hours, localizeOptions);
  } else if (minutes < MINUTES_IN_ALMOST_TWO_DAYS) {
    return locale2.formatDistance("xDays", 1, localizeOptions);
  } else if (minutes < MINUTES_IN_MONTH$1) {
    var days = Math.round(minutes / MINUTES_IN_DAY$1);
    return locale2.formatDistance("xDays", days, localizeOptions);
  } else if (minutes < MINUTES_IN_TWO_MONTHS) {
    months = Math.round(minutes / MINUTES_IN_MONTH$1);
    return locale2.formatDistance("aboutXMonths", months, localizeOptions);
  }
  months = differenceInMonths(dateRight, dateLeft);
  if (months < 12) {
    var nearestMonth = Math.round(minutes / MINUTES_IN_MONTH$1);
    return locale2.formatDistance("xMonths", nearestMonth, localizeOptions);
  } else {
    var monthsSinceStartOfYear = months % 12;
    var years = Math.floor(months / 12);
    if (monthsSinceStartOfYear < 3) {
      return locale2.formatDistance("aboutXYears", years, localizeOptions);
    } else if (monthsSinceStartOfYear < 9) {
      return locale2.formatDistance("overXYears", years, localizeOptions);
    } else {
      return locale2.formatDistance("almostXYears", years + 1, localizeOptions);
    }
  }
}
var MILLISECONDS_IN_MINUTE = 1e3 * 60;
var MINUTES_IN_DAY = 60 * 24;
var MINUTES_IN_MONTH = MINUTES_IN_DAY * 30;
var MINUTES_IN_YEAR = MINUTES_IN_DAY * 365;
function formatDistanceStrict(dirtyDate, dirtyBaseDate, options) {
  var _ref, _options$locale, _options$roundingMeth;
  requiredArgs(2, arguments);
  var defaultOptions2 = getDefaultOptions();
  var locale2 = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions2.locale) !== null && _ref !== void 0 ? _ref : defaultLocale;
  if (!locale2.formatDistance) {
    throw new RangeError("locale must contain localize.formatDistance property");
  }
  var comparison = compareAsc(dirtyDate, dirtyBaseDate);
  if (isNaN(comparison)) {
    throw new RangeError("Invalid time value");
  }
  var localizeOptions = assign$1(cloneObject(options), {
    addSuffix: Boolean(options === null || options === void 0 ? void 0 : options.addSuffix),
    comparison
  });
  var dateLeft;
  var dateRight;
  if (comparison > 0) {
    dateLeft = toDate(dirtyBaseDate);
    dateRight = toDate(dirtyDate);
  } else {
    dateLeft = toDate(dirtyDate);
    dateRight = toDate(dirtyBaseDate);
  }
  var roundingMethod = String((_options$roundingMeth = options === null || options === void 0 ? void 0 : options.roundingMethod) !== null && _options$roundingMeth !== void 0 ? _options$roundingMeth : "round");
  var roundingMethodFn;
  if (roundingMethod === "floor") {
    roundingMethodFn = Math.floor;
  } else if (roundingMethod === "ceil") {
    roundingMethodFn = Math.ceil;
  } else if (roundingMethod === "round") {
    roundingMethodFn = Math.round;
  } else {
    throw new RangeError("roundingMethod must be 'floor', 'ceil' or 'round'");
  }
  var milliseconds = dateRight.getTime() - dateLeft.getTime();
  var minutes = milliseconds / MILLISECONDS_IN_MINUTE;
  var timezoneOffset = getTimezoneOffsetInMilliseconds(dateRight) - getTimezoneOffsetInMilliseconds(dateLeft);
  var dstNormalizedMinutes = (milliseconds - timezoneOffset) / MILLISECONDS_IN_MINUTE;
  var defaultUnit = options === null || options === void 0 ? void 0 : options.unit;
  var unit;
  if (!defaultUnit) {
    if (minutes < 1) {
      unit = "second";
    } else if (minutes < 60) {
      unit = "minute";
    } else if (minutes < MINUTES_IN_DAY) {
      unit = "hour";
    } else if (dstNormalizedMinutes < MINUTES_IN_MONTH) {
      unit = "day";
    } else if (dstNormalizedMinutes < MINUTES_IN_YEAR) {
      unit = "month";
    } else {
      unit = "year";
    }
  } else {
    unit = String(defaultUnit);
  }
  if (unit === "second") {
    var seconds = roundingMethodFn(milliseconds / 1e3);
    return locale2.formatDistance("xSeconds", seconds, localizeOptions);
  } else if (unit === "minute") {
    var roundedMinutes = roundingMethodFn(minutes);
    return locale2.formatDistance("xMinutes", roundedMinutes, localizeOptions);
  } else if (unit === "hour") {
    var hours = roundingMethodFn(minutes / 60);
    return locale2.formatDistance("xHours", hours, localizeOptions);
  } else if (unit === "day") {
    var days = roundingMethodFn(dstNormalizedMinutes / MINUTES_IN_DAY);
    return locale2.formatDistance("xDays", days, localizeOptions);
  } else if (unit === "month") {
    var months = roundingMethodFn(dstNormalizedMinutes / MINUTES_IN_MONTH);
    return months === 12 && defaultUnit !== "month" ? locale2.formatDistance("xYears", 1, localizeOptions) : locale2.formatDistance("xMonths", months, localizeOptions);
  } else if (unit === "year") {
    var years = roundingMethodFn(dstNormalizedMinutes / MINUTES_IN_YEAR);
    return locale2.formatDistance("xYears", years, localizeOptions);
  }
  throw new RangeError("unit must be 'second', 'minute', 'hour', 'day', 'month' or 'year'");
}
function formatDistanceToNow(dirtyDate, options) {
  requiredArgs(1, arguments);
  return formatDistance2(dirtyDate, Date.now(), options);
}
function formatDistanceToNowStrict(dirtyDate, options) {
  requiredArgs(1, arguments);
  return formatDistanceStrict(dirtyDate, Date.now(), options);
}
function parseISO$1(argument, options) {
  var _options$additionalDi;
  requiredArgs(1, arguments);
  var additionalDigits = toInteger((_options$additionalDi = options === null || options === void 0 ? void 0 : options.additionalDigits) !== null && _options$additionalDi !== void 0 ? _options$additionalDi : 2);
  if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
    throw new RangeError("additionalDigits must be 0, 1 or 2");
  }
  if (!(typeof argument === "string" || Object.prototype.toString.call(argument) === "[object String]")) {
    return /* @__PURE__ */ new Date(NaN);
  }
  var dateStrings = splitDateString(argument);
  var date2;
  if (dateStrings.date) {
    var parseYearResult = parseYear(dateStrings.date, additionalDigits);
    date2 = parseDate(parseYearResult.restDateString, parseYearResult.year);
  }
  if (!date2 || isNaN(date2.getTime())) {
    return /* @__PURE__ */ new Date(NaN);
  }
  var timestamp = date2.getTime();
  var time = 0;
  var offset;
  if (dateStrings.time) {
    time = parseTime(dateStrings.time);
    if (isNaN(time)) {
      return /* @__PURE__ */ new Date(NaN);
    }
  }
  if (dateStrings.timezone) {
    offset = parseTimezone(dateStrings.timezone);
    if (isNaN(offset)) {
      return /* @__PURE__ */ new Date(NaN);
    }
  } else {
    var dirtyDate = new Date(timestamp + time);
    var result = /* @__PURE__ */ new Date(0);
    result.setFullYear(dirtyDate.getUTCFullYear(), dirtyDate.getUTCMonth(), dirtyDate.getUTCDate());
    result.setHours(dirtyDate.getUTCHours(), dirtyDate.getUTCMinutes(), dirtyDate.getUTCSeconds(), dirtyDate.getUTCMilliseconds());
    return result;
  }
  return new Date(timestamp + time + offset);
}
var patterns = {
  dateTimeDelimiter: /[T ]/,
  timeZoneDelimiter: /[Z ]/i,
  timezone: /([Z+-].*)$/
};
var dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
var timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
var timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
function splitDateString(dateString) {
  var dateStrings = {};
  var array = dateString.split(patterns.dateTimeDelimiter);
  var timeString;
  if (array.length > 2) {
    return dateStrings;
  }
  if (/:/.test(array[0])) {
    timeString = array[0];
  } else {
    dateStrings.date = array[0];
    timeString = array[1];
    if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
      dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
      timeString = dateString.substr(dateStrings.date.length, dateString.length);
    }
  }
  if (timeString) {
    var token2 = patterns.timezone.exec(timeString);
    if (token2) {
      dateStrings.time = timeString.replace(token2[1], "");
      dateStrings.timezone = token2[1];
    } else {
      dateStrings.time = timeString;
    }
  }
  return dateStrings;
}
function parseYear(dateString, additionalDigits) {
  var regex2 = new RegExp("^(?:(\\d{4}|[+-]\\d{" + (4 + additionalDigits) + "})|(\\d{2}|[+-]\\d{" + (2 + additionalDigits) + "})$)");
  var captures = dateString.match(regex2);
  if (!captures)
    return {
      year: NaN,
      restDateString: ""
    };
  var year = captures[1] ? parseInt(captures[1]) : null;
  var century = captures[2] ? parseInt(captures[2]) : null;
  return {
    year: century === null ? year : century * 100,
    restDateString: dateString.slice((captures[1] || captures[2]).length)
  };
}
function parseDate(dateString, year) {
  if (year === null)
    return /* @__PURE__ */ new Date(NaN);
  var captures = dateString.match(dateRegex);
  if (!captures)
    return /* @__PURE__ */ new Date(NaN);
  var isWeekDate = !!captures[4];
  var dayOfYear = parseDateUnit(captures[1]);
  var month = parseDateUnit(captures[2]) - 1;
  var day = parseDateUnit(captures[3]);
  var week = parseDateUnit(captures[4]);
  var dayOfWeek = parseDateUnit(captures[5]) - 1;
  if (isWeekDate) {
    if (!validateWeekDate(year, week, dayOfWeek)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    return dayOfISOWeekYear(year, week, dayOfWeek);
  } else {
    var date2 = /* @__PURE__ */ new Date(0);
    if (!validateDate(year, month, day) || !validateDayOfYearDate(year, dayOfYear)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    date2.setUTCFullYear(year, month, Math.max(dayOfYear, day));
    return date2;
  }
}
function parseDateUnit(value) {
  return value ? parseInt(value) : 1;
}
function parseTime(timeString) {
  var captures = timeString.match(timeRegex);
  if (!captures)
    return NaN;
  var hours = parseTimeUnit(captures[1]);
  var minutes = parseTimeUnit(captures[2]);
  var seconds = parseTimeUnit(captures[3]);
  if (!validateTime(hours, minutes, seconds)) {
    return NaN;
  }
  return hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * 1e3;
}
function parseTimeUnit(value) {
  return value && parseFloat(value.replace(",", ".")) || 0;
}
function parseTimezone(timezoneString) {
  if (timezoneString === "Z")
    return 0;
  var captures = timezoneString.match(timezoneRegex);
  if (!captures)
    return 0;
  var sign2 = captures[1] === "+" ? -1 : 1;
  var hours = parseInt(captures[2]);
  var minutes = captures[3] && parseInt(captures[3]) || 0;
  if (!validateTimezone(hours, minutes)) {
    return NaN;
  }
  return sign2 * (hours * millisecondsInHour + minutes * millisecondsInMinute);
}
function dayOfISOWeekYear(isoWeekYear, week, day) {
  var date2 = /* @__PURE__ */ new Date(0);
  date2.setUTCFullYear(isoWeekYear, 0, 4);
  var fourthOfJanuaryDay = date2.getUTCDay() || 7;
  var diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
  date2.setUTCDate(date2.getUTCDate() + diff);
  return date2;
}
var daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
function validateDate(year, month, date2) {
  return month >= 0 && month <= 11 && date2 >= 1 && date2 <= (daysInMonths[month] || (isLeapYearIndex(year) ? 29 : 28));
}
function validateDayOfYearDate(year, dayOfYear) {
  return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex(year) ? 366 : 365);
}
function validateWeekDate(_year, week, day) {
  return week >= 1 && week <= 53 && day >= 0 && day <= 6;
}
function validateTime(hours, minutes, seconds) {
  if (hours === 24) {
    return minutes === 0 && seconds === 0;
  }
  return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
}
function validateTimezone(_hours, minutes) {
  return minutes >= 0 && minutes <= 59;
}
var defaultConverter = (date2, converterOptions = {}, locale2) => {
  var _a2, _b;
  if (typeof date2 === "string") {
    date2 = parseISO$1(date2);
  }
  if (converterOptions.useStrict) {
    return formatDistanceToNowStrict(date2, {
      addSuffix: (_a2 = converterOptions.addSuffix) != null ? _a2 : true,
      locale: locale2,
      unit: converterOptions.unit,
      roundingMethod: converterOptions.roundingMethod
    });
  }
  return formatDistanceToNow(date2, {
    includeSeconds: converterOptions.includeSeconds,
    addSuffix: (_b = converterOptions.addSuffix) != null ? _b : true,
    locale: locale2
  });
};
const createTimeago = (opts = {}) => {
  const name = opts.name || "Timeago";
  return /* @__PURE__ */ defineComponent$1({
    name,
    props: {
      datetime: {
        type: [String, Number, Date],
        required: true
      },
      title: {
        type: [String, Boolean],
        required: false,
        default: null
      },
      autoUpdate: {
        type: [Number, Boolean],
        required: false,
        default: null
      },
      converter: {
        type: Function,
        required: false,
        default: null
      },
      converterOptions: {
        type: Object,
        required: false,
        default: null
      },
      locale: {
        type: Object,
        required: false,
        default: null
      }
    },
    setup(props2) {
      const updateTimer = ref();
      onBeforeMount(() => {
        startUpdater();
      });
      onBeforeUnmount(() => {
        stopUpdater();
      });
      const getTimeago = (datetime) => {
        const converter = props2.converter || defaultConverter;
        return converter(
          datetime || props2.datetime,
          props2.converterOptions || opts.converterOptions,
          props2.locale || opts.locale
        );
      };
      const timeago = ref(getTimeago());
      const convert = (datetime) => {
        timeago.value = getTimeago(datetime);
      };
      const startUpdater = () => {
        if (props2.autoUpdate) {
          const autoUpdate = props2.autoUpdate === true ? 60 : props2.autoUpdate;
          updateTimer.value = setInterval(() => {
            convert(props2.datetime);
          }, autoUpdate * 1e3);
        }
      };
      const stopUpdater = () => {
        if (updateTimer.value) {
          clearInterval(updateTimer.value);
          updateTimer.value = void 0;
        }
      };
      watch(
        () => props2.autoUpdate,
        (newValue) => {
          stopUpdater();
          if (newValue) {
            startUpdater();
          }
        }
      );
      watch(
        () => [props2.datetime, props2.converter],
        () => {
          convert();
        }
      );
      watch(
        () => props2.converterOptions,
        () => {
          convert();
        },
        {
          deep: true
        }
      );
      return { timeago, updateTimer };
    },
    render() {
      return h(
        "timeago",
        {
          attrs: {
            datetime: new Date(this.datetime).toISOString(),
            title: typeof this.title === "string" ? this.title : this.title === false ? null : this.timeago
          }
        },
        [this.timeago]
      );
    }
  });
};
var install = (app, options) => {
  if (app.config.globalProperties.$timeago) {
    return;
  }
  const version2 = Number(app.version.split(".")[0]);
  if (version2 < 3) {
    console.warn(
      "[vue-timeago3] This plugin requires at least Vue version 3.0"
    );
  }
  const Component = createTimeago(options);
  app.component(Component.name, Component);
};
const JsonTreeViewItem_vue_vue_type_style_index_0_lang = "";
const JsonTreeView_vue_vue_type_style_index_0_scoped_770fed52_lang = "";
const _export_sfc = (sfc, props2) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key2, val] of props2) {
    target[key2] = val;
  }
  return target;
};
function getInternetExplorerVersion() {
  var ua = window.navigator.userAgent;
  var msie = ua.indexOf("MSIE ");
  if (msie > 0) {
    return parseInt(ua.substring(msie + 5, ua.indexOf(".", msie)), 10);
  }
  var trident = ua.indexOf("Trident/");
  if (trident > 0) {
    var rv = ua.indexOf("rv:");
    return parseInt(ua.substring(rv + 3, ua.indexOf(".", rv)), 10);
  }
  var edge = ua.indexOf("Edge/");
  if (edge > 0) {
    return parseInt(ua.substring(edge + 5, ua.indexOf(".", edge)), 10);
  }
  return -1;
}
let isIE;
function initCompat() {
  if (!initCompat.init) {
    initCompat.init = true;
    isIE = getInternetExplorerVersion() !== -1;
  }
}
var script$3 = {
  name: "ResizeObserver",
  props: {
    emitOnMount: {
      type: Boolean,
      default: false
    },
    ignoreWidth: {
      type: Boolean,
      default: false
    },
    ignoreHeight: {
      type: Boolean,
      default: false
    }
  },
  emits: [
    "notify"
  ],
  mounted() {
    initCompat();
    nextTick(() => {
      this._w = this.$el.offsetWidth;
      this._h = this.$el.offsetHeight;
      if (this.emitOnMount) {
        this.emitSize();
      }
    });
    const object = document.createElement("object");
    this._resizeObject = object;
    object.setAttribute("aria-hidden", "true");
    object.setAttribute("tabindex", -1);
    object.onload = this.addResizeHandlers;
    object.type = "text/html";
    if (isIE) {
      this.$el.appendChild(object);
    }
    object.data = "about:blank";
    if (!isIE) {
      this.$el.appendChild(object);
    }
  },
  beforeUnmount() {
    this.removeResizeHandlers();
  },
  methods: {
    compareAndNotify() {
      if (!this.ignoreWidth && this._w !== this.$el.offsetWidth || !this.ignoreHeight && this._h !== this.$el.offsetHeight) {
        this._w = this.$el.offsetWidth;
        this._h = this.$el.offsetHeight;
        this.emitSize();
      }
    },
    emitSize() {
      this.$emit("notify", {
        width: this._w,
        height: this._h
      });
    },
    addResizeHandlers() {
      this._resizeObject.contentDocument.defaultView.addEventListener("resize", this.compareAndNotify);
      this.compareAndNotify();
    },
    removeResizeHandlers() {
      if (this._resizeObject && this._resizeObject.onload) {
        if (!isIE && this._resizeObject.contentDocument) {
          this._resizeObject.contentDocument.defaultView.removeEventListener("resize", this.compareAndNotify);
        }
        this.$el.removeChild(this._resizeObject);
        this._resizeObject.onload = null;
        this._resizeObject = null;
      }
    }
  }
};
const _withId = /* @__PURE__ */ withScopeId();
pushScopeId("data-v-b329ee4c");
const _hoisted_1$1 = {
  class: "resize-observer",
  tabindex: "-1"
};
popScopeId();
const render$2 = /* @__PURE__ */ _withId((_ctx, _cache, $props, $setup, $data, $options) => {
  return openBlock(), createBlock("div", _hoisted_1$1);
});
script$3.render = render$2;
script$3.__scopeId = "data-v-b329ee4c";
script$3.__file = "src/components/ResizeObserver.vue";
function _typeof$2(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$2 = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$2 = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$2(obj);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props2) {
  for (var i = 0; i < props2.length; i++) {
    var descriptor = props2[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _toConsumableArray$1(arr) {
  return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread$1();
}
function _arrayWithoutHoles$1(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$1(arr);
}
function _iterableToArray$1(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
    return Array.from(iter);
}
function _unsupportedIterableToArray$1(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$1(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$1(o, minLen);
}
function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _nonIterableSpread$1() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function processOptions(value) {
  var options;
  if (typeof value === "function") {
    options = {
      callback: value
    };
  } else {
    options = value;
  }
  return options;
}
function throttle$1(callback, delay) {
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var timeout;
  var lastState;
  var currentArgs;
  var throttled = function throttled2(state) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    currentArgs = args;
    if (timeout && state === lastState)
      return;
    var leading = options.leading;
    if (typeof leading === "function") {
      leading = leading(state, lastState);
    }
    if ((!timeout || state !== lastState) && leading) {
      callback.apply(void 0, [state].concat(_toConsumableArray$1(currentArgs)));
    }
    lastState = state;
    clearTimeout(timeout);
    timeout = setTimeout(function() {
      callback.apply(void 0, [state].concat(_toConsumableArray$1(currentArgs)));
      timeout = 0;
    }, delay);
  };
  throttled._clear = function() {
    clearTimeout(timeout);
    timeout = null;
  };
  return throttled;
}
function deepEqual$1(val1, val2) {
  if (val1 === val2)
    return true;
  if (_typeof$2(val1) === "object") {
    for (var key2 in val1) {
      if (!deepEqual$1(val1[key2], val2[key2])) {
        return false;
      }
    }
    return true;
  }
  return false;
}
var VisibilityState = /* @__PURE__ */ function() {
  function VisibilityState2(el, options, vnode) {
    _classCallCheck(this, VisibilityState2);
    this.el = el;
    this.observer = null;
    this.frozen = false;
    this.createObserver(options, vnode);
  }
  _createClass(VisibilityState2, [{
    key: "createObserver",
    value: function createObserver(options, vnode) {
      var _this = this;
      if (this.observer) {
        this.destroyObserver();
      }
      if (this.frozen)
        return;
      this.options = processOptions(options);
      this.callback = function(result, entry) {
        _this.options.callback(result, entry);
        if (result && _this.options.once) {
          _this.frozen = true;
          _this.destroyObserver();
        }
      };
      if (this.callback && this.options.throttle) {
        var _ref = this.options.throttleOptions || {}, _leading = _ref.leading;
        this.callback = throttle$1(this.callback, this.options.throttle, {
          leading: function leading(state) {
            return _leading === "both" || _leading === "visible" && state || _leading === "hidden" && !state;
          }
        });
      }
      this.oldResult = void 0;
      this.observer = new IntersectionObserver(function(entries) {
        var entry = entries[0];
        if (entries.length > 1) {
          var intersectingEntry = entries.find(function(e) {
            return e.isIntersecting;
          });
          if (intersectingEntry) {
            entry = intersectingEntry;
          }
        }
        if (_this.callback) {
          var result = entry.isIntersecting && entry.intersectionRatio >= _this.threshold;
          if (result === _this.oldResult)
            return;
          _this.oldResult = result;
          _this.callback(result, entry);
        }
      }, this.options.intersection);
      nextTick(function() {
        if (_this.observer) {
          _this.observer.observe(_this.el);
        }
      });
    }
  }, {
    key: "destroyObserver",
    value: function destroyObserver() {
      if (this.observer) {
        this.observer.disconnect();
        this.observer = null;
      }
      if (this.callback && this.callback._clear) {
        this.callback._clear();
        this.callback = null;
      }
    }
  }, {
    key: "threshold",
    get: function get2() {
      return this.options.intersection && typeof this.options.intersection.threshold === "number" ? this.options.intersection.threshold : 0;
    }
  }]);
  return VisibilityState2;
}();
function beforeMount(el, _ref2, vnode) {
  var value = _ref2.value;
  if (!value)
    return;
  if (typeof IntersectionObserver === "undefined") {
    console.warn("[vue-observe-visibility] IntersectionObserver API is not available in your browser. Please install this polyfill: https://github.com/w3c/IntersectionObserver/tree/master/polyfill");
  } else {
    var state = new VisibilityState(el, value, vnode);
    el._vue_visibilityState = state;
  }
}
function updated$2(el, _ref3, vnode) {
  var value = _ref3.value, oldValue = _ref3.oldValue;
  if (deepEqual$1(value, oldValue))
    return;
  var state = el._vue_visibilityState;
  if (!value) {
    unmounted$6(el);
    return;
  }
  if (state) {
    state.createObserver(value, vnode);
  } else {
    beforeMount(el, {
      value
    }, vnode);
  }
}
function unmounted$6(el) {
  var state = el._vue_visibilityState;
  if (state) {
    state.destroyObserver();
    delete el._vue_visibilityState;
  }
}
var ObserveVisibility = {
  beforeMount,
  updated: updated$2,
  unmounted: unmounted$6
};
function mitt(n) {
  return { all: n = n || /* @__PURE__ */ new Map(), on: function(t, e) {
    var i = n.get(t);
    i && i.push(e) || n.set(t, [e]);
  }, off: function(t, e) {
    var i = n.get(t);
    i && i.splice(i.indexOf(e) >>> 0, 1);
  }, emit: function(t, e) {
    (n.get(t) || []).slice().map(function(n2) {
      n2(e);
    }), (n.get("*") || []).slice().map(function(n2) {
      n2(t, e);
    });
  } };
}
var config = {
  itemsLimit: 1e3
};
var regex = /(auto|scroll)/;
function parents(node, ps) {
  if (node.parentNode === null) {
    return ps;
  }
  return parents(node.parentNode, ps.concat([node]));
}
var style$1 = function style(node, prop) {
  return getComputedStyle(node, null).getPropertyValue(prop);
};
var overflow = function overflow2(node) {
  return style$1(node, "overflow") + style$1(node, "overflow-y") + style$1(node, "overflow-x");
};
var scroll = function scroll2(node) {
  return regex.test(overflow(node));
};
function getScrollParent$1(node) {
  if (!(node instanceof HTMLElement || node instanceof SVGElement)) {
    return;
  }
  var ps = parents(node.parentNode, []);
  for (var i = 0; i < ps.length; i += 1) {
    if (scroll(ps[i])) {
      return ps[i];
    }
  }
  return document.scrollingElement || document.documentElement;
}
function _typeof$1(obj) {
  "@babel/helpers - typeof";
  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1(obj);
}
var props = {
  items: {
    type: Array,
    required: true
  },
  keyField: {
    type: String,
    default: "id"
  },
  direction: {
    type: String,
    default: "vertical",
    validator: function validator(value) {
      return ["vertical", "horizontal"].includes(value);
    }
  },
  listTag: {
    type: String,
    default: "div"
  },
  itemTag: {
    type: String,
    default: "div"
  }
};
function simpleArray() {
  return this.items.length && _typeof$1(this.items[0]) !== "object";
}
var supportsPassive = false;
if (typeof window !== "undefined") {
  supportsPassive = false;
  try {
    var opts = Object.defineProperty({}, "passive", {
      get: function get2() {
        supportsPassive = true;
      }
    });
    window.addEventListener("test", null, opts);
  } catch (e) {
  }
}
let uid = 0;
var script$2 = {
  name: "RecycleScroller",
  components: {
    ResizeObserver: script$3
  },
  directives: {
    ObserveVisibility
  },
  props: {
    ...props,
    itemSize: {
      type: Number,
      default: null
    },
    gridItems: {
      type: Number,
      default: void 0
    },
    itemSecondarySize: {
      type: Number,
      default: void 0
    },
    minItemSize: {
      type: [Number, String],
      default: null
    },
    sizeField: {
      type: String,
      default: "size"
    },
    typeField: {
      type: String,
      default: "type"
    },
    buffer: {
      type: Number,
      default: 200
    },
    pageMode: {
      type: Boolean,
      default: false
    },
    prerender: {
      type: Number,
      default: 0
    },
    emitUpdate: {
      type: Boolean,
      default: false
    },
    updateInterval: {
      type: Number,
      default: 0
    },
    skipHover: {
      type: Boolean,
      default: false
    },
    listTag: {
      type: String,
      default: "div"
    },
    itemTag: {
      type: String,
      default: "div"
    },
    listClass: {
      type: [String, Object, Array],
      default: ""
    },
    itemClass: {
      type: [String, Object, Array],
      default: ""
    }
  },
  emits: [
    "resize",
    "visible",
    "hidden",
    "update",
    "scroll-start",
    "scroll-end"
  ],
  data() {
    return {
      pool: [],
      totalSize: 0,
      ready: false,
      hoverKey: null
    };
  },
  computed: {
    sizes() {
      if (this.itemSize === null) {
        const sizes = {
          "-1": { accumulator: 0 }
        };
        const items = this.items;
        const field = this.sizeField;
        const minItemSize = this.minItemSize;
        let computedMinSize = 1e4;
        let accumulator = 0;
        let current;
        for (let i = 0, l = items.length; i < l; i++) {
          current = items[i][field] || minItemSize;
          if (current < computedMinSize) {
            computedMinSize = current;
          }
          accumulator += current;
          sizes[i] = { accumulator, size: current };
        }
        this.$_computedMinItemSize = computedMinSize;
        return sizes;
      }
      return [];
    },
    simpleArray,
    itemIndexByKey() {
      const { keyField, items } = this;
      const result = {};
      for (let i = 0, l = items.length; i < l; i++) {
        result[items[i][keyField]] = i;
      }
      return result;
    }
  },
  watch: {
    items() {
      this.updateVisibleItems(true);
    },
    pageMode() {
      this.applyPageMode();
      this.updateVisibleItems(false);
    },
    sizes: {
      handler() {
        this.updateVisibleItems(false);
      },
      deep: true
    },
    gridItems() {
      this.updateVisibleItems(true);
    },
    itemSecondarySize() {
      this.updateVisibleItems(true);
    }
  },
  created() {
    this.$_startIndex = 0;
    this.$_endIndex = 0;
    this.$_views = /* @__PURE__ */ new Map();
    this.$_unusedViews = /* @__PURE__ */ new Map();
    this.$_scrollDirty = false;
    this.$_lastUpdateScrollPosition = 0;
    if (this.prerender) {
      this.$_prerender = true;
      this.updateVisibleItems(false);
    }
    if (this.gridItems && !this.itemSize) {
      console.error("[vue-recycle-scroller] You must provide an itemSize when using gridItems");
    }
  },
  mounted() {
    this.applyPageMode();
    this.$nextTick(() => {
      this.$_prerender = false;
      this.updateVisibleItems(true);
      this.ready = true;
    });
  },
  activated() {
    const lastPosition = this.$_lastUpdateScrollPosition;
    if (typeof lastPosition === "number") {
      this.$nextTick(() => {
        this.scrollToPosition(lastPosition);
      });
    }
  },
  beforeUnmount() {
    this.removeListeners();
  },
  methods: {
    addView(pool, index2, item, key2, type2) {
      const nr = markRaw({
        id: uid++,
        index: index2,
        used: true,
        key: key2,
        type: type2
      });
      const view = shallowReactive({
        item,
        position: 0,
        nr
      });
      pool.push(view);
      return view;
    },
    unuseView(view, fake = false) {
      const unusedViews = this.$_unusedViews;
      const type2 = view.nr.type;
      let unusedPool = unusedViews.get(type2);
      if (!unusedPool) {
        unusedPool = [];
        unusedViews.set(type2, unusedPool);
      }
      unusedPool.push(view);
      if (!fake) {
        view.nr.used = false;
        view.position = -9999;
      }
    },
    handleResize() {
      this.$emit("resize");
      if (this.ready)
        this.updateVisibleItems(false);
    },
    handleScroll(event) {
      if (!this.$_scrollDirty) {
        this.$_scrollDirty = true;
        if (this.$_updateTimeout)
          return;
        const requestUpdate = () => requestAnimationFrame(() => {
          this.$_scrollDirty = false;
          const { continuous } = this.updateVisibleItems(false, true);
          if (!continuous) {
            clearTimeout(this.$_refreshTimout);
            this.$_refreshTimout = setTimeout(this.handleScroll, this.updateInterval + 100);
          }
        });
        requestUpdate();
        if (this.updateInterval) {
          this.$_updateTimeout = setTimeout(() => {
            this.$_updateTimeout = 0;
            if (this.$_scrollDirty)
              requestUpdate();
          }, this.updateInterval);
        }
      }
    },
    handleVisibilityChange(isVisible, entry) {
      if (this.ready) {
        if (isVisible || entry.boundingClientRect.width !== 0 || entry.boundingClientRect.height !== 0) {
          this.$emit("visible");
          requestAnimationFrame(() => {
            this.updateVisibleItems(false);
          });
        } else {
          this.$emit("hidden");
        }
      }
    },
    updateVisibleItems(checkItem, checkPositionDiff = false) {
      const itemSize = this.itemSize;
      const gridItems = this.gridItems || 1;
      const itemSecondarySize = this.itemSecondarySize || itemSize;
      const minItemSize = this.$_computedMinItemSize;
      const typeField = this.typeField;
      const keyField = this.simpleArray ? null : this.keyField;
      const items = this.items;
      const count = items.length;
      const sizes = this.sizes;
      const views = this.$_views;
      const unusedViews = this.$_unusedViews;
      const pool = this.pool;
      const itemIndexByKey = this.itemIndexByKey;
      let startIndex, endIndex;
      let totalSize;
      let visibleStartIndex, visibleEndIndex;
      if (!count) {
        startIndex = endIndex = visibleStartIndex = visibleEndIndex = totalSize = 0;
      } else if (this.$_prerender) {
        startIndex = visibleStartIndex = 0;
        endIndex = visibleEndIndex = Math.min(this.prerender, items.length);
        totalSize = null;
      } else {
        const scroll3 = this.getScroll();
        if (checkPositionDiff) {
          let positionDiff = scroll3.start - this.$_lastUpdateScrollPosition;
          if (positionDiff < 0)
            positionDiff = -positionDiff;
          if (itemSize === null && positionDiff < minItemSize || positionDiff < itemSize) {
            return {
              continuous: true
            };
          }
        }
        this.$_lastUpdateScrollPosition = scroll3.start;
        const buffer2 = this.buffer;
        scroll3.start -= buffer2;
        scroll3.end += buffer2;
        let beforeSize = 0;
        if (this.$refs.before) {
          beforeSize = this.$refs.before.scrollHeight;
          scroll3.start -= beforeSize;
        }
        if (this.$refs.after) {
          const afterSize = this.$refs.after.scrollHeight;
          scroll3.end += afterSize;
        }
        if (itemSize === null) {
          let h2;
          let a = 0;
          let b2 = count - 1;
          let i = ~~(count / 2);
          let oldI;
          do {
            oldI = i;
            h2 = sizes[i].accumulator;
            if (h2 < scroll3.start) {
              a = i;
            } else if (i < count - 1 && sizes[i + 1].accumulator > scroll3.start) {
              b2 = i;
            }
            i = ~~((a + b2) / 2);
          } while (i !== oldI);
          i < 0 && (i = 0);
          startIndex = i;
          totalSize = sizes[count - 1].accumulator;
          for (endIndex = i; endIndex < count && sizes[endIndex].accumulator < scroll3.end; endIndex++)
            ;
          if (endIndex === -1) {
            endIndex = items.length - 1;
          } else {
            endIndex++;
            endIndex > count && (endIndex = count);
          }
          for (visibleStartIndex = startIndex; visibleStartIndex < count && beforeSize + sizes[visibleStartIndex].accumulator < scroll3.start; visibleStartIndex++)
            ;
          for (visibleEndIndex = visibleStartIndex; visibleEndIndex < count && beforeSize + sizes[visibleEndIndex].accumulator < scroll3.end; visibleEndIndex++)
            ;
        } else {
          startIndex = ~~(scroll3.start / itemSize * gridItems);
          const remainer = startIndex % gridItems;
          startIndex -= remainer;
          endIndex = Math.ceil(scroll3.end / itemSize * gridItems);
          visibleStartIndex = Math.max(0, Math.floor((scroll3.start - beforeSize) / itemSize * gridItems));
          visibleEndIndex = Math.floor((scroll3.end - beforeSize) / itemSize * gridItems);
          startIndex < 0 && (startIndex = 0);
          endIndex > count && (endIndex = count);
          visibleStartIndex < 0 && (visibleStartIndex = 0);
          visibleEndIndex > count && (visibleEndIndex = count);
          totalSize = Math.ceil(count / gridItems) * itemSize;
        }
      }
      if (endIndex - startIndex > config.itemsLimit) {
        this.itemsLimitError();
      }
      this.totalSize = totalSize;
      let view;
      const continuous = startIndex <= this.$_endIndex && endIndex >= this.$_startIndex;
      if (continuous) {
        for (let i = 0, l = pool.length; i < l; i++) {
          view = pool[i];
          if (view.nr.used) {
            if (checkItem) {
              view.nr.index = itemIndexByKey[view.item[keyField]];
            }
            if (view.nr.index == null || view.nr.index < startIndex || view.nr.index >= endIndex) {
              this.unuseView(view);
            }
          }
        }
      }
      const unusedIndex = continuous ? null : /* @__PURE__ */ new Map();
      let item, type2;
      let v2;
      for (let i = startIndex; i < endIndex; i++) {
        item = items[i];
        const key2 = keyField ? item[keyField] : item;
        if (key2 == null) {
          throw new Error(`Key is ${key2} on item (keyField is '${keyField}')`);
        }
        view = views.get(key2);
        if (!itemSize && !sizes[i].size) {
          if (view)
            this.unuseView(view);
          continue;
        }
        type2 = item[typeField];
        let unusedPool = unusedViews.get(type2);
        let newlyUsedView = false;
        if (!view) {
          if (continuous) {
            if (unusedPool && unusedPool.length) {
              view = unusedPool.pop();
            } else {
              view = this.addView(pool, i, item, key2, type2);
            }
          } else {
            v2 = unusedIndex.get(type2) || 0;
            if (!unusedPool || v2 >= unusedPool.length) {
              view = this.addView(pool, i, item, key2, type2);
              this.unuseView(view, true);
              unusedPool = unusedViews.get(type2);
            }
            view = unusedPool[v2];
            unusedIndex.set(type2, v2 + 1);
          }
          views.delete(view.nr.key);
          view.nr.used = true;
          view.nr.index = i;
          view.nr.key = key2;
          view.nr.type = type2;
          views.set(key2, view);
          newlyUsedView = true;
        } else {
          if (!view.nr.used) {
            view.nr.used = true;
            newlyUsedView = true;
            if (unusedPool) {
              const index2 = unusedPool.indexOf(view);
              if (index2 !== -1)
                unusedPool.splice(index2, 1);
            }
          }
        }
        view.item = item;
        if (newlyUsedView) {
          if (i === items.length - 1)
            this.$emit("scroll-end");
          if (i === 0)
            this.$emit("scroll-start");
        }
        if (itemSize === null) {
          view.position = sizes[i - 1].accumulator;
          view.offset = 0;
        } else {
          view.position = Math.floor(i / gridItems) * itemSize;
          view.offset = i % gridItems * itemSecondarySize;
        }
      }
      this.$_startIndex = startIndex;
      this.$_endIndex = endIndex;
      if (this.emitUpdate)
        this.$emit("update", startIndex, endIndex, visibleStartIndex, visibleEndIndex);
      clearTimeout(this.$_sortTimer);
      this.$_sortTimer = setTimeout(this.sortViews, this.updateInterval + 300);
      return {
        continuous
      };
    },
    getListenerTarget() {
      let target = getScrollParent$1(this.$el);
      if (window.document && (target === window.document.documentElement || target === window.document.body)) {
        target = window;
      }
      return target;
    },
    getScroll() {
      const { $el: el, direction } = this;
      const isVertical = direction === "vertical";
      let scrollState;
      if (this.pageMode) {
        const bounds = el.getBoundingClientRect();
        const boundsSize = isVertical ? bounds.height : bounds.width;
        let start = -(isVertical ? bounds.top : bounds.left);
        let size2 = isVertical ? window.innerHeight : window.innerWidth;
        if (start < 0) {
          size2 += start;
          start = 0;
        }
        if (start + size2 > boundsSize) {
          size2 = boundsSize - start;
        }
        scrollState = {
          start,
          end: start + size2
        };
      } else if (isVertical) {
        scrollState = {
          start: el.scrollTop,
          end: el.scrollTop + el.clientHeight
        };
      } else {
        scrollState = {
          start: el.scrollLeft,
          end: el.scrollLeft + el.clientWidth
        };
      }
      return scrollState;
    },
    applyPageMode() {
      if (this.pageMode) {
        this.addListeners();
      } else {
        this.removeListeners();
      }
    },
    addListeners() {
      this.listenerTarget = this.getListenerTarget();
      this.listenerTarget.addEventListener("scroll", this.handleScroll, supportsPassive ? {
        passive: true
      } : false);
      this.listenerTarget.addEventListener("resize", this.handleResize);
    },
    removeListeners() {
      if (!this.listenerTarget) {
        return;
      }
      this.listenerTarget.removeEventListener("scroll", this.handleScroll);
      this.listenerTarget.removeEventListener("resize", this.handleResize);
      this.listenerTarget = null;
    },
    scrollToItem(index2) {
      let scroll3;
      const gridItems = this.gridItems || 1;
      if (this.itemSize === null) {
        scroll3 = index2 > 0 ? this.sizes[index2 - 1].accumulator : 0;
      } else {
        scroll3 = Math.floor(index2 / gridItems) * this.itemSize;
      }
      this.scrollToPosition(scroll3);
    },
    scrollToPosition(position) {
      const direction = this.direction === "vertical" ? { scroll: "scrollTop", start: "top" } : { scroll: "scrollLeft", start: "left" };
      let viewport;
      let scrollDirection;
      let scrollDistance;
      if (this.pageMode) {
        const viewportEl = getScrollParent$1(this.$el);
        const scrollTop = viewportEl.tagName === "HTML" ? 0 : viewportEl[direction.scroll];
        const bounds = viewportEl.getBoundingClientRect();
        const scroller = this.$el.getBoundingClientRect();
        const scrollerPosition = scroller[direction.start] - bounds[direction.start];
        viewport = viewportEl;
        scrollDirection = direction.scroll;
        scrollDistance = position + scrollTop + scrollerPosition;
      } else {
        viewport = this.$el;
        scrollDirection = direction.scroll;
        scrollDistance = position;
      }
      viewport[scrollDirection] = scrollDistance;
    },
    itemsLimitError() {
      setTimeout(() => {
        console.log("It seems the scroller element isn't scrolling, so it tries to render all the items at once.", "Scroller:", this.$el);
        console.log("Make sure the scroller has a fixed height (or width) and 'overflow-y' (or 'overflow-x') set to 'auto' so it can scroll correctly and only render the items visible in the scroll viewport.");
      });
      throw new Error("Rendered items limit reached");
    },
    sortViews() {
      this.pool.sort((viewA, viewB) => viewA.nr.index - viewB.nr.index);
    }
  }
};
const _hoisted_1 = {
  key: 0,
  ref: "before",
  class: "vue-recycle-scroller__slot"
};
const _hoisted_2 = {
  key: 1,
  ref: "after",
  class: "vue-recycle-scroller__slot"
};
function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ResizeObserver = resolveComponent("ResizeObserver");
  const _directive_observe_visibility = resolveDirective("observe-visibility");
  return withDirectives((openBlock(), createElementBlock(
    "div",
    {
      class: normalizeClass(["vue-recycle-scroller", {
        ready: $data.ready,
        "page-mode": $props.pageMode,
        [`direction-${_ctx.direction}`]: true
      }]),
      onScrollPassive: _cache[0] || (_cache[0] = (...args) => $options.handleScroll && $options.handleScroll(...args))
    },
    [
      _ctx.$slots.before ? (openBlock(), createElementBlock(
        "div",
        _hoisted_1,
        [
          renderSlot(_ctx.$slots, "before")
        ],
        512
        /* NEED_PATCH */
      )) : createCommentVNode("v-if", true),
      (openBlock(), createBlock(resolveDynamicComponent($props.listTag), {
        ref: "wrapper",
        style: normalizeStyle({ [_ctx.direction === "vertical" ? "minHeight" : "minWidth"]: $data.totalSize + "px" }),
        class: normalizeClass(["vue-recycle-scroller__item-wrapper", $props.listClass])
      }, {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(
            Fragment,
            null,
            renderList($data.pool, (view) => {
              return openBlock(), createBlock(resolveDynamicComponent($props.itemTag), mergeProps({
                key: view.nr.id,
                style: $data.ready ? {
                  transform: `translate${_ctx.direction === "vertical" ? "Y" : "X"}(${view.position}px) translate${_ctx.direction === "vertical" ? "X" : "Y"}(${view.offset}px)`,
                  width: $props.gridItems ? `${_ctx.direction === "vertical" ? $props.itemSecondarySize || $props.itemSize : $props.itemSize}px` : void 0,
                  height: $props.gridItems ? `${_ctx.direction === "horizontal" ? $props.itemSecondarySize || $props.itemSize : $props.itemSize}px` : void 0
                } : null,
                class: ["vue-recycle-scroller__item-view", [
                  $props.itemClass,
                  {
                    hover: !$props.skipHover && $data.hoverKey === view.nr.key
                  }
                ]]
              }, toHandlers($props.skipHover ? {} : {
                mouseenter: () => {
                  $data.hoverKey = view.nr.key;
                },
                mouseleave: () => {
                  $data.hoverKey = null;
                }
              })), {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "default", {
                    item: view.item,
                    index: view.nr.index,
                    active: view.nr.used
                  })
                ]),
                _: 2
                /* DYNAMIC */
              }, 1040, ["style", "class"]);
            }),
            128
            /* KEYED_FRAGMENT */
          )),
          renderSlot(_ctx.$slots, "empty")
        ]),
        _: 3
        /* FORWARDED */
      }, 8, ["style", "class"])),
      _ctx.$slots.after ? (openBlock(), createElementBlock(
        "div",
        _hoisted_2,
        [
          renderSlot(_ctx.$slots, "after")
        ],
        512
        /* NEED_PATCH */
      )) : createCommentVNode("v-if", true),
      createVNode(_component_ResizeObserver, { onNotify: $options.handleResize }, null, 8, ["onNotify"])
    ],
    34
    /* CLASS, HYDRATE_EVENTS */
  )), [
    [_directive_observe_visibility, $options.handleVisibilityChange]
  ]);
}
script$2.render = render$1;
script$2.__file = "src/components/RecycleScroller.vue";
var script$1 = {
  name: "DynamicScroller",
  components: {
    RecycleScroller: script$2
  },
  provide() {
    if (typeof ResizeObserver !== "undefined") {
      this.$_resizeObserver = new ResizeObserver((entries) => {
        requestAnimationFrame(() => {
          if (!Array.isArray(entries)) {
            return;
          }
          for (const entry of entries) {
            if (entry.target && entry.target.$_vs_onResize) {
              let width, height;
              if (entry.borderBoxSize) {
                const resizeObserverSize = entry.borderBoxSize[0];
                width = resizeObserverSize.inlineSize;
                height = resizeObserverSize.blockSize;
              } else {
                width = entry.contentRect.width;
                height = entry.contentRect.height;
              }
              entry.target.$_vs_onResize(entry.target.$_vs_id, width, height);
            }
          }
        });
      });
    }
    return {
      vscrollData: this.vscrollData,
      vscrollParent: this,
      vscrollResizeObserver: this.$_resizeObserver
    };
  },
  inheritAttrs: false,
  props: {
    ...props,
    minItemSize: {
      type: [Number, String],
      required: true
    }
  },
  emits: [
    "resize",
    "visible"
  ],
  data() {
    return {
      vscrollData: {
        active: true,
        sizes: {},
        keyField: this.keyField,
        simpleArray: false
      }
    };
  },
  computed: {
    simpleArray,
    itemsWithSize() {
      const result = [];
      const { items, keyField, simpleArray: simpleArray2 } = this;
      const sizes = this.vscrollData.sizes;
      const l = items.length;
      for (let i = 0; i < l; i++) {
        const item = items[i];
        const id = simpleArray2 ? i : item[keyField];
        let size2 = sizes[id];
        if (typeof size2 === "undefined" && !this.$_undefinedMap[id]) {
          size2 = 0;
        }
        result.push({
          item,
          id,
          size: size2
        });
      }
      return result;
    }
  },
  watch: {
    items() {
      this.forceUpdate();
    },
    simpleArray: {
      handler(value) {
        this.vscrollData.simpleArray = value;
      },
      immediate: true
    },
    direction(value) {
      this.forceUpdate(true);
    },
    itemsWithSize(next, prev) {
      const scrollTop = this.$el.scrollTop;
      let prevActiveTop = 0;
      let activeTop = 0;
      const length = Math.min(next.length, prev.length);
      for (let i = 0; i < length; i++) {
        if (prevActiveTop >= scrollTop) {
          break;
        }
        prevActiveTop += prev[i].size || this.minItemSize;
        activeTop += next[i].size || this.minItemSize;
      }
      const offset = activeTop - prevActiveTop;
      if (offset === 0) {
        return;
      }
      this.$el.scrollTop += offset;
    }
  },
  beforeCreate() {
    this.$_updates = [];
    this.$_undefinedSizes = 0;
    this.$_undefinedMap = {};
    this.$_events = mitt();
  },
  activated() {
    this.vscrollData.active = true;
  },
  deactivated() {
    this.vscrollData.active = false;
  },
  unmounted() {
    this.$_events.all.clear();
  },
  methods: {
    onScrollerResize() {
      const scroller = this.$refs.scroller;
      if (scroller) {
        this.forceUpdate();
      }
      this.$emit("resize");
    },
    onScrollerVisible() {
      this.$_events.emit("vscroll:update", { force: false });
      this.$emit("visible");
    },
    forceUpdate(clear2 = false) {
      if (clear2 || this.simpleArray) {
        this.vscrollData.sizes = {};
      }
      this.$_events.emit("vscroll:update", { force: true });
    },
    scrollToItem(index2) {
      const scroller = this.$refs.scroller;
      if (scroller)
        scroller.scrollToItem(index2);
    },
    getItemSize(item, index2 = void 0) {
      const id = this.simpleArray ? index2 != null ? index2 : this.items.indexOf(item) : item[this.keyField];
      return this.vscrollData.sizes[id] || 0;
    },
    scrollToBottom() {
      if (this.$_scrollingToBottom)
        return;
      this.$_scrollingToBottom = true;
      const el = this.$el;
      this.$nextTick(() => {
        el.scrollTop = el.scrollHeight + 5e3;
        const cb = () => {
          el.scrollTop = el.scrollHeight + 5e3;
          requestAnimationFrame(() => {
            el.scrollTop = el.scrollHeight + 5e3;
            if (this.$_undefinedSizes === 0) {
              this.$_scrollingToBottom = false;
            } else {
              requestAnimationFrame(cb);
            }
          });
        };
        requestAnimationFrame(cb);
      });
    }
  }
};
function render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_RecycleScroller = resolveComponent("RecycleScroller");
  return openBlock(), createBlock(_component_RecycleScroller, mergeProps({
    ref: "scroller",
    items: $options.itemsWithSize,
    "min-item-size": $props.minItemSize,
    direction: _ctx.direction,
    "key-field": "id",
    "list-tag": _ctx.listTag,
    "item-tag": _ctx.itemTag
  }, _ctx.$attrs, {
    onResize: $options.onScrollerResize,
    onVisible: $options.onScrollerVisible
  }), {
    default: withCtx(({ item: itemWithSize, index: index2, active }) => [
      renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({
        item: itemWithSize.item,
        index: index2,
        active,
        itemWithSize
      })))
    ]),
    before: withCtx(() => [
      renderSlot(_ctx.$slots, "before")
    ]),
    after: withCtx(() => [
      renderSlot(_ctx.$slots, "after")
    ]),
    empty: withCtx(() => [
      renderSlot(_ctx.$slots, "empty")
    ]),
    _: 3
    /* FORWARDED */
  }, 16, ["items", "min-item-size", "direction", "list-tag", "item-tag", "onResize", "onVisible"]);
}
script$1.render = render;
script$1.__file = "src/components/DynamicScroller.vue";
var script = {
  name: "DynamicScrollerItem",
  inject: [
    "vscrollData",
    "vscrollParent",
    "vscrollResizeObserver"
  ],
  props: {
    // eslint-disable-next-line vue/require-prop-types
    item: {
      required: true
    },
    watchData: {
      type: Boolean,
      default: false
    },
    /**
     * Indicates if the view is actively used to display an item.
     */
    active: {
      type: Boolean,
      required: true
    },
    index: {
      type: Number,
      default: void 0
    },
    sizeDependencies: {
      type: [Array, Object],
      default: null
    },
    emitResize: {
      type: Boolean,
      default: false
    },
    tag: {
      type: String,
      default: "div"
    }
  },
  emits: [
    "resize"
  ],
  computed: {
    id() {
      if (this.vscrollData.simpleArray)
        return this.index;
      if (this.vscrollData.keyField in this.item)
        return this.item[this.vscrollData.keyField];
      throw new Error(`keyField '${this.vscrollData.keyField}' not found in your item. You should set a valid keyField prop on your Scroller`);
    },
    size() {
      return this.vscrollData.sizes[this.id] || 0;
    },
    finalActive() {
      return this.active && this.vscrollData.active;
    }
  },
  watch: {
    watchData: "updateWatchData",
    id(value, oldValue) {
      this.$el.$_vs_id = this.id;
      if (!this.size) {
        this.onDataUpdate();
      }
      if (this.$_sizeObserved) {
        const oldSize = this.vscrollData.sizes[oldValue];
        const size2 = this.vscrollData.sizes[value];
        if (oldSize != null && oldSize !== size2) {
          this.applySize(oldSize);
        }
      }
    },
    finalActive(value) {
      if (!this.size) {
        if (value) {
          if (!this.vscrollParent.$_undefinedMap[this.id]) {
            this.vscrollParent.$_undefinedSizes++;
            this.vscrollParent.$_undefinedMap[this.id] = true;
          }
        } else {
          if (this.vscrollParent.$_undefinedMap[this.id]) {
            this.vscrollParent.$_undefinedSizes--;
            this.vscrollParent.$_undefinedMap[this.id] = false;
          }
        }
      }
      if (this.vscrollResizeObserver) {
        if (value) {
          this.observeSize();
        } else {
          this.unobserveSize();
        }
      } else if (value && this.$_pendingVScrollUpdate === this.id) {
        this.updateSize();
      }
    }
  },
  created() {
    if (this.$isServer)
      return;
    this.$_forceNextVScrollUpdate = null;
    this.updateWatchData();
    if (!this.vscrollResizeObserver) {
      for (const k2 in this.sizeDependencies) {
        this.$watch(() => this.sizeDependencies[k2], this.onDataUpdate);
      }
      this.vscrollParent.$_events.on("vscroll:update", this.onVscrollUpdate);
    }
  },
  mounted() {
    if (this.finalActive) {
      this.updateSize();
      this.observeSize();
    }
  },
  beforeUnmount() {
    this.vscrollParent.$_events.off("vscroll:update", this.onVscrollUpdate);
    this.unobserveSize();
  },
  methods: {
    updateSize() {
      if (this.finalActive) {
        if (this.$_pendingSizeUpdate !== this.id) {
          this.$_pendingSizeUpdate = this.id;
          this.$_forceNextVScrollUpdate = null;
          this.$_pendingVScrollUpdate = null;
          this.computeSize(this.id);
        }
      } else {
        this.$_forceNextVScrollUpdate = this.id;
      }
    },
    updateWatchData() {
      if (this.watchData && !this.vscrollResizeObserver) {
        this.$_watchData = this.$watch("item", () => {
          this.onDataUpdate();
        }, {
          deep: true
        });
      } else if (this.$_watchData) {
        this.$_watchData();
        this.$_watchData = null;
      }
    },
    onVscrollUpdate({ force }) {
      if (!this.finalActive && force) {
        this.$_pendingVScrollUpdate = this.id;
      }
      if (this.$_forceNextVScrollUpdate === this.id || force || !this.size) {
        this.updateSize();
      }
    },
    onDataUpdate() {
      this.updateSize();
    },
    computeSize(id) {
      this.$nextTick(() => {
        if (this.id === id) {
          const width = this.$el.offsetWidth;
          const height = this.$el.offsetHeight;
          this.applyWidthHeight(width, height);
        }
        this.$_pendingSizeUpdate = null;
      });
    },
    applyWidthHeight(width, height) {
      const size2 = ~~(this.vscrollParent.direction === "vertical" ? height : width);
      if (size2 && this.size !== size2) {
        this.applySize(size2);
      }
    },
    applySize(size2) {
      if (this.vscrollParent.$_undefinedMap[this.id]) {
        this.vscrollParent.$_undefinedSizes--;
        this.vscrollParent.$_undefinedMap[this.id] = void 0;
      }
      this.vscrollData.sizes[this.id] = size2;
      if (this.emitResize)
        this.$emit("resize", this.id);
    },
    observeSize() {
      if (!this.vscrollResizeObserver)
        return;
      if (this.$_sizeObserved)
        return;
      this.vscrollResizeObserver.observe(this.$el);
      this.$el.$_vs_id = this.id;
      this.$el.$_vs_onResize = this.onResize;
      this.$_sizeObserved = true;
    },
    unobserveSize() {
      if (!this.vscrollResizeObserver)
        return;
      if (!this.$_sizeObserved)
        return;
      this.vscrollResizeObserver.unobserve(this.$el);
      this.$el.$_vs_onResize = void 0;
      this.$_sizeObserved = false;
    },
    onResize(id, width, height) {
      if (this.id === id) {
        this.applyWidthHeight(width, height);
      }
    }
  },
  render() {
    return h(this.tag, this.$slots.default());
  }
};
script.__file = "src/components/DynamicScrollerItem.vue";
function registerComponents(app, prefix) {
  app.component("".concat(prefix, "recycle-scroller"), script$2);
  app.component("".concat(prefix, "RecycleScroller"), script$2);
  app.component("".concat(prefix, "dynamic-scroller"), script$1);
  app.component("".concat(prefix, "DynamicScroller"), script$1);
  app.component("".concat(prefix, "dynamic-scroller-item"), script);
  app.component("".concat(prefix, "DynamicScrollerItem"), script);
}
var plugin = {
  // eslint-disable-next-line no-undef
  version: "2.0.0-beta.8",
  install: function install2(app, options) {
    var finalOptions = Object.assign({}, {
      installComponents: true,
      componentsPrefix: ""
    }, options);
    for (var key2 in finalOptions) {
      if (typeof finalOptions[key2] !== "undefined") {
        config[key2] = finalOptions[key2];
      }
    }
    if (finalOptions.installComponents) {
      registerComponents(app, finalOptions.componentsPrefix);
    }
  }
};
const vueVirtualScroller = "";
var axios$4 = { exports: {} };
var bind$4 = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};
var bind$3 = bind$4;
var toString$1 = Object.prototype.toString;
function isArray$4(val) {
  return toString$1.call(val) === "[object Array]";
}
function isUndefined(val) {
  return typeof val === "undefined";
}
function isBuffer$1(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
}
function isArrayBuffer(val) {
  return toString$1.call(val) === "[object ArrayBuffer]";
}
function isFormData(val) {
  return typeof FormData !== "undefined" && val instanceof FormData;
}
function isArrayBufferView(val) {
  var result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && val.buffer instanceof ArrayBuffer;
  }
  return result;
}
function isString$1(val) {
  return typeof val === "string";
}
function isNumber$1(val) {
  return typeof val === "number";
}
function isObject$1(val) {
  return val !== null && typeof val === "object";
}
function isDate$1(val) {
  return toString$1.call(val) === "[object Date]";
}
function isFile(val) {
  return toString$1.call(val) === "[object File]";
}
function isBlob(val) {
  return toString$1.call(val) === "[object Blob]";
}
function isFunction(val) {
  return toString$1.call(val) === "[object Function]";
}
function isStream(val) {
  return isObject$1(val) && isFunction(val.pipe);
}
function isURLSearchParams(val) {
  return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
}
function trim(str) {
  return str.replace(/^\s*/, "").replace(/\s*$/, "");
}
function isStandardBrowserEnv() {
  if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function forEach(obj, fn) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray$4(obj)) {
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    for (var key2 in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key2)) {
        fn.call(null, obj[key2], key2, obj);
      }
    }
  }
}
function merge$1() {
  var result = {};
  function assignValue(val, key2) {
    if (typeof result[key2] === "object" && typeof val === "object") {
      result[key2] = merge$1(result[key2], val);
    } else {
      result[key2] = val;
    }
  }
  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}
function deepMerge() {
  var result = {};
  function assignValue(val, key2) {
    if (typeof result[key2] === "object" && typeof val === "object") {
      result[key2] = deepMerge(result[key2], val);
    } else if (typeof val === "object") {
      result[key2] = deepMerge({}, val);
    } else {
      result[key2] = val;
    }
  }
  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}
function extend$1(a, b2, thisArg) {
  forEach(b2, function assignValue(val, key2) {
    if (thisArg && typeof val === "function") {
      a[key2] = bind$3(val, thisArg);
    } else {
      a[key2] = val;
    }
  });
  return a;
}
var utils$c = {
  isArray: isArray$4,
  isArrayBuffer,
  isBuffer: isBuffer$1,
  isFormData,
  isArrayBufferView,
  isString: isString$1,
  isNumber: isNumber$1,
  isObject: isObject$1,
  isUndefined,
  isDate: isDate$1,
  isFile,
  isBlob,
  isFunction,
  isStream,
  isURLSearchParams,
  isStandardBrowserEnv,
  forEach,
  merge: merge$1,
  deepMerge,
  extend: extend$1,
  trim
};
var utils$b = utils$c;
function encode$1(val) {
  return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
var buildURL$1 = function buildURL(url, params, paramsSerializer) {
  if (!params) {
    return url;
  }
  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils$b.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];
    utils$b.forEach(params, function serialize(val, key2) {
      if (val === null || typeof val === "undefined") {
        return;
      }
      if (utils$b.isArray(val)) {
        key2 = key2 + "[]";
      } else {
        val = [val];
      }
      utils$b.forEach(val, function parseValue(v2) {
        if (utils$b.isDate(v2)) {
          v2 = v2.toISOString();
        } else if (utils$b.isObject(v2)) {
          v2 = JSON.stringify(v2);
        }
        parts.push(encode$1(key2) + "=" + encode$1(v2));
      });
    });
    serializedParams = parts.join("&");
  }
  if (serializedParams) {
    var hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
};
var utils$a = utils$c;
function InterceptorManager$1() {
  this.handlers = [];
}
InterceptorManager$1.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled,
    rejected
  });
  return this.handlers.length - 1;
};
InterceptorManager$1.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};
InterceptorManager$1.prototype.forEach = function forEach2(fn) {
  utils$a.forEach(this.handlers, function forEachHandler(h2) {
    if (h2 !== null) {
      fn(h2);
    }
  });
};
var InterceptorManager_1 = InterceptorManager$1;
var utils$9 = utils$c;
var transformData$1 = function transformData(data, headers, fns) {
  utils$9.forEach(fns, function transform2(fn) {
    data = fn(data, headers);
  });
  return data;
};
var isCancel$1;
var hasRequiredIsCancel;
function requireIsCancel() {
  if (hasRequiredIsCancel)
    return isCancel$1;
  hasRequiredIsCancel = 1;
  isCancel$1 = function isCancel2(value) {
    return !!(value && value.__CANCEL__);
  };
  return isCancel$1;
}
var utils$8 = utils$c;
var normalizeHeaderName$1 = function normalizeHeaderName(headers, normalizedName) {
  utils$8.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};
var enhanceError;
var hasRequiredEnhanceError;
function requireEnhanceError() {
  if (hasRequiredEnhanceError)
    return enhanceError;
  hasRequiredEnhanceError = 1;
  enhanceError = function enhanceError2(error, config2, code, request2, response) {
    error.config = config2;
    if (code) {
      error.code = code;
    }
    error.request = request2;
    error.response = response;
    error.isAxiosError = true;
    error.toJSON = function() {
      return {
        // Standard
        message: this.message,
        name: this.name,
        // Microsoft
        description: this.description,
        number: this.number,
        // Mozilla
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        // Axios
        config: this.config,
        code: this.code
      };
    };
    return error;
  };
  return enhanceError;
}
var createError;
var hasRequiredCreateError;
function requireCreateError() {
  if (hasRequiredCreateError)
    return createError;
  hasRequiredCreateError = 1;
  var enhanceError2 = requireEnhanceError();
  createError = function createError2(message, config2, code, request2, response) {
    var error = new Error(message);
    return enhanceError2(error, config2, code, request2, response);
  };
  return createError;
}
var settle;
var hasRequiredSettle;
function requireSettle() {
  if (hasRequiredSettle)
    return settle;
  hasRequiredSettle = 1;
  var createError2 = requireCreateError();
  settle = function settle2(resolve2, reject, response) {
    var validateStatus2 = response.config.validateStatus;
    if (!validateStatus2 || validateStatus2(response.status)) {
      resolve2(response);
    } else {
      reject(createError2(
        "Request failed with status code " + response.status,
        response.config,
        null,
        response.request,
        response
      ));
    }
  };
  return settle;
}
var isAbsoluteURL;
var hasRequiredIsAbsoluteURL;
function requireIsAbsoluteURL() {
  if (hasRequiredIsAbsoluteURL)
    return isAbsoluteURL;
  hasRequiredIsAbsoluteURL = 1;
  isAbsoluteURL = function isAbsoluteURL2(url) {
    return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
  };
  return isAbsoluteURL;
}
var combineURLs;
var hasRequiredCombineURLs;
function requireCombineURLs() {
  if (hasRequiredCombineURLs)
    return combineURLs;
  hasRequiredCombineURLs = 1;
  combineURLs = function combineURLs2(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
  };
  return combineURLs;
}
var buildFullPath;
var hasRequiredBuildFullPath;
function requireBuildFullPath() {
  if (hasRequiredBuildFullPath)
    return buildFullPath;
  hasRequiredBuildFullPath = 1;
  var isAbsoluteURL2 = requireIsAbsoluteURL();
  var combineURLs2 = requireCombineURLs();
  buildFullPath = function buildFullPath2(baseURL, requestedURL) {
    if (baseURL && !isAbsoluteURL2(requestedURL)) {
      return combineURLs2(baseURL, requestedURL);
    }
    return requestedURL;
  };
  return buildFullPath;
}
var parseHeaders;
var hasRequiredParseHeaders;
function requireParseHeaders() {
  if (hasRequiredParseHeaders)
    return parseHeaders;
  hasRequiredParseHeaders = 1;
  var utils2 = utils$c;
  var ignoreDuplicateOf = [
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ];
  parseHeaders = function parseHeaders2(headers) {
    var parsed = {};
    var key2;
    var val;
    var i;
    if (!headers) {
      return parsed;
    }
    utils2.forEach(headers.split("\n"), function parser(line2) {
      i = line2.indexOf(":");
      key2 = utils2.trim(line2.substr(0, i)).toLowerCase();
      val = utils2.trim(line2.substr(i + 1));
      if (key2) {
        if (parsed[key2] && ignoreDuplicateOf.indexOf(key2) >= 0) {
          return;
        }
        if (key2 === "set-cookie") {
          parsed[key2] = (parsed[key2] ? parsed[key2] : []).concat([val]);
        } else {
          parsed[key2] = parsed[key2] ? parsed[key2] + ", " + val : val;
        }
      }
    });
    return parsed;
  };
  return parseHeaders;
}
var isURLSameOrigin;
var hasRequiredIsURLSameOrigin;
function requireIsURLSameOrigin() {
  if (hasRequiredIsURLSameOrigin)
    return isURLSameOrigin;
  hasRequiredIsURLSameOrigin = 1;
  var utils2 = utils$c;
  isURLSameOrigin = utils2.isStandardBrowserEnv() ? (
    // Standard browser envs have full support of the APIs needed to test
    // whether the request URL is of the same origin as current location.
    function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement("a");
      var originURL;
      function resolveURL(url) {
        var href = url;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
      }
      originURL = resolveURL(window.location.href);
      return function isURLSameOrigin2(requestURL) {
        var parsed = utils2.isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
      };
    }()
  ) : (
    // Non standard browser envs (web workers, react-native) lack needed support.
    function nonStandardBrowserEnv() {
      return function isURLSameOrigin2() {
        return true;
      };
    }()
  );
  return isURLSameOrigin;
}
var cookies;
var hasRequiredCookies;
function requireCookies() {
  if (hasRequiredCookies)
    return cookies;
  hasRequiredCookies = 1;
  var utils2 = utils$c;
  cookies = utils2.isStandardBrowserEnv() ? (
    // Standard browser envs support document.cookie
    function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + "=" + encodeURIComponent(value));
          if (utils2.isNumber(expires)) {
            cookie.push("expires=" + new Date(expires).toGMTString());
          }
          if (utils2.isString(path)) {
            cookie.push("path=" + path);
          }
          if (utils2.isString(domain)) {
            cookie.push("domain=" + domain);
          }
          if (secure === true) {
            cookie.push("secure");
          }
          document.cookie = cookie.join("; ");
        },
        read: function read2(name) {
          var match2 = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match2 ? decodeURIComponent(match2[3]) : null;
        },
        remove: function remove2(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      };
    }()
  ) : (
    // Non standard browser env (web workers, react-native) lack needed support.
    function nonStandardBrowserEnv() {
      return {
        write: function write() {
        },
        read: function read2() {
          return null;
        },
        remove: function remove2() {
        }
      };
    }()
  );
  return cookies;
}
var xhr;
var hasRequiredXhr;
function requireXhr() {
  if (hasRequiredXhr)
    return xhr;
  hasRequiredXhr = 1;
  var utils2 = utils$c;
  var settle2 = requireSettle();
  var buildURL3 = buildURL$1;
  var buildFullPath2 = requireBuildFullPath();
  var parseHeaders2 = requireParseHeaders();
  var isURLSameOrigin2 = requireIsURLSameOrigin();
  var createError2 = requireCreateError();
  xhr = function xhrAdapter(config2) {
    return new Promise(function dispatchXhrRequest(resolve2, reject) {
      var requestData = config2.data;
      var requestHeaders = config2.headers;
      if (utils2.isFormData(requestData)) {
        delete requestHeaders["Content-Type"];
      }
      var request2 = new XMLHttpRequest();
      if (config2.auth) {
        var username = config2.auth.username || "";
        var password = config2.auth.password || "";
        requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
      }
      var fullPath = buildFullPath2(config2.baseURL, config2.url);
      request2.open(config2.method.toUpperCase(), buildURL3(fullPath, config2.params, config2.paramsSerializer), true);
      request2.timeout = config2.timeout;
      request2.onreadystatechange = function handleLoad() {
        if (!request2 || request2.readyState !== 4) {
          return;
        }
        if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
          return;
        }
        var responseHeaders = "getAllResponseHeaders" in request2 ? parseHeaders2(request2.getAllResponseHeaders()) : null;
        var responseData = !config2.responseType || config2.responseType === "text" ? request2.responseText : request2.response;
        var response = {
          data: responseData,
          status: request2.status,
          statusText: request2.statusText,
          headers: responseHeaders,
          config: config2,
          request: request2
        };
        settle2(resolve2, reject, response);
        request2 = null;
      };
      request2.onabort = function handleAbort() {
        if (!request2) {
          return;
        }
        reject(createError2("Request aborted", config2, "ECONNABORTED", request2));
        request2 = null;
      };
      request2.onerror = function handleError2() {
        reject(createError2("Network Error", config2, null, request2));
        request2 = null;
      };
      request2.ontimeout = function handleTimeout() {
        var timeoutErrorMessage = "timeout of " + config2.timeout + "ms exceeded";
        if (config2.timeoutErrorMessage) {
          timeoutErrorMessage = config2.timeoutErrorMessage;
        }
        reject(createError2(
          timeoutErrorMessage,
          config2,
          "ECONNABORTED",
          request2
        ));
        request2 = null;
      };
      if (utils2.isStandardBrowserEnv()) {
        var cookies2 = requireCookies();
        var xsrfValue = (config2.withCredentials || isURLSameOrigin2(fullPath)) && config2.xsrfCookieName ? cookies2.read(config2.xsrfCookieName) : void 0;
        if (xsrfValue) {
          requestHeaders[config2.xsrfHeaderName] = xsrfValue;
        }
      }
      if ("setRequestHeader" in request2) {
        utils2.forEach(requestHeaders, function setRequestHeader(val, key2) {
          if (typeof requestData === "undefined" && key2.toLowerCase() === "content-type") {
            delete requestHeaders[key2];
          } else {
            request2.setRequestHeader(key2, val);
          }
        });
      }
      if (!utils2.isUndefined(config2.withCredentials)) {
        request2.withCredentials = !!config2.withCredentials;
      }
      if (config2.responseType) {
        try {
          request2.responseType = config2.responseType;
        } catch (e) {
          if (config2.responseType !== "json") {
            throw e;
          }
        }
      }
      if (typeof config2.onDownloadProgress === "function") {
        request2.addEventListener("progress", config2.onDownloadProgress);
      }
      if (typeof config2.onUploadProgress === "function" && request2.upload) {
        request2.upload.addEventListener("progress", config2.onUploadProgress);
      }
      if (config2.cancelToken) {
        config2.cancelToken.promise.then(function onCanceled(cancel) {
          if (!request2) {
            return;
          }
          request2.abort();
          reject(cancel);
          request2 = null;
        });
      }
      if (requestData === void 0) {
        requestData = null;
      }
      request2.send(requestData);
    });
  };
  return xhr;
}
var utils$7 = utils$c;
var normalizeHeaderName2 = normalizeHeaderName$1;
var DEFAULT_CONTENT_TYPE = {
  "Content-Type": "application/x-www-form-urlencoded"
};
function setContentTypeIfUnset(headers, value) {
  if (!utils$7.isUndefined(headers) && utils$7.isUndefined(headers["Content-Type"])) {
    headers["Content-Type"] = value;
  }
}
function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== "undefined") {
    adapter = requireXhr();
  } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
    adapter = requireXhr();
  }
  return adapter;
}
var defaults$5 = {
  adapter: getDefaultAdapter(),
  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName2(headers, "Accept");
    normalizeHeaderName2(headers, "Content-Type");
    if (utils$7.isFormData(data) || utils$7.isArrayBuffer(data) || utils$7.isBuffer(data) || utils$7.isStream(data) || utils$7.isFile(data) || utils$7.isBlob(data)) {
      return data;
    }
    if (utils$7.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils$7.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
      return data.toString();
    }
    if (utils$7.isObject(data)) {
      setContentTypeIfUnset(headers, "application/json;charset=utf-8");
      return JSON.stringify(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    if (typeof data === "string") {
      try {
        data = JSON.parse(data);
      } catch (e) {
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};
defaults$5.headers = {
  common: {
    "Accept": "application/json, text/plain, */*"
  }
};
utils$7.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
  defaults$5.headers[method] = {};
});
utils$7.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  defaults$5.headers[method] = utils$7.merge(DEFAULT_CONTENT_TYPE);
});
var defaults_1 = defaults$5;
var utils$6 = utils$c;
var transformData2 = transformData$1;
var isCancel = requireIsCancel();
var defaults$4 = defaults_1;
function throwIfCancellationRequested(config2) {
  if (config2.cancelToken) {
    config2.cancelToken.throwIfRequested();
  }
}
var dispatchRequest$1 = function dispatchRequest(config2) {
  throwIfCancellationRequested(config2);
  config2.headers = config2.headers || {};
  config2.data = transformData2(
    config2.data,
    config2.headers,
    config2.transformRequest
  );
  config2.headers = utils$6.merge(
    config2.headers.common || {},
    config2.headers[config2.method] || {},
    config2.headers
  );
  utils$6.forEach(
    ["delete", "get", "head", "post", "put", "patch", "common"],
    function cleanHeaderConfig(method) {
      delete config2.headers[method];
    }
  );
  var adapter = config2.adapter || defaults$4.adapter;
  return adapter(config2).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config2);
    response.data = transformData2(
      response.data,
      response.headers,
      config2.transformResponse
    );
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config2);
      if (reason && reason.response) {
        reason.response.data = transformData2(
          reason.response.data,
          reason.response.headers,
          config2.transformResponse
        );
      }
    }
    return Promise.reject(reason);
  });
};
var utils$5 = utils$c;
var mergeConfig$2 = function mergeConfig(config1, config2) {
  config2 = config2 || {};
  var config3 = {};
  var valueFromConfig2Keys = ["url", "method", "params", "data"];
  var mergeDeepPropertiesKeys = ["headers", "auth", "proxy"];
  var defaultToConfig2Keys = [
    "baseURL",
    "url",
    "transformRequest",
    "transformResponse",
    "paramsSerializer",
    "timeout",
    "withCredentials",
    "adapter",
    "responseType",
    "xsrfCookieName",
    "xsrfHeaderName",
    "onUploadProgress",
    "onDownloadProgress",
    "maxContentLength",
    "validateStatus",
    "maxRedirects",
    "httpAgent",
    "httpsAgent",
    "cancelToken",
    "socketPath"
  ];
  utils$5.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (typeof config2[prop] !== "undefined") {
      config3[prop] = config2[prop];
    }
  });
  utils$5.forEach(mergeDeepPropertiesKeys, function mergeDeepProperties(prop) {
    if (utils$5.isObject(config2[prop])) {
      config3[prop] = utils$5.deepMerge(config1[prop], config2[prop]);
    } else if (typeof config2[prop] !== "undefined") {
      config3[prop] = config2[prop];
    } else if (utils$5.isObject(config1[prop])) {
      config3[prop] = utils$5.deepMerge(config1[prop]);
    } else if (typeof config1[prop] !== "undefined") {
      config3[prop] = config1[prop];
    }
  });
  utils$5.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (typeof config2[prop] !== "undefined") {
      config3[prop] = config2[prop];
    } else if (typeof config1[prop] !== "undefined") {
      config3[prop] = config1[prop];
    }
  });
  var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys);
  var otherKeys = Object.keys(config2).filter(function filterAxiosKeys(key2) {
    return axiosKeys.indexOf(key2) === -1;
  });
  utils$5.forEach(otherKeys, function otherKeysDefaultToConfig2(prop) {
    if (typeof config2[prop] !== "undefined") {
      config3[prop] = config2[prop];
    } else if (typeof config1[prop] !== "undefined") {
      config3[prop] = config1[prop];
    }
  });
  return config3;
};
var utils$4 = utils$c;
var buildURL2 = buildURL$1;
var InterceptorManager = InterceptorManager_1;
var dispatchRequest2 = dispatchRequest$1;
var mergeConfig$1 = mergeConfig$2;
function Axios$1(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}
Axios$1.prototype.request = function request(config2) {
  if (typeof config2 === "string") {
    config2 = arguments[1] || {};
    config2.url = arguments[0];
  } else {
    config2 = config2 || {};
  }
  config2 = mergeConfig$1(this.defaults, config2);
  if (config2.method) {
    config2.method = config2.method.toLowerCase();
  } else if (this.defaults.method) {
    config2.method = this.defaults.method.toLowerCase();
  } else {
    config2.method = "get";
  }
  var chain = [dispatchRequest2, void 0];
  var promise = Promise.resolve(config2);
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });
  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }
  return promise;
};
Axios$1.prototype.getUri = function getUri(config2) {
  config2 = mergeConfig$1(this.defaults, config2);
  return buildURL2(config2.url, config2.params, config2.paramsSerializer).replace(/^\?/, "");
};
utils$4.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method) {
  Axios$1.prototype[method] = function(url, config2) {
    return this.request(utils$4.merge(config2 || {}, {
      method,
      url
    }));
  };
});
utils$4.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
  Axios$1.prototype[method] = function(url, data, config2) {
    return this.request(utils$4.merge(config2 || {}, {
      method,
      url,
      data
    }));
  };
});
var Axios_1 = Axios$1;
var Cancel_1;
var hasRequiredCancel;
function requireCancel() {
  if (hasRequiredCancel)
    return Cancel_1;
  hasRequiredCancel = 1;
  function Cancel(message) {
    this.message = message;
  }
  Cancel.prototype.toString = function toString2() {
    return "Cancel" + (this.message ? ": " + this.message : "");
  };
  Cancel.prototype.__CANCEL__ = true;
  Cancel_1 = Cancel;
  return Cancel_1;
}
var CancelToken_1;
var hasRequiredCancelToken;
function requireCancelToken() {
  if (hasRequiredCancelToken)
    return CancelToken_1;
  hasRequiredCancelToken = 1;
  var Cancel = requireCancel();
  function CancelToken(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    var resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve2) {
      resolvePromise = resolve2;
    });
    var token2 = this;
    executor(function cancel(message) {
      if (token2.reason) {
        return;
      }
      token2.reason = new Cancel(message);
      resolvePromise(token2.reason);
    });
  }
  CancelToken.prototype.throwIfRequested = function throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  };
  CancelToken.source = function source2() {
    var cancel;
    var token2 = new CancelToken(function executor(c2) {
      cancel = c2;
    });
    return {
      token: token2,
      cancel
    };
  };
  CancelToken_1 = CancelToken;
  return CancelToken_1;
}
var spread;
var hasRequiredSpread;
function requireSpread() {
  if (hasRequiredSpread)
    return spread;
  hasRequiredSpread = 1;
  spread = function spread2(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  };
  return spread;
}
var utils$3 = utils$c;
var bind$2 = bind$4;
var Axios = Axios_1;
var mergeConfig2 = mergeConfig$2;
var defaults$3 = defaults_1;
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind$2(Axios.prototype.request, context);
  utils$3.extend(instance, Axios.prototype, context);
  utils$3.extend(instance, context);
  return instance;
}
var axios$3 = createInstance(defaults$3);
axios$3.Axios = Axios;
axios$3.create = function create(instanceConfig) {
  return createInstance(mergeConfig2(axios$3.defaults, instanceConfig));
};
axios$3.Cancel = requireCancel();
axios$3.CancelToken = requireCancelToken();
axios$3.isCancel = requireIsCancel();
axios$3.all = function all(promises) {
  return Promise.all(promises);
};
axios$3.spread = requireSpread();
axios$4.exports = axios$3;
axios$4.exports.default = axios$3;
var axiosExports = axios$4.exports;
var axios$1 = axiosExports;
const axios$2 = /* @__PURE__ */ getDefaultExportFromCjs(axios$1);
var vuedraggable_umd = { exports: {} };
const require$$0$2 = /* @__PURE__ */ getAugmentedNamespace(vue_runtime_esmBundler);
/**!
 * Sortable 1.14.0
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function ownKeys(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source2 = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source2), true).forEach(function(key2) {
        _defineProperty(target, key2, source2[key2]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2));
    } else {
      ownKeys(Object(source2)).forEach(function(key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source2, key2));
      });
    }
  }
  return target;
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _defineProperty(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source2 = arguments[i];
      for (var key2 in source2) {
        if (Object.prototype.hasOwnProperty.call(source2, key2)) {
          target[key2] = source2[key2];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source2, excluded) {
  if (source2 == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source2);
  var key2, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key2 = sourceKeys[i];
    if (excluded.indexOf(key2) >= 0)
      continue;
    target[key2] = source2[key2];
  }
  return target;
}
function _objectWithoutProperties(source2, excluded) {
  if (source2 == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source2, excluded);
  var key2, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source2);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key2 = sourceSymbolKeys[i];
      if (excluded.indexOf(key2) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source2, key2))
        continue;
      target[key2] = source2[key2];
    }
  }
  return target;
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var version$1 = "1.14.0";
function userAgent(pattern) {
  if (typeof window !== "undefined" && window.navigator) {
    return !!/* @__PURE__ */ navigator.userAgent.match(pattern);
  }
}
var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
var captureMode = {
  capture: false,
  passive: false
};
function on(el, event, fn) {
  el.addEventListener(event, fn, !IE11OrLess && captureMode);
}
function off(el, event, fn) {
  el.removeEventListener(event, fn, !IE11OrLess && captureMode);
}
function matches(el, selector) {
  if (!selector)
    return;
  selector[0] === ">" && (selector = selector.substring(1));
  if (el) {
    try {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      }
    } catch (_2) {
      return false;
    }
  }
  return false;
}
function getParentOrHost(el) {
  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
}
function closest(el, selector, ctx, includeCTX) {
  if (el) {
    ctx = ctx || document;
    do {
      if (selector != null && (selector[0] === ">" ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
        return el;
      }
      if (el === ctx)
        break;
    } while (el = getParentOrHost(el));
  }
  return null;
}
var R_SPACE = /\s+/g;
function toggleClass(el, name, state) {
  if (el && name) {
    if (el.classList) {
      el.classList[state ? "add" : "remove"](name);
    } else {
      var className = (" " + el.className + " ").replace(R_SPACE, " ").replace(" " + name + " ", " ");
      el.className = (className + (state ? " " + name : "")).replace(R_SPACE, " ");
    }
  }
}
function css(el, prop, val) {
  var style3 = el && el.style;
  if (style3) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el, "");
      } else if (el.currentStyle) {
        val = el.currentStyle;
      }
      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style3) && prop.indexOf("webkit") === -1) {
        prop = "-webkit-" + prop;
      }
      style3[prop] = val + (typeof val === "string" ? "" : "px");
    }
  }
}
function matrix(el, selfOnly) {
  var appliedTransforms = "";
  if (typeof el === "string") {
    appliedTransforms = el;
  } else {
    do {
      var transform2 = css(el, "transform");
      if (transform2 && transform2 !== "none") {
        appliedTransforms = transform2 + " " + appliedTransforms;
      }
    } while (!selfOnly && (el = el.parentNode));
  }
  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  return matrixFn && new matrixFn(appliedTransforms);
}
function find(ctx, tagName, iterator) {
  if (ctx) {
    var list = ctx.getElementsByTagName(tagName), i = 0, n = list.length;
    if (iterator) {
      for (; i < n; i++) {
        iterator(list[i], i);
      }
    }
    return list;
  }
  return [];
}
function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;
  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}
function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el.getBoundingClientRect && el !== window)
    return;
  var elRect, top, left, bottom, right, height, width;
  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
    elRect = el.getBoundingClientRect();
    top = elRect.top;
    left = elRect.left;
    bottom = elRect.bottom;
    right = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top = 0;
    left = 0;
    bottom = window.innerHeight;
    right = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }
  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
    container = container || el.parentNode;
    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, "transform") !== "none" || relativeToNonStaticParent && css(container, "position") !== "static")) {
          var containerRect = container.getBoundingClientRect();
          top -= containerRect.top + parseInt(css(container, "border-top-width"));
          left -= containerRect.left + parseInt(css(container, "border-left-width"));
          bottom = top + elRect.height;
          right = left + elRect.width;
          break;
        }
      } while (container = container.parentNode);
    }
  }
  if (undoScale && el !== window) {
    var elMatrix = matrix(container || el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d;
    if (elMatrix) {
      top /= scaleY;
      left /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom = top + height;
      right = left + width;
    }
  }
  return {
    top,
    left,
    bottom,
    right,
    width,
    height
  };
}
function isScrolledPast(el, elSide, parentSide) {
  var parent = getParentAutoScrollElement(el, true), elSideVal = getRect(el)[elSide];
  while (parent) {
    var parentSideVal = getRect(parent)[parentSide], visible = void 0;
    if (parentSide === "top" || parentSide === "left") {
      visible = elSideVal >= parentSideVal;
    } else {
      visible = elSideVal <= parentSideVal;
    }
    if (!visible)
      return parent;
    if (parent === getWindowScrollingElement())
      break;
    parent = getParentAutoScrollElement(parent, false);
  }
  return false;
}
function getChild(el, childNum, options, includeDragEl) {
  var currentChild = 0, i = 0, children = el.children;
  while (i < children.length) {
    if (children[i].style.display !== "none" && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el, false)) {
      if (currentChild === childNum) {
        return children[i];
      }
      currentChild++;
    }
    i++;
  }
  return null;
}
function lastChild(el, selector) {
  var last = el.lastElementChild;
  while (last && (last === Sortable.ghost || css(last, "display") === "none" || selector && !matches(last, selector))) {
    last = last.previousElementSibling;
  }
  return last || null;
}
function index(el, selector) {
  var index2 = 0;
  if (!el || !el.parentNode) {
    return -1;
  }
  while (el = el.previousElementSibling) {
    if (el.nodeName.toUpperCase() !== "TEMPLATE" && el !== Sortable.clone && (!selector || matches(el, selector))) {
      index2++;
    }
  }
  return index2;
}
function getRelativeScrollOffset(el) {
  var offsetLeft = 0, offsetTop = 0, winScroller = getWindowScrollingElement();
  if (el) {
    do {
      var elMatrix = matrix(el), scaleX = elMatrix.a, scaleY = elMatrix.d;
      offsetLeft += el.scrollLeft * scaleX;
      offsetTop += el.scrollTop * scaleY;
    } while (el !== winScroller && (el = el.parentNode));
  }
  return [offsetLeft, offsetTop];
}
function indexOfObject(arr, obj) {
  for (var i in arr) {
    if (!arr.hasOwnProperty(i))
      continue;
    for (var key2 in obj) {
      if (obj.hasOwnProperty(key2) && obj[key2] === arr[i][key2])
        return Number(i);
    }
  }
  return -1;
}
function getParentAutoScrollElement(el, includeSelf) {
  if (!el || !el.getBoundingClientRect)
    return getWindowScrollingElement();
  var elem = el;
  var gotSelf = false;
  do {
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);
      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == "auto" || elemCSS.overflowX == "scroll") || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == "auto" || elemCSS.overflowY == "scroll")) {
        if (!elem.getBoundingClientRect || elem === document.body)
          return getWindowScrollingElement();
        if (gotSelf || includeSelf)
          return elem;
        gotSelf = true;
      }
    }
  } while (elem = elem.parentNode);
  return getWindowScrollingElement();
}
function extend(dst, src) {
  if (dst && src) {
    for (var key2 in src) {
      if (src.hasOwnProperty(key2)) {
        dst[key2] = src[key2];
      }
    }
  }
  return dst;
}
function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}
var _throttleTimeout;
function throttle(callback, ms) {
  return function() {
    if (!_throttleTimeout) {
      var args = arguments, _this = this;
      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }
      _throttleTimeout = setTimeout(function() {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}
function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}
function scrollBy(el, x2, y2) {
  el.scrollLeft += x2;
  el.scrollTop += y2;
}
function clone(el) {
  var Polymer = window.Polymer;
  var $2 = window.jQuery || window.Zepto;
  if (Polymer && Polymer.dom) {
    return Polymer.dom(el).cloneNode(true);
  } else if ($2) {
    return $2(el).clone(true)[0];
  } else {
    return el.cloneNode(true);
  }
}
function setRect(el, rect) {
  css(el, "position", "absolute");
  css(el, "top", rect.top);
  css(el, "left", rect.left);
  css(el, "width", rect.width);
  css(el, "height", rect.height);
}
function unsetRect(el) {
  css(el, "position", "");
  css(el, "top", "");
  css(el, "left", "");
  css(el, "width", "");
  css(el, "height", "");
}
var expando = "Sortable" + (/* @__PURE__ */ new Date()).getTime();
function AnimationStateManager() {
  var animationStates = [], animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation)
        return;
      var children = [].slice.call(this.el.children);
      children.forEach(function(child) {
        if (css(child, "display") === "none" || child === Sortable.ghost)
          return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });
        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);
        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);
          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }
        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state) {
      animationStates.push(state);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;
      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === "function")
          callback();
        return;
      }
      var animating = false, animationTime = 0;
      animationStates.forEach(function(state) {
        var time = 0, target = state.target, fromRect = target.fromRect, toRect = getRect(target), prevFromRect = target.prevFromRect, prevToRect = target.prevToRect, animatingRect = state.rect, targetMatrix = matrix(target, true);
        if (targetMatrix) {
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }
        target.toRect = toRect;
        if (target.thisAnimationDuration) {
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect
          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        }
        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;
          if (!time) {
            time = _this.options.animation;
          }
          _this.animate(target, animatingRect, toRect, time);
        }
        if (time) {
          animating = true;
          animationTime = Math.max(animationTime, time);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function() {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time);
          target.thisAnimationDuration = time;
        }
      });
      clearTimeout(animationCallbackId);
      if (!animating) {
        if (typeof callback === "function")
          callback();
      } else {
        animationCallbackId = setTimeout(function() {
          if (typeof callback === "function")
            callback();
        }, animationTime);
      }
      animationStates = [];
    },
    animate: function animate2(target, currentRect, toRect, duration) {
      if (duration) {
        css(target, "transition", "");
        css(target, "transform", "");
        var elMatrix = matrix(this.el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d, translateX = (currentRect.left - toRect.left) / (scaleX || 1), translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target.animatingX = !!translateX;
        target.animatingY = !!translateY;
        css(target, "transform", "translate3d(" + translateX + "px," + translateY + "px,0)");
        this.forRepaintDummy = repaint(target);
        css(target, "transition", "transform " + duration + "ms" + (this.options.easing ? " " + this.options.easing : ""));
        css(target, "transform", "translate3d(0,0,0)");
        typeof target.animated === "number" && clearTimeout(target.animated);
        target.animated = setTimeout(function() {
          css(target, "transition", "");
          css(target, "transform", "");
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration);
      }
    }
  };
}
function repaint(target) {
  return target.offsetWidth;
}
function calculateRealTime(animatingRect, fromRect, toRect, options) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}
var plugins = [];
var defaults$2 = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin2) {
    for (var option2 in defaults$2) {
      if (defaults$2.hasOwnProperty(option2) && !(option2 in plugin2)) {
        plugin2[option2] = defaults$2[option2];
      }
    }
    plugins.forEach(function(p2) {
      if (p2.pluginName === plugin2.pluginName) {
        throw "Sortable: Cannot mount plugin ".concat(plugin2.pluginName, " more than once");
      }
    });
    plugins.push(plugin2);
  },
  pluginEvent: function pluginEvent(eventName2, sortable, evt) {
    var _this = this;
    this.eventCanceled = false;
    evt.cancel = function() {
      _this.eventCanceled = true;
    };
    var eventNameGlobal = eventName2 + "Global";
    plugins.forEach(function(plugin2) {
      if (!sortable[plugin2.pluginName])
        return;
      if (sortable[plugin2.pluginName][eventNameGlobal]) {
        sortable[plugin2.pluginName][eventNameGlobal](_objectSpread2({
          sortable
        }, evt));
      }
      if (sortable.options[plugin2.pluginName] && sortable[plugin2.pluginName][eventName2]) {
        sortable[plugin2.pluginName][eventName2](_objectSpread2({
          sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el, defaults2, options) {
    plugins.forEach(function(plugin2) {
      var pluginName = plugin2.pluginName;
      if (!sortable.options[pluginName] && !plugin2.initializeByDefault)
        return;
      var initialized = new plugin2(sortable, el, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized;
      _extends(defaults2, initialized.defaults);
    });
    for (var option2 in sortable.options) {
      if (!sortable.options.hasOwnProperty(option2))
        continue;
      var modified = this.modifyOption(sortable, option2, sortable.options[option2]);
      if (typeof modified !== "undefined") {
        sortable.options[option2] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name, sortable) {
    var eventProperties = {};
    plugins.forEach(function(plugin2) {
      if (typeof plugin2.eventProperties !== "function")
        return;
      _extends(eventProperties, plugin2.eventProperties.call(sortable[plugin2.pluginName], name));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name, value) {
    var modifiedValue;
    plugins.forEach(function(plugin2) {
      if (!sortable[plugin2.pluginName])
        return;
      if (plugin2.optionListeners && typeof plugin2.optionListeners[name] === "function") {
        modifiedValue = plugin2.optionListeners[name].call(sortable[plugin2.pluginName], value);
      }
    });
    return modifiedValue;
  }
};
function dispatchEvent(_ref) {
  var sortable = _ref.sortable, rootEl2 = _ref.rootEl, name = _ref.name, targetEl = _ref.targetEl, cloneEl2 = _ref.cloneEl, toEl = _ref.toEl, fromEl = _ref.fromEl, oldIndex2 = _ref.oldIndex, newIndex2 = _ref.newIndex, oldDraggableIndex2 = _ref.oldDraggableIndex, newDraggableIndex2 = _ref.newDraggableIndex, originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, extraEventProperties = _ref.extraEventProperties;
  sortable = sortable || rootEl2 && rootEl2[expando];
  if (!sortable)
    return;
  var evt, options = sortable.options, onName = "on" + name.charAt(0).toUpperCase() + name.substr(1);
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent(name, true, true);
  }
  evt.to = toEl || rootEl2;
  evt.from = fromEl || rootEl2;
  evt.item = targetEl || rootEl2;
  evt.clone = cloneEl2;
  evt.oldIndex = oldIndex2;
  evt.newIndex = newIndex2;
  evt.oldDraggableIndex = oldDraggableIndex2;
  evt.newDraggableIndex = newDraggableIndex2;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable2 ? putSortable2.lastPutMode : void 0;
  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));
  for (var option2 in allEventProperties) {
    evt[option2] = allEventProperties[option2];
  }
  if (rootEl2) {
    rootEl2.dispatchEvent(evt);
  }
  if (options[onName]) {
    options[onName].call(sortable, evt);
  }
}
var _excluded = ["evt"];
var pluginEvent2 = function pluginEvent3(eventName2, sortable) {
  var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, originalEvent = _ref.evt, data = _objectWithoutProperties(_ref, _excluded);
  PluginManager.pluginEvent.bind(Sortable)(eventName2, sortable, _objectSpread2({
    dragEl,
    parentEl,
    ghostEl,
    rootEl,
    nextEl,
    lastDownEl,
    cloneEl,
    cloneHidden,
    dragStarted: moved,
    putSortable,
    activeSortable: Sortable.active,
    originalEvent,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name) {
      _dispatchEvent({
        sortable,
        name,
        originalEvent
      });
    }
  }, data));
};
function _dispatchEvent(info) {
  dispatchEvent(_objectSpread2({
    putSortable,
    cloneEl,
    targetEl: dragEl,
    rootEl,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex
  }, info));
}
var dragEl, parentEl, ghostEl, rootEl, nextEl, lastDownEl, cloneEl, cloneHidden, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, activeGroup, putSortable, awaitingDragStarted = false, ignoreNextClick = false, sortables = [], tapEvt, touchEvt, lastDx, lastDy, tapDistanceLeft, tapDistanceTop, moved, lastTarget, lastDirection, pastFirstInvertThresh = false, isCircumstantialInvert = false, targetMoveDistance, ghostRelativeParent, ghostRelativeParentInitialScroll = [], _silent = false, savedInputChecked = [];
var documentExists = typeof document !== "undefined", PositionGhostAbsolutely = IOS, CSSFloatProperty = Edge || IE11OrLess ? "cssFloat" : "float", supportDraggable = documentExists && !ChromeForAndroid && !IOS && "draggable" in document.createElement("div"), supportCssPointerEvents = function() {
  if (!documentExists)
    return;
  if (IE11OrLess) {
    return false;
  }
  var el = document.createElement("x");
  el.style.cssText = "pointer-events:auto";
  return el.style.pointerEvents === "auto";
}(), _detectDirection = function _detectDirection2(el, options) {
  var elCSS = css(el), elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth), child1 = getChild(el, 0, options), child2 = getChild(el, 1, options), firstChildCSS = child1 && css(child1), secondChildCSS = child2 && css(child2), firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width, secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
  if (elCSS.display === "flex") {
    return elCSS.flexDirection === "column" || elCSS.flexDirection === "column-reverse" ? "vertical" : "horizontal";
  }
  if (elCSS.display === "grid") {
    return elCSS.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
  }
  if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== "none") {
    var touchingSideChild2 = firstChildCSS["float"] === "left" ? "left" : "right";
    return child2 && (secondChildCSS.clear === "both" || secondChildCSS.clear === touchingSideChild2) ? "vertical" : "horizontal";
  }
  return child1 && (firstChildCSS.display === "block" || firstChildCSS.display === "flex" || firstChildCSS.display === "table" || firstChildCSS.display === "grid" || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === "none" || child2 && elCSS[CSSFloatProperty] === "none" && firstChildWidth + secondChildWidth > elWidth) ? "vertical" : "horizontal";
}, _dragElInRowColumn = function _dragElInRowColumn2(dragRect, targetRect, vertical) {
  var dragElS1Opp = vertical ? dragRect.left : dragRect.top, dragElS2Opp = vertical ? dragRect.right : dragRect.bottom, dragElOppLength = vertical ? dragRect.width : dragRect.height, targetS1Opp = vertical ? targetRect.left : targetRect.top, targetS2Opp = vertical ? targetRect.right : targetRect.bottom, targetOppLength = vertical ? targetRect.width : targetRect.height;
  return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
}, _detectNearestEmptySortable = function _detectNearestEmptySortable2(x2, y2) {
  var ret;
  sortables.some(function(sortable) {
    var threshold = sortable[expando].options.emptyInsertThreshold;
    if (!threshold || lastChild(sortable))
      return;
    var rect = getRect(sortable), insideHorizontally = x2 >= rect.left - threshold && x2 <= rect.right + threshold, insideVertically = y2 >= rect.top - threshold && y2 <= rect.bottom + threshold;
    if (insideHorizontally && insideVertically) {
      return ret = sortable;
    }
  });
  return ret;
}, _prepareGroup = function _prepareGroup2(options) {
  function toFn(value, pull) {
    return function(to, from, dragEl2, evt) {
      var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;
      if (value == null && (pull || sameGroup)) {
        return true;
      } else if (value == null || value === false) {
        return false;
      } else if (pull && value === "clone") {
        return value;
      } else if (typeof value === "function") {
        return toFn(value(to, from, dragEl2, evt), pull)(to, from, dragEl2, evt);
      } else {
        var otherGroup = (pull ? to : from).options.group.name;
        return value === true || typeof value === "string" && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
      }
    };
  }
  var group = {};
  var originalGroup = options.group;
  if (!originalGroup || _typeof(originalGroup) != "object") {
    originalGroup = {
      name: originalGroup
    };
  }
  group.name = originalGroup.name;
  group.checkPull = toFn(originalGroup.pull, true);
  group.checkPut = toFn(originalGroup.put);
  group.revertClone = originalGroup.revertClone;
  options.group = group;
}, _hideGhostForTarget = function _hideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, "display", "none");
  }
}, _unhideGhostForTarget = function _unhideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, "display", "");
  }
};
if (documentExists) {
  document.addEventListener("click", function(evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}
var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent2(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;
    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
    if (nearest) {
      var event = {};
      for (var i in evt) {
        if (evt.hasOwnProperty(i)) {
          event[i] = evt[i];
        }
      }
      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;
      nearest[expando]._onDragOver(event);
    }
  }
};
var _checkOutsideTargetEl = function _checkOutsideTargetEl2(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};
function Sortable(el, options) {
  if (!(el && el.nodeType && el.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
  }
  this.el = el;
  this.options = options = _extends({}, options);
  el[expando] = this;
  var defaults2 = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el.nodeName) ? ">li" : ">*",
    swapThreshold: 1,
    // percentage; 0 <= x <= 1
    invertSwap: false,
    // invert always
    invertedSwapThreshold: null,
    // will be set to same as swapThreshold if default
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el, this.options);
    },
    ghostClass: "sortable-ghost",
    chosenClass: "sortable-chosen",
    dragClass: "sortable-drag",
    ignore: "a, img",
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl2) {
      dataTransfer.setData("Text", dragEl2.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: "data-id",
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: "sortable-fallback",
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: Sortable.supportPointer !== false && "PointerEvent" in window && !Safari,
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el, defaults2);
  for (var name in defaults2) {
    !(name in options) && (options[name] = defaults2[name]);
  }
  _prepareGroup(options);
  for (var fn in this) {
    if (fn.charAt(0) === "_" && typeof this[fn] === "function") {
      this[fn] = this[fn].bind(this);
    }
  }
  this.nativeDraggable = options.forceFallback ? false : supportDraggable;
  if (this.nativeDraggable) {
    this.options.touchStartThreshold = 1;
  }
  if (options.supportPointer) {
    on(el, "pointerdown", this._onTapStart);
  } else {
    on(el, "mousedown", this._onTapStart);
    on(el, "touchstart", this._onTapStart);
  }
  if (this.nativeDraggable) {
    on(el, "dragover", this);
    on(el, "dragenter", this);
  }
  sortables.push(this.el);
  options.store && options.store.get && this.sort(options.store.get(this) || []);
  _extends(this, AnimationStateManager());
}
Sortable.prototype = /** @lends Sortable.prototype */
{
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target) {
    if (!this.el.contains(target) && target !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target) {
    return typeof this.options.direction === "function" ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart(evt) {
    if (!evt.cancelable)
      return;
    var _this = this, el = this.el, options = this.options, preventOnFilter = options.preventOnFilter, type2 = evt.type, touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === "touch" && evt, target = (touch || evt).target, originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target, filter = options.filter;
    _saveInputCheckedState(el);
    if (dragEl) {
      return;
    }
    if (/mousedown|pointerdown/.test(type2) && evt.button !== 0 || options.disabled) {
      return;
    }
    if (originalTarget.isContentEditable) {
      return;
    }
    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === "SELECT") {
      return;
    }
    target = closest(target, options.draggable, el, false);
    if (target && target.animated) {
      return;
    }
    if (lastDownEl === target) {
      return;
    }
    oldIndex = index(target);
    oldDraggableIndex = index(target, options.draggable);
    if (typeof filter === "function") {
      if (filter.call(this, evt, target, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: "filter",
          targetEl: target,
          toEl: el,
          fromEl: el
        });
        pluginEvent2("filter", _this, {
          evt
        });
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return;
      }
    } else if (filter) {
      filter = filter.split(",").some(function(criteria) {
        criteria = closest(originalTarget, criteria.trim(), el, false);
        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: "filter",
            targetEl: target,
            fromEl: el,
            toEl: el
          });
          pluginEvent2("filter", _this, {
            evt
          });
          return true;
        }
      });
      if (filter) {
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return;
      }
    }
    if (options.handle && !closest(originalTarget, options.handle, el, false)) {
      return;
    }
    this._prepareDragStart(evt, touch, target);
  },
  _prepareDragStart: function _prepareDragStart(evt, touch, target) {
    var _this = this, el = _this.el, options = _this.options, ownerDocument = el.ownerDocument, dragStartFn;
    if (target && !dragEl && target.parentNode === el) {
      var dragRect = getRect(target);
      rootEl = el;
      dragEl = target;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target;
      activeGroup = options.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style["will-change"] = "all";
      dragStartFn = function dragStartFn2() {
        pluginEvent2("delayEnded", _this, {
          evt
        });
        if (Sortable.eventCanceled) {
          _this._onDrop();
          return;
        }
        _this._disableDelayedDragEvents();
        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        }
        _this._triggerDragStart(evt, touch);
        _dispatchEvent({
          sortable: _this,
          name: "choose",
          originalEvent: evt
        });
        toggleClass(dragEl, options.chosenClass, true);
      };
      options.ignore.split(",").forEach(function(criteria) {
        find(dragEl, criteria.trim(), _disableDraggable);
      });
      on(ownerDocument, "dragover", nearestEmptyInsertDetectEvent);
      on(ownerDocument, "mousemove", nearestEmptyInsertDetectEvent);
      on(ownerDocument, "touchmove", nearestEmptyInsertDetectEvent);
      on(ownerDocument, "mouseup", _this._onDrop);
      on(ownerDocument, "touchend", _this._onDrop);
      on(ownerDocument, "touchcancel", _this._onDrop);
      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }
      pluginEvent2("delayStart", this, {
        evt
      });
      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();
          return;
        }
        on(ownerDocument, "mouseup", _this._disableDelayedDrag);
        on(ownerDocument, "touchend", _this._disableDelayedDrag);
        on(ownerDocument, "touchcancel", _this._disableDelayedDrag);
        on(ownerDocument, "mousemove", _this._delayedDragTouchMoveHandler);
        on(ownerDocument, "touchmove", _this._delayedDragTouchMoveHandler);
        options.supportPointer && on(ownerDocument, "pointermove", _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(e) {
    var touch = e.touches ? e.touches[0] : e;
    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);
    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, "mouseup", this._disableDelayedDrag);
    off(ownerDocument, "touchend", this._disableDelayedDrag);
    off(ownerDocument, "touchcancel", this._disableDelayedDrag);
    off(ownerDocument, "mousemove", this._delayedDragTouchMoveHandler);
    off(ownerDocument, "touchmove", this._delayedDragTouchMoveHandler);
    off(ownerDocument, "pointermove", this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart(evt, touch) {
    touch = touch || evt.pointerType == "touch" && evt;
    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on(document, "pointermove", this._onTouchMove);
      } else if (touch) {
        on(document, "touchmove", this._onTouchMove);
      } else {
        on(document, "mousemove", this._onTouchMove);
      }
    } else {
      on(dragEl, "dragend", this);
      on(rootEl, "dragstart", this._onDragStart);
    }
    try {
      if (document.selection) {
        _nextTick(function() {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {
    }
  },
  _dragStarted: function _dragStarted(fallback, evt) {
    awaitingDragStarted = false;
    if (rootEl && dragEl) {
      pluginEvent2("dragStarted", this, {
        evt
      });
      if (this.nativeDraggable) {
        on(document, "dragover", _checkOutsideTargetEl);
      }
      var options = this.options;
      !fallback && toggleClass(dragEl, options.dragClass, false);
      toggleClass(dragEl, options.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost();
      _dispatchEvent({
        sortable: this,
        name: "start",
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;
      _hideGhostForTarget();
      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent = target;
      while (target && target.shadowRoot) {
        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target === parent)
          break;
        parent = target;
      }
      dragEl.parentNode[expando]._isOutsideThisEl(target);
      if (parent) {
        do {
          if (parent[expando]) {
            var inserted = void 0;
            inserted = parent[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target,
              rootEl: parent
            });
            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }
          target = parent;
        } while (parent = parent.parentNode);
      }
      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove(evt) {
    if (tapEvt) {
      var options = this.options, fallbackTolerance = options.fallbackTolerance, fallbackOffset = options.fallbackOffset, touch = evt.touches ? evt.touches[0] : evt, ghostMatrix = ghostEl && matrix(ghostEl, true), scaleX = ghostEl && ghostMatrix && ghostMatrix.a, scaleY = ghostEl && ghostMatrix && ghostMatrix.d, relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent), dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1), dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);
      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }
        this._onDragStart(evt, true);
      }
      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }
        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, "webkitTransform", cssMatrix);
        css(ghostEl, "mozTransform", cssMatrix);
        css(ghostEl, "msTransform", cssMatrix);
        css(ghostEl, "transform", cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch;
      }
      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl, rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container), options = this.options;
      if (PositionGhostAbsolutely) {
        ghostRelativeParent = container;
        while (css(ghostRelativeParent, "position") === "static" && css(ghostRelativeParent, "transform") === "none" && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }
        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document)
            ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }
        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }
      ghostEl = dragEl.cloneNode(true);
      toggleClass(ghostEl, options.ghostClass, false);
      toggleClass(ghostEl, options.fallbackClass, true);
      toggleClass(ghostEl, options.dragClass, true);
      css(ghostEl, "transition", "");
      css(ghostEl, "transform", "");
      css(ghostEl, "box-sizing", "border-box");
      css(ghostEl, "margin", 0);
      css(ghostEl, "top", rect.top);
      css(ghostEl, "left", rect.left);
      css(ghostEl, "width", rect.width);
      css(ghostEl, "height", rect.height);
      css(ghostEl, "opacity", "0.8");
      css(ghostEl, "position", PositionGhostAbsolutely ? "absolute" : "fixed");
      css(ghostEl, "zIndex", "100000");
      css(ghostEl, "pointerEvents", "none");
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl);
      css(ghostEl, "transform-origin", tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + "% " + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + "%");
    }
  },
  _onDragStart: function _onDragStart(evt, fallback) {
    var _this = this;
    var dataTransfer = evt.dataTransfer;
    var options = _this.options;
    pluginEvent2("dragStart", this, {
      evt
    });
    if (Sortable.eventCanceled) {
      this._onDrop();
      return;
    }
    pluginEvent2("setupClone", this);
    if (!Sortable.eventCanceled) {
      cloneEl = clone(dragEl);
      cloneEl.draggable = false;
      cloneEl.style["will-change"] = "";
      this._hideClone();
      toggleClass(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    }
    _this.cloneId = _nextTick(function() {
      pluginEvent2("clone", _this);
      if (Sortable.eventCanceled)
        return;
      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }
      _this._hideClone();
      _dispatchEvent({
        sortable: _this,
        name: "clone"
      });
    });
    !fallback && toggleClass(dragEl, options.dragClass, true);
    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      off(document, "mouseup", _this._onDrop);
      off(document, "touchend", _this._onDrop);
      off(document, "touchcancel", _this._onDrop);
      if (dataTransfer) {
        dataTransfer.effectAllowed = "move";
        options.setData && options.setData.call(_this, dataTransfer, dragEl);
      }
      on(document, "drop", _this);
      css(dragEl, "transform", "translateZ(0)");
    }
    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on(document, "selectstart", _this);
    moved = true;
    if (Safari) {
      css(document.body, "user-select", "none");
    }
  },
  // Returns true - if no further action is needed (either inserted or another condition)
  _onDragOver: function _onDragOver(evt) {
    var el = this.el, target = evt.target, dragRect, targetRect, revert, options = this.options, group = options.group, activeSortable = Sortable.active, isOwner = activeGroup === group, canSort = options.sort, fromSortable = putSortable || activeSortable, vertical, _this = this, completedFired = false;
    if (_silent)
      return;
    function dragOverEvent(name, extra) {
      pluginEvent2(name, _this, _objectSpread2({
        evt,
        isOwner,
        axis: vertical ? "vertical" : "horizontal",
        revert,
        dragRect,
        targetRect,
        canSort,
        fromSortable,
        target,
        completed,
        onMove: function onMove(target2, after2) {
          return _onMove(rootEl, el, dragEl, dragRect, target2, getRect(target2), evt, after2);
        },
        changed
      }, extra));
    }
    function capture() {
      dragOverEvent("dragOverAnimationCapture");
      _this.captureAnimationState();
      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    }
    function completed(insertion) {
      dragOverEvent("dragOverCompleted", {
        insertion
      });
      if (insertion) {
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }
        if (_this !== fromSortable) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass(dragEl, options.ghostClass, true);
        }
        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        }
        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target;
        }
        _this.animateAll(function() {
          dragOverEvent("dragOverAnimationComplete");
          _this._ignoreWhileAnimating = null;
        });
        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      }
      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
        lastTarget = null;
      }
      if (!options.dragoverBubble && !evt.rootEl && target !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
        !insertion && nearestEmptyInsertDetectEvent(evt);
      }
      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    }
    function changed() {
      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);
      _dispatchEvent({
        sortable: _this,
        name: "change",
        toEl: el,
        newIndex,
        newDraggableIndex,
        originalEvent: evt
      });
    }
    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }
    target = closest(target, options.draggable, el, true);
    dragOverEvent("dragOver");
    if (Sortable.eventCanceled)
      return completedFired;
    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
      return completed(false);
    }
    ignoreNextClick = false;
    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target) === "vertical";
      dragRect = getRect(dragEl);
      dragOverEvent("dragOverValid");
      if (Sortable.eventCanceled)
        return completedFired;
      if (revert) {
        parentEl = rootEl;
        capture();
        this._hideClone();
        dragOverEvent("revert");
        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }
        return completed(true);
      }
      var elLastChild = lastChild(el, options.draggable);
      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        if (elLastChild === dragEl) {
          return completed(false);
        }
        if (elLastChild && el === evt.target) {
          target = elLastChild;
        }
        if (target) {
          targetRect = getRect(target);
        }
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
          capture();
          el.appendChild(dragEl);
          parentEl = el;
          changed();
          return completed(true);
        }
      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
        var firstChild = getChild(el, 0, options, true);
        if (firstChild === dragEl) {
          return completed(false);
        }
        target = firstChild;
        targetRect = getRect(target);
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
          capture();
          el.insertBefore(dragEl, firstChild);
          parentEl = el;
          changed();
          return completed(true);
        }
      } else if (target.parentNode === el) {
        targetRect = getRect(target);
        var direction = 0, targetBeforeFirstSwap, differentLevel = dragEl.parentNode !== el, differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical), side1 = vertical ? "top" : "left", scrolledPastTop = isScrolledPast(target, "top", "top") || isScrolledPast(dragEl, "top", "top"), scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
        if (lastTarget !== target) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
        }
        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
        var sibling;
        if (direction !== 0) {
          var dragIndex = index(dragEl);
          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, "display") === "none" || sibling === ghostEl));
        }
        if (direction === 0 || sibling === target) {
          return completed(false);
        }
        lastTarget = target;
        lastDirection = direction;
        var nextSibling = target.nextElementSibling, after = false;
        after = direction === 1;
        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);
        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }
          _silent = true;
          setTimeout(_unsilent, 30);
          capture();
          if (after && !nextSibling) {
            el.appendChild(dragEl);
          } else {
            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
          }
          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }
          parentEl = dragEl.parentNode;
          if (targetBeforeFirstSwap !== void 0 && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
          }
          changed();
          return completed(true);
        }
      }
      if (el.contains(dragEl)) {
        return completed(false);
      }
    }
    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, "mousemove", this._onTouchMove);
    off(document, "touchmove", this._onTouchMove);
    off(document, "pointermove", this._onTouchMove);
    off(document, "dragover", nearestEmptyInsertDetectEvent);
    off(document, "mousemove", nearestEmptyInsertDetectEvent);
    off(document, "touchmove", nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, "mouseup", this._onDrop);
    off(ownerDocument, "touchend", this._onDrop);
    off(ownerDocument, "pointerup", this._onDrop);
    off(ownerDocument, "touchcancel", this._onDrop);
    off(document, "selectstart", this);
  },
  _onDrop: function _onDrop(evt) {
    var el = this.el, options = this.options;
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    pluginEvent2("drop", this, {
      evt
    });
    parentEl = dragEl && dragEl.parentNode;
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    if (Sortable.eventCanceled) {
      this._nulling();
      return;
    }
    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);
    _cancelNextTick(this.cloneId);
    _cancelNextTick(this._dragStartId);
    if (this.nativeDraggable) {
      off(document, "drop", this);
      off(el, "dragstart", this._onDragStart);
    }
    this._offMoveEvents();
    this._offUpEvents();
    if (Safari) {
      css(document.body, "user-select", "");
    }
    css(dragEl, "transform", "");
    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options.dropBubble && evt.stopPropagation();
      }
      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== "clone") {
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }
      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, "dragend", this);
        }
        _disableDraggable(dragEl);
        dragEl.style["will-change"] = "";
        if (moved && !awaitingDragStarted) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }
        toggleClass(dragEl, this.options.chosenClass, false);
        _dispatchEvent({
          sortable: this,
          name: "unchoose",
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });
        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            _dispatchEvent({
              rootEl: parentEl,
              name: "add",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "remove",
              toEl: parentEl,
              originalEvent: evt
            });
            _dispatchEvent({
              rootEl: parentEl,
              name: "sort",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "sort",
              toEl: parentEl,
              originalEvent: evt
            });
          }
          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              _dispatchEvent({
                sortable: this,
                name: "update",
                toEl: parentEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: "sort",
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }
        if (Sortable.active) {
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }
          _dispatchEvent({
            sortable: this,
            name: "end",
            toEl: parentEl,
            originalEvent: evt
          });
          this.save();
        }
      }
    }
    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent2("nulling", this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function(el) {
      el.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent(evt) {
    switch (evt.type) {
      case "drop":
      case "dragend":
        this._onDrop(evt);
        break;
      case "dragenter":
      case "dragover":
        if (dragEl) {
          this._onDragOver(evt);
          _globalDragOver(evt);
        }
        break;
      case "selectstart":
        evt.preventDefault();
        break;
    }
  },
  /**
   * Serializes the item into an array of string.
   * @returns {String[]}
   */
  toArray: function toArray() {
    var order = [], el, children = this.el.children, i = 0, n = children.length, options = this.options;
    for (; i < n; i++) {
      el = children[i];
      if (closest(el, options.draggable, this.el, false)) {
        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
      }
    }
    return order;
  },
  /**
   * Sorts the elements according to the array.
   * @param  {String[]}  order  order of the items
   */
  sort: function sort(order, useAnimation) {
    var items = {}, rootEl2 = this.el;
    this.toArray().forEach(function(id, i) {
      var el = rootEl2.children[i];
      if (closest(el, this.options.draggable, rootEl2, false)) {
        items[id] = el;
      }
    }, this);
    useAnimation && this.captureAnimationState();
    order.forEach(function(id) {
      if (items[id]) {
        rootEl2.removeChild(items[id]);
        rootEl2.appendChild(items[id]);
      }
    });
    useAnimation && this.animateAll();
  },
  /**
   * Save the current sorting
   */
  save: function save() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },
  /**
   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
   * @param   {HTMLElement}  el
   * @param   {String}       [selector]  default: `options.draggable`
   * @returns {HTMLElement|null}
   */
  closest: function closest$1(el, selector) {
    return closest(el, selector || this.options.draggable, this.el, false);
  },
  /**
   * Set/get option
   * @param   {string} name
   * @param   {*}      [value]
   * @returns {*}
   */
  option: function option(name, value) {
    var options = this.options;
    if (value === void 0) {
      return options[name];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name, value);
      if (typeof modifiedValue !== "undefined") {
        options[name] = modifiedValue;
      } else {
        options[name] = value;
      }
      if (name === "group") {
        _prepareGroup(options);
      }
    }
  },
  /**
   * Destroy
   */
  destroy: function destroy() {
    pluginEvent2("destroy", this);
    var el = this.el;
    el[expando] = null;
    off(el, "mousedown", this._onTapStart);
    off(el, "touchstart", this._onTapStart);
    off(el, "pointerdown", this._onTapStart);
    if (this.nativeDraggable) {
      off(el, "dragover", this);
      off(el, "dragenter", this);
    }
    Array.prototype.forEach.call(el.querySelectorAll("[draggable]"), function(el2) {
      el2.removeAttribute("draggable");
    });
    this._onDrop();
    this._disableDelayedDragEvents();
    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent2("hideClone", this);
      if (Sortable.eventCanceled)
        return;
      css(cloneEl, "display", "none");
      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }
      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable2) {
    if (putSortable2.lastPutMode !== "clone") {
      this._hideClone();
      return;
    }
    if (cloneHidden) {
      pluginEvent2("showClone", this);
      if (Sortable.eventCanceled)
        return;
      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }
      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }
      css(cloneEl, "display", "");
      cloneHidden = false;
    }
  }
};
function _globalDragOver(evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = "move";
  }
  evt.cancelable && evt.preventDefault();
}
function _onMove(fromEl, toEl, dragEl2, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt, sortable = fromEl[expando], onMoveFn = sortable.options.onMove, retVal;
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent("move", {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent("move", true, true);
  }
  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl2;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);
  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }
  return retVal;
}
function _disableDraggable(el) {
  el.draggable = false;
}
function _unsilent() {
  _silent = false;
}
function _ghostIsFirst(evt, vertical, sortable) {
  var rect = getRect(getChild(sortable.el, 0, sortable.options, true));
  var spacer = 10;
  return vertical ? evt.clientX < rect.left - spacer || evt.clientY < rect.top && evt.clientX < rect.right : evt.clientY < rect.top - spacer || evt.clientY < rect.bottom && evt.clientX < rect.left;
}
function _ghostIsLast(evt, vertical, sortable) {
  var rect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var spacer = 10;
  return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;
}
function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX, targetLength = vertical ? targetRect.height : targetRect.width, targetS1 = vertical ? targetRect.top : targetRect.left, targetS2 = vertical ? targetRect.bottom : targetRect.right, invert = false;
  if (!invertSwap) {
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        pastFirstInvertThresh = true;
      }
      if (!pastFirstInvertThresh) {
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }
  invert = invert || invertSwap;
  if (invert) {
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }
  return 0;
}
function _getInsertDirection(target) {
  if (index(dragEl) < index(target)) {
    return 1;
  } else {
    return -1;
  }
}
function _generateId(el) {
  var str = el.tagName + el.className + el.src + el.href + el.textContent, i = str.length, sum = 0;
  while (i--) {
    sum += str.charCodeAt(i);
  }
  return sum.toString(36);
}
function _saveInputCheckedState(root2) {
  savedInputChecked.length = 0;
  var inputs = root2.getElementsByTagName("input");
  var idx = inputs.length;
  while (idx--) {
    var el = inputs[idx];
    el.checked && savedInputChecked.push(el);
  }
}
function _nextTick(fn) {
  return setTimeout(fn, 0);
}
function _cancelNextTick(id) {
  return clearTimeout(id);
}
if (documentExists) {
  on(document, "touchmove", function(evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
}
Sortable.utils = {
  on,
  off,
  css,
  find,
  is: function is(el, selector) {
    return !!closest(el, selector, el, false);
  },
  extend,
  throttle,
  closest,
  toggleClass,
  clone,
  index,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild
};
Sortable.get = function(element) {
  return element[expando];
};
Sortable.mount = function() {
  for (var _len = arguments.length, plugins2 = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins2[_key] = arguments[_key];
  }
  if (plugins2[0].constructor === Array)
    plugins2 = plugins2[0];
  plugins2.forEach(function(plugin2) {
    if (!plugin2.prototype || !plugin2.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin2));
    }
    if (plugin2.utils)
      Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin2.utils);
    PluginManager.mount(plugin2);
  });
};
Sortable.create = function(el, options) {
  return new Sortable(el, options);
};
Sortable.version = version$1;
var autoScrolls = [], scrollEl, scrollRootEl, scrolling = false, lastAutoScrollX, lastAutoScrollY, touchEvt$1, pointerElemChangedInterval;
function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      forceAutoScrollFallback: false,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    };
    for (var fn in this) {
      if (fn.charAt(0) === "_" && typeof this[fn] === "function") {
        this[fn] = this[fn].bind(this);
      }
    }
  }
  AutoScroll.prototype = {
    dragStarted: function dragStarted2(_ref) {
      var originalEvent = _ref.originalEvent;
      if (this.sortable.nativeDraggable) {
        on(document, "dragover", this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on(document, "pointermove", this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on(document, "touchmove", this._handleFallbackAutoScroll);
        } else {
          on(document, "mousemove", this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent;
      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop3() {
      if (this.sortable.nativeDraggable) {
        off(document, "dragover", this._handleAutoScroll);
      } else {
        off(document, "pointermove", this._handleFallbackAutoScroll);
        off(document, "touchmove", this._handleFallbackAutoScroll);
        off(document, "mousemove", this._handleFallbackAutoScroll);
      }
      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;
      var x2 = (evt.touches ? evt.touches[0] : evt).clientX, y2 = (evt.touches ? evt.touches[0] : evt).clientY, elem = document.elementFromPoint(x2, y2);
      touchEvt$1 = evt;
      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback);
        var ogElemScroller = getParentAutoScrollElement(elem, true);
        if (scrolling && (!pointerElemChangedInterval || x2 !== lastAutoScrollX || y2 !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval();
          pointerElemChangedInterval = setInterval(function() {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x2, y2), true);
            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }
            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x2;
          lastAutoScrollY = y2;
        }
      } else {
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }
        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: "scroll",
    initializeByDefault: true
  });
}
function clearAutoScrolls() {
  autoScrolls.forEach(function(autoScroll2) {
    clearInterval(autoScroll2.pid);
  });
  autoScrolls = [];
}
function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}
var autoScroll = throttle(function(evt, options, rootEl2, isFallback) {
  if (!options.scroll)
    return;
  var x2 = (evt.touches ? evt.touches[0] : evt).clientX, y2 = (evt.touches ? evt.touches[0] : evt).clientY, sens = options.scrollSensitivity, speed = options.scrollSpeed, winScroller = getWindowScrollingElement();
  var scrollThisInstance = false, scrollCustomFn;
  if (scrollRootEl !== rootEl2) {
    scrollRootEl = rootEl2;
    clearAutoScrolls();
    scrollEl = options.scroll;
    scrollCustomFn = options.scrollFn;
    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl2, true);
    }
  }
  var layersOut = 0;
  var currentParent = scrollEl;
  do {
    var el = currentParent, rect = getRect(el), top = rect.top, bottom = rect.bottom, left = rect.left, right = rect.right, width = rect.width, height = rect.height, canScrollX = void 0, canScrollY = void 0, scrollWidth = el.scrollWidth, scrollHeight = el.scrollHeight, elCSS = css(el), scrollPosX = el.scrollLeft, scrollPosY = el.scrollTop;
    if (el === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll" || elCSS.overflowX === "visible");
      canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll" || elCSS.overflowY === "visible");
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll");
      canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll");
    }
    var vx = canScrollX && (Math.abs(right - x2) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x2) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom - y2) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y2) <= sens && !!scrollPosY);
    if (!autoScrolls[layersOut]) {
      for (var i = 0; i <= layersOut; i++) {
        if (!autoScrolls[i]) {
          autoScrolls[i] = {};
        }
      }
    }
    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
      autoScrolls[layersOut].el = el;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);
      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        autoScrolls[layersOut].pid = setInterval((function() {
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1);
          }
          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
          if (typeof scrollCustomFn === "function") {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== "continue") {
              return;
            }
          }
          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }).bind({
          layer: layersOut
        }), 24);
      }
    }
    layersOut++;
  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
  scrolling = scrollThisInstance;
}, 30);
var drop = function drop2(_ref) {
  var originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, dragEl2 = _ref.dragEl, activeSortable = _ref.activeSortable, dispatchSortableEvent = _ref.dispatchSortableEvent, hideGhostForTarget = _ref.hideGhostForTarget, unhideGhostForTarget = _ref.unhideGhostForTarget;
  if (!originalEvent)
    return;
  var toSortable = putSortable2 || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();
  if (toSortable && !toSortable.el.contains(target)) {
    dispatchSortableEvent("spill");
    this.onSpill({
      dragEl: dragEl2,
      putSortable: putSortable2
    });
  }
};
function Revert() {
}
Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex2 = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex2;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl2 = _ref3.dragEl, putSortable2 = _ref3.putSortable;
    this.sortable.captureAnimationState();
    if (putSortable2) {
      putSortable2.captureAnimationState();
    }
    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl2, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl2);
    }
    this.sortable.animateAll();
    if (putSortable2) {
      putSortable2.animateAll();
    }
  },
  drop
};
_extends(Revert, {
  pluginName: "revertOnSpill"
});
function Remove() {
}
Remove.prototype = {
  onSpill: function onSpill2(_ref4) {
    var dragEl2 = _ref4.dragEl, putSortable2 = _ref4.putSortable;
    var parentSortable = putSortable2 || this.sortable;
    parentSortable.captureAnimationState();
    dragEl2.parentNode && dragEl2.parentNode.removeChild(dragEl2);
    parentSortable.animateAll();
  },
  drop
};
_extends(Remove, {
  pluginName: "removeOnSpill"
});
var lastSwapEl;
function SwapPlugin() {
  function Swap() {
    this.defaults = {
      swapClass: "sortable-swap-highlight"
    };
  }
  Swap.prototype = {
    dragStart: function dragStart2(_ref) {
      var dragEl2 = _ref.dragEl;
      lastSwapEl = dragEl2;
    },
    dragOverValid: function dragOverValid(_ref2) {
      var completed = _ref2.completed, target = _ref2.target, onMove = _ref2.onMove, activeSortable = _ref2.activeSortable, changed = _ref2.changed, cancel = _ref2.cancel;
      if (!activeSortable.options.swap)
        return;
      var el = this.sortable.el, options = this.options;
      if (target && target !== el) {
        var prevSwapEl = lastSwapEl;
        if (onMove(target) !== false) {
          toggleClass(target, options.swapClass, true);
          lastSwapEl = target;
        } else {
          lastSwapEl = null;
        }
        if (prevSwapEl && prevSwapEl !== lastSwapEl) {
          toggleClass(prevSwapEl, options.swapClass, false);
        }
      }
      changed();
      completed(true);
      cancel();
    },
    drop: function drop3(_ref3) {
      var activeSortable = _ref3.activeSortable, putSortable2 = _ref3.putSortable, dragEl2 = _ref3.dragEl;
      var toSortable = putSortable2 || this.sortable;
      var options = this.options;
      lastSwapEl && toggleClass(lastSwapEl, options.swapClass, false);
      if (lastSwapEl && (options.swap || putSortable2 && putSortable2.options.swap)) {
        if (dragEl2 !== lastSwapEl) {
          toSortable.captureAnimationState();
          if (toSortable !== activeSortable)
            activeSortable.captureAnimationState();
          swapNodes(dragEl2, lastSwapEl);
          toSortable.animateAll();
          if (toSortable !== activeSortable)
            activeSortable.animateAll();
        }
      }
    },
    nulling: function nulling() {
      lastSwapEl = null;
    }
  };
  return _extends(Swap, {
    pluginName: "swap",
    eventProperties: function eventProperties() {
      return {
        swapItem: lastSwapEl
      };
    }
  });
}
function swapNodes(n1, n2) {
  var p1 = n1.parentNode, p2 = n2.parentNode, i1, i2;
  if (!p1 || !p2 || p1.isEqualNode(n2) || p2.isEqualNode(n1))
    return;
  i1 = index(n1);
  i2 = index(n2);
  if (p1.isEqualNode(p2) && i1 < i2) {
    i2++;
  }
  p1.insertBefore(n2, p1.children[i1]);
  p2.insertBefore(n1, p2.children[i2]);
}
var multiDragElements = [], multiDragClones = [], lastMultiDragSelect, multiDragSortable, initialFolding = false, folding = false, dragStarted = false, dragEl$1, clonesFromRect, clonesHidden;
function MultiDragPlugin() {
  function MultiDrag(sortable) {
    for (var fn in this) {
      if (fn.charAt(0) === "_" && typeof this[fn] === "function") {
        this[fn] = this[fn].bind(this);
      }
    }
    if (sortable.options.supportPointer) {
      on(document, "pointerup", this._deselectMultiDrag);
    } else {
      on(document, "mouseup", this._deselectMultiDrag);
      on(document, "touchend", this._deselectMultiDrag);
    }
    on(document, "keydown", this._checkKeyDown);
    on(document, "keyup", this._checkKeyUp);
    this.defaults = {
      selectedClass: "sortable-selected",
      multiDragKey: null,
      setData: function setData(dataTransfer, dragEl2) {
        var data = "";
        if (multiDragElements.length && multiDragSortable === sortable) {
          multiDragElements.forEach(function(multiDragElement, i) {
            data += (!i ? "" : ", ") + multiDragElement.textContent;
          });
        } else {
          data = dragEl2.textContent;
        }
        dataTransfer.setData("Text", data);
      }
    };
  }
  MultiDrag.prototype = {
    multiDragKeyDown: false,
    isMultiDrag: false,
    delayStartGlobal: function delayStartGlobal(_ref) {
      var dragged = _ref.dragEl;
      dragEl$1 = dragged;
    },
    delayEnded: function delayEnded() {
      this.isMultiDrag = ~multiDragElements.indexOf(dragEl$1);
    },
    setupClone: function setupClone(_ref2) {
      var sortable = _ref2.sortable, cancel = _ref2.cancel;
      if (!this.isMultiDrag)
        return;
      for (var i = 0; i < multiDragElements.length; i++) {
        multiDragClones.push(clone(multiDragElements[i]));
        multiDragClones[i].sortableIndex = multiDragElements[i].sortableIndex;
        multiDragClones[i].draggable = false;
        multiDragClones[i].style["will-change"] = "";
        toggleClass(multiDragClones[i], this.options.selectedClass, false);
        multiDragElements[i] === dragEl$1 && toggleClass(multiDragClones[i], this.options.chosenClass, false);
      }
      sortable._hideClone();
      cancel();
    },
    clone: function clone2(_ref3) {
      var sortable = _ref3.sortable, rootEl2 = _ref3.rootEl, dispatchSortableEvent = _ref3.dispatchSortableEvent, cancel = _ref3.cancel;
      if (!this.isMultiDrag)
        return;
      if (!this.options.removeCloneOnHide) {
        if (multiDragElements.length && multiDragSortable === sortable) {
          insertMultiDragClones(true, rootEl2);
          dispatchSortableEvent("clone");
          cancel();
        }
      }
    },
    showClone: function showClone(_ref4) {
      var cloneNowShown = _ref4.cloneNowShown, rootEl2 = _ref4.rootEl, cancel = _ref4.cancel;
      if (!this.isMultiDrag)
        return;
      insertMultiDragClones(false, rootEl2);
      multiDragClones.forEach(function(clone2) {
        css(clone2, "display", "");
      });
      cloneNowShown();
      clonesHidden = false;
      cancel();
    },
    hideClone: function hideClone(_ref5) {
      var _this = this;
      _ref5.sortable;
      var cloneNowHidden = _ref5.cloneNowHidden, cancel = _ref5.cancel;
      if (!this.isMultiDrag)
        return;
      multiDragClones.forEach(function(clone2) {
        css(clone2, "display", "none");
        if (_this.options.removeCloneOnHide && clone2.parentNode) {
          clone2.parentNode.removeChild(clone2);
        }
      });
      cloneNowHidden();
      clonesHidden = true;
      cancel();
    },
    dragStartGlobal: function dragStartGlobal(_ref6) {
      _ref6.sortable;
      if (!this.isMultiDrag && multiDragSortable) {
        multiDragSortable.multiDrag._deselectMultiDrag();
      }
      multiDragElements.forEach(function(multiDragElement) {
        multiDragElement.sortableIndex = index(multiDragElement);
      });
      multiDragElements = multiDragElements.sort(function(a, b2) {
        return a.sortableIndex - b2.sortableIndex;
      });
      dragStarted = true;
    },
    dragStarted: function dragStarted2(_ref7) {
      var _this2 = this;
      var sortable = _ref7.sortable;
      if (!this.isMultiDrag)
        return;
      if (this.options.sort) {
        sortable.captureAnimationState();
        if (this.options.animation) {
          multiDragElements.forEach(function(multiDragElement) {
            if (multiDragElement === dragEl$1)
              return;
            css(multiDragElement, "position", "absolute");
          });
          var dragRect = getRect(dragEl$1, false, true, true);
          multiDragElements.forEach(function(multiDragElement) {
            if (multiDragElement === dragEl$1)
              return;
            setRect(multiDragElement, dragRect);
          });
          folding = true;
          initialFolding = true;
        }
      }
      sortable.animateAll(function() {
        folding = false;
        initialFolding = false;
        if (_this2.options.animation) {
          multiDragElements.forEach(function(multiDragElement) {
            unsetRect(multiDragElement);
          });
        }
        if (_this2.options.sort) {
          removeMultiDragElements();
        }
      });
    },
    dragOver: function dragOver(_ref8) {
      var target = _ref8.target, completed = _ref8.completed, cancel = _ref8.cancel;
      if (folding && ~multiDragElements.indexOf(target)) {
        completed(false);
        cancel();
      }
    },
    revert: function revert(_ref9) {
      var fromSortable = _ref9.fromSortable, rootEl2 = _ref9.rootEl, sortable = _ref9.sortable, dragRect = _ref9.dragRect;
      if (multiDragElements.length > 1) {
        multiDragElements.forEach(function(multiDragElement) {
          sortable.addAnimationState({
            target: multiDragElement,
            rect: folding ? getRect(multiDragElement) : dragRect
          });
          unsetRect(multiDragElement);
          multiDragElement.fromRect = dragRect;
          fromSortable.removeAnimationState(multiDragElement);
        });
        folding = false;
        insertMultiDragElements(!this.options.removeCloneOnHide, rootEl2);
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref10) {
      var sortable = _ref10.sortable, isOwner = _ref10.isOwner, insertion = _ref10.insertion, activeSortable = _ref10.activeSortable, parentEl2 = _ref10.parentEl, putSortable2 = _ref10.putSortable;
      var options = this.options;
      if (insertion) {
        if (isOwner) {
          activeSortable._hideClone();
        }
        initialFolding = false;
        if (options.animation && multiDragElements.length > 1 && (folding || !isOwner && !activeSortable.options.sort && !putSortable2)) {
          var dragRectAbsolute = getRect(dragEl$1, false, true, true);
          multiDragElements.forEach(function(multiDragElement) {
            if (multiDragElement === dragEl$1)
              return;
            setRect(multiDragElement, dragRectAbsolute);
            parentEl2.appendChild(multiDragElement);
          });
          folding = true;
        }
        if (!isOwner) {
          if (!folding) {
            removeMultiDragElements();
          }
          if (multiDragElements.length > 1) {
            var clonesHiddenBefore = clonesHidden;
            activeSortable._showClone(sortable);
            if (activeSortable.options.animation && !clonesHidden && clonesHiddenBefore) {
              multiDragClones.forEach(function(clone2) {
                activeSortable.addAnimationState({
                  target: clone2,
                  rect: clonesFromRect
                });
                clone2.fromRect = clonesFromRect;
                clone2.thisAnimationDuration = null;
              });
            }
          } else {
            activeSortable._showClone(sortable);
          }
        }
      }
    },
    dragOverAnimationCapture: function dragOverAnimationCapture(_ref11) {
      var dragRect = _ref11.dragRect, isOwner = _ref11.isOwner, activeSortable = _ref11.activeSortable;
      multiDragElements.forEach(function(multiDragElement) {
        multiDragElement.thisAnimationDuration = null;
      });
      if (activeSortable.options.animation && !isOwner && activeSortable.multiDrag.isMultiDrag) {
        clonesFromRect = _extends({}, dragRect);
        var dragMatrix = matrix(dragEl$1, true);
        clonesFromRect.top -= dragMatrix.f;
        clonesFromRect.left -= dragMatrix.e;
      }
    },
    dragOverAnimationComplete: function dragOverAnimationComplete() {
      if (folding) {
        folding = false;
        removeMultiDragElements();
      }
    },
    drop: function drop3(_ref12) {
      var evt = _ref12.originalEvent, rootEl2 = _ref12.rootEl, parentEl2 = _ref12.parentEl, sortable = _ref12.sortable, dispatchSortableEvent = _ref12.dispatchSortableEvent, oldIndex2 = _ref12.oldIndex, putSortable2 = _ref12.putSortable;
      var toSortable = putSortable2 || this.sortable;
      if (!evt)
        return;
      var options = this.options, children = parentEl2.children;
      if (!dragStarted) {
        if (options.multiDragKey && !this.multiDragKeyDown) {
          this._deselectMultiDrag();
        }
        toggleClass(dragEl$1, options.selectedClass, !~multiDragElements.indexOf(dragEl$1));
        if (!~multiDragElements.indexOf(dragEl$1)) {
          multiDragElements.push(dragEl$1);
          dispatchEvent({
            sortable,
            rootEl: rootEl2,
            name: "select",
            targetEl: dragEl$1,
            originalEvt: evt
          });
          if (evt.shiftKey && lastMultiDragSelect && sortable.el.contains(lastMultiDragSelect)) {
            var lastIndex = index(lastMultiDragSelect), currentIndex = index(dragEl$1);
            if (~lastIndex && ~currentIndex && lastIndex !== currentIndex) {
              var n, i;
              if (currentIndex > lastIndex) {
                i = lastIndex;
                n = currentIndex;
              } else {
                i = currentIndex;
                n = lastIndex + 1;
              }
              for (; i < n; i++) {
                if (~multiDragElements.indexOf(children[i]))
                  continue;
                toggleClass(children[i], options.selectedClass, true);
                multiDragElements.push(children[i]);
                dispatchEvent({
                  sortable,
                  rootEl: rootEl2,
                  name: "select",
                  targetEl: children[i],
                  originalEvt: evt
                });
              }
            }
          } else {
            lastMultiDragSelect = dragEl$1;
          }
          multiDragSortable = toSortable;
        } else {
          multiDragElements.splice(multiDragElements.indexOf(dragEl$1), 1);
          lastMultiDragSelect = null;
          dispatchEvent({
            sortable,
            rootEl: rootEl2,
            name: "deselect",
            targetEl: dragEl$1,
            originalEvt: evt
          });
        }
      }
      if (dragStarted && this.isMultiDrag) {
        folding = false;
        if ((parentEl2[expando].options.sort || parentEl2 !== rootEl2) && multiDragElements.length > 1) {
          var dragRect = getRect(dragEl$1), multiDragIndex = index(dragEl$1, ":not(." + this.options.selectedClass + ")");
          if (!initialFolding && options.animation)
            dragEl$1.thisAnimationDuration = null;
          toSortable.captureAnimationState();
          if (!initialFolding) {
            if (options.animation) {
              dragEl$1.fromRect = dragRect;
              multiDragElements.forEach(function(multiDragElement) {
                multiDragElement.thisAnimationDuration = null;
                if (multiDragElement !== dragEl$1) {
                  var rect = folding ? getRect(multiDragElement) : dragRect;
                  multiDragElement.fromRect = rect;
                  toSortable.addAnimationState({
                    target: multiDragElement,
                    rect
                  });
                }
              });
            }
            removeMultiDragElements();
            multiDragElements.forEach(function(multiDragElement) {
              if (children[multiDragIndex]) {
                parentEl2.insertBefore(multiDragElement, children[multiDragIndex]);
              } else {
                parentEl2.appendChild(multiDragElement);
              }
              multiDragIndex++;
            });
            if (oldIndex2 === index(dragEl$1)) {
              var update = false;
              multiDragElements.forEach(function(multiDragElement) {
                if (multiDragElement.sortableIndex !== index(multiDragElement)) {
                  update = true;
                  return;
                }
              });
              if (update) {
                dispatchSortableEvent("update");
              }
            }
          }
          multiDragElements.forEach(function(multiDragElement) {
            unsetRect(multiDragElement);
          });
          toSortable.animateAll();
        }
        multiDragSortable = toSortable;
      }
      if (rootEl2 === parentEl2 || putSortable2 && putSortable2.lastPutMode !== "clone") {
        multiDragClones.forEach(function(clone2) {
          clone2.parentNode && clone2.parentNode.removeChild(clone2);
        });
      }
    },
    nullingGlobal: function nullingGlobal() {
      this.isMultiDrag = dragStarted = false;
      multiDragClones.length = 0;
    },
    destroyGlobal: function destroyGlobal() {
      this._deselectMultiDrag();
      off(document, "pointerup", this._deselectMultiDrag);
      off(document, "mouseup", this._deselectMultiDrag);
      off(document, "touchend", this._deselectMultiDrag);
      off(document, "keydown", this._checkKeyDown);
      off(document, "keyup", this._checkKeyUp);
    },
    _deselectMultiDrag: function _deselectMultiDrag(evt) {
      if (typeof dragStarted !== "undefined" && dragStarted)
        return;
      if (multiDragSortable !== this.sortable)
        return;
      if (evt && closest(evt.target, this.options.draggable, this.sortable.el, false))
        return;
      if (evt && evt.button !== 0)
        return;
      while (multiDragElements.length) {
        var el = multiDragElements[0];
        toggleClass(el, this.options.selectedClass, false);
        multiDragElements.shift();
        dispatchEvent({
          sortable: this.sortable,
          rootEl: this.sortable.el,
          name: "deselect",
          targetEl: el,
          originalEvt: evt
        });
      }
    },
    _checkKeyDown: function _checkKeyDown(evt) {
      if (evt.key === this.options.multiDragKey) {
        this.multiDragKeyDown = true;
      }
    },
    _checkKeyUp: function _checkKeyUp(evt) {
      if (evt.key === this.options.multiDragKey) {
        this.multiDragKeyDown = false;
      }
    }
  };
  return _extends(MultiDrag, {
    // Static methods & properties
    pluginName: "multiDrag",
    utils: {
      /**
       * Selects the provided multi-drag item
       * @param  {HTMLElement} el    The element to be selected
       */
      select: function select(el) {
        var sortable = el.parentNode[expando];
        if (!sortable || !sortable.options.multiDrag || ~multiDragElements.indexOf(el))
          return;
        if (multiDragSortable && multiDragSortable !== sortable) {
          multiDragSortable.multiDrag._deselectMultiDrag();
          multiDragSortable = sortable;
        }
        toggleClass(el, sortable.options.selectedClass, true);
        multiDragElements.push(el);
      },
      /**
       * Deselects the provided multi-drag item
       * @param  {HTMLElement} el    The element to be deselected
       */
      deselect: function deselect(el) {
        var sortable = el.parentNode[expando], index2 = multiDragElements.indexOf(el);
        if (!sortable || !sortable.options.multiDrag || !~index2)
          return;
        toggleClass(el, sortable.options.selectedClass, false);
        multiDragElements.splice(index2, 1);
      }
    },
    eventProperties: function eventProperties() {
      var _this3 = this;
      var oldIndicies = [], newIndicies = [];
      multiDragElements.forEach(function(multiDragElement) {
        oldIndicies.push({
          multiDragElement,
          index: multiDragElement.sortableIndex
        });
        var newIndex2;
        if (folding && multiDragElement !== dragEl$1) {
          newIndex2 = -1;
        } else if (folding) {
          newIndex2 = index(multiDragElement, ":not(." + _this3.options.selectedClass + ")");
        } else {
          newIndex2 = index(multiDragElement);
        }
        newIndicies.push({
          multiDragElement,
          index: newIndex2
        });
      });
      return {
        items: _toConsumableArray(multiDragElements),
        clones: [].concat(multiDragClones),
        oldIndicies,
        newIndicies
      };
    },
    optionListeners: {
      multiDragKey: function multiDragKey(key2) {
        key2 = key2.toLowerCase();
        if (key2 === "ctrl") {
          key2 = "Control";
        } else if (key2.length > 1) {
          key2 = key2.charAt(0).toUpperCase() + key2.substr(1);
        }
        return key2;
      }
    }
  });
}
function insertMultiDragElements(clonesInserted, rootEl2) {
  multiDragElements.forEach(function(multiDragElement, i) {
    var target = rootEl2.children[multiDragElement.sortableIndex + (clonesInserted ? Number(i) : 0)];
    if (target) {
      rootEl2.insertBefore(multiDragElement, target);
    } else {
      rootEl2.appendChild(multiDragElement);
    }
  });
}
function insertMultiDragClones(elementsInserted, rootEl2) {
  multiDragClones.forEach(function(clone2, i) {
    var target = rootEl2.children[clone2.sortableIndex + (elementsInserted ? Number(i) : 0)];
    if (target) {
      rootEl2.insertBefore(clone2, target);
    } else {
      rootEl2.appendChild(clone2);
    }
  });
}
function removeMultiDragElements() {
  multiDragElements.forEach(function(multiDragElement) {
    if (multiDragElement === dragEl$1)
      return;
    multiDragElement.parentNode && multiDragElement.parentNode.removeChild(multiDragElement);
  });
}
Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);
const sortable_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  MultiDrag: MultiDragPlugin,
  Sortable,
  Swap: SwapPlugin,
  default: Sortable
}, Symbol.toStringTag, { value: "Module" }));
const require$$1 = /* @__PURE__ */ getAugmentedNamespace(sortable_esm);
(function(module, exports) {
  (function webpackUniversalModuleDefinition(root2, factory) {
    module.exports = factory(require$$0$2, require$$1);
  })(typeof self !== "undefined" ? self : commonjsGlobal, function(__WEBPACK_EXTERNAL_MODULE__8bbf__, __WEBPACK_EXTERNAL_MODULE_a352__) {
    return (
      /******/
      function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
          if (installedModules[moduleId]) {
            return installedModules[moduleId].exports;
          }
          var module2 = installedModules[moduleId] = {
            /******/
            i: moduleId,
            /******/
            l: false,
            /******/
            exports: {}
            /******/
          };
          modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
          module2.l = true;
          return module2.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.d = function(exports2, name, getter) {
          if (!__webpack_require__.o(exports2, name)) {
            Object.defineProperty(exports2, name, { enumerable: true, get: getter });
          }
        };
        __webpack_require__.r = function(exports2) {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
          }
          Object.defineProperty(exports2, "__esModule", { value: true });
        };
        __webpack_require__.t = function(value, mode) {
          if (mode & 1)
            value = __webpack_require__(value);
          if (mode & 8)
            return value;
          if (mode & 4 && typeof value === "object" && value && value.__esModule)
            return value;
          var ns = /* @__PURE__ */ Object.create(null);
          __webpack_require__.r(ns);
          Object.defineProperty(ns, "default", { enumerable: true, value });
          if (mode & 2 && typeof value != "string")
            for (var key2 in value)
              __webpack_require__.d(ns, key2, (function(key3) {
                return value[key3];
              }).bind(null, key2));
          return ns;
        };
        __webpack_require__.n = function(module2) {
          var getter = module2 && module2.__esModule ? (
            /******/
            function getDefault() {
              return module2["default"];
            }
          ) : (
            /******/
            function getModuleExports() {
              return module2;
            }
          );
          __webpack_require__.d(getter, "a", getter);
          return getter;
        };
        __webpack_require__.o = function(object, property) {
          return Object.prototype.hasOwnProperty.call(object, property);
        };
        __webpack_require__.p = "";
        return __webpack_require__(__webpack_require__.s = "fb15");
      }({
        /***/
        "00ee": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var wellKnownSymbol = __webpack_require__("b622");
            var TO_STRING_TAG = wellKnownSymbol("toStringTag");
            var test2 = {};
            test2[TO_STRING_TAG] = "z";
            module2.exports = String(test2) === "[object z]";
          }
        ),
        /***/
        "0366": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var aFunction = __webpack_require__("1c0b");
            module2.exports = function(fn, that, length) {
              aFunction(fn);
              if (that === void 0)
                return fn;
              switch (length) {
                case 0:
                  return function() {
                    return fn.call(that);
                  };
                case 1:
                  return function(a) {
                    return fn.call(that, a);
                  };
                case 2:
                  return function(a, b2) {
                    return fn.call(that, a, b2);
                  };
                case 3:
                  return function(a, b2, c2) {
                    return fn.call(that, a, b2, c2);
                  };
              }
              return function() {
                return fn.apply(that, arguments);
              };
            };
          }
        ),
        /***/
        "057f": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var toIndexedObject = __webpack_require__("fc6a");
            var nativeGetOwnPropertyNames = __webpack_require__("241c").f;
            var toString2 = {}.toString;
            var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
            var getWindowNames = function(it2) {
              try {
                return nativeGetOwnPropertyNames(it2);
              } catch (error) {
                return windowNames.slice();
              }
            };
            module2.exports.f = function getOwnPropertyNames(it2) {
              return windowNames && toString2.call(it2) == "[object Window]" ? getWindowNames(it2) : nativeGetOwnPropertyNames(toIndexedObject(it2));
            };
          }
        ),
        /***/
        "06cf": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var DESCRIPTORS = __webpack_require__("83ab");
            var propertyIsEnumerableModule = __webpack_require__("d1e7");
            var createPropertyDescriptor = __webpack_require__("5c6c");
            var toIndexedObject = __webpack_require__("fc6a");
            var toPrimitive = __webpack_require__("c04e");
            var has2 = __webpack_require__("5135");
            var IE8_DOM_DEFINE = __webpack_require__("0cfb");
            var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
            exports2.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O2, P2) {
              O2 = toIndexedObject(O2);
              P2 = toPrimitive(P2, true);
              if (IE8_DOM_DEFINE)
                try {
                  return nativeGetOwnPropertyDescriptor(O2, P2);
                } catch (error) {
                }
              if (has2(O2, P2))
                return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O2, P2), O2[P2]);
            };
          }
        ),
        /***/
        "0cfb": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var DESCRIPTORS = __webpack_require__("83ab");
            var fails = __webpack_require__("d039");
            var createElement = __webpack_require__("cc12");
            module2.exports = !DESCRIPTORS && !fails(function() {
              return Object.defineProperty(createElement("div"), "a", {
                get: function() {
                  return 7;
                }
              }).a != 7;
            });
          }
        ),
        /***/
        "13d5": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var $2 = __webpack_require__("23e7");
            var $reduce = __webpack_require__("d58f").left;
            var arrayMethodIsStrict = __webpack_require__("a640");
            var arrayMethodUsesToLength = __webpack_require__("ae40");
            var STRICT_METHOD = arrayMethodIsStrict("reduce");
            var USES_TO_LENGTH = arrayMethodUsesToLength("reduce", { 1: 0 });
            $2({ target: "Array", proto: true, forced: !STRICT_METHOD || !USES_TO_LENGTH }, {
              reduce: function reduce(callbackfn) {
                return $reduce(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : void 0);
              }
            });
          }
        ),
        /***/
        "14c3": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var classof = __webpack_require__("c6b6");
            var regexpExec = __webpack_require__("9263");
            module2.exports = function(R2, S2) {
              var exec = R2.exec;
              if (typeof exec === "function") {
                var result = exec.call(R2, S2);
                if (typeof result !== "object") {
                  throw TypeError("RegExp exec method returned something other than an Object or null");
                }
                return result;
              }
              if (classof(R2) !== "RegExp") {
                throw TypeError("RegExp#exec called on incompatible receiver");
              }
              return regexpExec.call(R2, S2);
            };
          }
        ),
        /***/
        "159b": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var global2 = __webpack_require__("da84");
            var DOMIterables = __webpack_require__("fdbc");
            var forEach3 = __webpack_require__("17c2");
            var createNonEnumerableProperty = __webpack_require__("9112");
            for (var COLLECTION_NAME in DOMIterables) {
              var Collection = global2[COLLECTION_NAME];
              var CollectionPrototype = Collection && Collection.prototype;
              if (CollectionPrototype && CollectionPrototype.forEach !== forEach3)
                try {
                  createNonEnumerableProperty(CollectionPrototype, "forEach", forEach3);
                } catch (error) {
                  CollectionPrototype.forEach = forEach3;
                }
            }
          }
        ),
        /***/
        "17c2": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var $forEach = __webpack_require__("b727").forEach;
            var arrayMethodIsStrict = __webpack_require__("a640");
            var arrayMethodUsesToLength = __webpack_require__("ae40");
            var STRICT_METHOD = arrayMethodIsStrict("forEach");
            var USES_TO_LENGTH = arrayMethodUsesToLength("forEach");
            module2.exports = !STRICT_METHOD || !USES_TO_LENGTH ? function forEach3(callbackfn) {
              return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
            } : [].forEach;
          }
        ),
        /***/
        "1be4": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var getBuiltIn = __webpack_require__("d066");
            module2.exports = getBuiltIn("document", "documentElement");
          }
        ),
        /***/
        "1c0b": (
          /***/
          function(module2, exports2) {
            module2.exports = function(it2) {
              if (typeof it2 != "function") {
                throw TypeError(String(it2) + " is not a function");
              }
              return it2;
            };
          }
        ),
        /***/
        "1c7e": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var wellKnownSymbol = __webpack_require__("b622");
            var ITERATOR = wellKnownSymbol("iterator");
            var SAFE_CLOSING = false;
            try {
              var called = 0;
              var iteratorWithReturn = {
                next: function() {
                  return { done: !!called++ };
                },
                "return": function() {
                  SAFE_CLOSING = true;
                }
              };
              iteratorWithReturn[ITERATOR] = function() {
                return this;
              };
              Array.from(iteratorWithReturn, function() {
                throw 2;
              });
            } catch (error) {
            }
            module2.exports = function(exec, SKIP_CLOSING) {
              if (!SKIP_CLOSING && !SAFE_CLOSING)
                return false;
              var ITERATION_SUPPORT = false;
              try {
                var object = {};
                object[ITERATOR] = function() {
                  return {
                    next: function() {
                      return { done: ITERATION_SUPPORT = true };
                    }
                  };
                };
                exec(object);
              } catch (error) {
              }
              return ITERATION_SUPPORT;
            };
          }
        ),
        /***/
        "1d80": (
          /***/
          function(module2, exports2) {
            module2.exports = function(it2) {
              if (it2 == void 0)
                throw TypeError("Can't call method on " + it2);
              return it2;
            };
          }
        ),
        /***/
        "1dde": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var fails = __webpack_require__("d039");
            var wellKnownSymbol = __webpack_require__("b622");
            var V8_VERSION = __webpack_require__("2d00");
            var SPECIES = wellKnownSymbol("species");
            module2.exports = function(METHOD_NAME) {
              return V8_VERSION >= 51 || !fails(function() {
                var array = [];
                var constructor = array.constructor = {};
                constructor[SPECIES] = function() {
                  return { foo: 1 };
                };
                return array[METHOD_NAME](Boolean).foo !== 1;
              });
            };
          }
        ),
        /***/
        "23cb": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var toInteger2 = __webpack_require__("a691");
            var max2 = Math.max;
            var min = Math.min;
            module2.exports = function(index2, length) {
              var integer = toInteger2(index2);
              return integer < 0 ? max2(integer + length, 0) : min(integer, length);
            };
          }
        ),
        /***/
        "23e7": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var global2 = __webpack_require__("da84");
            var getOwnPropertyDescriptor = __webpack_require__("06cf").f;
            var createNonEnumerableProperty = __webpack_require__("9112");
            var redefine = __webpack_require__("6eeb");
            var setGlobal = __webpack_require__("ce4e");
            var copyConstructorProperties = __webpack_require__("e893");
            var isForced = __webpack_require__("94ca");
            module2.exports = function(options, source2) {
              var TARGET = options.target;
              var GLOBAL = options.global;
              var STATIC = options.stat;
              var FORCED, target, key2, targetProperty, sourceProperty, descriptor;
              if (GLOBAL) {
                target = global2;
              } else if (STATIC) {
                target = global2[TARGET] || setGlobal(TARGET, {});
              } else {
                target = (global2[TARGET] || {}).prototype;
              }
              if (target)
                for (key2 in source2) {
                  sourceProperty = source2[key2];
                  if (options.noTargetGet) {
                    descriptor = getOwnPropertyDescriptor(target, key2);
                    targetProperty = descriptor && descriptor.value;
                  } else
                    targetProperty = target[key2];
                  FORCED = isForced(GLOBAL ? key2 : TARGET + (STATIC ? "." : "#") + key2, options.forced);
                  if (!FORCED && targetProperty !== void 0) {
                    if (typeof sourceProperty === typeof targetProperty)
                      continue;
                    copyConstructorProperties(sourceProperty, targetProperty);
                  }
                  if (options.sham || targetProperty && targetProperty.sham) {
                    createNonEnumerableProperty(sourceProperty, "sham", true);
                  }
                  redefine(target, key2, sourceProperty, options);
                }
            };
          }
        ),
        /***/
        "241c": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var internalObjectKeys = __webpack_require__("ca84");
            var enumBugKeys = __webpack_require__("7839");
            var hiddenKeys = enumBugKeys.concat("length", "prototype");
            exports2.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O2) {
              return internalObjectKeys(O2, hiddenKeys);
            };
          }
        ),
        /***/
        "25f0": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var redefine = __webpack_require__("6eeb");
            var anObject = __webpack_require__("825a");
            var fails = __webpack_require__("d039");
            var flags = __webpack_require__("ad6d");
            var TO_STRING = "toString";
            var RegExpPrototype = RegExp.prototype;
            var nativeToString = RegExpPrototype[TO_STRING];
            var NOT_GENERIC = fails(function() {
              return nativeToString.call({ source: "a", flags: "b" }) != "/a/b";
            });
            var INCORRECT_NAME = nativeToString.name != TO_STRING;
            if (NOT_GENERIC || INCORRECT_NAME) {
              redefine(RegExp.prototype, TO_STRING, function toString2() {
                var R2 = anObject(this);
                var p2 = String(R2.source);
                var rf = R2.flags;
                var f2 = String(rf === void 0 && R2 instanceof RegExp && !("flags" in RegExpPrototype) ? flags.call(R2) : rf);
                return "/" + p2 + "/" + f2;
              }, { unsafe: true });
            }
          }
        ),
        /***/
        "2ca0": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var $2 = __webpack_require__("23e7");
            var getOwnPropertyDescriptor = __webpack_require__("06cf").f;
            var toLength = __webpack_require__("50c4");
            var notARegExp = __webpack_require__("5a34");
            var requireObjectCoercible = __webpack_require__("1d80");
            var correctIsRegExpLogic = __webpack_require__("ab13");
            var IS_PURE = __webpack_require__("c430");
            var nativeStartsWith = "".startsWith;
            var min = Math.min;
            var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic("startsWith");
            var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function() {
              var descriptor = getOwnPropertyDescriptor(String.prototype, "startsWith");
              return descriptor && !descriptor.writable;
            }();
            $2({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
              startsWith: function startsWith(searchString) {
                var that = String(requireObjectCoercible(this));
                notARegExp(searchString);
                var index2 = toLength(min(arguments.length > 1 ? arguments[1] : void 0, that.length));
                var search = String(searchString);
                return nativeStartsWith ? nativeStartsWith.call(that, search, index2) : that.slice(index2, index2 + search.length) === search;
              }
            });
          }
        ),
        /***/
        "2d00": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var global2 = __webpack_require__("da84");
            var userAgent2 = __webpack_require__("342f");
            var process2 = global2.process;
            var versions = process2 && process2.versions;
            var v8 = versions && versions.v8;
            var match2, version2;
            if (v8) {
              match2 = v8.split(".");
              version2 = match2[0] + match2[1];
            } else if (userAgent2) {
              match2 = userAgent2.match(/Edge\/(\d+)/);
              if (!match2 || match2[1] >= 74) {
                match2 = userAgent2.match(/Chrome\/(\d+)/);
                if (match2)
                  version2 = match2[1];
              }
            }
            module2.exports = version2 && +version2;
          }
        ),
        /***/
        "342f": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var getBuiltIn = __webpack_require__("d066");
            module2.exports = getBuiltIn("navigator", "userAgent") || "";
          }
        ),
        /***/
        "35a1": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var classof = __webpack_require__("f5df");
            var Iterators = __webpack_require__("3f8c");
            var wellKnownSymbol = __webpack_require__("b622");
            var ITERATOR = wellKnownSymbol("iterator");
            module2.exports = function(it2) {
              if (it2 != void 0)
                return it2[ITERATOR] || it2["@@iterator"] || Iterators[classof(it2)];
            };
          }
        ),
        /***/
        "37e8": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var DESCRIPTORS = __webpack_require__("83ab");
            var definePropertyModule = __webpack_require__("9bf2");
            var anObject = __webpack_require__("825a");
            var objectKeys = __webpack_require__("df75");
            module2.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O2, Properties) {
              anObject(O2);
              var keys2 = objectKeys(Properties);
              var length = keys2.length;
              var index2 = 0;
              var key2;
              while (length > index2)
                definePropertyModule.f(O2, key2 = keys2[index2++], Properties[key2]);
              return O2;
            };
          }
        ),
        /***/
        "3bbe": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var isObject2 = __webpack_require__("861d");
            module2.exports = function(it2) {
              if (!isObject2(it2) && it2 !== null) {
                throw TypeError("Can't set " + String(it2) + " as a prototype");
              }
              return it2;
            };
          }
        ),
        /***/
        "3ca3": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var charAt = __webpack_require__("6547").charAt;
            var InternalStateModule = __webpack_require__("69f3");
            var defineIterator = __webpack_require__("7dd0");
            var STRING_ITERATOR = "String Iterator";
            var setInternalState = InternalStateModule.set;
            var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
            defineIterator(String, "String", function(iterated) {
              setInternalState(this, {
                type: STRING_ITERATOR,
                string: String(iterated),
                index: 0
              });
            }, function next() {
              var state = getInternalState(this);
              var string = state.string;
              var index2 = state.index;
              var point;
              if (index2 >= string.length)
                return { value: void 0, done: true };
              point = charAt(string, index2);
              state.index += point.length;
              return { value: point, done: false };
            });
          }
        ),
        /***/
        "3f8c": (
          /***/
          function(module2, exports2) {
            module2.exports = {};
          }
        ),
        /***/
        "4160": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var $2 = __webpack_require__("23e7");
            var forEach3 = __webpack_require__("17c2");
            $2({ target: "Array", proto: true, forced: [].forEach != forEach3 }, {
              forEach: forEach3
            });
          }
        ),
        /***/
        "428f": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var global2 = __webpack_require__("da84");
            module2.exports = global2;
          }
        ),
        /***/
        "44ad": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var fails = __webpack_require__("d039");
            var classof = __webpack_require__("c6b6");
            var split = "".split;
            module2.exports = fails(function() {
              return !Object("z").propertyIsEnumerable(0);
            }) ? function(it2) {
              return classof(it2) == "String" ? split.call(it2, "") : Object(it2);
            } : Object;
          }
        ),
        /***/
        "44d2": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var wellKnownSymbol = __webpack_require__("b622");
            var create2 = __webpack_require__("7c73");
            var definePropertyModule = __webpack_require__("9bf2");
            var UNSCOPABLES = wellKnownSymbol("unscopables");
            var ArrayPrototype = Array.prototype;
            if (ArrayPrototype[UNSCOPABLES] == void 0) {
              definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
                configurable: true,
                value: create2(null)
              });
            }
            module2.exports = function(key2) {
              ArrayPrototype[UNSCOPABLES][key2] = true;
            };
          }
        ),
        /***/
        "44e7": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var isObject2 = __webpack_require__("861d");
            var classof = __webpack_require__("c6b6");
            var wellKnownSymbol = __webpack_require__("b622");
            var MATCH = wellKnownSymbol("match");
            module2.exports = function(it2) {
              var isRegExp3;
              return isObject2(it2) && ((isRegExp3 = it2[MATCH]) !== void 0 ? !!isRegExp3 : classof(it2) == "RegExp");
            };
          }
        ),
        /***/
        "4930": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var fails = __webpack_require__("d039");
            module2.exports = !!Object.getOwnPropertySymbols && !fails(function() {
              return !String(Symbol());
            });
          }
        ),
        /***/
        "4d64": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var toIndexedObject = __webpack_require__("fc6a");
            var toLength = __webpack_require__("50c4");
            var toAbsoluteIndex = __webpack_require__("23cb");
            var createMethod = function(IS_INCLUDES) {
              return function($this, el, fromIndex) {
                var O2 = toIndexedObject($this);
                var length = toLength(O2.length);
                var index2 = toAbsoluteIndex(fromIndex, length);
                var value;
                if (IS_INCLUDES && el != el)
                  while (length > index2) {
                    value = O2[index2++];
                    if (value != value)
                      return true;
                  }
                else
                  for (; length > index2; index2++) {
                    if ((IS_INCLUDES || index2 in O2) && O2[index2] === el)
                      return IS_INCLUDES || index2 || 0;
                  }
                return !IS_INCLUDES && -1;
              };
            };
            module2.exports = {
              // `Array.prototype.includes` method
              // https://tc39.github.io/ecma262/#sec-array.prototype.includes
              includes: createMethod(true),
              // `Array.prototype.indexOf` method
              // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
              indexOf: createMethod(false)
            };
          }
        ),
        /***/
        "4de4": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var $2 = __webpack_require__("23e7");
            var $filter = __webpack_require__("b727").filter;
            var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
            var arrayMethodUsesToLength = __webpack_require__("ae40");
            var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("filter");
            var USES_TO_LENGTH = arrayMethodUsesToLength("filter");
            $2({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {
              filter: function filter(callbackfn) {
                return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
              }
            });
          }
        ),
        /***/
        "4df4": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var bind4 = __webpack_require__("0366");
            var toObject = __webpack_require__("7b0b");
            var callWithSafeIterationClosing = __webpack_require__("9bdd");
            var isArrayIteratorMethod = __webpack_require__("e95a");
            var toLength = __webpack_require__("50c4");
            var createProperty = __webpack_require__("8418");
            var getIteratorMethod = __webpack_require__("35a1");
            module2.exports = function from(arrayLike) {
              var O2 = toObject(arrayLike);
              var C2 = typeof this == "function" ? this : Array;
              var argumentsLength = arguments.length;
              var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
              var mapping = mapfn !== void 0;
              var iteratorMethod = getIteratorMethod(O2);
              var index2 = 0;
              var length, result, step, iterator, next, value;
              if (mapping)
                mapfn = bind4(mapfn, argumentsLength > 2 ? arguments[2] : void 0, 2);
              if (iteratorMethod != void 0 && !(C2 == Array && isArrayIteratorMethod(iteratorMethod))) {
                iterator = iteratorMethod.call(O2);
                next = iterator.next;
                result = new C2();
                for (; !(step = next.call(iterator)).done; index2++) {
                  value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index2], true) : step.value;
                  createProperty(result, index2, value);
                }
              } else {
                length = toLength(O2.length);
                result = new C2(length);
                for (; length > index2; index2++) {
                  value = mapping ? mapfn(O2[index2], index2) : O2[index2];
                  createProperty(result, index2, value);
                }
              }
              result.length = index2;
              return result;
            };
          }
        ),
        /***/
        "4fad": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var $2 = __webpack_require__("23e7");
            var $entries = __webpack_require__("6f53").entries;
            $2({ target: "Object", stat: true }, {
              entries: function entries(O2) {
                return $entries(O2);
              }
            });
          }
        ),
        /***/
        "50c4": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var toInteger2 = __webpack_require__("a691");
            var min = Math.min;
            module2.exports = function(argument) {
              return argument > 0 ? min(toInteger2(argument), 9007199254740991) : 0;
            };
          }
        ),
        /***/
        "5135": (
          /***/
          function(module2, exports2) {
            var hasOwnProperty2 = {}.hasOwnProperty;
            module2.exports = function(it2, key2) {
              return hasOwnProperty2.call(it2, key2);
            };
          }
        ),
        /***/
        "5319": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var fixRegExpWellKnownSymbolLogic = __webpack_require__("d784");
            var anObject = __webpack_require__("825a");
            var toObject = __webpack_require__("7b0b");
            var toLength = __webpack_require__("50c4");
            var toInteger2 = __webpack_require__("a691");
            var requireObjectCoercible = __webpack_require__("1d80");
            var advanceStringIndex = __webpack_require__("8aa5");
            var regExpExec = __webpack_require__("14c3");
            var max2 = Math.max;
            var min = Math.min;
            var floor2 = Math.floor;
            var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d\d?|<[^>]*>)/g;
            var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d\d?)/g;
            var maybeToString = function(it2) {
              return it2 === void 0 ? it2 : String(it2);
            };
            fixRegExpWellKnownSymbolLogic("replace", 2, function(REPLACE, nativeReplace, maybeCallNative, reason) {
              var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = reason.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE;
              var REPLACE_KEEPS_$0 = reason.REPLACE_KEEPS_$0;
              var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? "$" : "$0";
              return [
                // `String.prototype.replace` method
                // https://tc39.github.io/ecma262/#sec-string.prototype.replace
                function replace2(searchValue, replaceValue) {
                  var O2 = requireObjectCoercible(this);
                  var replacer2 = searchValue == void 0 ? void 0 : searchValue[REPLACE];
                  return replacer2 !== void 0 ? replacer2.call(searchValue, O2, replaceValue) : nativeReplace.call(String(O2), searchValue, replaceValue);
                },
                // `RegExp.prototype[@@replace]` method
                // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
                function(regexp, replaceValue) {
                  if (!REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE && REPLACE_KEEPS_$0 || typeof replaceValue === "string" && replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1) {
                    var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);
                    if (res.done)
                      return res.value;
                  }
                  var rx = anObject(regexp);
                  var S2 = String(this);
                  var functionalReplace = typeof replaceValue === "function";
                  if (!functionalReplace)
                    replaceValue = String(replaceValue);
                  var global2 = rx.global;
                  if (global2) {
                    var fullUnicode = rx.unicode;
                    rx.lastIndex = 0;
                  }
                  var results = [];
                  while (true) {
                    var result = regExpExec(rx, S2);
                    if (result === null)
                      break;
                    results.push(result);
                    if (!global2)
                      break;
                    var matchStr = String(result[0]);
                    if (matchStr === "")
                      rx.lastIndex = advanceStringIndex(S2, toLength(rx.lastIndex), fullUnicode);
                  }
                  var accumulatedResult = "";
                  var nextSourcePosition = 0;
                  for (var i = 0; i < results.length; i++) {
                    result = results[i];
                    var matched = String(result[0]);
                    var position = max2(min(toInteger2(result.index), S2.length), 0);
                    var captures = [];
                    for (var j2 = 1; j2 < result.length; j2++)
                      captures.push(maybeToString(result[j2]));
                    var namedCaptures = result.groups;
                    if (functionalReplace) {
                      var replacerArgs = [matched].concat(captures, position, S2);
                      if (namedCaptures !== void 0)
                        replacerArgs.push(namedCaptures);
                      var replacement = String(replaceValue.apply(void 0, replacerArgs));
                    } else {
                      replacement = getSubstitution(matched, S2, position, captures, namedCaptures, replaceValue);
                    }
                    if (position >= nextSourcePosition) {
                      accumulatedResult += S2.slice(nextSourcePosition, position) + replacement;
                      nextSourcePosition = position + matched.length;
                    }
                  }
                  return accumulatedResult + S2.slice(nextSourcePosition);
                }
              ];
              function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
                var tailPos = position + matched.length;
                var m = captures.length;
                var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
                if (namedCaptures !== void 0) {
                  namedCaptures = toObject(namedCaptures);
                  symbols = SUBSTITUTION_SYMBOLS;
                }
                return nativeReplace.call(replacement, symbols, function(match2, ch) {
                  var capture;
                  switch (ch.charAt(0)) {
                    case "$":
                      return "$";
                    case "&":
                      return matched;
                    case "`":
                      return str.slice(0, position);
                    case "'":
                      return str.slice(tailPos);
                    case "<":
                      capture = namedCaptures[ch.slice(1, -1)];
                      break;
                    default:
                      var n = +ch;
                      if (n === 0)
                        return match2;
                      if (n > m) {
                        var f2 = floor2(n / 10);
                        if (f2 === 0)
                          return match2;
                        if (f2 <= m)
                          return captures[f2 - 1] === void 0 ? ch.charAt(1) : captures[f2 - 1] + ch.charAt(1);
                        return match2;
                      }
                      capture = captures[n - 1];
                  }
                  return capture === void 0 ? "" : capture;
                });
              }
            });
          }
        ),
        /***/
        "5692": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var IS_PURE = __webpack_require__("c430");
            var store = __webpack_require__("c6cd");
            (module2.exports = function(key2, value) {
              return store[key2] || (store[key2] = value !== void 0 ? value : {});
            })("versions", []).push({
              version: "3.6.5",
              mode: IS_PURE ? "pure" : "global",
              copyright: "© 2020 Denis Pushkarev (zloirock.ru)"
            });
          }
        ),
        /***/
        "56ef": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var getBuiltIn = __webpack_require__("d066");
            var getOwnPropertyNamesModule = __webpack_require__("241c");
            var getOwnPropertySymbolsModule = __webpack_require__("7418");
            var anObject = __webpack_require__("825a");
            module2.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys2(it2) {
              var keys2 = getOwnPropertyNamesModule.f(anObject(it2));
              var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
              return getOwnPropertySymbols ? keys2.concat(getOwnPropertySymbols(it2)) : keys2;
            };
          }
        ),
        /***/
        "5a34": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var isRegExp3 = __webpack_require__("44e7");
            module2.exports = function(it2) {
              if (isRegExp3(it2)) {
                throw TypeError("The method doesn't accept regular expressions");
              }
              return it2;
            };
          }
        ),
        /***/
        "5c6c": (
          /***/
          function(module2, exports2) {
            module2.exports = function(bitmap, value) {
              return {
                enumerable: !(bitmap & 1),
                configurable: !(bitmap & 2),
                writable: !(bitmap & 4),
                value
              };
            };
          }
        ),
        /***/
        "5db7": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var $2 = __webpack_require__("23e7");
            var flattenIntoArray = __webpack_require__("a2bf");
            var toObject = __webpack_require__("7b0b");
            var toLength = __webpack_require__("50c4");
            var aFunction = __webpack_require__("1c0b");
            var arraySpeciesCreate = __webpack_require__("65f0");
            $2({ target: "Array", proto: true }, {
              flatMap: function flatMap(callbackfn) {
                var O2 = toObject(this);
                var sourceLen = toLength(O2.length);
                var A2;
                aFunction(callbackfn);
                A2 = arraySpeciesCreate(O2, 0);
                A2.length = flattenIntoArray(A2, O2, O2, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
                return A2;
              }
            });
          }
        ),
        /***/
        "6547": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var toInteger2 = __webpack_require__("a691");
            var requireObjectCoercible = __webpack_require__("1d80");
            var createMethod = function(CONVERT_TO_STRING) {
              return function($this, pos2) {
                var S2 = String(requireObjectCoercible($this));
                var position = toInteger2(pos2);
                var size2 = S2.length;
                var first, second;
                if (position < 0 || position >= size2)
                  return CONVERT_TO_STRING ? "" : void 0;
                first = S2.charCodeAt(position);
                return first < 55296 || first > 56319 || position + 1 === size2 || (second = S2.charCodeAt(position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? S2.charAt(position) : first : CONVERT_TO_STRING ? S2.slice(position, position + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
              };
            };
            module2.exports = {
              // `String.prototype.codePointAt` method
              // https://tc39.github.io/ecma262/#sec-string.prototype.codepointat
              codeAt: createMethod(false),
              // `String.prototype.at` method
              // https://github.com/mathiasbynens/String.prototype.at
              charAt: createMethod(true)
            };
          }
        ),
        /***/
        "65f0": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var isObject2 = __webpack_require__("861d");
            var isArray2 = __webpack_require__("e8b5");
            var wellKnownSymbol = __webpack_require__("b622");
            var SPECIES = wellKnownSymbol("species");
            module2.exports = function(originalArray, length) {
              var C2;
              if (isArray2(originalArray)) {
                C2 = originalArray.constructor;
                if (typeof C2 == "function" && (C2 === Array || isArray2(C2.prototype)))
                  C2 = void 0;
                else if (isObject2(C2)) {
                  C2 = C2[SPECIES];
                  if (C2 === null)
                    C2 = void 0;
                }
              }
              return new (C2 === void 0 ? Array : C2)(length === 0 ? 0 : length);
            };
          }
        ),
        /***/
        "69f3": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var NATIVE_WEAK_MAP = __webpack_require__("7f9a");
            var global2 = __webpack_require__("da84");
            var isObject2 = __webpack_require__("861d");
            var createNonEnumerableProperty = __webpack_require__("9112");
            var objectHas = __webpack_require__("5135");
            var sharedKey = __webpack_require__("f772");
            var hiddenKeys = __webpack_require__("d012");
            var WeakMap2 = global2.WeakMap;
            var set2, get2, has2;
            var enforce = function(it2) {
              return has2(it2) ? get2(it2) : set2(it2, {});
            };
            var getterFor = function(TYPE) {
              return function(it2) {
                var state;
                if (!isObject2(it2) || (state = get2(it2)).type !== TYPE) {
                  throw TypeError("Incompatible receiver, " + TYPE + " required");
                }
                return state;
              };
            };
            if (NATIVE_WEAK_MAP) {
              var store = new WeakMap2();
              var wmget = store.get;
              var wmhas = store.has;
              var wmset = store.set;
              set2 = function(it2, metadata) {
                wmset.call(store, it2, metadata);
                return metadata;
              };
              get2 = function(it2) {
                return wmget.call(store, it2) || {};
              };
              has2 = function(it2) {
                return wmhas.call(store, it2);
              };
            } else {
              var STATE = sharedKey("state");
              hiddenKeys[STATE] = true;
              set2 = function(it2, metadata) {
                createNonEnumerableProperty(it2, STATE, metadata);
                return metadata;
              };
              get2 = function(it2) {
                return objectHas(it2, STATE) ? it2[STATE] : {};
              };
              has2 = function(it2) {
                return objectHas(it2, STATE);
              };
            }
            module2.exports = {
              set: set2,
              get: get2,
              has: has2,
              enforce,
              getterFor
            };
          }
        ),
        /***/
        "6eeb": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var global2 = __webpack_require__("da84");
            var createNonEnumerableProperty = __webpack_require__("9112");
            var has2 = __webpack_require__("5135");
            var setGlobal = __webpack_require__("ce4e");
            var inspectSource = __webpack_require__("8925");
            var InternalStateModule = __webpack_require__("69f3");
            var getInternalState = InternalStateModule.get;
            var enforceInternalState = InternalStateModule.enforce;
            var TEMPLATE = String(String).split("String");
            (module2.exports = function(O2, key2, value, options) {
              var unsafe = options ? !!options.unsafe : false;
              var simple = options ? !!options.enumerable : false;
              var noTargetGet = options ? !!options.noTargetGet : false;
              if (typeof value == "function") {
                if (typeof key2 == "string" && !has2(value, "name"))
                  createNonEnumerableProperty(value, "name", key2);
                enforceInternalState(value).source = TEMPLATE.join(typeof key2 == "string" ? key2 : "");
              }
              if (O2 === global2) {
                if (simple)
                  O2[key2] = value;
                else
                  setGlobal(key2, value);
                return;
              } else if (!unsafe) {
                delete O2[key2];
              } else if (!noTargetGet && O2[key2]) {
                simple = true;
              }
              if (simple)
                O2[key2] = value;
              else
                createNonEnumerableProperty(O2, key2, value);
            })(Function.prototype, "toString", function toString2() {
              return typeof this == "function" && getInternalState(this).source || inspectSource(this);
            });
          }
        ),
        /***/
        "6f53": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var DESCRIPTORS = __webpack_require__("83ab");
            var objectKeys = __webpack_require__("df75");
            var toIndexedObject = __webpack_require__("fc6a");
            var propertyIsEnumerable = __webpack_require__("d1e7").f;
            var createMethod = function(TO_ENTRIES) {
              return function(it2) {
                var O2 = toIndexedObject(it2);
                var keys2 = objectKeys(O2);
                var length = keys2.length;
                var i = 0;
                var result = [];
                var key2;
                while (length > i) {
                  key2 = keys2[i++];
                  if (!DESCRIPTORS || propertyIsEnumerable.call(O2, key2)) {
                    result.push(TO_ENTRIES ? [key2, O2[key2]] : O2[key2]);
                  }
                }
                return result;
              };
            };
            module2.exports = {
              // `Object.entries` method
              // https://tc39.github.io/ecma262/#sec-object.entries
              entries: createMethod(true),
              // `Object.values` method
              // https://tc39.github.io/ecma262/#sec-object.values
              values: createMethod(false)
            };
          }
        ),
        /***/
        "73d9": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var addToUnscopables = __webpack_require__("44d2");
            addToUnscopables("flatMap");
          }
        ),
        /***/
        "7418": (
          /***/
          function(module2, exports2) {
            exports2.f = Object.getOwnPropertySymbols;
          }
        ),
        /***/
        "746f": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var path = __webpack_require__("428f");
            var has2 = __webpack_require__("5135");
            var wrappedWellKnownSymbolModule = __webpack_require__("e538");
            var defineProperty = __webpack_require__("9bf2").f;
            module2.exports = function(NAME) {
              var Symbol2 = path.Symbol || (path.Symbol = {});
              if (!has2(Symbol2, NAME))
                defineProperty(Symbol2, NAME, {
                  value: wrappedWellKnownSymbolModule.f(NAME)
                });
            };
          }
        ),
        /***/
        "7839": (
          /***/
          function(module2, exports2) {
            module2.exports = [
              "constructor",
              "hasOwnProperty",
              "isPrototypeOf",
              "propertyIsEnumerable",
              "toLocaleString",
              "toString",
              "valueOf"
            ];
          }
        ),
        /***/
        "7b0b": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var requireObjectCoercible = __webpack_require__("1d80");
            module2.exports = function(argument) {
              return Object(requireObjectCoercible(argument));
            };
          }
        ),
        /***/
        "7c73": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var anObject = __webpack_require__("825a");
            var defineProperties = __webpack_require__("37e8");
            var enumBugKeys = __webpack_require__("7839");
            var hiddenKeys = __webpack_require__("d012");
            var html = __webpack_require__("1be4");
            var documentCreateElement = __webpack_require__("cc12");
            var sharedKey = __webpack_require__("f772");
            var GT = ">";
            var LT = "<";
            var PROTOTYPE = "prototype";
            var SCRIPT = "script";
            var IE_PROTO = sharedKey("IE_PROTO");
            var EmptyConstructor = function() {
            };
            var scriptTag = function(content) {
              return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
            };
            var NullProtoObjectViaActiveX = function(activeXDocument2) {
              activeXDocument2.write(scriptTag(""));
              activeXDocument2.close();
              var temp = activeXDocument2.parentWindow.Object;
              activeXDocument2 = null;
              return temp;
            };
            var NullProtoObjectViaIFrame = function() {
              var iframe = documentCreateElement("iframe");
              var JS = "java" + SCRIPT + ":";
              var iframeDocument;
              iframe.style.display = "none";
              html.appendChild(iframe);
              iframe.src = String(JS);
              iframeDocument = iframe.contentWindow.document;
              iframeDocument.open();
              iframeDocument.write(scriptTag("document.F=Object"));
              iframeDocument.close();
              return iframeDocument.F;
            };
            var activeXDocument;
            var NullProtoObject = function() {
              try {
                activeXDocument = document.domain && new ActiveXObject("htmlfile");
              } catch (error) {
              }
              NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
              var length = enumBugKeys.length;
              while (length--)
                delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
              return NullProtoObject();
            };
            hiddenKeys[IE_PROTO] = true;
            module2.exports = Object.create || function create2(O2, Properties) {
              var result;
              if (O2 !== null) {
                EmptyConstructor[PROTOTYPE] = anObject(O2);
                result = new EmptyConstructor();
                EmptyConstructor[PROTOTYPE] = null;
                result[IE_PROTO] = O2;
              } else
                result = NullProtoObject();
              return Properties === void 0 ? result : defineProperties(result, Properties);
            };
          }
        ),
        /***/
        "7dd0": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var $2 = __webpack_require__("23e7");
            var createIteratorConstructor = __webpack_require__("9ed3");
            var getPrototypeOf = __webpack_require__("e163");
            var setPrototypeOf = __webpack_require__("d2bb");
            var setToStringTag = __webpack_require__("d44e");
            var createNonEnumerableProperty = __webpack_require__("9112");
            var redefine = __webpack_require__("6eeb");
            var wellKnownSymbol = __webpack_require__("b622");
            var IS_PURE = __webpack_require__("c430");
            var Iterators = __webpack_require__("3f8c");
            var IteratorsCore = __webpack_require__("ae93");
            var IteratorPrototype = IteratorsCore.IteratorPrototype;
            var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
            var ITERATOR = wellKnownSymbol("iterator");
            var KEYS = "keys";
            var VALUES = "values";
            var ENTRIES = "entries";
            var returnThis = function() {
              return this;
            };
            module2.exports = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
              createIteratorConstructor(IteratorConstructor, NAME, next);
              var getIterationMethod = function(KIND) {
                if (KIND === DEFAULT && defaultIterator)
                  return defaultIterator;
                if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)
                  return IterablePrototype[KIND];
                switch (KIND) {
                  case KEYS:
                    return function keys2() {
                      return new IteratorConstructor(this, KIND);
                    };
                  case VALUES:
                    return function values() {
                      return new IteratorConstructor(this, KIND);
                    };
                  case ENTRIES:
                    return function entries() {
                      return new IteratorConstructor(this, KIND);
                    };
                }
                return function() {
                  return new IteratorConstructor(this);
                };
              };
              var TO_STRING_TAG = NAME + " Iterator";
              var INCORRECT_VALUES_NAME = false;
              var IterablePrototype = Iterable.prototype;
              var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
              var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
              var anyNativeIterator = NAME == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
              var CurrentIteratorPrototype, methods, KEY;
              if (anyNativeIterator) {
                CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
                if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
                  if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
                    if (setPrototypeOf) {
                      setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
                    } else if (typeof CurrentIteratorPrototype[ITERATOR] != "function") {
                      createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);
                    }
                  }
                  setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
                  if (IS_PURE)
                    Iterators[TO_STRING_TAG] = returnThis;
                }
              }
              if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
                INCORRECT_VALUES_NAME = true;
                defaultIterator = function values() {
                  return nativeIterator.call(this);
                };
              }
              if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
                createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);
              }
              Iterators[NAME] = defaultIterator;
              if (DEFAULT) {
                methods = {
                  values: getIterationMethod(VALUES),
                  keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
                  entries: getIterationMethod(ENTRIES)
                };
                if (FORCED)
                  for (KEY in methods) {
                    if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
                      redefine(IterablePrototype, KEY, methods[KEY]);
                    }
                  }
                else
                  $2({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
              }
              return methods;
            };
          }
        ),
        /***/
        "7f9a": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var global2 = __webpack_require__("da84");
            var inspectSource = __webpack_require__("8925");
            var WeakMap2 = global2.WeakMap;
            module2.exports = typeof WeakMap2 === "function" && /native code/.test(inspectSource(WeakMap2));
          }
        ),
        /***/
        "825a": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var isObject2 = __webpack_require__("861d");
            module2.exports = function(it2) {
              if (!isObject2(it2)) {
                throw TypeError(String(it2) + " is not an object");
              }
              return it2;
            };
          }
        ),
        /***/
        "83ab": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var fails = __webpack_require__("d039");
            module2.exports = !fails(function() {
              return Object.defineProperty({}, 1, { get: function() {
                return 7;
              } })[1] != 7;
            });
          }
        ),
        /***/
        "8418": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var toPrimitive = __webpack_require__("c04e");
            var definePropertyModule = __webpack_require__("9bf2");
            var createPropertyDescriptor = __webpack_require__("5c6c");
            module2.exports = function(object, key2, value) {
              var propertyKey = toPrimitive(key2);
              if (propertyKey in object)
                definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
              else
                object[propertyKey] = value;
            };
          }
        ),
        /***/
        "861d": (
          /***/
          function(module2, exports2) {
            module2.exports = function(it2) {
              return typeof it2 === "object" ? it2 !== null : typeof it2 === "function";
            };
          }
        ),
        /***/
        "8875": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
            (function(root2, factory) {
              {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = factory, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function" ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports2, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
              }
            })(typeof self !== "undefined" ? self : this, function() {
              function getCurrentScript() {
                var descriptor = Object.getOwnPropertyDescriptor(document, "currentScript");
                if (!descriptor && "currentScript" in document && document.currentScript) {
                  return document.currentScript;
                }
                if (descriptor && descriptor.get !== getCurrentScript && document.currentScript) {
                  return document.currentScript;
                }
                try {
                  throw new Error();
                } catch (err) {
                  var ieStackRegExp = /.*at [^(]*\((.*):(.+):(.+)\)$/ig, ffStackRegExp = /@([^@]*):(\d+):(\d+)\s*$/ig, stackDetails = ieStackRegExp.exec(err.stack) || ffStackRegExp.exec(err.stack), scriptLocation = stackDetails && stackDetails[1] || false, line2 = stackDetails && stackDetails[2] || false, currentLocation = document.location.href.replace(document.location.hash, ""), pageSource, inlineScriptSourceRegExp, inlineScriptSource, scripts = document.getElementsByTagName("script");
                  if (scriptLocation === currentLocation) {
                    pageSource = document.documentElement.outerHTML;
                    inlineScriptSourceRegExp = new RegExp("(?:[^\\n]+?\\n){0," + (line2 - 2) + "}[^<]*<script>([\\d\\D]*?)<\\/script>[\\d\\D]*", "i");
                    inlineScriptSource = pageSource.replace(inlineScriptSourceRegExp, "$1").trim();
                  }
                  for (var i = 0; i < scripts.length; i++) {
                    if (scripts[i].readyState === "interactive") {
                      return scripts[i];
                    }
                    if (scripts[i].src === scriptLocation) {
                      return scripts[i];
                    }
                    if (scriptLocation === currentLocation && scripts[i].innerHTML && scripts[i].innerHTML.trim() === inlineScriptSource) {
                      return scripts[i];
                    }
                  }
                  return null;
                }
              }
              return getCurrentScript;
            });
          }
        ),
        /***/
        "8925": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var store = __webpack_require__("c6cd");
            var functionToString2 = Function.toString;
            if (typeof store.inspectSource != "function") {
              store.inspectSource = function(it2) {
                return functionToString2.call(it2);
              };
            }
            module2.exports = store.inspectSource;
          }
        ),
        /***/
        "8aa5": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var charAt = __webpack_require__("6547").charAt;
            module2.exports = function(S2, index2, unicode2) {
              return index2 + (unicode2 ? charAt(S2, index2).length : 1);
            };
          }
        ),
        /***/
        "8bbf": (
          /***/
          function(module2, exports2) {
            module2.exports = __WEBPACK_EXTERNAL_MODULE__8bbf__;
          }
        ),
        /***/
        "90e3": (
          /***/
          function(module2, exports2) {
            var id = 0;
            var postfix = Math.random();
            module2.exports = function(key2) {
              return "Symbol(" + String(key2 === void 0 ? "" : key2) + ")_" + (++id + postfix).toString(36);
            };
          }
        ),
        /***/
        "9112": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var DESCRIPTORS = __webpack_require__("83ab");
            var definePropertyModule = __webpack_require__("9bf2");
            var createPropertyDescriptor = __webpack_require__("5c6c");
            module2.exports = DESCRIPTORS ? function(object, key2, value) {
              return definePropertyModule.f(object, key2, createPropertyDescriptor(1, value));
            } : function(object, key2, value) {
              object[key2] = value;
              return object;
            };
          }
        ),
        /***/
        "9263": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var regexpFlags = __webpack_require__("ad6d");
            var stickyHelpers = __webpack_require__("9f7f");
            var nativeExec = RegExp.prototype.exec;
            var nativeReplace = String.prototype.replace;
            var patchedExec = nativeExec;
            var UPDATES_LAST_INDEX_WRONG = function() {
              var re1 = /a/;
              var re2 = /b*/g;
              nativeExec.call(re1, "a");
              nativeExec.call(re2, "a");
              return re1.lastIndex !== 0 || re2.lastIndex !== 0;
            }();
            var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y || stickyHelpers.BROKEN_CARET;
            var NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
            var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y;
            if (PATCH) {
              patchedExec = function exec(str) {
                var re2 = this;
                var lastIndex, reCopy, match2, i;
                var sticky = UNSUPPORTED_Y && re2.sticky;
                var flags = regexpFlags.call(re2);
                var source2 = re2.source;
                var charsAdded = 0;
                var strCopy = str;
                if (sticky) {
                  flags = flags.replace("y", "");
                  if (flags.indexOf("g") === -1) {
                    flags += "g";
                  }
                  strCopy = String(str).slice(re2.lastIndex);
                  if (re2.lastIndex > 0 && (!re2.multiline || re2.multiline && str[re2.lastIndex - 1] !== "\n")) {
                    source2 = "(?: " + source2 + ")";
                    strCopy = " " + strCopy;
                    charsAdded++;
                  }
                  reCopy = new RegExp("^(?:" + source2 + ")", flags);
                }
                if (NPCG_INCLUDED) {
                  reCopy = new RegExp("^" + source2 + "$(?!\\s)", flags);
                }
                if (UPDATES_LAST_INDEX_WRONG)
                  lastIndex = re2.lastIndex;
                match2 = nativeExec.call(sticky ? reCopy : re2, strCopy);
                if (sticky) {
                  if (match2) {
                    match2.input = match2.input.slice(charsAdded);
                    match2[0] = match2[0].slice(charsAdded);
                    match2.index = re2.lastIndex;
                    re2.lastIndex += match2[0].length;
                  } else
                    re2.lastIndex = 0;
                } else if (UPDATES_LAST_INDEX_WRONG && match2) {
                  re2.lastIndex = re2.global ? match2.index + match2[0].length : lastIndex;
                }
                if (NPCG_INCLUDED && match2 && match2.length > 1) {
                  nativeReplace.call(match2[0], reCopy, function() {
                    for (i = 1; i < arguments.length - 2; i++) {
                      if (arguments[i] === void 0)
                        match2[i] = void 0;
                    }
                  });
                }
                return match2;
              };
            }
            module2.exports = patchedExec;
          }
        ),
        /***/
        "94ca": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var fails = __webpack_require__("d039");
            var replacement = /#|\.prototype\./;
            var isForced = function(feature, detection) {
              var value = data[normalize(feature)];
              return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == "function" ? fails(detection) : !!detection;
            };
            var normalize = isForced.normalize = function(string) {
              return String(string).replace(replacement, ".").toLowerCase();
            };
            var data = isForced.data = {};
            var NATIVE = isForced.NATIVE = "N";
            var POLYFILL = isForced.POLYFILL = "P";
            module2.exports = isForced;
          }
        ),
        /***/
        "99af": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var $2 = __webpack_require__("23e7");
            var fails = __webpack_require__("d039");
            var isArray2 = __webpack_require__("e8b5");
            var isObject2 = __webpack_require__("861d");
            var toObject = __webpack_require__("7b0b");
            var toLength = __webpack_require__("50c4");
            var createProperty = __webpack_require__("8418");
            var arraySpeciesCreate = __webpack_require__("65f0");
            var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
            var wellKnownSymbol = __webpack_require__("b622");
            var V8_VERSION = __webpack_require__("2d00");
            var IS_CONCAT_SPREADABLE = wellKnownSymbol("isConcatSpreadable");
            var MAX_SAFE_INTEGER = 9007199254740991;
            var MAXIMUM_ALLOWED_INDEX_EXCEEDED = "Maximum allowed index exceeded";
            var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function() {
              var array = [];
              array[IS_CONCAT_SPREADABLE] = false;
              return array.concat()[0] !== array;
            });
            var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("concat");
            var isConcatSpreadable = function(O2) {
              if (!isObject2(O2))
                return false;
              var spreadable = O2[IS_CONCAT_SPREADABLE];
              return spreadable !== void 0 ? !!spreadable : isArray2(O2);
            };
            var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;
            $2({ target: "Array", proto: true, forced: FORCED }, {
              concat: function concat(arg) {
                var O2 = toObject(this);
                var A2 = arraySpeciesCreate(O2, 0);
                var n = 0;
                var i, k2, length, len, E2;
                for (i = -1, length = arguments.length; i < length; i++) {
                  E2 = i === -1 ? O2 : arguments[i];
                  if (isConcatSpreadable(E2)) {
                    len = toLength(E2.length);
                    if (n + len > MAX_SAFE_INTEGER)
                      throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
                    for (k2 = 0; k2 < len; k2++, n++)
                      if (k2 in E2)
                        createProperty(A2, n, E2[k2]);
                  } else {
                    if (n >= MAX_SAFE_INTEGER)
                      throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
                    createProperty(A2, n++, E2);
                  }
                }
                A2.length = n;
                return A2;
              }
            });
          }
        ),
        /***/
        "9bdd": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var anObject = __webpack_require__("825a");
            module2.exports = function(iterator, fn, value, ENTRIES) {
              try {
                return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
              } catch (error) {
                var returnMethod = iterator["return"];
                if (returnMethod !== void 0)
                  anObject(returnMethod.call(iterator));
                throw error;
              }
            };
          }
        ),
        /***/
        "9bf2": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var DESCRIPTORS = __webpack_require__("83ab");
            var IE8_DOM_DEFINE = __webpack_require__("0cfb");
            var anObject = __webpack_require__("825a");
            var toPrimitive = __webpack_require__("c04e");
            var nativeDefineProperty = Object.defineProperty;
            exports2.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O2, P2, Attributes) {
              anObject(O2);
              P2 = toPrimitive(P2, true);
              anObject(Attributes);
              if (IE8_DOM_DEFINE)
                try {
                  return nativeDefineProperty(O2, P2, Attributes);
                } catch (error) {
                }
              if ("get" in Attributes || "set" in Attributes)
                throw TypeError("Accessors not supported");
              if ("value" in Attributes)
                O2[P2] = Attributes.value;
              return O2;
            };
          }
        ),
        /***/
        "9ed3": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var IteratorPrototype = __webpack_require__("ae93").IteratorPrototype;
            var create2 = __webpack_require__("7c73");
            var createPropertyDescriptor = __webpack_require__("5c6c");
            var setToStringTag = __webpack_require__("d44e");
            var Iterators = __webpack_require__("3f8c");
            var returnThis = function() {
              return this;
            };
            module2.exports = function(IteratorConstructor, NAME, next) {
              var TO_STRING_TAG = NAME + " Iterator";
              IteratorConstructor.prototype = create2(IteratorPrototype, { next: createPropertyDescriptor(1, next) });
              setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
              Iterators[TO_STRING_TAG] = returnThis;
              return IteratorConstructor;
            };
          }
        ),
        /***/
        "9f7f": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var fails = __webpack_require__("d039");
            function RE(s, f2) {
              return RegExp(s, f2);
            }
            exports2.UNSUPPORTED_Y = fails(function() {
              var re2 = RE("a", "y");
              re2.lastIndex = 2;
              return re2.exec("abcd") != null;
            });
            exports2.BROKEN_CARET = fails(function() {
              var re2 = RE("^r", "gy");
              re2.lastIndex = 2;
              return re2.exec("str") != null;
            });
          }
        ),
        /***/
        "a2bf": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var isArray2 = __webpack_require__("e8b5");
            var toLength = __webpack_require__("50c4");
            var bind4 = __webpack_require__("0366");
            var flattenIntoArray = function(target, original, source2, sourceLen, start, depth, mapper, thisArg) {
              var targetIndex = start;
              var sourceIndex = 0;
              var mapFn = mapper ? bind4(mapper, thisArg, 3) : false;
              var element;
              while (sourceIndex < sourceLen) {
                if (sourceIndex in source2) {
                  element = mapFn ? mapFn(source2[sourceIndex], sourceIndex, original) : source2[sourceIndex];
                  if (depth > 0 && isArray2(element)) {
                    targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
                  } else {
                    if (targetIndex >= 9007199254740991)
                      throw TypeError("Exceed the acceptable array length");
                    target[targetIndex] = element;
                  }
                  targetIndex++;
                }
                sourceIndex++;
              }
              return targetIndex;
            };
            module2.exports = flattenIntoArray;
          }
        ),
        /***/
        "a352": (
          /***/
          function(module2, exports2) {
            module2.exports = __WEBPACK_EXTERNAL_MODULE_a352__;
          }
        ),
        /***/
        "a434": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var $2 = __webpack_require__("23e7");
            var toAbsoluteIndex = __webpack_require__("23cb");
            var toInteger2 = __webpack_require__("a691");
            var toLength = __webpack_require__("50c4");
            var toObject = __webpack_require__("7b0b");
            var arraySpeciesCreate = __webpack_require__("65f0");
            var createProperty = __webpack_require__("8418");
            var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
            var arrayMethodUsesToLength = __webpack_require__("ae40");
            var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("splice");
            var USES_TO_LENGTH = arrayMethodUsesToLength("splice", { ACCESSORS: true, 0: 0, 1: 2 });
            var max2 = Math.max;
            var min = Math.min;
            var MAX_SAFE_INTEGER = 9007199254740991;
            var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = "Maximum allowed length exceeded";
            $2({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {
              splice: function splice(start, deleteCount) {
                var O2 = toObject(this);
                var len = toLength(O2.length);
                var actualStart = toAbsoluteIndex(start, len);
                var argumentsLength = arguments.length;
                var insertCount, actualDeleteCount, A2, k2, from, to;
                if (argumentsLength === 0) {
                  insertCount = actualDeleteCount = 0;
                } else if (argumentsLength === 1) {
                  insertCount = 0;
                  actualDeleteCount = len - actualStart;
                } else {
                  insertCount = argumentsLength - 2;
                  actualDeleteCount = min(max2(toInteger2(deleteCount), 0), len - actualStart);
                }
                if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {
                  throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
                }
                A2 = arraySpeciesCreate(O2, actualDeleteCount);
                for (k2 = 0; k2 < actualDeleteCount; k2++) {
                  from = actualStart + k2;
                  if (from in O2)
                    createProperty(A2, k2, O2[from]);
                }
                A2.length = actualDeleteCount;
                if (insertCount < actualDeleteCount) {
                  for (k2 = actualStart; k2 < len - actualDeleteCount; k2++) {
                    from = k2 + actualDeleteCount;
                    to = k2 + insertCount;
                    if (from in O2)
                      O2[to] = O2[from];
                    else
                      delete O2[to];
                  }
                  for (k2 = len; k2 > len - actualDeleteCount + insertCount; k2--)
                    delete O2[k2 - 1];
                } else if (insertCount > actualDeleteCount) {
                  for (k2 = len - actualDeleteCount; k2 > actualStart; k2--) {
                    from = k2 + actualDeleteCount - 1;
                    to = k2 + insertCount - 1;
                    if (from in O2)
                      O2[to] = O2[from];
                    else
                      delete O2[to];
                  }
                }
                for (k2 = 0; k2 < insertCount; k2++) {
                  O2[k2 + actualStart] = arguments[k2 + 2];
                }
                O2.length = len - actualDeleteCount + insertCount;
                return A2;
              }
            });
          }
        ),
        /***/
        "a4d3": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var $2 = __webpack_require__("23e7");
            var global2 = __webpack_require__("da84");
            var getBuiltIn = __webpack_require__("d066");
            var IS_PURE = __webpack_require__("c430");
            var DESCRIPTORS = __webpack_require__("83ab");
            var NATIVE_SYMBOL = __webpack_require__("4930");
            var USE_SYMBOL_AS_UID = __webpack_require__("fdbf");
            var fails = __webpack_require__("d039");
            var has2 = __webpack_require__("5135");
            var isArray2 = __webpack_require__("e8b5");
            var isObject2 = __webpack_require__("861d");
            var anObject = __webpack_require__("825a");
            var toObject = __webpack_require__("7b0b");
            var toIndexedObject = __webpack_require__("fc6a");
            var toPrimitive = __webpack_require__("c04e");
            var createPropertyDescriptor = __webpack_require__("5c6c");
            var nativeObjectCreate = __webpack_require__("7c73");
            var objectKeys = __webpack_require__("df75");
            var getOwnPropertyNamesModule = __webpack_require__("241c");
            var getOwnPropertyNamesExternal = __webpack_require__("057f");
            var getOwnPropertySymbolsModule = __webpack_require__("7418");
            var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
            var definePropertyModule = __webpack_require__("9bf2");
            var propertyIsEnumerableModule = __webpack_require__("d1e7");
            var createNonEnumerableProperty = __webpack_require__("9112");
            var redefine = __webpack_require__("6eeb");
            var shared = __webpack_require__("5692");
            var sharedKey = __webpack_require__("f772");
            var hiddenKeys = __webpack_require__("d012");
            var uid2 = __webpack_require__("90e3");
            var wellKnownSymbol = __webpack_require__("b622");
            var wrappedWellKnownSymbolModule = __webpack_require__("e538");
            var defineWellKnownSymbol = __webpack_require__("746f");
            var setToStringTag = __webpack_require__("d44e");
            var InternalStateModule = __webpack_require__("69f3");
            var $forEach = __webpack_require__("b727").forEach;
            var HIDDEN = sharedKey("hidden");
            var SYMBOL = "Symbol";
            var PROTOTYPE = "prototype";
            var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
            var setInternalState = InternalStateModule.set;
            var getInternalState = InternalStateModule.getterFor(SYMBOL);
            var ObjectPrototype = Object[PROTOTYPE];
            var $Symbol = global2.Symbol;
            var $stringify = getBuiltIn("JSON", "stringify");
            var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
            var nativeDefineProperty = definePropertyModule.f;
            var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
            var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
            var AllSymbols = shared("symbols");
            var ObjectPrototypeSymbols = shared("op-symbols");
            var StringToSymbolRegistry = shared("string-to-symbol-registry");
            var SymbolToStringRegistry = shared("symbol-to-string-registry");
            var WellKnownSymbolsStore = shared("wks");
            var QObject = global2.QObject;
            var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
            var setSymbolDescriptor = DESCRIPTORS && fails(function() {
              return nativeObjectCreate(nativeDefineProperty({}, "a", {
                get: function() {
                  return nativeDefineProperty(this, "a", { value: 7 }).a;
                }
              })).a != 7;
            }) ? function(O2, P2, Attributes) {
              var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P2);
              if (ObjectPrototypeDescriptor)
                delete ObjectPrototype[P2];
              nativeDefineProperty(O2, P2, Attributes);
              if (ObjectPrototypeDescriptor && O2 !== ObjectPrototype) {
                nativeDefineProperty(ObjectPrototype, P2, ObjectPrototypeDescriptor);
              }
            } : nativeDefineProperty;
            var wrap = function(tag, description) {
              var symbol = AllSymbols[tag] = nativeObjectCreate($Symbol[PROTOTYPE]);
              setInternalState(symbol, {
                type: SYMBOL,
                tag,
                description
              });
              if (!DESCRIPTORS)
                symbol.description = description;
              return symbol;
            };
            var isSymbol2 = USE_SYMBOL_AS_UID ? function(it2) {
              return typeof it2 == "symbol";
            } : function(it2) {
              return Object(it2) instanceof $Symbol;
            };
            var $defineProperty2 = function defineProperty(O2, P2, Attributes) {
              if (O2 === ObjectPrototype)
                $defineProperty2(ObjectPrototypeSymbols, P2, Attributes);
              anObject(O2);
              var key2 = toPrimitive(P2, true);
              anObject(Attributes);
              if (has2(AllSymbols, key2)) {
                if (!Attributes.enumerable) {
                  if (!has2(O2, HIDDEN))
                    nativeDefineProperty(O2, HIDDEN, createPropertyDescriptor(1, {}));
                  O2[HIDDEN][key2] = true;
                } else {
                  if (has2(O2, HIDDEN) && O2[HIDDEN][key2])
                    O2[HIDDEN][key2] = false;
                  Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
                }
                return setSymbolDescriptor(O2, key2, Attributes);
              }
              return nativeDefineProperty(O2, key2, Attributes);
            };
            var $defineProperties = function defineProperties(O2, Properties) {
              anObject(O2);
              var properties = toIndexedObject(Properties);
              var keys2 = objectKeys(properties).concat($getOwnPropertySymbols(properties));
              $forEach(keys2, function(key2) {
                if (!DESCRIPTORS || $propertyIsEnumerable.call(properties, key2))
                  $defineProperty2(O2, key2, properties[key2]);
              });
              return O2;
            };
            var $create = function create2(O2, Properties) {
              return Properties === void 0 ? nativeObjectCreate(O2) : $defineProperties(nativeObjectCreate(O2), Properties);
            };
            var $propertyIsEnumerable = function propertyIsEnumerable(V2) {
              var P2 = toPrimitive(V2, true);
              var enumerable = nativePropertyIsEnumerable.call(this, P2);
              if (this === ObjectPrototype && has2(AllSymbols, P2) && !has2(ObjectPrototypeSymbols, P2))
                return false;
              return enumerable || !has2(this, P2) || !has2(AllSymbols, P2) || has2(this, HIDDEN) && this[HIDDEN][P2] ? enumerable : true;
            };
            var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O2, P2) {
              var it2 = toIndexedObject(O2);
              var key2 = toPrimitive(P2, true);
              if (it2 === ObjectPrototype && has2(AllSymbols, key2) && !has2(ObjectPrototypeSymbols, key2))
                return;
              var descriptor = nativeGetOwnPropertyDescriptor(it2, key2);
              if (descriptor && has2(AllSymbols, key2) && !(has2(it2, HIDDEN) && it2[HIDDEN][key2])) {
                descriptor.enumerable = true;
              }
              return descriptor;
            };
            var $getOwnPropertyNames = function getOwnPropertyNames(O2) {
              var names = nativeGetOwnPropertyNames(toIndexedObject(O2));
              var result = [];
              $forEach(names, function(key2) {
                if (!has2(AllSymbols, key2) && !has2(hiddenKeys, key2))
                  result.push(key2);
              });
              return result;
            };
            var $getOwnPropertySymbols = function getOwnPropertySymbols(O2) {
              var IS_OBJECT_PROTOTYPE = O2 === ObjectPrototype;
              var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O2));
              var result = [];
              $forEach(names, function(key2) {
                if (has2(AllSymbols, key2) && (!IS_OBJECT_PROTOTYPE || has2(ObjectPrototype, key2))) {
                  result.push(AllSymbols[key2]);
                }
              });
              return result;
            };
            if (!NATIVE_SYMBOL) {
              $Symbol = function Symbol2() {
                if (this instanceof $Symbol)
                  throw TypeError("Symbol is not a constructor");
                var description = !arguments.length || arguments[0] === void 0 ? void 0 : String(arguments[0]);
                var tag = uid2(description);
                var setter = function(value) {
                  if (this === ObjectPrototype)
                    setter.call(ObjectPrototypeSymbols, value);
                  if (has2(this, HIDDEN) && has2(this[HIDDEN], tag))
                    this[HIDDEN][tag] = false;
                  setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
                };
                if (DESCRIPTORS && USE_SETTER)
                  setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
                return wrap(tag, description);
              };
              redefine($Symbol[PROTOTYPE], "toString", function toString2() {
                return getInternalState(this).tag;
              });
              redefine($Symbol, "withoutSetter", function(description) {
                return wrap(uid2(description), description);
              });
              propertyIsEnumerableModule.f = $propertyIsEnumerable;
              definePropertyModule.f = $defineProperty2;
              getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
              getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
              getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;
              wrappedWellKnownSymbolModule.f = function(name) {
                return wrap(wellKnownSymbol(name), name);
              };
              if (DESCRIPTORS) {
                nativeDefineProperty($Symbol[PROTOTYPE], "description", {
                  configurable: true,
                  get: function description() {
                    return getInternalState(this).description;
                  }
                });
                if (!IS_PURE) {
                  redefine(ObjectPrototype, "propertyIsEnumerable", $propertyIsEnumerable, { unsafe: true });
                }
              }
            }
            $2({ global: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
              Symbol: $Symbol
            });
            $forEach(objectKeys(WellKnownSymbolsStore), function(name) {
              defineWellKnownSymbol(name);
            });
            $2({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
              // `Symbol.for` method
              // https://tc39.github.io/ecma262/#sec-symbol.for
              "for": function(key2) {
                var string = String(key2);
                if (has2(StringToSymbolRegistry, string))
                  return StringToSymbolRegistry[string];
                var symbol = $Symbol(string);
                StringToSymbolRegistry[string] = symbol;
                SymbolToStringRegistry[symbol] = string;
                return symbol;
              },
              // `Symbol.keyFor` method
              // https://tc39.github.io/ecma262/#sec-symbol.keyfor
              keyFor: function keyFor(sym) {
                if (!isSymbol2(sym))
                  throw TypeError(sym + " is not a symbol");
                if (has2(SymbolToStringRegistry, sym))
                  return SymbolToStringRegistry[sym];
              },
              useSetter: function() {
                USE_SETTER = true;
              },
              useSimple: function() {
                USE_SETTER = false;
              }
            });
            $2({ target: "Object", stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
              // `Object.create` method
              // https://tc39.github.io/ecma262/#sec-object.create
              create: $create,
              // `Object.defineProperty` method
              // https://tc39.github.io/ecma262/#sec-object.defineproperty
              defineProperty: $defineProperty2,
              // `Object.defineProperties` method
              // https://tc39.github.io/ecma262/#sec-object.defineproperties
              defineProperties: $defineProperties,
              // `Object.getOwnPropertyDescriptor` method
              // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
              getOwnPropertyDescriptor: $getOwnPropertyDescriptor
            });
            $2({ target: "Object", stat: true, forced: !NATIVE_SYMBOL }, {
              // `Object.getOwnPropertyNames` method
              // https://tc39.github.io/ecma262/#sec-object.getownpropertynames
              getOwnPropertyNames: $getOwnPropertyNames,
              // `Object.getOwnPropertySymbols` method
              // https://tc39.github.io/ecma262/#sec-object.getownpropertysymbols
              getOwnPropertySymbols: $getOwnPropertySymbols
            });
            $2({ target: "Object", stat: true, forced: fails(function() {
              getOwnPropertySymbolsModule.f(1);
            }) }, {
              getOwnPropertySymbols: function getOwnPropertySymbols(it2) {
                return getOwnPropertySymbolsModule.f(toObject(it2));
              }
            });
            if ($stringify) {
              var FORCED_JSON_STRINGIFY = !NATIVE_SYMBOL || fails(function() {
                var symbol = $Symbol();
                return $stringify([symbol]) != "[null]" || $stringify({ a: symbol }) != "{}" || $stringify(Object(symbol)) != "{}";
              });
              $2({ target: "JSON", stat: true, forced: FORCED_JSON_STRINGIFY }, {
                // eslint-disable-next-line no-unused-vars
                stringify: function stringify4(it2, replacer2, space) {
                  var args = [it2];
                  var index2 = 1;
                  var $replacer;
                  while (arguments.length > index2)
                    args.push(arguments[index2++]);
                  $replacer = replacer2;
                  if (!isObject2(replacer2) && it2 === void 0 || isSymbol2(it2))
                    return;
                  if (!isArray2(replacer2))
                    replacer2 = function(key2, value) {
                      if (typeof $replacer == "function")
                        value = $replacer.call(this, key2, value);
                      if (!isSymbol2(value))
                        return value;
                    };
                  args[1] = replacer2;
                  return $stringify.apply(null, args);
                }
              });
            }
            if (!$Symbol[PROTOTYPE][TO_PRIMITIVE]) {
              createNonEnumerableProperty($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
            }
            setToStringTag($Symbol, SYMBOL);
            hiddenKeys[HIDDEN] = true;
          }
        ),
        /***/
        "a630": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var $2 = __webpack_require__("23e7");
            var from = __webpack_require__("4df4");
            var checkCorrectnessOfIteration = __webpack_require__("1c7e");
            var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function(iterable) {
              Array.from(iterable);
            });
            $2({ target: "Array", stat: true, forced: INCORRECT_ITERATION }, {
              from
            });
          }
        ),
        /***/
        "a640": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var fails = __webpack_require__("d039");
            module2.exports = function(METHOD_NAME, argument) {
              var method = [][METHOD_NAME];
              return !!method && fails(function() {
                method.call(null, argument || function() {
                  throw 1;
                }, 1);
              });
            };
          }
        ),
        /***/
        "a691": (
          /***/
          function(module2, exports2) {
            var ceil = Math.ceil;
            var floor2 = Math.floor;
            module2.exports = function(argument) {
              return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor2 : ceil)(argument);
            };
          }
        ),
        /***/
        "ab13": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var wellKnownSymbol = __webpack_require__("b622");
            var MATCH = wellKnownSymbol("match");
            module2.exports = function(METHOD_NAME) {
              var regexp = /./;
              try {
                "/./"[METHOD_NAME](regexp);
              } catch (e) {
                try {
                  regexp[MATCH] = false;
                  return "/./"[METHOD_NAME](regexp);
                } catch (f2) {
                }
              }
              return false;
            };
          }
        ),
        /***/
        "ac1f": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var $2 = __webpack_require__("23e7");
            var exec = __webpack_require__("9263");
            $2({ target: "RegExp", proto: true, forced: /./.exec !== exec }, {
              exec
            });
          }
        ),
        /***/
        "ad6d": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var anObject = __webpack_require__("825a");
            module2.exports = function() {
              var that = anObject(this);
              var result = "";
              if (that.global)
                result += "g";
              if (that.ignoreCase)
                result += "i";
              if (that.multiline)
                result += "m";
              if (that.dotAll)
                result += "s";
              if (that.unicode)
                result += "u";
              if (that.sticky)
                result += "y";
              return result;
            };
          }
        ),
        /***/
        "ae40": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var DESCRIPTORS = __webpack_require__("83ab");
            var fails = __webpack_require__("d039");
            var has2 = __webpack_require__("5135");
            var defineProperty = Object.defineProperty;
            var cache = {};
            var thrower = function(it2) {
              throw it2;
            };
            module2.exports = function(METHOD_NAME, options) {
              if (has2(cache, METHOD_NAME))
                return cache[METHOD_NAME];
              if (!options)
                options = {};
              var method = [][METHOD_NAME];
              var ACCESSORS = has2(options, "ACCESSORS") ? options.ACCESSORS : false;
              var argument0 = has2(options, 0) ? options[0] : thrower;
              var argument1 = has2(options, 1) ? options[1] : void 0;
              return cache[METHOD_NAME] = !!method && !fails(function() {
                if (ACCESSORS && !DESCRIPTORS)
                  return true;
                var O2 = { length: -1 };
                if (ACCESSORS)
                  defineProperty(O2, 1, { enumerable: true, get: thrower });
                else
                  O2[1] = 1;
                method.call(O2, argument0, argument1);
              });
            };
          }
        ),
        /***/
        "ae93": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var getPrototypeOf = __webpack_require__("e163");
            var createNonEnumerableProperty = __webpack_require__("9112");
            var has2 = __webpack_require__("5135");
            var wellKnownSymbol = __webpack_require__("b622");
            var IS_PURE = __webpack_require__("c430");
            var ITERATOR = wellKnownSymbol("iterator");
            var BUGGY_SAFARI_ITERATORS = false;
            var returnThis = function() {
              return this;
            };
            var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
            if ([].keys) {
              arrayIterator = [].keys();
              if (!("next" in arrayIterator))
                BUGGY_SAFARI_ITERATORS = true;
              else {
                PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
                if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
                  IteratorPrototype = PrototypeOfArrayIteratorPrototype;
              }
            }
            if (IteratorPrototype == void 0)
              IteratorPrototype = {};
            if (!IS_PURE && !has2(IteratorPrototype, ITERATOR)) {
              createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
            }
            module2.exports = {
              IteratorPrototype,
              BUGGY_SAFARI_ITERATORS
            };
          }
        ),
        /***/
        "b041": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var TO_STRING_TAG_SUPPORT = __webpack_require__("00ee");
            var classof = __webpack_require__("f5df");
            module2.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString2() {
              return "[object " + classof(this) + "]";
            };
          }
        ),
        /***/
        "b0c0": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var DESCRIPTORS = __webpack_require__("83ab");
            var defineProperty = __webpack_require__("9bf2").f;
            var FunctionPrototype = Function.prototype;
            var FunctionPrototypeToString = FunctionPrototype.toString;
            var nameRE = /^\s*function ([^ (]*)/;
            var NAME = "name";
            if (DESCRIPTORS && !(NAME in FunctionPrototype)) {
              defineProperty(FunctionPrototype, NAME, {
                configurable: true,
                get: function() {
                  try {
                    return FunctionPrototypeToString.call(this).match(nameRE)[1];
                  } catch (error) {
                    return "";
                  }
                }
              });
            }
          }
        ),
        /***/
        "b622": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var global2 = __webpack_require__("da84");
            var shared = __webpack_require__("5692");
            var has2 = __webpack_require__("5135");
            var uid2 = __webpack_require__("90e3");
            var NATIVE_SYMBOL = __webpack_require__("4930");
            var USE_SYMBOL_AS_UID = __webpack_require__("fdbf");
            var WellKnownSymbolsStore = shared("wks");
            var Symbol2 = global2.Symbol;
            var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2 : Symbol2 && Symbol2.withoutSetter || uid2;
            module2.exports = function(name) {
              if (!has2(WellKnownSymbolsStore, name)) {
                if (NATIVE_SYMBOL && has2(Symbol2, name))
                  WellKnownSymbolsStore[name] = Symbol2[name];
                else
                  WellKnownSymbolsStore[name] = createWellKnownSymbol("Symbol." + name);
              }
              return WellKnownSymbolsStore[name];
            };
          }
        ),
        /***/
        "b64b": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var $2 = __webpack_require__("23e7");
            var toObject = __webpack_require__("7b0b");
            var nativeKeys = __webpack_require__("df75");
            var fails = __webpack_require__("d039");
            var FAILS_ON_PRIMITIVES = fails(function() {
              nativeKeys(1);
            });
            $2({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES }, {
              keys: function keys2(it2) {
                return nativeKeys(toObject(it2));
              }
            });
          }
        ),
        /***/
        "b727": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var bind4 = __webpack_require__("0366");
            var IndexedObject = __webpack_require__("44ad");
            var toObject = __webpack_require__("7b0b");
            var toLength = __webpack_require__("50c4");
            var arraySpeciesCreate = __webpack_require__("65f0");
            var push2 = [].push;
            var createMethod = function(TYPE) {
              var IS_MAP = TYPE == 1;
              var IS_FILTER = TYPE == 2;
              var IS_SOME = TYPE == 3;
              var IS_EVERY = TYPE == 4;
              var IS_FIND_INDEX = TYPE == 6;
              var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
              return function($this, callbackfn, that, specificCreate) {
                var O2 = toObject($this);
                var self2 = IndexedObject(O2);
                var boundFunction = bind4(callbackfn, that, 3);
                var length = toLength(self2.length);
                var index2 = 0;
                var create2 = specificCreate || arraySpeciesCreate;
                var target = IS_MAP ? create2($this, length) : IS_FILTER ? create2($this, 0) : void 0;
                var value, result;
                for (; length > index2; index2++)
                  if (NO_HOLES || index2 in self2) {
                    value = self2[index2];
                    result = boundFunction(value, index2, O2);
                    if (TYPE) {
                      if (IS_MAP)
                        target[index2] = result;
                      else if (result)
                        switch (TYPE) {
                          case 3:
                            return true;
                          case 5:
                            return value;
                          case 6:
                            return index2;
                          case 2:
                            push2.call(target, value);
                        }
                      else if (IS_EVERY)
                        return false;
                    }
                  }
                return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
              };
            };
            module2.exports = {
              // `Array.prototype.forEach` method
              // https://tc39.github.io/ecma262/#sec-array.prototype.foreach
              forEach: createMethod(0),
              // `Array.prototype.map` method
              // https://tc39.github.io/ecma262/#sec-array.prototype.map
              map: createMethod(1),
              // `Array.prototype.filter` method
              // https://tc39.github.io/ecma262/#sec-array.prototype.filter
              filter: createMethod(2),
              // `Array.prototype.some` method
              // https://tc39.github.io/ecma262/#sec-array.prototype.some
              some: createMethod(3),
              // `Array.prototype.every` method
              // https://tc39.github.io/ecma262/#sec-array.prototype.every
              every: createMethod(4),
              // `Array.prototype.find` method
              // https://tc39.github.io/ecma262/#sec-array.prototype.find
              find: createMethod(5),
              // `Array.prototype.findIndex` method
              // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
              findIndex: createMethod(6)
            };
          }
        ),
        /***/
        "c04e": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var isObject2 = __webpack_require__("861d");
            module2.exports = function(input, PREFERRED_STRING) {
              if (!isObject2(input))
                return input;
              var fn, val;
              if (PREFERRED_STRING && typeof (fn = input.toString) == "function" && !isObject2(val = fn.call(input)))
                return val;
              if (typeof (fn = input.valueOf) == "function" && !isObject2(val = fn.call(input)))
                return val;
              if (!PREFERRED_STRING && typeof (fn = input.toString) == "function" && !isObject2(val = fn.call(input)))
                return val;
              throw TypeError("Can't convert object to primitive value");
            };
          }
        ),
        /***/
        "c430": (
          /***/
          function(module2, exports2) {
            module2.exports = false;
          }
        ),
        /***/
        "c6b6": (
          /***/
          function(module2, exports2) {
            var toString2 = {}.toString;
            module2.exports = function(it2) {
              return toString2.call(it2).slice(8, -1);
            };
          }
        ),
        /***/
        "c6cd": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var global2 = __webpack_require__("da84");
            var setGlobal = __webpack_require__("ce4e");
            var SHARED = "__core-js_shared__";
            var store = global2[SHARED] || setGlobal(SHARED, {});
            module2.exports = store;
          }
        ),
        /***/
        "c740": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var $2 = __webpack_require__("23e7");
            var $findIndex = __webpack_require__("b727").findIndex;
            var addToUnscopables = __webpack_require__("44d2");
            var arrayMethodUsesToLength = __webpack_require__("ae40");
            var FIND_INDEX = "findIndex";
            var SKIPS_HOLES = true;
            var USES_TO_LENGTH = arrayMethodUsesToLength(FIND_INDEX);
            if (FIND_INDEX in [])
              Array(1)[FIND_INDEX](function() {
                SKIPS_HOLES = false;
              });
            $2({ target: "Array", proto: true, forced: SKIPS_HOLES || !USES_TO_LENGTH }, {
              findIndex: function findIndex2(callbackfn) {
                return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
              }
            });
            addToUnscopables(FIND_INDEX);
          }
        ),
        /***/
        "c8ba": (
          /***/
          function(module2, exports2) {
            var g2;
            g2 = function() {
              return this;
            }();
            try {
              g2 = g2 || new Function("return this")();
            } catch (e) {
              if (typeof window === "object")
                g2 = window;
            }
            module2.exports = g2;
          }
        ),
        /***/
        "c975": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var $2 = __webpack_require__("23e7");
            var $indexOf2 = __webpack_require__("4d64").indexOf;
            var arrayMethodIsStrict = __webpack_require__("a640");
            var arrayMethodUsesToLength = __webpack_require__("ae40");
            var nativeIndexOf = [].indexOf;
            var NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0;
            var STRICT_METHOD = arrayMethodIsStrict("indexOf");
            var USES_TO_LENGTH = arrayMethodUsesToLength("indexOf", { ACCESSORS: true, 1: 0 });
            $2({ target: "Array", proto: true, forced: NEGATIVE_ZERO || !STRICT_METHOD || !USES_TO_LENGTH }, {
              indexOf: function indexOf2(searchElement) {
                return NEGATIVE_ZERO ? nativeIndexOf.apply(this, arguments) || 0 : $indexOf2(this, searchElement, arguments.length > 1 ? arguments[1] : void 0);
              }
            });
          }
        ),
        /***/
        "ca84": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var has2 = __webpack_require__("5135");
            var toIndexedObject = __webpack_require__("fc6a");
            var indexOf2 = __webpack_require__("4d64").indexOf;
            var hiddenKeys = __webpack_require__("d012");
            module2.exports = function(object, names) {
              var O2 = toIndexedObject(object);
              var i = 0;
              var result = [];
              var key2;
              for (key2 in O2)
                !has2(hiddenKeys, key2) && has2(O2, key2) && result.push(key2);
              while (names.length > i)
                if (has2(O2, key2 = names[i++])) {
                  ~indexOf2(result, key2) || result.push(key2);
                }
              return result;
            };
          }
        ),
        /***/
        "caad": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var $2 = __webpack_require__("23e7");
            var $includes = __webpack_require__("4d64").includes;
            var addToUnscopables = __webpack_require__("44d2");
            var arrayMethodUsesToLength = __webpack_require__("ae40");
            var USES_TO_LENGTH = arrayMethodUsesToLength("indexOf", { ACCESSORS: true, 1: 0 });
            $2({ target: "Array", proto: true, forced: !USES_TO_LENGTH }, {
              includes: function includes2(el) {
                return $includes(this, el, arguments.length > 1 ? arguments[1] : void 0);
              }
            });
            addToUnscopables("includes");
          }
        ),
        /***/
        "cc12": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var global2 = __webpack_require__("da84");
            var isObject2 = __webpack_require__("861d");
            var document2 = global2.document;
            var EXISTS = isObject2(document2) && isObject2(document2.createElement);
            module2.exports = function(it2) {
              return EXISTS ? document2.createElement(it2) : {};
            };
          }
        ),
        /***/
        "ce4e": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var global2 = __webpack_require__("da84");
            var createNonEnumerableProperty = __webpack_require__("9112");
            module2.exports = function(key2, value) {
              try {
                createNonEnumerableProperty(global2, key2, value);
              } catch (error) {
                global2[key2] = value;
              }
              return value;
            };
          }
        ),
        /***/
        "d012": (
          /***/
          function(module2, exports2) {
            module2.exports = {};
          }
        ),
        /***/
        "d039": (
          /***/
          function(module2, exports2) {
            module2.exports = function(exec) {
              try {
                return !!exec();
              } catch (error) {
                return true;
              }
            };
          }
        ),
        /***/
        "d066": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var path = __webpack_require__("428f");
            var global2 = __webpack_require__("da84");
            var aFunction = function(variable) {
              return typeof variable == "function" ? variable : void 0;
            };
            module2.exports = function(namespace, method) {
              return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global2[namespace]) : path[namespace] && path[namespace][method] || global2[namespace] && global2[namespace][method];
            };
          }
        ),
        /***/
        "d1e7": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
            var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
            var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);
            exports2.f = NASHORN_BUG ? function propertyIsEnumerable(V2) {
              var descriptor = getOwnPropertyDescriptor(this, V2);
              return !!descriptor && descriptor.enumerable;
            } : nativePropertyIsEnumerable;
          }
        ),
        /***/
        "d28b": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var defineWellKnownSymbol = __webpack_require__("746f");
            defineWellKnownSymbol("iterator");
          }
        ),
        /***/
        "d2bb": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var anObject = __webpack_require__("825a");
            var aPossiblePrototype = __webpack_require__("3bbe");
            module2.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
              var CORRECT_SETTER = false;
              var test2 = {};
              var setter;
              try {
                setter = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set;
                setter.call(test2, []);
                CORRECT_SETTER = test2 instanceof Array;
              } catch (error) {
              }
              return function setPrototypeOf(O2, proto) {
                anObject(O2);
                aPossiblePrototype(proto);
                if (CORRECT_SETTER)
                  setter.call(O2, proto);
                else
                  O2.__proto__ = proto;
                return O2;
              };
            }() : void 0);
          }
        ),
        /***/
        "d3b7": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var TO_STRING_TAG_SUPPORT = __webpack_require__("00ee");
            var redefine = __webpack_require__("6eeb");
            var toString2 = __webpack_require__("b041");
            if (!TO_STRING_TAG_SUPPORT) {
              redefine(Object.prototype, "toString", toString2, { unsafe: true });
            }
          }
        ),
        /***/
        "d44e": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var defineProperty = __webpack_require__("9bf2").f;
            var has2 = __webpack_require__("5135");
            var wellKnownSymbol = __webpack_require__("b622");
            var TO_STRING_TAG = wellKnownSymbol("toStringTag");
            module2.exports = function(it2, TAG, STATIC) {
              if (it2 && !has2(it2 = STATIC ? it2 : it2.prototype, TO_STRING_TAG)) {
                defineProperty(it2, TO_STRING_TAG, { configurable: true, value: TAG });
              }
            };
          }
        ),
        /***/
        "d58f": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var aFunction = __webpack_require__("1c0b");
            var toObject = __webpack_require__("7b0b");
            var IndexedObject = __webpack_require__("44ad");
            var toLength = __webpack_require__("50c4");
            var createMethod = function(IS_RIGHT) {
              return function(that, callbackfn, argumentsLength, memo) {
                aFunction(callbackfn);
                var O2 = toObject(that);
                var self2 = IndexedObject(O2);
                var length = toLength(O2.length);
                var index2 = IS_RIGHT ? length - 1 : 0;
                var i = IS_RIGHT ? -1 : 1;
                if (argumentsLength < 2)
                  while (true) {
                    if (index2 in self2) {
                      memo = self2[index2];
                      index2 += i;
                      break;
                    }
                    index2 += i;
                    if (IS_RIGHT ? index2 < 0 : length <= index2) {
                      throw TypeError("Reduce of empty array with no initial value");
                    }
                  }
                for (; IS_RIGHT ? index2 >= 0 : length > index2; index2 += i)
                  if (index2 in self2) {
                    memo = callbackfn(memo, self2[index2], index2, O2);
                  }
                return memo;
              };
            };
            module2.exports = {
              // `Array.prototype.reduce` method
              // https://tc39.github.io/ecma262/#sec-array.prototype.reduce
              left: createMethod(false),
              // `Array.prototype.reduceRight` method
              // https://tc39.github.io/ecma262/#sec-array.prototype.reduceright
              right: createMethod(true)
            };
          }
        ),
        /***/
        "d784": (
          /***/
          function(module2, exports2, __webpack_require__) {
            __webpack_require__("ac1f");
            var redefine = __webpack_require__("6eeb");
            var fails = __webpack_require__("d039");
            var wellKnownSymbol = __webpack_require__("b622");
            var regexpExec = __webpack_require__("9263");
            var createNonEnumerableProperty = __webpack_require__("9112");
            var SPECIES = wellKnownSymbol("species");
            var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function() {
              var re2 = /./;
              re2.exec = function() {
                var result = [];
                result.groups = { a: "7" };
                return result;
              };
              return "".replace(re2, "$<a>") !== "7";
            });
            var REPLACE_KEEPS_$0 = function() {
              return "a".replace(/./, "$0") === "$0";
            }();
            var REPLACE = wellKnownSymbol("replace");
            var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function() {
              if (/./[REPLACE]) {
                return /./[REPLACE]("a", "$0") === "";
              }
              return false;
            }();
            var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function() {
              var re2 = /(?:)/;
              var originalExec = re2.exec;
              re2.exec = function() {
                return originalExec.apply(this, arguments);
              };
              var result = "ab".split(re2);
              return result.length !== 2 || result[0] !== "a" || result[1] !== "b";
            });
            module2.exports = function(KEY, length, exec, sham) {
              var SYMBOL = wellKnownSymbol(KEY);
              var DELEGATES_TO_SYMBOL = !fails(function() {
                var O2 = {};
                O2[SYMBOL] = function() {
                  return 7;
                };
                return ""[KEY](O2) != 7;
              });
              var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function() {
                var execCalled = false;
                var re2 = /a/;
                if (KEY === "split") {
                  re2 = {};
                  re2.constructor = {};
                  re2.constructor[SPECIES] = function() {
                    return re2;
                  };
                  re2.flags = "";
                  re2[SYMBOL] = /./[SYMBOL];
                }
                re2.exec = function() {
                  execCalled = true;
                  return null;
                };
                re2[SYMBOL]("");
                return !execCalled;
              });
              if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === "replace" && !(REPLACE_SUPPORTS_NAMED_GROUPS && REPLACE_KEEPS_$0 && !REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE) || KEY === "split" && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
                var nativeRegExpMethod = /./[SYMBOL];
                var methods = exec(SYMBOL, ""[KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {
                  if (regexp.exec === regexpExec) {
                    if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
                      return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
                    }
                    return { done: true, value: nativeMethod.call(str, regexp, arg2) };
                  }
                  return { done: false };
                }, {
                  REPLACE_KEEPS_$0,
                  REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
                });
                var stringMethod = methods[0];
                var regexMethod = methods[1];
                redefine(String.prototype, KEY, stringMethod);
                redefine(
                  RegExp.prototype,
                  SYMBOL,
                  length == 2 ? function(string, arg) {
                    return regexMethod.call(string, this, arg);
                  } : function(string) {
                    return regexMethod.call(string, this);
                  }
                );
              }
              if (sham)
                createNonEnumerableProperty(RegExp.prototype[SYMBOL], "sham", true);
            };
          }
        ),
        /***/
        "d81d": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var $2 = __webpack_require__("23e7");
            var $map = __webpack_require__("b727").map;
            var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
            var arrayMethodUsesToLength = __webpack_require__("ae40");
            var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("map");
            var USES_TO_LENGTH = arrayMethodUsesToLength("map");
            $2({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {
              map: function map(callbackfn) {
                return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
              }
            });
          }
        ),
        /***/
        "da84": (
          /***/
          function(module2, exports2, __webpack_require__) {
            (function(global2) {
              var check = function(it2) {
                return it2 && it2.Math == Math && it2;
              };
              module2.exports = // eslint-disable-next-line no-undef
              check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || check(typeof self == "object" && self) || check(typeof global2 == "object" && global2) || // eslint-disable-next-line no-new-func
              Function("return this")();
            }).call(this, __webpack_require__("c8ba"));
          }
        ),
        /***/
        "dbb4": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var $2 = __webpack_require__("23e7");
            var DESCRIPTORS = __webpack_require__("83ab");
            var ownKeys2 = __webpack_require__("56ef");
            var toIndexedObject = __webpack_require__("fc6a");
            var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
            var createProperty = __webpack_require__("8418");
            $2({ target: "Object", stat: true, sham: !DESCRIPTORS }, {
              getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
                var O2 = toIndexedObject(object);
                var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
                var keys2 = ownKeys2(O2);
                var result = {};
                var index2 = 0;
                var key2, descriptor;
                while (keys2.length > index2) {
                  descriptor = getOwnPropertyDescriptor(O2, key2 = keys2[index2++]);
                  if (descriptor !== void 0)
                    createProperty(result, key2, descriptor);
                }
                return result;
              }
            });
          }
        ),
        /***/
        "dbf1": (
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            (function(global2) {
              __webpack_require__.d(__webpack_exports__, "a", function() {
                return console2;
              });
              function getConsole() {
                if (typeof window !== "undefined") {
                  return window.console;
                }
                return global2.console;
              }
              var console2 = getConsole();
            }).call(this, __webpack_require__("c8ba"));
          }
        ),
        /***/
        "ddb0": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var global2 = __webpack_require__("da84");
            var DOMIterables = __webpack_require__("fdbc");
            var ArrayIteratorMethods = __webpack_require__("e260");
            var createNonEnumerableProperty = __webpack_require__("9112");
            var wellKnownSymbol = __webpack_require__("b622");
            var ITERATOR = wellKnownSymbol("iterator");
            var TO_STRING_TAG = wellKnownSymbol("toStringTag");
            var ArrayValues = ArrayIteratorMethods.values;
            for (var COLLECTION_NAME in DOMIterables) {
              var Collection = global2[COLLECTION_NAME];
              var CollectionPrototype = Collection && Collection.prototype;
              if (CollectionPrototype) {
                if (CollectionPrototype[ITERATOR] !== ArrayValues)
                  try {
                    createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
                  } catch (error) {
                    CollectionPrototype[ITERATOR] = ArrayValues;
                  }
                if (!CollectionPrototype[TO_STRING_TAG]) {
                  createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
                }
                if (DOMIterables[COLLECTION_NAME])
                  for (var METHOD_NAME in ArrayIteratorMethods) {
                    if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME])
                      try {
                        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
                      } catch (error) {
                        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
                      }
                  }
              }
            }
          }
        ),
        /***/
        "df75": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var internalObjectKeys = __webpack_require__("ca84");
            var enumBugKeys = __webpack_require__("7839");
            module2.exports = Object.keys || function keys2(O2) {
              return internalObjectKeys(O2, enumBugKeys);
            };
          }
        ),
        /***/
        "e01a": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var $2 = __webpack_require__("23e7");
            var DESCRIPTORS = __webpack_require__("83ab");
            var global2 = __webpack_require__("da84");
            var has2 = __webpack_require__("5135");
            var isObject2 = __webpack_require__("861d");
            var defineProperty = __webpack_require__("9bf2").f;
            var copyConstructorProperties = __webpack_require__("e893");
            var NativeSymbol = global2.Symbol;
            if (DESCRIPTORS && typeof NativeSymbol == "function" && (!("description" in NativeSymbol.prototype) || // Safari 12 bug
            NativeSymbol().description !== void 0)) {
              var EmptyStringDescriptionStore = {};
              var SymbolWrapper = function Symbol2() {
                var description = arguments.length < 1 || arguments[0] === void 0 ? void 0 : String(arguments[0]);
                var result = this instanceof SymbolWrapper ? new NativeSymbol(description) : description === void 0 ? NativeSymbol() : NativeSymbol(description);
                if (description === "")
                  EmptyStringDescriptionStore[result] = true;
                return result;
              };
              copyConstructorProperties(SymbolWrapper, NativeSymbol);
              var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;
              symbolPrototype.constructor = SymbolWrapper;
              var symbolToString = symbolPrototype.toString;
              var native = String(NativeSymbol("test")) == "Symbol(test)";
              var regexp = /^Symbol\((.*)\)[^)]+$/;
              defineProperty(symbolPrototype, "description", {
                configurable: true,
                get: function description() {
                  var symbol = isObject2(this) ? this.valueOf() : this;
                  var string = symbolToString.call(symbol);
                  if (has2(EmptyStringDescriptionStore, symbol))
                    return "";
                  var desc = native ? string.slice(7, -1) : string.replace(regexp, "$1");
                  return desc === "" ? void 0 : desc;
                }
              });
              $2({ global: true, forced: true }, {
                Symbol: SymbolWrapper
              });
            }
          }
        ),
        /***/
        "e163": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var has2 = __webpack_require__("5135");
            var toObject = __webpack_require__("7b0b");
            var sharedKey = __webpack_require__("f772");
            var CORRECT_PROTOTYPE_GETTER = __webpack_require__("e177");
            var IE_PROTO = sharedKey("IE_PROTO");
            var ObjectPrototype = Object.prototype;
            module2.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function(O2) {
              O2 = toObject(O2);
              if (has2(O2, IE_PROTO))
                return O2[IE_PROTO];
              if (typeof O2.constructor == "function" && O2 instanceof O2.constructor) {
                return O2.constructor.prototype;
              }
              return O2 instanceof Object ? ObjectPrototype : null;
            };
          }
        ),
        /***/
        "e177": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var fails = __webpack_require__("d039");
            module2.exports = !fails(function() {
              function F2() {
              }
              F2.prototype.constructor = null;
              return Object.getPrototypeOf(new F2()) !== F2.prototype;
            });
          }
        ),
        /***/
        "e260": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var toIndexedObject = __webpack_require__("fc6a");
            var addToUnscopables = __webpack_require__("44d2");
            var Iterators = __webpack_require__("3f8c");
            var InternalStateModule = __webpack_require__("69f3");
            var defineIterator = __webpack_require__("7dd0");
            var ARRAY_ITERATOR = "Array Iterator";
            var setInternalState = InternalStateModule.set;
            var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
            module2.exports = defineIterator(Array, "Array", function(iterated, kind) {
              setInternalState(this, {
                type: ARRAY_ITERATOR,
                target: toIndexedObject(iterated),
                // target
                index: 0,
                // next index
                kind
                // kind
              });
            }, function() {
              var state = getInternalState(this);
              var target = state.target;
              var kind = state.kind;
              var index2 = state.index++;
              if (!target || index2 >= target.length) {
                state.target = void 0;
                return { value: void 0, done: true };
              }
              if (kind == "keys")
                return { value: index2, done: false };
              if (kind == "values")
                return { value: target[index2], done: false };
              return { value: [index2, target[index2]], done: false };
            }, "values");
            Iterators.Arguments = Iterators.Array;
            addToUnscopables("keys");
            addToUnscopables("values");
            addToUnscopables("entries");
          }
        ),
        /***/
        "e439": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var $2 = __webpack_require__("23e7");
            var fails = __webpack_require__("d039");
            var toIndexedObject = __webpack_require__("fc6a");
            var nativeGetOwnPropertyDescriptor = __webpack_require__("06cf").f;
            var DESCRIPTORS = __webpack_require__("83ab");
            var FAILS_ON_PRIMITIVES = fails(function() {
              nativeGetOwnPropertyDescriptor(1);
            });
            var FORCED = !DESCRIPTORS || FAILS_ON_PRIMITIVES;
            $2({ target: "Object", stat: true, forced: FORCED, sham: !DESCRIPTORS }, {
              getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it2, key2) {
                return nativeGetOwnPropertyDescriptor(toIndexedObject(it2), key2);
              }
            });
          }
        ),
        /***/
        "e538": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var wellKnownSymbol = __webpack_require__("b622");
            exports2.f = wellKnownSymbol;
          }
        ),
        /***/
        "e893": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var has2 = __webpack_require__("5135");
            var ownKeys2 = __webpack_require__("56ef");
            var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
            var definePropertyModule = __webpack_require__("9bf2");
            module2.exports = function(target, source2) {
              var keys2 = ownKeys2(source2);
              var defineProperty = definePropertyModule.f;
              var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
              for (var i = 0; i < keys2.length; i++) {
                var key2 = keys2[i];
                if (!has2(target, key2))
                  defineProperty(target, key2, getOwnPropertyDescriptor(source2, key2));
              }
            };
          }
        ),
        /***/
        "e8b5": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var classof = __webpack_require__("c6b6");
            module2.exports = Array.isArray || function isArray2(arg) {
              return classof(arg) == "Array";
            };
          }
        ),
        /***/
        "e95a": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var wellKnownSymbol = __webpack_require__("b622");
            var Iterators = __webpack_require__("3f8c");
            var ITERATOR = wellKnownSymbol("iterator");
            var ArrayPrototype = Array.prototype;
            module2.exports = function(it2) {
              return it2 !== void 0 && (Iterators.Array === it2 || ArrayPrototype[ITERATOR] === it2);
            };
          }
        ),
        /***/
        "f5df": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var TO_STRING_TAG_SUPPORT = __webpack_require__("00ee");
            var classofRaw = __webpack_require__("c6b6");
            var wellKnownSymbol = __webpack_require__("b622");
            var TO_STRING_TAG = wellKnownSymbol("toStringTag");
            var CORRECT_ARGUMENTS = classofRaw(function() {
              return arguments;
            }()) == "Arguments";
            var tryGet = function(it2, key2) {
              try {
                return it2[key2];
              } catch (error) {
              }
            };
            module2.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it2) {
              var O2, tag, result;
              return it2 === void 0 ? "Undefined" : it2 === null ? "Null" : typeof (tag = tryGet(O2 = Object(it2), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O2) : (result = classofRaw(O2)) == "Object" && typeof O2.callee == "function" ? "Arguments" : result;
            };
          }
        ),
        /***/
        "f772": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var shared = __webpack_require__("5692");
            var uid2 = __webpack_require__("90e3");
            var keys2 = shared("keys");
            module2.exports = function(key2) {
              return keys2[key2] || (keys2[key2] = uid2(key2));
            };
          }
        ),
        /***/
        "fb15": (
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            __webpack_require__.r(__webpack_exports__);
            if (typeof window !== "undefined") {
              var currentScript = window.document.currentScript;
              {
                var getCurrentScript = __webpack_require__("8875");
                currentScript = getCurrentScript();
                if (!("currentScript" in document)) {
                  Object.defineProperty(document, "currentScript", { get: getCurrentScript });
                }
              }
              var src = currentScript && currentScript.src.match(/(.+\/)[^/]+\.js(\?.*)?$/);
              if (src) {
                __webpack_require__.p = src[1];
              }
            }
            __webpack_require__("99af");
            __webpack_require__("4de4");
            __webpack_require__("4160");
            __webpack_require__("c975");
            __webpack_require__("d81d");
            __webpack_require__("a434");
            __webpack_require__("159b");
            __webpack_require__("a4d3");
            __webpack_require__("e439");
            __webpack_require__("dbb4");
            __webpack_require__("b64b");
            function _defineProperty2(obj, key2, value) {
              if (key2 in obj) {
                Object.defineProperty(obj, key2, {
                  value,
                  enumerable: true,
                  configurable: true,
                  writable: true
                });
              } else {
                obj[key2] = value;
              }
              return obj;
            }
            function ownKeys2(object, enumerableOnly) {
              var keys2 = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly)
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                keys2.push.apply(keys2, symbols);
              }
              return keys2;
            }
            function _objectSpread22(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source2 = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  ownKeys2(Object(source2), true).forEach(function(key2) {
                    _defineProperty2(target, key2, source2[key2]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2));
                } else {
                  ownKeys2(Object(source2)).forEach(function(key2) {
                    Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source2, key2));
                  });
                }
              }
              return target;
            }
            function _arrayWithHoles(arr) {
              if (Array.isArray(arr))
                return arr;
            }
            __webpack_require__("e01a");
            __webpack_require__("d28b");
            __webpack_require__("e260");
            __webpack_require__("d3b7");
            __webpack_require__("3ca3");
            __webpack_require__("ddb0");
            function _iterableToArrayLimit(arr, i) {
              if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
                return;
              var _arr2 = [];
              var _n = true;
              var _d = false;
              var _e = void 0;
              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr2.push(_s.value);
                  if (i && _arr2.length === i)
                    break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"] != null)
                    _i["return"]();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr2;
            }
            __webpack_require__("a630");
            __webpack_require__("fb6a");
            __webpack_require__("b0c0");
            __webpack_require__("25f0");
            function _arrayLikeToArray2(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function _unsupportedIterableToArray2(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return _arrayLikeToArray2(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return _arrayLikeToArray2(o, minLen);
            }
            function _nonIterableRest() {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function _slicedToArray(arr, i) {
              return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray2(arr, i) || _nonIterableRest();
            }
            function _arrayWithoutHoles2(arr) {
              if (Array.isArray(arr))
                return _arrayLikeToArray2(arr);
            }
            function _iterableToArray2(iter) {
              if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
                return Array.from(iter);
            }
            function _nonIterableSpread2() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function _toConsumableArray2(arr) {
              return _arrayWithoutHoles2(arr) || _iterableToArray2(arr) || _unsupportedIterableToArray2(arr) || _nonIterableSpread2();
            }
            var external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_ = __webpack_require__("a352");
            var external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_default = /* @__PURE__ */ __webpack_require__.n(external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_);
            function removeNode(node) {
              if (node.parentElement !== null) {
                node.parentElement.removeChild(node);
              }
            }
            function insertNodeAt(fatherNode, node, position) {
              var refNode = position === 0 ? fatherNode.children[0] : fatherNode.children[position - 1].nextSibling;
              fatherNode.insertBefore(node, refNode);
            }
            var console2 = __webpack_require__("dbf1");
            __webpack_require__("13d5");
            __webpack_require__("4fad");
            __webpack_require__("ac1f");
            __webpack_require__("5319");
            function cached(fn) {
              var cache = /* @__PURE__ */ Object.create(null);
              return function cachedFn(str) {
                var hit = cache[str];
                return hit || (cache[str] = fn(str));
              };
            }
            var regex2 = /-(\w)/g;
            var camelize2 = cached(function(str) {
              return str.replace(regex2, function(_2, c2) {
                return c2.toUpperCase();
              });
            });
            __webpack_require__("5db7");
            __webpack_require__("73d9");
            var manageAndEmit = ["Start", "Add", "Remove", "Update", "End"];
            var emit2 = ["Choose", "Unchoose", "Sort", "Filter", "Clone"];
            var manage = ["Move"];
            var eventHandlerNames = [manage, manageAndEmit, emit2].flatMap(function(events2) {
              return events2;
            }).map(function(evt) {
              return "on".concat(evt);
            });
            var events = {
              manage,
              manageAndEmit,
              emit: emit2
            };
            function isReadOnly(eventName2) {
              return eventHandlerNames.indexOf(eventName2) !== -1;
            }
            __webpack_require__("caad");
            __webpack_require__("2ca0");
            var tags = ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "label", "legend", "li", "link", "main", "map", "mark", "math", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rb", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "section", "select", "slot", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr"];
            function isHtmlTag(name) {
              return tags.includes(name);
            }
            function isTransition(name) {
              return ["transition-group", "TransitionGroup"].includes(name);
            }
            function isHtmlAttribute(value) {
              return ["id", "class", "role", "style"].includes(value) || value.startsWith("data-") || value.startsWith("aria-") || value.startsWith("on");
            }
            function project(entries) {
              return entries.reduce(function(res, _ref) {
                var _ref2 = _slicedToArray(_ref, 2), key2 = _ref2[0], value = _ref2[1];
                res[key2] = value;
                return res;
              }, {});
            }
            function getComponentAttributes(_ref3) {
              var $attrs = _ref3.$attrs, _ref3$componentData = _ref3.componentData, componentData = _ref3$componentData === void 0 ? {} : _ref3$componentData;
              var attributes = project(Object.entries($attrs).filter(function(_ref4) {
                var _ref5 = _slicedToArray(_ref4, 2), key2 = _ref5[0];
                _ref5[1];
                return isHtmlAttribute(key2);
              }));
              return _objectSpread22(_objectSpread22({}, attributes), componentData);
            }
            function createSortableOption(_ref6) {
              var $attrs = _ref6.$attrs, callBackBuilder = _ref6.callBackBuilder;
              var options = project(getValidSortableEntries($attrs));
              Object.entries(callBackBuilder).forEach(function(_ref7) {
                var _ref8 = _slicedToArray(_ref7, 2), eventType = _ref8[0], eventBuilder = _ref8[1];
                events[eventType].forEach(function(event) {
                  options["on".concat(event)] = eventBuilder(event);
                });
              });
              var draggable = "[data-draggable]".concat(options.draggable || "");
              return _objectSpread22(_objectSpread22({}, options), {}, {
                draggable
              });
            }
            function getValidSortableEntries(value) {
              return Object.entries(value).filter(function(_ref9) {
                var _ref10 = _slicedToArray(_ref9, 2), key2 = _ref10[0];
                _ref10[1];
                return !isHtmlAttribute(key2);
              }).map(function(_ref11) {
                var _ref12 = _slicedToArray(_ref11, 2), key2 = _ref12[0], value2 = _ref12[1];
                return [camelize2(key2), value2];
              }).filter(function(_ref13) {
                var _ref14 = _slicedToArray(_ref13, 2), key2 = _ref14[0];
                _ref14[1];
                return !isReadOnly(key2);
              });
            }
            __webpack_require__("c740");
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _defineProperties2(target, props3) {
              for (var i = 0; i < props3.length; i++) {
                var descriptor = props3[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function _createClass2(Constructor, protoProps, staticProps) {
              if (protoProps)
                _defineProperties2(Constructor.prototype, protoProps);
              if (staticProps)
                _defineProperties2(Constructor, staticProps);
              return Constructor;
            }
            var getHtmlElementFromNode = function getHtmlElementFromNode2(_ref) {
              var el = _ref.el;
              return el;
            };
            var addContext = function addContext2(domElement, context) {
              return domElement.__draggable_context = context;
            };
            var getContext2 = function getContext3(domElement) {
              return domElement.__draggable_context;
            };
            var componentStructure_ComponentStructure = /* @__PURE__ */ function() {
              function ComponentStructure(_ref2) {
                var _ref2$nodes = _ref2.nodes, header = _ref2$nodes.header, defaultNodes = _ref2$nodes.default, footer = _ref2$nodes.footer, root2 = _ref2.root, realList = _ref2.realList;
                _classCallCheck2(this, ComponentStructure);
                this.defaultNodes = defaultNodes;
                this.children = [].concat(_toConsumableArray2(header), _toConsumableArray2(defaultNodes), _toConsumableArray2(footer));
                this.externalComponent = root2.externalComponent;
                this.rootTransition = root2.transition;
                this.tag = root2.tag;
                this.realList = realList;
              }
              _createClass2(ComponentStructure, [{
                key: "render",
                value: function render2(h2, attributes) {
                  var tag = this.tag, children = this.children, _isRootComponent = this._isRootComponent;
                  var option2 = !_isRootComponent ? children : {
                    default: function _default() {
                      return children;
                    }
                  };
                  return h2(tag, attributes, option2);
                }
              }, {
                key: "updated",
                value: function updated2() {
                  var defaultNodes = this.defaultNodes, realList = this.realList;
                  defaultNodes.forEach(function(node, index2) {
                    addContext(getHtmlElementFromNode(node), {
                      element: realList[index2],
                      index: index2
                    });
                  });
                }
              }, {
                key: "getUnderlyingVm",
                value: function getUnderlyingVm(domElement) {
                  return getContext2(domElement);
                }
              }, {
                key: "getVmIndexFromDomIndex",
                value: function getVmIndexFromDomIndex(domIndex, element) {
                  var defaultNodes = this.defaultNodes;
                  var length = defaultNodes.length;
                  var domChildren = element.children;
                  var domElement = domChildren.item(domIndex);
                  if (domElement === null) {
                    return length;
                  }
                  var context = getContext2(domElement);
                  if (context) {
                    return context.index;
                  }
                  if (length === 0) {
                    return 0;
                  }
                  var firstDomListElement = getHtmlElementFromNode(defaultNodes[0]);
                  var indexFirstDomListElement = _toConsumableArray2(domChildren).findIndex(function(element2) {
                    return element2 === firstDomListElement;
                  });
                  return domIndex < indexFirstDomListElement ? 0 : length;
                }
              }, {
                key: "_isRootComponent",
                get: function get2() {
                  return this.externalComponent || this.rootTransition;
                }
              }]);
              return ComponentStructure;
            }();
            var external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__("8bbf");
            function getSlot(slots, key2) {
              var slotValue = slots[key2];
              return slotValue ? slotValue() : [];
            }
            function computeNodes(_ref) {
              var $slots = _ref.$slots, realList = _ref.realList, getKey = _ref.getKey;
              var normalizedList = realList || [];
              var _map2 = ["header", "footer"].map(function(name) {
                return getSlot($slots, name);
              }), _map22 = _slicedToArray(_map2, 2), header = _map22[0], footer = _map22[1];
              var item = $slots.item;
              if (!item) {
                throw new Error("draggable element must have an item slot");
              }
              var defaultNodes = normalizedList.flatMap(function(element, index2) {
                return item({
                  element,
                  index: index2
                }).map(function(node) {
                  node.key = getKey(element);
                  node.props = _objectSpread22(_objectSpread22({}, node.props || {}), {}, {
                    "data-draggable": true
                  });
                  return node;
                });
              });
              if (defaultNodes.length !== normalizedList.length) {
                throw new Error("Item slot must have only one child");
              }
              return {
                header,
                footer,
                default: defaultNodes
              };
            }
            function getRootInformation(tag) {
              var transition = isTransition(tag);
              var externalComponent = !isHtmlTag(tag) && !transition;
              return {
                transition,
                externalComponent,
                tag: externalComponent ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["resolveComponent"])(tag) : transition ? external_commonjs_vue_commonjs2_vue_root_Vue_["TransitionGroup"] : tag
              };
            }
            function computeComponentStructure(_ref2) {
              var $slots = _ref2.$slots, tag = _ref2.tag, realList = _ref2.realList, getKey = _ref2.getKey;
              var nodes = computeNodes({
                $slots,
                realList,
                getKey
              });
              var root2 = getRootInformation(tag);
              return new componentStructure_ComponentStructure({
                nodes,
                root: root2,
                realList
              });
            }
            function _emit(evtName, evtData) {
              var _this = this;
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function() {
                return _this.$emit(evtName.toLowerCase(), evtData);
              });
            }
            function _manage(evtName) {
              var _this2 = this;
              return function(evtData, originalElement) {
                if (_this2.realList !== null) {
                  return _this2["onDrag".concat(evtName)](evtData, originalElement);
                }
              };
            }
            function _manageAndEmit(evtName) {
              var _this3 = this;
              var delegateCallBack = _manage.call(this, evtName);
              return function(evtData, originalElement) {
                delegateCallBack.call(_this3, evtData, originalElement);
                _emit.call(_this3, evtName, evtData);
              };
            }
            var draggingElement = null;
            var props2 = {
              list: {
                type: Array,
                required: false,
                default: null
              },
              modelValue: {
                type: Array,
                required: false,
                default: null
              },
              itemKey: {
                type: [String, Function],
                required: true
              },
              clone: {
                type: Function,
                default: function _default(original) {
                  return original;
                }
              },
              tag: {
                type: String,
                default: "div"
              },
              move: {
                type: Function,
                default: null
              },
              componentData: {
                type: Object,
                required: false,
                default: null
              }
            };
            var emits = ["update:modelValue", "change"].concat(_toConsumableArray2([].concat(_toConsumableArray2(events.manageAndEmit), _toConsumableArray2(events.emit)).map(function(evt) {
              return evt.toLowerCase();
            })));
            var draggableComponent = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
              name: "draggable",
              inheritAttrs: false,
              props: props2,
              emits,
              data: function data() {
                return {
                  error: false
                };
              },
              render: function render2() {
                try {
                  this.error = false;
                  var $slots = this.$slots, $attrs = this.$attrs, tag = this.tag, componentData = this.componentData, realList = this.realList, getKey = this.getKey;
                  var componentStructure = computeComponentStructure({
                    $slots,
                    tag,
                    realList,
                    getKey
                  });
                  this.componentStructure = componentStructure;
                  var attributes = getComponentAttributes({
                    $attrs,
                    componentData
                  });
                  return componentStructure.render(external_commonjs_vue_commonjs2_vue_root_Vue_["h"], attributes);
                } catch (err) {
                  this.error = true;
                  return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("pre", {
                    style: {
                      color: "red"
                    }
                  }, err.stack);
                }
              },
              created: function created() {
                if (this.list !== null && this.modelValue !== null) {
                  console2[
                    "a"
                    /* console */
                  ].error("modelValue and list props are mutually exclusive! Please set one or another.");
                }
              },
              mounted: function mounted2() {
                var _this4 = this;
                if (this.error) {
                  return;
                }
                var $attrs = this.$attrs, $el = this.$el, componentStructure = this.componentStructure;
                componentStructure.updated();
                var sortableOptions = createSortableOption({
                  $attrs,
                  callBackBuilder: {
                    manageAndEmit: function manageAndEmit2(event) {
                      return _manageAndEmit.call(_this4, event);
                    },
                    emit: function emit3(event) {
                      return _emit.bind(_this4, event);
                    },
                    manage: function manage2(event) {
                      return _manage.call(_this4, event);
                    }
                  }
                });
                var targetDomElement = $el.nodeType === 1 ? $el : $el.parentElement;
                this._sortable = new external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_default.a(targetDomElement, sortableOptions);
                this.targetDomElement = targetDomElement;
                targetDomElement.__draggable_component__ = this;
              },
              updated: function updated2() {
                this.componentStructure.updated();
              },
              beforeUnmount: function beforeUnmount() {
                if (this._sortable !== void 0)
                  this._sortable.destroy();
              },
              computed: {
                realList: function realList() {
                  var list = this.list;
                  return list ? list : this.modelValue;
                },
                getKey: function getKey() {
                  var itemKey = this.itemKey;
                  if (typeof itemKey === "function") {
                    return itemKey;
                  }
                  return function(element) {
                    return element[itemKey];
                  };
                }
              },
              watch: {
                $attrs: {
                  handler: function handler(newOptionValue) {
                    var _sortable = this._sortable;
                    if (!_sortable)
                      return;
                    getValidSortableEntries(newOptionValue).forEach(function(_ref) {
                      var _ref2 = _slicedToArray(_ref, 2), key2 = _ref2[0], value = _ref2[1];
                      _sortable.option(key2, value);
                    });
                  },
                  deep: true
                }
              },
              methods: {
                getUnderlyingVm: function getUnderlyingVm(domElement) {
                  return this.componentStructure.getUnderlyingVm(domElement) || null;
                },
                getUnderlyingPotencialDraggableComponent: function getUnderlyingPotencialDraggableComponent(htmElement) {
                  return htmElement.__draggable_component__;
                },
                emitChanges: function emitChanges(evt) {
                  var _this5 = this;
                  Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function() {
                    return _this5.$emit("change", evt);
                  });
                },
                alterList: function alterList(onList) {
                  if (this.list) {
                    onList(this.list);
                    return;
                  }
                  var newList = _toConsumableArray2(this.modelValue);
                  onList(newList);
                  this.$emit("update:modelValue", newList);
                },
                spliceList: function spliceList() {
                  var _arguments = arguments;
                  var spliceList2 = function spliceList3(list) {
                    return list.splice.apply(list, _toConsumableArray2(_arguments));
                  };
                  this.alterList(spliceList2);
                },
                updatePosition: function updatePosition(oldIndex2, newIndex2) {
                  var updatePosition2 = function updatePosition3(list) {
                    return list.splice(newIndex2, 0, list.splice(oldIndex2, 1)[0]);
                  };
                  this.alterList(updatePosition2);
                },
                getRelatedContextFromMoveEvent: function getRelatedContextFromMoveEvent(_ref3) {
                  var to = _ref3.to, related = _ref3.related;
                  var component = this.getUnderlyingPotencialDraggableComponent(to);
                  if (!component) {
                    return {
                      component
                    };
                  }
                  var list = component.realList;
                  var context = {
                    list,
                    component
                  };
                  if (to !== related && list) {
                    var destination = component.getUnderlyingVm(related) || {};
                    return _objectSpread22(_objectSpread22({}, destination), context);
                  }
                  return context;
                },
                getVmIndexFromDomIndex: function getVmIndexFromDomIndex(domIndex) {
                  return this.componentStructure.getVmIndexFromDomIndex(domIndex, this.targetDomElement);
                },
                onDragStart: function onDragStart(evt) {
                  this.context = this.getUnderlyingVm(evt.item);
                  evt.item._underlying_vm_ = this.clone(this.context.element);
                  draggingElement = evt.item;
                },
                onDragAdd: function onDragAdd(evt) {
                  var element = evt.item._underlying_vm_;
                  if (element === void 0) {
                    return;
                  }
                  removeNode(evt.item);
                  var newIndex2 = this.getVmIndexFromDomIndex(evt.newIndex);
                  this.spliceList(newIndex2, 0, element);
                  var added = {
                    element,
                    newIndex: newIndex2
                  };
                  this.emitChanges({
                    added
                  });
                },
                onDragRemove: function onDragRemove(evt) {
                  insertNodeAt(this.$el, evt.item, evt.oldIndex);
                  if (evt.pullMode === "clone") {
                    removeNode(evt.clone);
                    return;
                  }
                  var _this$context = this.context, oldIndex2 = _this$context.index, element = _this$context.element;
                  this.spliceList(oldIndex2, 1);
                  var removed = {
                    element,
                    oldIndex: oldIndex2
                  };
                  this.emitChanges({
                    removed
                  });
                },
                onDragUpdate: function onDragUpdate(evt) {
                  removeNode(evt.item);
                  insertNodeAt(evt.from, evt.item, evt.oldIndex);
                  var oldIndex2 = this.context.index;
                  var newIndex2 = this.getVmIndexFromDomIndex(evt.newIndex);
                  this.updatePosition(oldIndex2, newIndex2);
                  var moved2 = {
                    element: this.context.element,
                    oldIndex: oldIndex2,
                    newIndex: newIndex2
                  };
                  this.emitChanges({
                    moved: moved2
                  });
                },
                computeFutureIndex: function computeFutureIndex(relatedContext, evt) {
                  if (!relatedContext.element) {
                    return 0;
                  }
                  var domChildren = _toConsumableArray2(evt.to.children).filter(function(el) {
                    return el.style["display"] !== "none";
                  });
                  var currentDomIndex = domChildren.indexOf(evt.related);
                  var currentIndex = relatedContext.component.getVmIndexFromDomIndex(currentDomIndex);
                  var draggedInList = domChildren.indexOf(draggingElement) !== -1;
                  return draggedInList || !evt.willInsertAfter ? currentIndex : currentIndex + 1;
                },
                onDragMove: function onDragMove(evt, originalEvent) {
                  var move = this.move, realList = this.realList;
                  if (!move || !realList) {
                    return true;
                  }
                  var relatedContext = this.getRelatedContextFromMoveEvent(evt);
                  var futureIndex = this.computeFutureIndex(relatedContext, evt);
                  var draggedContext = _objectSpread22(_objectSpread22({}, this.context), {}, {
                    futureIndex
                  });
                  var sendEvent = _objectSpread22(_objectSpread22({}, evt), {}, {
                    relatedContext,
                    draggedContext
                  });
                  return move(sendEvent, originalEvent);
                },
                onDragEnd: function onDragEnd() {
                  draggingElement = null;
                }
              }
            });
            var vuedraggable = draggableComponent;
            __webpack_exports__["default"] = vuedraggable;
          }
        ),
        /***/
        "fb6a": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var $2 = __webpack_require__("23e7");
            var isObject2 = __webpack_require__("861d");
            var isArray2 = __webpack_require__("e8b5");
            var toAbsoluteIndex = __webpack_require__("23cb");
            var toLength = __webpack_require__("50c4");
            var toIndexedObject = __webpack_require__("fc6a");
            var createProperty = __webpack_require__("8418");
            var wellKnownSymbol = __webpack_require__("b622");
            var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
            var arrayMethodUsesToLength = __webpack_require__("ae40");
            var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("slice");
            var USES_TO_LENGTH = arrayMethodUsesToLength("slice", { ACCESSORS: true, 0: 0, 1: 2 });
            var SPECIES = wellKnownSymbol("species");
            var nativeSlice = [].slice;
            var max2 = Math.max;
            $2({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {
              slice: function slice(start, end) {
                var O2 = toIndexedObject(this);
                var length = toLength(O2.length);
                var k2 = toAbsoluteIndex(start, length);
                var fin = toAbsoluteIndex(end === void 0 ? length : end, length);
                var Constructor, result, n;
                if (isArray2(O2)) {
                  Constructor = O2.constructor;
                  if (typeof Constructor == "function" && (Constructor === Array || isArray2(Constructor.prototype))) {
                    Constructor = void 0;
                  } else if (isObject2(Constructor)) {
                    Constructor = Constructor[SPECIES];
                    if (Constructor === null)
                      Constructor = void 0;
                  }
                  if (Constructor === Array || Constructor === void 0) {
                    return nativeSlice.call(O2, k2, fin);
                  }
                }
                result = new (Constructor === void 0 ? Array : Constructor)(max2(fin - k2, 0));
                for (n = 0; k2 < fin; k2++, n++)
                  if (k2 in O2)
                    createProperty(result, n, O2[k2]);
                result.length = n;
                return result;
              }
            });
          }
        ),
        /***/
        "fc6a": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var IndexedObject = __webpack_require__("44ad");
            var requireObjectCoercible = __webpack_require__("1d80");
            module2.exports = function(it2) {
              return IndexedObject(requireObjectCoercible(it2));
            };
          }
        ),
        /***/
        "fdbc": (
          /***/
          function(module2, exports2) {
            module2.exports = {
              CSSRuleList: 0,
              CSSStyleDeclaration: 0,
              CSSValueList: 0,
              ClientRectList: 0,
              DOMRectList: 0,
              DOMStringList: 0,
              DOMTokenList: 1,
              DataTransferItemList: 0,
              FileList: 0,
              HTMLAllCollection: 0,
              HTMLCollection: 0,
              HTMLFormElement: 0,
              HTMLSelectElement: 0,
              MediaList: 0,
              MimeTypeArray: 0,
              NamedNodeMap: 0,
              NodeList: 1,
              PaintRequestList: 0,
              Plugin: 0,
              PluginArray: 0,
              SVGLengthList: 0,
              SVGNumberList: 0,
              SVGPathSegList: 0,
              SVGPointList: 0,
              SVGStringList: 0,
              SVGTransformList: 0,
              SourceBufferList: 0,
              StyleSheetList: 0,
              TextTrackCueList: 0,
              TextTrackList: 0,
              TouchList: 0
            };
          }
        ),
        /***/
        "fdbf": (
          /***/
          function(module2, exports2, __webpack_require__) {
            var NATIVE_SYMBOL = __webpack_require__("4930");
            module2.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
          }
        )
        /******/
      })["default"]
    );
  });
})(vuedraggable_umd);
const IN_BROWSER = typeof window !== "undefined";
const SUPPORTS_INTERSECTION = IN_BROWSER && "IntersectionObserver" in window;
const SUPPORTS_TOUCH = IN_BROWSER && ("ontouchstart" in window || window.navigator.maxTouchPoints > 0);
function _classPrivateFieldInitSpec(obj, privateMap, value) {
  _checkPrivateRedeclaration(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldSet(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");
  _classApplyDescriptorSet(receiver, descriptor, value);
  return value;
}
function _classApplyDescriptorSet(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
function _classPrivateFieldGet(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
  return _classApplyDescriptorGet(receiver, descriptor);
}
function _classExtractFieldDescriptor(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorGet(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function getNestedValue(obj, path, fallback) {
  const last = path.length - 1;
  if (last < 0)
    return obj === void 0 ? fallback : obj;
  for (let i = 0; i < last; i++) {
    if (obj == null) {
      return fallback;
    }
    obj = obj[path[i]];
  }
  if (obj == null)
    return fallback;
  return obj[path[last]] === void 0 ? fallback : obj[path[last]];
}
function deepEqual(a, b2) {
  if (a === b2)
    return true;
  if (a instanceof Date && b2 instanceof Date && a.getTime() !== b2.getTime()) {
    return false;
  }
  if (a !== Object(a) || b2 !== Object(b2)) {
    return false;
  }
  const props2 = Object.keys(a);
  if (props2.length !== Object.keys(b2).length) {
    return false;
  }
  return props2.every((p2) => deepEqual(a[p2], b2[p2]));
}
function getObjectValueByPath(obj, path, fallback) {
  if (obj == null || !path || typeof path !== "string")
    return fallback;
  if (obj[path] !== void 0)
    return obj[path];
  path = path.replace(/\[(\w+)\]/g, ".$1");
  path = path.replace(/^\./, "");
  return getNestedValue(obj, path.split("."), fallback);
}
function getPropertyFromItem(item, property, fallback) {
  if (property === true)
    return item === void 0 ? fallback : item;
  if (property == null || typeof property === "boolean")
    return fallback;
  if (item !== Object(item)) {
    if (typeof property !== "function")
      return fallback;
    const value2 = property(item, fallback);
    return typeof value2 === "undefined" ? fallback : value2;
  }
  if (typeof property === "string")
    return getObjectValueByPath(item, property, fallback);
  if (Array.isArray(property))
    return getNestedValue(item, property, fallback);
  if (typeof property !== "function")
    return fallback;
  const value = property(item, fallback);
  return typeof value === "undefined" ? fallback : value;
}
function createRange(length) {
  let start = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  return Array.from({
    length
  }, (v2, k2) => start + k2);
}
function convertToUnit(str) {
  let unit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "px";
  if (str == null || str === "") {
    return void 0;
  } else if (isNaN(+str)) {
    return String(str);
  } else if (!isFinite(+str)) {
    return void 0;
  } else {
    return `${Number(str)}${unit}`;
  }
}
function isObject(obj) {
  return obj !== null && typeof obj === "object" && !Array.isArray(obj);
}
function refElement(obj) {
  return obj && "$el" in obj ? obj.$el : obj;
}
const keyCodes = Object.freeze({
  enter: 13,
  tab: 9,
  delete: 46,
  esc: 27,
  space: 32,
  up: 38,
  down: 40,
  left: 37,
  right: 39,
  end: 35,
  home: 36,
  del: 46,
  backspace: 8,
  insert: 45,
  pageup: 33,
  pagedown: 34,
  shift: 16
});
const keyValues = Object.freeze({
  enter: "Enter",
  tab: "Tab",
  delete: "Delete",
  esc: "Escape",
  space: "Space",
  up: "ArrowUp",
  down: "ArrowDown",
  left: "ArrowLeft",
  right: "ArrowRight",
  end: "End",
  home: "Home",
  del: "Delete",
  backspace: "Backspace",
  insert: "Insert",
  pageup: "PageUp",
  pagedown: "PageDown",
  shift: "Shift"
});
function keys(o) {
  return Object.keys(o);
}
function has$4(obj, key2) {
  return key2.every((k2) => obj.hasOwnProperty(k2));
}
function pick(obj, paths, exclude) {
  const found = /* @__PURE__ */ Object.create(null);
  const rest = /* @__PURE__ */ Object.create(null);
  for (const key2 in obj) {
    if (paths.some((path) => path instanceof RegExp ? path.test(key2) : path === key2) && !(exclude == null ? void 0 : exclude.some((path) => path === key2))) {
      found[key2] = obj[key2];
    } else {
      rest[key2] = obj[key2];
    }
  }
  return [found, rest];
}
function omit(obj, exclude) {
  const clone2 = {
    ...obj
  };
  exclude.forEach((prop) => delete clone2[prop]);
  return clone2;
}
const onRE = /^on[^a-z]/;
const isOn = (key2) => onRE.test(key2);
const bubblingEvents = ["onAfterscriptexecute", "onAnimationcancel", "onAnimationend", "onAnimationiteration", "onAnimationstart", "onAuxclick", "onBeforeinput", "onBeforescriptexecute", "onChange", "onClick", "onCompositionend", "onCompositionstart", "onCompositionupdate", "onContextmenu", "onCopy", "onCut", "onDblclick", "onFocusin", "onFocusout", "onFullscreenchange", "onFullscreenerror", "onGesturechange", "onGestureend", "onGesturestart", "onGotpointercapture", "onInput", "onKeydown", "onKeypress", "onKeyup", "onLostpointercapture", "onMousedown", "onMousemove", "onMouseout", "onMouseover", "onMouseup", "onMousewheel", "onPaste", "onPointercancel", "onPointerdown", "onPointerenter", "onPointerleave", "onPointermove", "onPointerout", "onPointerover", "onPointerup", "onReset", "onSelect", "onSubmit", "onTouchcancel", "onTouchend", "onTouchmove", "onTouchstart", "onTransitioncancel", "onTransitionend", "onTransitionrun", "onTransitionstart", "onWheel"];
const compositionIgnoreKeys = ["ArrowUp", "ArrowDown", "ArrowRight", "ArrowLeft", "Enter", "Escape", "Tab", " "];
function isComposingIgnoreKey(e) {
  return e.isComposing && compositionIgnoreKeys.includes(e.key);
}
function filterInputAttrs(attrs) {
  const [events, props2] = pick(attrs, [onRE]);
  const inputEvents = omit(events, bubblingEvents);
  const [rootAttrs, inputAttrs] = pick(props2, ["class", "style", "id", /^data-/]);
  Object.assign(rootAttrs, events);
  Object.assign(inputAttrs, inputEvents);
  return [rootAttrs, inputAttrs];
}
function wrapInArray(v2) {
  return v2 == null ? [] : Array.isArray(v2) ? v2 : [v2];
}
function clamp(value) {
  let min = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  let max2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  return Math.max(min, Math.min(max2, value));
}
function getDecimals(value) {
  const trimmedStr = value.toString().trim();
  return trimmedStr.includes(".") ? trimmedStr.length - trimmedStr.indexOf(".") - 1 : 0;
}
function padEnd(str, length) {
  let char = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0";
  return str + char.repeat(Math.max(0, length - str.length));
}
function padStart(str, length) {
  let char = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0";
  return char.repeat(Math.max(0, length - str.length)) + str;
}
function chunk(str) {
  let size2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  const chunked = [];
  let index2 = 0;
  while (index2 < str.length) {
    chunked.push(str.substr(index2, size2));
    index2 += size2;
  }
  return chunked;
}
function humanReadableFileSize(bytes) {
  let base = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e3;
  if (bytes < base) {
    return `${bytes} B`;
  }
  const prefix = base === 1024 ? ["Ki", "Mi", "Gi"] : ["k", "M", "G"];
  let unit = -1;
  while (Math.abs(bytes) >= base && unit < prefix.length - 1) {
    bytes /= base;
    ++unit;
  }
  return `${bytes.toFixed(1)} ${prefix[unit]}B`;
}
function mergeDeep() {
  let source2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  let target = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  let arrayFn = arguments.length > 2 ? arguments[2] : void 0;
  const out = {};
  for (const key2 in source2) {
    out[key2] = source2[key2];
  }
  for (const key2 in target) {
    const sourceProperty = source2[key2];
    const targetProperty = target[key2];
    if (isObject(sourceProperty) && isObject(targetProperty)) {
      out[key2] = mergeDeep(sourceProperty, targetProperty, arrayFn);
      continue;
    }
    if (Array.isArray(sourceProperty) && Array.isArray(targetProperty) && arrayFn) {
      out[key2] = arrayFn(sourceProperty, targetProperty);
      continue;
    }
    out[key2] = targetProperty;
  }
  return out;
}
function flattenFragments(nodes) {
  return nodes.map((node) => {
    if (node.type === Fragment) {
      return flattenFragments(node.children);
    } else {
      return node;
    }
  }).flat();
}
function toKebabCase() {
  let str = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  if (toKebabCase.cache.has(str))
    return toKebabCase.cache.get(str);
  const kebab = str.replace(/[^a-z]/gi, "-").replace(/\B([A-Z])/g, "-$1").toLowerCase();
  toKebabCase.cache.set(str, kebab);
  return kebab;
}
toKebabCase.cache = /* @__PURE__ */ new Map();
function findChildrenWithProvide(key2, vnode) {
  if (!vnode || typeof vnode !== "object")
    return [];
  if (Array.isArray(vnode)) {
    return vnode.map((child) => findChildrenWithProvide(key2, child)).flat(1);
  } else if (Array.isArray(vnode.children)) {
    return vnode.children.map((child) => findChildrenWithProvide(key2, child)).flat(1);
  } else if (vnode.component) {
    if (Object.getOwnPropertySymbols(vnode.component.provides).includes(key2)) {
      return [vnode.component];
    } else if (vnode.component.subTree) {
      return findChildrenWithProvide(key2, vnode.component.subTree).flat(1);
    }
  }
  return [];
}
var _arr = /* @__PURE__ */ new WeakMap();
var _pointer = /* @__PURE__ */ new WeakMap();
class CircularBuffer {
  constructor(size2) {
    _classPrivateFieldInitSpec(this, _arr, {
      writable: true,
      value: []
    });
    _classPrivateFieldInitSpec(this, _pointer, {
      writable: true,
      value: 0
    });
    this.size = size2;
  }
  push(val) {
    _classPrivateFieldGet(this, _arr)[_classPrivateFieldGet(this, _pointer)] = val;
    _classPrivateFieldSet(this, _pointer, (_classPrivateFieldGet(this, _pointer) + 1) % this.size);
  }
  values() {
    return _classPrivateFieldGet(this, _arr).slice(_classPrivateFieldGet(this, _pointer)).concat(_classPrivateFieldGet(this, _arr).slice(0, _classPrivateFieldGet(this, _pointer)));
  }
}
function getEventCoordinates(e) {
  if ("touches" in e) {
    return {
      clientX: e.touches[0].clientX,
      clientY: e.touches[0].clientY
    };
  }
  return {
    clientX: e.clientX,
    clientY: e.clientY
  };
}
function destructComputed(getter) {
  const refs = reactive({});
  const base = computed(getter);
  watchEffect(() => {
    for (const key2 in base.value) {
      refs[key2] = base.value[key2];
    }
  }, {
    flush: "sync"
  });
  return toRefs(refs);
}
function includes(arr, val) {
  return arr.includes(val);
}
function eventName(propName) {
  return propName[2].toLowerCase() + propName.slice(3);
}
const EventProp = () => [Function, Array];
function hasEvent(props2, name) {
  name = "on" + capitalize(name);
  return !!(props2[name] || props2[`${name}Once`] || props2[`${name}Capture`] || props2[`${name}OnceCapture`] || props2[`${name}CaptureOnce`]);
}
function callEvent(handler) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  if (Array.isArray(handler)) {
    for (const h2 of handler) {
      h2(...args);
    }
  } else if (typeof handler === "function") {
    handler(...args);
  }
}
function focusableChildren(el) {
  let filterByTabIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  const targets = ["button", "[href]", 'input:not([type="hidden"])', "select", "textarea", "[tabindex]"].map((s) => `${s}${filterByTabIndex ? ':not([tabindex="-1"])' : ""}:not([disabled])`).join(", ");
  return [...el.querySelectorAll(targets)];
}
function getNextElement(elements, location2, condition) {
  let _el;
  let idx = elements.indexOf(document.activeElement);
  const inc = location2 === "next" ? 1 : -1;
  do {
    idx += inc;
    _el = elements[idx];
  } while ((!_el || _el.offsetParent == null || !((condition == null ? void 0 : condition(_el)) ?? true)) && idx < elements.length && idx >= 0);
  return _el;
}
function focusChild(el, location2) {
  var _a2, _b, _c, _d;
  const focusable = focusableChildren(el);
  if (!location2) {
    if (el === document.activeElement || !el.contains(document.activeElement)) {
      (_a2 = focusable[0]) == null ? void 0 : _a2.focus();
    }
  } else if (location2 === "first") {
    (_b = focusable[0]) == null ? void 0 : _b.focus();
  } else if (location2 === "last") {
    (_c = focusable.at(-1)) == null ? void 0 : _c.focus();
  } else if (typeof location2 === "number") {
    (_d = focusable[location2]) == null ? void 0 : _d.focus();
  } else {
    const _el = getNextElement(focusable, location2);
    if (_el)
      _el.focus();
    else
      focusChild(el, location2 === "next" ? "first" : "last");
  }
}
function noop() {
}
function matchesSelector(el, selector) {
  const supportsSelector = IN_BROWSER && typeof CSS !== "undefined" && typeof CSS.supports !== "undefined" && CSS.supports(`selector(${selector})`);
  if (!supportsSelector)
    return null;
  try {
    return !!el && el.matches(selector);
  } catch (err) {
    return null;
  }
}
const block = ["top", "bottom"];
const inline = ["start", "end", "left", "right"];
function parseAnchor(anchor, isRtl) {
  let [side, align] = anchor.split(" ");
  if (!align) {
    align = includes(block, side) ? "start" : includes(inline, side) ? "top" : "center";
  }
  return {
    side: toPhysical(side, isRtl),
    align: toPhysical(align, isRtl)
  };
}
function toPhysical(str, isRtl) {
  if (str === "start")
    return isRtl ? "right" : "left";
  if (str === "end")
    return isRtl ? "left" : "right";
  return str;
}
function flipSide(anchor) {
  return {
    side: {
      center: "center",
      top: "bottom",
      bottom: "top",
      left: "right",
      right: "left"
    }[anchor.side],
    align: anchor.align
  };
}
function flipAlign(anchor) {
  return {
    side: anchor.side,
    align: {
      center: "center",
      top: "bottom",
      bottom: "top",
      left: "right",
      right: "left"
    }[anchor.align]
  };
}
function flipCorner(anchor) {
  return {
    side: anchor.align,
    align: anchor.side
  };
}
function getAxis(anchor) {
  return includes(block, anchor.side) ? "y" : "x";
}
class Box {
  constructor(_ref) {
    let {
      x: x2,
      y: y2,
      width,
      height
    } = _ref;
    this.x = x2;
    this.y = y2;
    this.width = width;
    this.height = height;
  }
  get top() {
    return this.y;
  }
  get bottom() {
    return this.y + this.height;
  }
  get left() {
    return this.x;
  }
  get right() {
    return this.x + this.width;
  }
}
function getOverflow(a, b2) {
  return {
    x: {
      before: Math.max(0, b2.left - a.left),
      after: Math.max(0, a.right - b2.right)
    },
    y: {
      before: Math.max(0, b2.top - a.top),
      after: Math.max(0, a.bottom - b2.bottom)
    }
  };
}
function nullifyTransforms(el) {
  const rect = el.getBoundingClientRect();
  const style3 = getComputedStyle(el);
  const tx = style3.transform;
  if (tx) {
    let ta, sx, sy, dx, dy;
    if (tx.startsWith("matrix3d(")) {
      ta = tx.slice(9, -1).split(/, /);
      sx = +ta[0];
      sy = +ta[5];
      dx = +ta[12];
      dy = +ta[13];
    } else if (tx.startsWith("matrix(")) {
      ta = tx.slice(7, -1).split(/, /);
      sx = +ta[0];
      sy = +ta[3];
      dx = +ta[4];
      dy = +ta[5];
    } else {
      return new Box(rect);
    }
    const to = style3.transformOrigin;
    const x2 = rect.x - dx - (1 - sx) * parseFloat(to);
    const y2 = rect.y - dy - (1 - sy) * parseFloat(to.slice(to.indexOf(" ") + 1));
    const w2 = sx ? rect.width / sx : el.offsetWidth + 1;
    const h2 = sy ? rect.height / sy : el.offsetHeight + 1;
    return new Box({
      x: x2,
      y: y2,
      width: w2,
      height: h2
    });
  } else {
    return new Box(rect);
  }
}
function animate(el, keyframes, options) {
  if (typeof el.animate === "undefined")
    return {
      finished: Promise.resolve()
    };
  let animation;
  try {
    animation = el.animate(keyframes, options);
  } catch (err) {
    return {
      finished: Promise.resolve()
    };
  }
  if (typeof animation.finished === "undefined") {
    animation.finished = new Promise((resolve2) => {
      animation.onfinish = () => {
        resolve2(animation);
      };
    });
  }
  return animation;
}
const handlers = /* @__PURE__ */ new WeakMap();
function bindProps(el, props2) {
  Object.keys(props2).forEach((k2) => {
    var _a2;
    if (isOn(k2)) {
      const name = eventName(k2);
      const handler = handlers.get(el);
      if (props2[k2] == null) {
        handler == null ? void 0 : handler.forEach((v2) => {
          const [n, fn] = v2;
          if (n === name) {
            el.removeEventListener(name, fn);
            handler.delete(v2);
          }
        });
      } else if (!handler || !((_a2 = [...handler]) == null ? void 0 : _a2.some((v2) => v2[0] === name && v2[1] === props2[k2]))) {
        el.addEventListener(name, props2[k2]);
        const _handler = handler || /* @__PURE__ */ new Set();
        _handler.add([name, props2[k2]]);
        if (!handlers.has(el))
          handlers.set(el, _handler);
      }
    } else {
      if (props2[k2] == null) {
        el.removeAttribute(k2);
      } else {
        el.setAttribute(k2, props2[k2]);
      }
    }
  });
}
function unbindProps(el, props2) {
  Object.keys(props2).forEach((k2) => {
    if (isOn(k2)) {
      const name = eventName(k2);
      const handler = handlers.get(el);
      handler == null ? void 0 : handler.forEach((v2) => {
        const [n, fn] = v2;
        if (n === name) {
          el.removeEventListener(name, fn);
          handler.delete(v2);
        }
      });
    } else {
      el.removeAttribute(k2);
    }
  });
}
const mainTRC = 2.4;
const Rco = 0.2126729;
const Gco = 0.7151522;
const Bco = 0.072175;
const normBG = 0.55;
const normTXT = 0.58;
const revTXT = 0.57;
const revBG = 0.62;
const blkThrs = 0.03;
const blkClmp = 1.45;
const deltaYmin = 5e-4;
const scaleBoW = 1.25;
const scaleWoB = 1.25;
const loConThresh = 0.078;
const loConFactor = 12.82051282051282;
const loConOffset = 0.06;
const loClip = 1e-3;
function APCAcontrast(text, background) {
  const Rtxt = (text.r / 255) ** mainTRC;
  const Gtxt = (text.g / 255) ** mainTRC;
  const Btxt = (text.b / 255) ** mainTRC;
  const Rbg = (background.r / 255) ** mainTRC;
  const Gbg = (background.g / 255) ** mainTRC;
  const Bbg = (background.b / 255) ** mainTRC;
  let Ytxt = Rtxt * Rco + Gtxt * Gco + Btxt * Bco;
  let Ybg = Rbg * Rco + Gbg * Gco + Bbg * Bco;
  if (Ytxt <= blkThrs)
    Ytxt += (blkThrs - Ytxt) ** blkClmp;
  if (Ybg <= blkThrs)
    Ybg += (blkThrs - Ybg) ** blkClmp;
  if (Math.abs(Ybg - Ytxt) < deltaYmin)
    return 0;
  let outputContrast;
  if (Ybg > Ytxt) {
    const SAPC = (Ybg ** normBG - Ytxt ** normTXT) * scaleBoW;
    outputContrast = SAPC < loClip ? 0 : SAPC < loConThresh ? SAPC - SAPC * loConFactor * loConOffset : SAPC - loConOffset;
  } else {
    const SAPC = (Ybg ** revBG - Ytxt ** revTXT) * scaleWoB;
    outputContrast = SAPC > -loClip ? 0 : SAPC > -loConThresh ? SAPC - SAPC * loConFactor * loConOffset : SAPC + loConOffset;
  }
  return outputContrast * 100;
}
function consoleWarn(message) {
}
function deprecate(original, replacement) {
  replacement = Array.isArray(replacement) ? replacement.slice(0, -1).map((s) => `'${s}'`).join(", ") + ` or '${replacement.at(-1)}'` : `'${replacement}'`;
}
const delta = 0.20689655172413793;
const cielabForwardTransform = (t) => t > delta ** 3 ? Math.cbrt(t) : t / (3 * delta ** 2) + 4 / 29;
const cielabReverseTransform = (t) => t > delta ? t ** 3 : 3 * delta ** 2 * (t - 4 / 29);
function fromXYZ$1(xyz) {
  const transform2 = cielabForwardTransform;
  const transformedY = transform2(xyz[1]);
  return [116 * transformedY - 16, 500 * (transform2(xyz[0] / 0.95047) - transformedY), 200 * (transformedY - transform2(xyz[2] / 1.08883))];
}
function toXYZ$1(lab) {
  const transform2 = cielabReverseTransform;
  const Ln = (lab[0] + 16) / 116;
  return [transform2(Ln + lab[1] / 500) * 0.95047, transform2(Ln), transform2(Ln - lab[2] / 200) * 1.08883];
}
const srgbForwardMatrix = [[3.2406, -1.5372, -0.4986], [-0.9689, 1.8758, 0.0415], [0.0557, -0.204, 1.057]];
const srgbForwardTransform = (C2) => C2 <= 31308e-7 ? C2 * 12.92 : 1.055 * C2 ** (1 / 2.4) - 0.055;
const srgbReverseMatrix = [[0.4124, 0.3576, 0.1805], [0.2126, 0.7152, 0.0722], [0.0193, 0.1192, 0.9505]];
const srgbReverseTransform = (C2) => C2 <= 0.04045 ? C2 / 12.92 : ((C2 + 0.055) / 1.055) ** 2.4;
function fromXYZ(xyz) {
  const rgb2 = Array(3);
  const transform2 = srgbForwardTransform;
  const matrix2 = srgbForwardMatrix;
  for (let i = 0; i < 3; ++i) {
    rgb2[i] = Math.round(clamp(transform2(matrix2[i][0] * xyz[0] + matrix2[i][1] * xyz[1] + matrix2[i][2] * xyz[2])) * 255);
  }
  return {
    r: rgb2[0],
    g: rgb2[1],
    b: rgb2[2]
  };
}
function toXYZ(_ref) {
  let {
    r,
    g: g2,
    b: b2
  } = _ref;
  const xyz = [0, 0, 0];
  const transform2 = srgbReverseTransform;
  const matrix2 = srgbReverseMatrix;
  r = transform2(r / 255);
  g2 = transform2(g2 / 255);
  b2 = transform2(b2 / 255);
  for (let i = 0; i < 3; ++i) {
    xyz[i] = matrix2[i][0] * r + matrix2[i][1] * g2 + matrix2[i][2] * b2;
  }
  return xyz;
}
function isCssColor(color) {
  return !!color && /^(#|var\(--|(rgb|hsl)a?\()/.test(color);
}
const cssColorRe = /^(?<fn>(?:rgb|hsl)a?)\((?<values>.+)\)/;
const mappers = {
  rgb: (r, g2, b2, a) => ({
    r,
    g: g2,
    b: b2,
    a
  }),
  rgba: (r, g2, b2, a) => ({
    r,
    g: g2,
    b: b2,
    a
  }),
  hsl: (h2, s, l, a) => HSLtoRGB({
    h: h2,
    s,
    l,
    a
  }),
  hsla: (h2, s, l, a) => HSLtoRGB({
    h: h2,
    s,
    l,
    a
  }),
  hsv: (h2, s, v2, a) => HSVtoRGB({
    h: h2,
    s,
    v: v2,
    a
  }),
  hsva: (h2, s, v2, a) => HSVtoRGB({
    h: h2,
    s,
    v: v2,
    a
  })
};
function parseColor(color) {
  if (typeof color === "number") {
    return {
      r: (color & 16711680) >> 16,
      g: (color & 65280) >> 8,
      b: color & 255
    };
  } else if (typeof color === "string" && cssColorRe.test(color)) {
    const {
      groups
    } = color.match(cssColorRe);
    const {
      fn,
      values
    } = groups;
    const realValues = values.split(/,\s*/).map((v2) => {
      if (v2.endsWith("%") && ["hsl", "hsla", "hsv", "hsva"].includes(fn)) {
        return parseFloat(v2) / 100;
      } else {
        return parseFloat(v2);
      }
    });
    return mappers[fn](...realValues);
  } else if (typeof color === "string") {
    let hex2 = color.startsWith("#") ? color.slice(1) : color;
    if ([3, 4].includes(hex2.length)) {
      hex2 = hex2.split("").map((char) => char + char).join("");
    } else if (![6, 8].includes(hex2.length))
      ;
    return HexToRGB(hex2);
  } else if (typeof color === "object") {
    if (has$4(color, ["r", "g", "b"])) {
      return color;
    } else if (has$4(color, ["h", "s", "l"])) {
      return HSVtoRGB(HSLtoHSV(color));
    } else if (has$4(color, ["h", "s", "v"])) {
      return HSVtoRGB(color);
    }
  }
  throw new TypeError(`Invalid color: ${color == null ? color : String(color) || color.constructor.name}
Expected #hex, #hexa, rgb(), rgba(), hsl(), hsla(), object or number`);
}
function HSVtoRGB(hsva) {
  const {
    h: h2,
    s,
    v: v2,
    a
  } = hsva;
  const f2 = (n) => {
    const k2 = (n + h2 / 60) % 6;
    return v2 - v2 * s * Math.max(Math.min(k2, 4 - k2, 1), 0);
  };
  const rgb2 = [f2(5), f2(3), f2(1)].map((v3) => Math.round(v3 * 255));
  return {
    r: rgb2[0],
    g: rgb2[1],
    b: rgb2[2],
    a
  };
}
function HSLtoRGB(hsla2) {
  return HSVtoRGB(HSLtoHSV(hsla2));
}
function RGBtoHSV(rgba2) {
  if (!rgba2)
    return {
      h: 0,
      s: 1,
      v: 1,
      a: 1
    };
  const r = rgba2.r / 255;
  const g2 = rgba2.g / 255;
  const b2 = rgba2.b / 255;
  const max2 = Math.max(r, g2, b2);
  const min = Math.min(r, g2, b2);
  let h2 = 0;
  if (max2 !== min) {
    if (max2 === r) {
      h2 = 60 * (0 + (g2 - b2) / (max2 - min));
    } else if (max2 === g2) {
      h2 = 60 * (2 + (b2 - r) / (max2 - min));
    } else if (max2 === b2) {
      h2 = 60 * (4 + (r - g2) / (max2 - min));
    }
  }
  if (h2 < 0)
    h2 = h2 + 360;
  const s = max2 === 0 ? 0 : (max2 - min) / max2;
  const hsv = [h2, s, max2];
  return {
    h: hsv[0],
    s: hsv[1],
    v: hsv[2],
    a: rgba2.a
  };
}
function HSVtoHSL(hsva) {
  const {
    h: h2,
    s,
    v: v2,
    a
  } = hsva;
  const l = v2 - v2 * s / 2;
  const sprime = l === 1 || l === 0 ? 0 : (v2 - l) / Math.min(l, 1 - l);
  return {
    h: h2,
    s: sprime,
    l,
    a
  };
}
function HSLtoHSV(hsl2) {
  const {
    h: h2,
    s,
    l,
    a
  } = hsl2;
  const v2 = l + s * Math.min(l, 1 - l);
  const sprime = v2 === 0 ? 0 : 2 - 2 * l / v2;
  return {
    h: h2,
    s: sprime,
    v: v2,
    a
  };
}
function RGBtoCSS(_ref) {
  let {
    r,
    g: g2,
    b: b2,
    a
  } = _ref;
  return a === void 0 ? `rgb(${r}, ${g2}, ${b2})` : `rgba(${r}, ${g2}, ${b2}, ${a})`;
}
function HSVtoCSS(hsva) {
  return RGBtoCSS(HSVtoRGB(hsva));
}
function toHex(v2) {
  const h2 = Math.round(v2).toString(16);
  return ("00".substr(0, 2 - h2.length) + h2).toUpperCase();
}
function RGBtoHex(_ref2) {
  let {
    r,
    g: g2,
    b: b2,
    a
  } = _ref2;
  return `#${[toHex(r), toHex(g2), toHex(b2), a !== void 0 ? toHex(Math.round(a * 255)) : ""].join("")}`;
}
function HexToRGB(hex2) {
  hex2 = parseHex(hex2);
  let [r, g2, b2, a] = chunk(hex2, 2).map((c2) => parseInt(c2, 16));
  a = a === void 0 ? a : a / 255;
  return {
    r,
    g: g2,
    b: b2,
    a
  };
}
function HexToHSV(hex2) {
  const rgb2 = HexToRGB(hex2);
  return RGBtoHSV(rgb2);
}
function HSVtoHex(hsva) {
  return RGBtoHex(HSVtoRGB(hsva));
}
function parseHex(hex2) {
  if (hex2.startsWith("#")) {
    hex2 = hex2.slice(1);
  }
  hex2 = hex2.replace(/([^0-9a-f])/gi, "F");
  if (hex2.length === 3 || hex2.length === 4) {
    hex2 = hex2.split("").map((x2) => x2 + x2).join("");
  }
  if (hex2.length !== 6) {
    hex2 = padEnd(padEnd(hex2, 6), 8, "F");
  }
  return hex2;
}
function lighten(value, amount) {
  const lab = fromXYZ$1(toXYZ(value));
  lab[0] = lab[0] + amount * 10;
  return fromXYZ(toXYZ$1(lab));
}
function darken(value, amount) {
  const lab = fromXYZ$1(toXYZ(value));
  lab[0] = lab[0] - amount * 10;
  return fromXYZ(toXYZ$1(lab));
}
function getLuma(color) {
  const rgb2 = parseColor(color);
  return toXYZ(rgb2)[1];
}
function getContrast(first, second) {
  const l1 = getLuma(first);
  const l2 = getLuma(second);
  const light = Math.max(l1, l2);
  const dark = Math.min(l1, l2);
  return (light + 0.05) / (dark + 0.05);
}
function getForeground(color) {
  const blackContrast = Math.abs(APCAcontrast(parseColor(0), parseColor(color)));
  const whiteContrast = Math.abs(APCAcontrast(parseColor(16777215), parseColor(color)));
  return whiteContrast > Math.min(blackContrast, 50) ? "#fff" : "#000";
}
function propsFactory(props2, source2) {
  return (defaults2) => {
    return Object.keys(props2).reduce((obj, prop) => {
      const isObjectDefinition = typeof props2[prop] === "object" && props2[prop] != null && !Array.isArray(props2[prop]);
      const definition = isObjectDefinition ? props2[prop] : {
        type: props2[prop]
      };
      if (defaults2 && prop in defaults2) {
        obj[prop] = {
          ...definition,
          default: defaults2[prop]
        };
      } else {
        obj[prop] = definition;
      }
      if (source2 && !obj[prop].source) {
        obj[prop].source = source2;
      }
      return obj;
    }, {});
  };
}
const makeComponentProps = propsFactory({
  class: [String, Array],
  style: {
    type: [String, Array, Object],
    default: null
  }
}, "component");
function defineComponent(options) {
  options._setup = options._setup ?? options.setup;
  if (!options.name) {
    return options;
  }
  if (options._setup) {
    options.props = propsFactory(options.props ?? {}, options.name)();
    const propKeys = Object.keys(options.props);
    options.filterProps = function filterProps(props2) {
      return pick(props2, propKeys, ["class", "style"]);
    };
    options.props._as = String;
    options.setup = function setup(props2, ctx) {
      const defaults2 = injectDefaults();
      if (!defaults2.value)
        return options._setup(props2, ctx);
      const {
        props: _props,
        provideSubDefaults
      } = internalUseDefaults(props2, props2._as ?? options.name, defaults2);
      const setupBindings = options._setup(_props, ctx);
      provideSubDefaults();
      return setupBindings;
    };
  }
  return options;
}
function genericComponent() {
  let exposeDefaults = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
  return (options) => (exposeDefaults ? defineComponent : defineComponent$1)(options);
}
function createSimpleFunctional(klass) {
  let tag = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "div";
  let name = arguments.length > 2 ? arguments[2] : void 0;
  return genericComponent()({
    name: name ?? capitalize(camelize(klass.replace(/__/g, "-"))),
    props: {
      tag: {
        type: String,
        default: tag
      },
      ...makeComponentProps()
    },
    setup(props2, _ref) {
      let {
        slots
      } = _ref;
      return () => {
        var _a2;
        return h(props2.tag, {
          class: [klass, props2.class],
          style: props2.style
        }, (_a2 = slots.default) == null ? void 0 : _a2.call(slots));
      };
    }
  });
}
function attachedRoot(node) {
  if (typeof node.getRootNode !== "function") {
    while (node.parentNode)
      node = node.parentNode;
    if (node !== document)
      return null;
    return document;
  }
  const root2 = node.getRootNode();
  if (root2 !== document && root2.getRootNode({
    composed: true
  }) !== document)
    return null;
  return root2;
}
const standardEasing = "cubic-bezier(0.4, 0, 0.2, 1)";
const deceleratedEasing = "cubic-bezier(0.0, 0, 0.2, 1)";
const acceleratedEasing = "cubic-bezier(0.4, 0, 1, 1)";
function getCurrentInstance(name, message) {
  const vm = getCurrentInstance$1();
  if (!vm) {
    throw new Error(`[Vuetify] ${name} ${message || "must be called from inside a setup function"}`);
  }
  return vm;
}
function getCurrentInstanceName() {
  let name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "composables";
  const vm = getCurrentInstance(name).type;
  return toKebabCase((vm == null ? void 0 : vm.aliasName) || (vm == null ? void 0 : vm.name));
}
let _uid = 0;
let _map = /* @__PURE__ */ new WeakMap();
function getUid() {
  const vm = getCurrentInstance("getUid");
  if (_map.has(vm))
    return _map.get(vm);
  else {
    const uid2 = _uid++;
    _map.set(vm, uid2);
    return uid2;
  }
}
getUid.reset = () => {
  _uid = 0;
  _map = /* @__PURE__ */ new WeakMap();
};
function getScrollParent(el) {
  let includeHidden = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  while (el) {
    if (includeHidden ? isPotentiallyScrollable(el) : hasScrollbar(el))
      return el;
    el = el.parentElement;
  }
  return document.scrollingElement;
}
function getScrollParents(el, stopAt) {
  const elements = [];
  if (stopAt && el && !stopAt.contains(el))
    return elements;
  while (el) {
    if (hasScrollbar(el))
      elements.push(el);
    if (el === stopAt)
      break;
    el = el.parentElement;
  }
  return elements;
}
function hasScrollbar(el) {
  if (!el || el.nodeType !== Node.ELEMENT_NODE)
    return false;
  const style3 = window.getComputedStyle(el);
  return style3.overflowY === "scroll" || style3.overflowY === "auto" && el.scrollHeight > el.clientHeight;
}
function isPotentiallyScrollable(el) {
  if (!el || el.nodeType !== Node.ELEMENT_NODE)
    return false;
  const style3 = window.getComputedStyle(el);
  return ["scroll", "auto"].includes(style3.overflowY);
}
function injectSelf(key2) {
  let vm = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstance("injectSelf");
  const {
    provides
  } = vm;
  if (provides && key2 in provides) {
    return provides[key2];
  }
  return void 0;
}
function isFixedPosition(el) {
  while (el) {
    if (window.getComputedStyle(el).position === "fixed") {
      return true;
    }
    el = el.offsetParent;
  }
  return false;
}
function useRender(render2) {
  const vm = getCurrentInstance("useRender");
  vm.render = render2;
}
const DefaultsSymbol = Symbol.for("vuetify:defaults");
function createDefaults(options) {
  return ref(options);
}
function injectDefaults() {
  const defaults2 = inject$1(DefaultsSymbol);
  if (!defaults2)
    throw new Error("[Vuetify] Could not find defaults instance");
  return defaults2;
}
function provideDefaults(defaults2, options) {
  const injectedDefaults = injectDefaults();
  const providedDefaults = ref(defaults2);
  const newDefaults = computed(() => {
    const disabled = unref(options == null ? void 0 : options.disabled);
    if (disabled)
      return injectedDefaults.value;
    const scoped = unref(options == null ? void 0 : options.scoped);
    const reset = unref(options == null ? void 0 : options.reset);
    const root2 = unref(options == null ? void 0 : options.root);
    if (providedDefaults.value == null && !(scoped || reset || root2))
      return injectedDefaults.value;
    let properties = mergeDeep(providedDefaults.value, {
      prev: injectedDefaults.value
    });
    if (scoped)
      return properties;
    if (reset || root2) {
      const len = Number(reset || Infinity);
      for (let i = 0; i <= len; i++) {
        if (!properties || !("prev" in properties)) {
          break;
        }
        properties = properties.prev;
      }
      if (properties && typeof root2 === "string" && root2 in properties) {
        properties = mergeDeep(mergeDeep(properties, {
          prev: properties
        }), properties[root2]);
      }
      return properties;
    }
    return properties.prev ? mergeDeep(properties.prev, properties) : properties;
  });
  provide(DefaultsSymbol, newDefaults);
  return newDefaults;
}
function propIsDefined(vnode, prop) {
  var _a2, _b;
  return typeof ((_a2 = vnode.props) == null ? void 0 : _a2[prop]) !== "undefined" || typeof ((_b = vnode.props) == null ? void 0 : _b[toKebabCase(prop)]) !== "undefined";
}
function internalUseDefaults() {
  let props2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  let name = arguments.length > 1 ? arguments[1] : void 0;
  let defaults2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : injectDefaults();
  const vm = getCurrentInstance("useDefaults");
  name = name ?? vm.type.name ?? vm.type.__name;
  if (!name) {
    throw new Error("[Vuetify] Could not determine component name");
  }
  const componentDefaults = computed(() => {
    var _a2;
    return (_a2 = defaults2.value) == null ? void 0 : _a2[props2._as ?? name];
  });
  const _props = new Proxy(props2, {
    get(target, prop) {
      var _a2, _b, _c, _d;
      const propValue = Reflect.get(target, prop);
      if (prop === "class" || prop === "style") {
        return [(_a2 = componentDefaults.value) == null ? void 0 : _a2[prop], propValue].filter((v2) => v2 != null);
      } else if (typeof prop === "string" && !propIsDefined(vm.vnode, prop)) {
        return ((_b = componentDefaults.value) == null ? void 0 : _b[prop]) ?? ((_d = (_c = defaults2.value) == null ? void 0 : _c.global) == null ? void 0 : _d[prop]) ?? propValue;
      }
      return propValue;
    }
  });
  const _subcomponentDefaults = shallowRef();
  watchEffect(() => {
    if (componentDefaults.value) {
      const subComponents = Object.entries(componentDefaults.value).filter((_ref) => {
        let [key2] = _ref;
        return key2.startsWith(key2[0].toUpperCase());
      });
      _subcomponentDefaults.value = subComponents.length ? Object.fromEntries(subComponents) : void 0;
    } else {
      _subcomponentDefaults.value = void 0;
    }
  });
  function provideSubDefaults() {
    const injected = injectSelf(DefaultsSymbol, vm);
    provide(DefaultsSymbol, computed(() => {
      return _subcomponentDefaults.value ? mergeDeep((injected == null ? void 0 : injected.value) ?? {}, _subcomponentDefaults.value) : injected == null ? void 0 : injected.value;
    }));
  }
  return {
    props: _props,
    provideSubDefaults
  };
}
const breakpoints = ["sm", "md", "lg", "xl", "xxl"];
const DisplaySymbol = Symbol.for("vuetify:display");
const defaultDisplayOptions = {
  mobileBreakpoint: "lg",
  thresholds: {
    xs: 0,
    sm: 600,
    md: 960,
    lg: 1280,
    xl: 1920,
    xxl: 2560
  }
};
const parseDisplayOptions = function() {
  let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultDisplayOptions;
  return mergeDeep(defaultDisplayOptions, options);
};
function getClientWidth(ssr) {
  return IN_BROWSER && !ssr ? window.innerWidth : typeof ssr === "object" && ssr.clientWidth || 0;
}
function getClientHeight(ssr) {
  return IN_BROWSER && !ssr ? window.innerHeight : typeof ssr === "object" && ssr.clientHeight || 0;
}
function getPlatform(ssr) {
  const userAgent2 = IN_BROWSER && !ssr ? window.navigator.userAgent : "ssr";
  function match2(regexp) {
    return Boolean(userAgent2.match(regexp));
  }
  const android = match2(/android/i);
  const ios = match2(/iphone|ipad|ipod/i);
  const cordova = match2(/cordova/i);
  const electron = match2(/electron/i);
  const chrome = match2(/chrome/i);
  const edge = match2(/edge/i);
  const firefox = match2(/firefox/i);
  const opera = match2(/opera/i);
  const win = match2(/win/i);
  const mac = match2(/mac/i);
  const linux = match2(/linux/i);
  return {
    android,
    ios,
    cordova,
    electron,
    chrome,
    edge,
    firefox,
    opera,
    win,
    mac,
    linux,
    touch: SUPPORTS_TOUCH,
    ssr: userAgent2 === "ssr"
  };
}
function createDisplay(options, ssr) {
  const {
    thresholds,
    mobileBreakpoint
  } = parseDisplayOptions(options);
  const height = shallowRef(getClientHeight(ssr));
  const platform2 = shallowRef(getPlatform(ssr));
  const state = reactive({});
  const width = shallowRef(getClientWidth(ssr));
  function updateSize() {
    height.value = getClientHeight();
    width.value = getClientWidth();
  }
  function update() {
    updateSize();
    platform2.value = getPlatform();
  }
  watchEffect(() => {
    const xs = width.value < thresholds.sm;
    const sm = width.value < thresholds.md && !xs;
    const md = width.value < thresholds.lg && !(sm || xs);
    const lg = width.value < thresholds.xl && !(md || sm || xs);
    const xl = width.value < thresholds.xxl && !(lg || md || sm || xs);
    const xxl = width.value >= thresholds.xxl;
    const name = xs ? "xs" : sm ? "sm" : md ? "md" : lg ? "lg" : xl ? "xl" : "xxl";
    const breakpointValue = typeof mobileBreakpoint === "number" ? mobileBreakpoint : thresholds[mobileBreakpoint];
    const mobile = width.value < breakpointValue;
    state.xs = xs;
    state.sm = sm;
    state.md = md;
    state.lg = lg;
    state.xl = xl;
    state.xxl = xxl;
    state.smAndUp = !xs;
    state.mdAndUp = !(xs || sm);
    state.lgAndUp = !(xs || sm || md);
    state.xlAndUp = !(xs || sm || md || lg);
    state.smAndDown = !(md || lg || xl || xxl);
    state.mdAndDown = !(lg || xl || xxl);
    state.lgAndDown = !(xl || xxl);
    state.xlAndDown = !xxl;
    state.name = name;
    state.height = height.value;
    state.width = width.value;
    state.mobile = mobile;
    state.mobileBreakpoint = mobileBreakpoint;
    state.platform = platform2.value;
    state.thresholds = thresholds;
  });
  if (IN_BROWSER) {
    window.addEventListener("resize", updateSize, {
      passive: true
    });
  }
  return {
    ...toRefs(state),
    update,
    ssr: !!ssr
  };
}
function useDisplay() {
  const display = inject$1(DisplaySymbol);
  if (!display)
    throw new Error("Could not find Vuetify display injection");
  return display;
}
const aliases = {
  collapse: "mdi-chevron-up",
  complete: "mdi-check",
  cancel: "mdi-close-circle",
  close: "mdi-close",
  delete: "mdi-close-circle",
  // delete (e.g. v-chip close)
  clear: "mdi-close-circle",
  success: "mdi-check-circle",
  info: "mdi-information",
  warning: "mdi-alert-circle",
  error: "mdi-close-circle",
  prev: "mdi-chevron-left",
  next: "mdi-chevron-right",
  checkboxOn: "mdi-checkbox-marked",
  checkboxOff: "mdi-checkbox-blank-outline",
  checkboxIndeterminate: "mdi-minus-box",
  delimiter: "mdi-circle",
  // for carousel
  sortAsc: "mdi-arrow-up",
  sortDesc: "mdi-arrow-down",
  expand: "mdi-chevron-down",
  menu: "mdi-menu",
  subgroup: "mdi-menu-down",
  dropdown: "mdi-menu-down",
  radioOn: "mdi-radiobox-marked",
  radioOff: "mdi-radiobox-blank",
  edit: "mdi-pencil",
  ratingEmpty: "mdi-star-outline",
  ratingFull: "mdi-star",
  ratingHalf: "mdi-star-half-full",
  loading: "mdi-cached",
  first: "mdi-page-first",
  last: "mdi-page-last",
  unfold: "mdi-unfold-more-horizontal",
  file: "mdi-paperclip",
  plus: "mdi-plus",
  minus: "mdi-minus",
  calendar: "mdi-calendar"
};
const mdi = {
  // Not using mergeProps here, functional components merge props by default (?)
  component: (props2) => h(VClassIcon, {
    ...props2,
    class: "mdi"
  })
};
const IconValue = [String, Function, Object, Array];
const IconSymbol = Symbol.for("vuetify:icons");
const makeIconProps = propsFactory({
  icon: {
    type: IconValue
  },
  // Could not remove this and use makeTagProps, types complained because it is not required
  tag: {
    type: String,
    required: true
  }
}, "icon");
const VComponentIcon = genericComponent()({
  name: "VComponentIcon",
  props: makeIconProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    return () => {
      const Icon = props2.icon;
      return createVNode(props2.tag, null, {
        default: () => {
          var _a2;
          return [props2.icon ? createVNode(Icon, null, null) : (_a2 = slots.default) == null ? void 0 : _a2.call(slots)];
        }
      });
    };
  }
});
const VSvgIcon = defineComponent({
  name: "VSvgIcon",
  inheritAttrs: false,
  props: makeIconProps(),
  setup(props2, _ref2) {
    let {
      attrs
    } = _ref2;
    return () => {
      return createVNode(props2.tag, mergeProps(attrs, {
        "style": null
      }), {
        default: () => [createVNode("svg", {
          "class": "v-icon__svg",
          "xmlns": "http://www.w3.org/2000/svg",
          "viewBox": "0 0 24 24",
          "role": "img",
          "aria-hidden": "true"
        }, [Array.isArray(props2.icon) ? props2.icon.map((path) => Array.isArray(path) ? createVNode("path", {
          "d": path[0],
          "fill-opacity": path[1]
        }, null) : createVNode("path", {
          "d": path
        }, null)) : createVNode("path", {
          "d": props2.icon
        }, null)])]
      });
    };
  }
});
const VLigatureIcon = defineComponent({
  name: "VLigatureIcon",
  props: makeIconProps(),
  setup(props2) {
    return () => {
      return createVNode(props2.tag, null, {
        default: () => [props2.icon]
      });
    };
  }
});
const VClassIcon = defineComponent({
  name: "VClassIcon",
  props: makeIconProps(),
  setup(props2) {
    return () => {
      return createVNode(props2.tag, {
        "class": props2.icon
      }, null);
    };
  }
});
const defaultSets = {
  svg: {
    component: VSvgIcon
  },
  class: {
    component: VClassIcon
  }
};
function createIcons(options) {
  return mergeDeep({
    defaultSet: "mdi",
    sets: {
      ...defaultSets,
      mdi
    },
    aliases: {
      ...aliases,
      /* eslint-disable max-len */
      vuetify: ["M8.2241 14.2009L12 21L22 3H14.4459L8.2241 14.2009Z", ["M7.26303 12.4733L7.00113 12L2 3H12.5261C12.5261 3 12.5261 3 12.5261 3L7.26303 12.4733Z", 0.6]],
      "vuetify-outline": "svg:M7.26 12.47 12.53 3H2L7.26 12.47ZM14.45 3 8.22 14.2 12 21 22 3H14.45ZM18.6 5 12 16.88 10.51 14.2 15.62 5ZM7.26 8.35 5.4 5H9.13L7.26 8.35Z"
      /* eslint-enable max-len */
    }
  }, options);
}
const useIcon = (props2) => {
  const icons = inject$1(IconSymbol);
  if (!icons)
    throw new Error("Missing Vuetify Icons provide!");
  const iconData = computed(() => {
    var _a2;
    const iconAlias = unref(props2);
    if (!iconAlias)
      return {
        component: VComponentIcon
      };
    let icon = iconAlias;
    if (typeof icon === "string") {
      icon = icon.trim();
      if (icon.startsWith("$")) {
        icon = (_a2 = icons.aliases) == null ? void 0 : _a2[icon.slice(1)];
      }
    }
    if (!icon)
      throw new Error(`Could not find aliased icon "${iconAlias}"`);
    if (Array.isArray(icon)) {
      return {
        component: VSvgIcon,
        icon
      };
    } else if (typeof icon !== "string") {
      return {
        component: VComponentIcon,
        icon
      };
    }
    const iconSetName = Object.keys(icons.sets).find((setName) => typeof icon === "string" && icon.startsWith(`${setName}:`));
    const iconName = iconSetName ? icon.slice(iconSetName.length + 1) : icon;
    const iconSet = icons.sets[iconSetName ?? icons.defaultSet];
    return {
      component: iconSet.component,
      icon: iconName
    };
  });
  return {
    iconData
  };
};
const en = {
  badge: "Badge",
  open: "Open",
  close: "Close",
  dataIterator: {
    noResultsText: "No matching records found",
    loadingText: "Loading items..."
  },
  dataTable: {
    itemsPerPageText: "Rows per page:",
    ariaLabel: {
      sortDescending: "Sorted descending.",
      sortAscending: "Sorted ascending.",
      sortNone: "Not sorted.",
      activateNone: "Activate to remove sorting.",
      activateDescending: "Activate to sort descending.",
      activateAscending: "Activate to sort ascending."
    },
    sortBy: "Sort by"
  },
  dataFooter: {
    itemsPerPageText: "Items per page:",
    itemsPerPageAll: "All",
    nextPage: "Next page",
    prevPage: "Previous page",
    firstPage: "First page",
    lastPage: "Last page",
    pageText: "{0}-{1} of {2}"
  },
  dateRangeInput: {
    divider: "to"
  },
  datePicker: {
    ok: "OK",
    cancel: "Cancel",
    range: {
      title: "Select dates",
      header: "Enter dates"
    },
    title: "Select date",
    header: "Enter date",
    input: {
      placeholder: "Enter date"
    }
  },
  noDataText: "No data available",
  carousel: {
    prev: "Previous visual",
    next: "Next visual",
    ariaLabel: {
      delimiter: "Carousel slide {0} of {1}"
    }
  },
  calendar: {
    moreEvents: "{0} more"
  },
  input: {
    clear: "Clear {0}",
    prependAction: "{0} prepended action",
    appendAction: "{0} appended action",
    otp: "Please enter OTP character {0}"
  },
  fileInput: {
    counter: "{0} files",
    counterSize: "{0} files ({1} in total)"
  },
  timePicker: {
    am: "AM",
    pm: "PM"
  },
  pagination: {
    ariaLabel: {
      root: "Pagination Navigation",
      next: "Next page",
      previous: "Previous page",
      page: "Go to page {0}",
      currentPage: "Page {0}, Current page",
      first: "First page",
      last: "Last page"
    }
  },
  stepper: {
    next: "Next",
    prev: "Previous"
  },
  rating: {
    ariaLabel: {
      item: "Rating {0} of {1}"
    }
  },
  loading: "Loading...",
  infiniteScroll: {
    loadMore: "Load more",
    empty: "No more"
  }
};
const defaultRtl = {
  af: false,
  ar: true,
  bg: false,
  ca: false,
  ckb: false,
  cs: false,
  de: false,
  el: false,
  en: false,
  es: false,
  et: false,
  fa: true,
  fi: false,
  fr: false,
  hr: false,
  hu: false,
  he: true,
  id: false,
  it: false,
  ja: false,
  ko: false,
  lv: false,
  lt: false,
  nl: false,
  no: false,
  pl: false,
  pt: false,
  ro: false,
  ru: false,
  sk: false,
  sl: false,
  srCyrl: false,
  srLatn: false,
  sv: false,
  th: false,
  tr: false,
  az: false,
  uk: false,
  vi: false,
  zhHans: false,
  zhHant: false
};
function useToggleScope(source2, fn) {
  let scope;
  function start() {
    scope = effectScope();
    scope.run(() => fn.length ? fn(() => {
      scope == null ? void 0 : scope.stop();
      start();
    }) : fn());
  }
  watch(source2, (active) => {
    if (active && !scope) {
      start();
    } else if (!active) {
      scope == null ? void 0 : scope.stop();
      scope = void 0;
    }
  }, {
    immediate: true
  });
  onScopeDispose(() => {
    scope == null ? void 0 : scope.stop();
  });
}
function useProxiedModel(props2, prop, defaultValue) {
  let transformIn = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : (v2) => v2;
  let transformOut = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : (v2) => v2;
  const vm = getCurrentInstance("useProxiedModel");
  const internal = ref(props2[prop] !== void 0 ? props2[prop] : defaultValue);
  const kebabProp = toKebabCase(prop);
  const checkKebab = kebabProp !== prop;
  const isControlled = checkKebab ? computed(() => {
    var _a2, _b, _c, _d;
    void props2[prop];
    return !!((((_a2 = vm.vnode.props) == null ? void 0 : _a2.hasOwnProperty(prop)) || ((_b = vm.vnode.props) == null ? void 0 : _b.hasOwnProperty(kebabProp))) && (((_c = vm.vnode.props) == null ? void 0 : _c.hasOwnProperty(`onUpdate:${prop}`)) || ((_d = vm.vnode.props) == null ? void 0 : _d.hasOwnProperty(`onUpdate:${kebabProp}`))));
  }) : computed(() => {
    var _a2, _b;
    void props2[prop];
    return !!(((_a2 = vm.vnode.props) == null ? void 0 : _a2.hasOwnProperty(prop)) && ((_b = vm.vnode.props) == null ? void 0 : _b.hasOwnProperty(`onUpdate:${prop}`)));
  });
  useToggleScope(() => !isControlled.value, () => {
    watch(() => props2[prop], (val) => {
      internal.value = val;
    });
  });
  const model = computed({
    get() {
      const externalValue = props2[prop];
      return transformIn(isControlled.value ? externalValue : internal.value);
    },
    set(internalValue) {
      const newValue = transformOut(internalValue);
      const value = toRaw(isControlled.value ? props2[prop] : internal.value);
      if (value === newValue || transformIn(value) === internalValue) {
        return;
      }
      internal.value = newValue;
      vm == null ? void 0 : vm.emit(`update:${prop}`, newValue);
    }
  });
  Object.defineProperty(model, "externalValue", {
    get: () => isControlled.value ? props2[prop] : internal.value
  });
  return model;
}
const LANG_PREFIX = "$vuetify.";
const replace$1 = (str, params) => {
  return str.replace(/\{(\d+)\}/g, (match2, index2) => {
    return String(params[+index2]);
  });
};
const createTranslateFunction = (current, fallback, messages) => {
  return function(key2) {
    for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      params[_key - 1] = arguments[_key];
    }
    if (!key2.startsWith(LANG_PREFIX)) {
      return replace$1(key2, params);
    }
    const shortKey = key2.replace(LANG_PREFIX, "");
    const currentLocale = current.value && messages.value[current.value];
    const fallbackLocale = fallback.value && messages.value[fallback.value];
    let str = getObjectValueByPath(currentLocale, shortKey, null);
    if (!str) {
      consoleWarn(`Translation key "${key2}" not found in "${current.value}", trying fallback locale`);
      str = getObjectValueByPath(fallbackLocale, shortKey, null);
    }
    if (!str) {
      str = key2;
    }
    if (typeof str !== "string") {
      str = key2;
    }
    return replace$1(str, params);
  };
};
function createNumberFunction(current, fallback) {
  return (value, options) => {
    const numberFormat = new Intl.NumberFormat([current.value, fallback.value], options);
    return numberFormat.format(value);
  };
}
function useProvided(props2, prop, provided) {
  const internal = useProxiedModel(props2, prop, props2[prop] ?? provided.value);
  internal.value = props2[prop] ?? provided.value;
  watch(provided, (v2) => {
    if (props2[prop] == null) {
      internal.value = provided.value;
    }
  });
  return internal;
}
function createProvideFunction(state) {
  return (props2) => {
    const current = useProvided(props2, "locale", state.current);
    const fallback = useProvided(props2, "fallback", state.fallback);
    const messages = useProvided(props2, "messages", state.messages);
    return {
      name: "vuetify",
      current,
      fallback,
      messages,
      t: createTranslateFunction(current, fallback, messages),
      n: createNumberFunction(current, fallback),
      provide: createProvideFunction({
        current,
        fallback,
        messages
      })
    };
  };
}
function createVuetifyAdapter(options) {
  const current = shallowRef((options == null ? void 0 : options.locale) ?? "en");
  const fallback = shallowRef((options == null ? void 0 : options.fallback) ?? "en");
  const messages = ref({
    en,
    ...options == null ? void 0 : options.messages
  });
  return {
    name: "vuetify",
    current,
    fallback,
    messages,
    t: createTranslateFunction(current, fallback, messages),
    n: createNumberFunction(current, fallback),
    provide: createProvideFunction({
      current,
      fallback,
      messages
    })
  };
}
const LocaleSymbol = Symbol.for("vuetify:locale");
function isLocaleInstance(obj) {
  return obj.name != null;
}
function createLocale(options) {
  const i18n = (options == null ? void 0 : options.adapter) && isLocaleInstance(options == null ? void 0 : options.adapter) ? options == null ? void 0 : options.adapter : createVuetifyAdapter(options);
  const rtl = createRtl(i18n, options);
  return {
    ...i18n,
    ...rtl
  };
}
function useLocale() {
  const locale2 = inject$1(LocaleSymbol);
  if (!locale2)
    throw new Error("[Vuetify] Could not find injected locale instance");
  return locale2;
}
function provideLocale(props2) {
  const locale2 = inject$1(LocaleSymbol);
  if (!locale2)
    throw new Error("[Vuetify] Could not find injected locale instance");
  const i18n = locale2.provide(props2);
  const rtl = provideRtl(i18n, locale2.rtl, props2);
  const data = {
    ...i18n,
    ...rtl
  };
  provide(LocaleSymbol, data);
  return data;
}
function createRtl(i18n, options) {
  const rtl = ref((options == null ? void 0 : options.rtl) ?? defaultRtl);
  const isRtl = computed(() => rtl.value[i18n.current.value] ?? false);
  return {
    isRtl,
    rtl,
    rtlClasses: computed(() => `v-locale--is-${isRtl.value ? "rtl" : "ltr"}`)
  };
}
function provideRtl(locale2, rtl, props2) {
  const isRtl = computed(() => props2.rtl ?? rtl.value[locale2.current.value] ?? false);
  return {
    isRtl,
    rtl,
    rtlClasses: computed(() => `v-locale--is-${isRtl.value ? "rtl" : "ltr"}`)
  };
}
function useRtl() {
  const locale2 = inject$1(LocaleSymbol);
  if (!locale2)
    throw new Error("[Vuetify] Could not find injected rtl instance");
  return {
    isRtl: locale2.isRtl,
    rtlClasses: locale2.rtlClasses
  };
}
const ThemeSymbol = Symbol.for("vuetify:theme");
const makeThemeProps = propsFactory({
  theme: String
}, "theme");
const defaultThemeOptions = {
  defaultTheme: "light",
  variations: {
    colors: [],
    lighten: 0,
    darken: 0
  },
  themes: {
    light: {
      dark: false,
      colors: {
        background: "#FFFFFF",
        surface: "#FFFFFF",
        "surface-bright": "#FFFFFF",
        "surface-variant": "#424242",
        "on-surface-variant": "#EEEEEE",
        primary: "#6200EE",
        "primary-darken-1": "#3700B3",
        secondary: "#03DAC6",
        "secondary-darken-1": "#018786",
        error: "#B00020",
        info: "#2196F3",
        success: "#4CAF50",
        warning: "#FB8C00"
      },
      variables: {
        "border-color": "#000000",
        "border-opacity": 0.12,
        "high-emphasis-opacity": 0.87,
        "medium-emphasis-opacity": 0.6,
        "disabled-opacity": 0.38,
        "idle-opacity": 0.04,
        "hover-opacity": 0.04,
        "focus-opacity": 0.12,
        "selected-opacity": 0.08,
        "activated-opacity": 0.12,
        "pressed-opacity": 0.12,
        "dragged-opacity": 0.08,
        "theme-kbd": "#212529",
        "theme-on-kbd": "#FFFFFF",
        "theme-code": "#F5F5F5",
        "theme-on-code": "#000000"
      }
    },
    dark: {
      dark: true,
      colors: {
        background: "#121212",
        surface: "#212121",
        "surface-bright": "#ccbfd6",
        "surface-variant": "#a3a3a3",
        "on-surface-variant": "#424242",
        primary: "#BB86FC",
        "primary-darken-1": "#3700B3",
        secondary: "#03DAC5",
        "secondary-darken-1": "#03DAC5",
        error: "#CF6679",
        info: "#2196F3",
        success: "#4CAF50",
        warning: "#FB8C00"
      },
      variables: {
        "border-color": "#FFFFFF",
        "border-opacity": 0.12,
        "high-emphasis-opacity": 1,
        "medium-emphasis-opacity": 0.7,
        "disabled-opacity": 0.5,
        "idle-opacity": 0.1,
        "hover-opacity": 0.04,
        "focus-opacity": 0.12,
        "selected-opacity": 0.08,
        "activated-opacity": 0.12,
        "pressed-opacity": 0.16,
        "dragged-opacity": 0.08,
        "theme-kbd": "#212529",
        "theme-on-kbd": "#FFFFFF",
        "theme-code": "#343434",
        "theme-on-code": "#CCCCCC"
      }
    }
  }
};
function parseThemeOptions() {
  var _a2, _b;
  let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultThemeOptions;
  if (!options)
    return {
      ...defaultThemeOptions,
      isDisabled: true
    };
  const themes = {};
  for (const [key2, theme] of Object.entries(options.themes ?? {})) {
    const defaultTheme = theme.dark || key2 === "dark" ? (_a2 = defaultThemeOptions.themes) == null ? void 0 : _a2.dark : (_b = defaultThemeOptions.themes) == null ? void 0 : _b.light;
    themes[key2] = mergeDeep(defaultTheme, theme);
  }
  return mergeDeep(defaultThemeOptions, {
    ...options,
    themes
  });
}
function createTheme(options) {
  const parsedOptions = parseThemeOptions(options);
  const name = ref(parsedOptions.defaultTheme);
  const themes = ref(parsedOptions.themes);
  const computedThemes = computed(() => {
    const acc = {};
    for (const [name2, original] of Object.entries(themes.value)) {
      const theme = acc[name2] = {
        ...original,
        colors: {
          ...original.colors
        }
      };
      if (parsedOptions.variations) {
        for (const name3 of parsedOptions.variations.colors) {
          const color = theme.colors[name3];
          if (!color)
            continue;
          for (const variation of ["lighten", "darken"]) {
            const fn = variation === "lighten" ? lighten : darken;
            for (const amount of createRange(parsedOptions.variations[variation], 1)) {
              theme.colors[`${name3}-${variation}-${amount}`] = RGBtoHex(fn(parseColor(color), amount));
            }
          }
        }
      }
      for (const color of Object.keys(theme.colors)) {
        if (/^on-[a-z]/.test(color) || theme.colors[`on-${color}`])
          continue;
        const onColor = `on-${color}`;
        const colorVal = parseColor(theme.colors[color]);
        theme.colors[onColor] = getForeground(colorVal);
      }
    }
    return acc;
  });
  const current = computed(() => computedThemes.value[name.value]);
  const styles = computed(() => {
    const lines = [];
    if (current.value.dark) {
      createCssClass(lines, ":root", ["color-scheme: dark"]);
    }
    createCssClass(lines, ":root", genCssVariables(current.value));
    for (const [themeName, theme] of Object.entries(computedThemes.value)) {
      createCssClass(lines, `.v-theme--${themeName}`, [`color-scheme: ${theme.dark ? "dark" : "normal"}`, ...genCssVariables(theme)]);
    }
    const bgLines = [];
    const fgLines = [];
    const colors2 = new Set(Object.values(computedThemes.value).flatMap((theme) => Object.keys(theme.colors)));
    for (const key2 of colors2) {
      if (/^on-[a-z]/.test(key2)) {
        createCssClass(fgLines, `.${key2}`, [`color: rgb(var(--v-theme-${key2})) !important`]);
      } else {
        createCssClass(bgLines, `.bg-${key2}`, [`--v-theme-overlay-multiplier: var(--v-theme-${key2}-overlay-multiplier)`, `background-color: rgb(var(--v-theme-${key2})) !important`, `color: rgb(var(--v-theme-on-${key2})) !important`]);
        createCssClass(fgLines, `.text-${key2}`, [`color: rgb(var(--v-theme-${key2})) !important`]);
        createCssClass(fgLines, `.border-${key2}`, [`--v-border-color: var(--v-theme-${key2})`]);
      }
    }
    lines.push(...bgLines, ...fgLines);
    return lines.map((str, i) => i === 0 ? str : `    ${str}`).join("");
  });
  function getHead() {
    return {
      style: [{
        children: styles.value,
        id: "vuetify-theme-stylesheet",
        nonce: parsedOptions.cspNonce || false
      }]
    };
  }
  function install3(app) {
    if (parsedOptions.isDisabled)
      return;
    const head = app._context.provides.usehead;
    if (head) {
      if (head.push) {
        const entry = head.push(getHead);
        if (IN_BROWSER) {
          watch(styles, () => {
            entry.patch(getHead);
          });
        }
      } else {
        if (IN_BROWSER) {
          head.addHeadObjs(computed(getHead));
          watchEffect(() => head.updateDOM());
        } else {
          head.addHeadObjs(getHead());
        }
      }
    } else {
      let updateStyles = function() {
        if (typeof document !== "undefined" && !styleEl) {
          const el = document.createElement("style");
          el.type = "text/css";
          el.id = "vuetify-theme-stylesheet";
          if (parsedOptions.cspNonce)
            el.setAttribute("nonce", parsedOptions.cspNonce);
          styleEl = el;
          document.head.appendChild(styleEl);
        }
        if (styleEl)
          styleEl.innerHTML = styles.value;
      };
      let styleEl = IN_BROWSER ? document.getElementById("vuetify-theme-stylesheet") : null;
      if (IN_BROWSER) {
        watch(styles, updateStyles, {
          immediate: true
        });
      } else {
        updateStyles();
      }
    }
  }
  const themeClasses = computed(() => parsedOptions.isDisabled ? void 0 : `v-theme--${name.value}`);
  return {
    install: install3,
    isDisabled: parsedOptions.isDisabled,
    name,
    themes,
    current,
    computedThemes,
    themeClasses,
    styles,
    global: {
      name,
      current
    }
  };
}
function provideTheme(props2) {
  getCurrentInstance("provideTheme");
  const theme = inject$1(ThemeSymbol, null);
  if (!theme)
    throw new Error("Could not find Vuetify theme injection");
  const name = computed(() => {
    return props2.theme ?? theme.name.value;
  });
  const current = computed(() => theme.themes.value[name.value]);
  const themeClasses = computed(() => theme.isDisabled ? void 0 : `v-theme--${name.value}`);
  const newTheme = {
    ...theme,
    name,
    current,
    themeClasses
  };
  provide(ThemeSymbol, newTheme);
  return newTheme;
}
function useTheme() {
  getCurrentInstance("useTheme");
  const theme = inject$1(ThemeSymbol, null);
  if (!theme)
    throw new Error("Could not find Vuetify theme injection");
  return theme;
}
function createCssClass(lines, selector, content) {
  lines.push(`${selector} {
`, ...content.map((line2) => `  ${line2};
`), "}\n");
}
function genCssVariables(theme) {
  const lightOverlay = theme.dark ? 2 : 1;
  const darkOverlay = theme.dark ? 1 : 2;
  const variables = [];
  for (const [key2, value] of Object.entries(theme.colors)) {
    const rgb2 = parseColor(value);
    variables.push(`--v-theme-${key2}: ${rgb2.r},${rgb2.g},${rgb2.b}`);
    if (!key2.startsWith("on-")) {
      variables.push(`--v-theme-${key2}-overlay-multiplier: ${getLuma(value) > 0.18 ? lightOverlay : darkOverlay}`);
    }
  }
  for (const [key2, value] of Object.entries(theme.variables)) {
    const color = typeof value === "string" && value.startsWith("#") ? parseColor(value) : void 0;
    const rgb2 = color ? `${color.r}, ${color.g}, ${color.b}` : void 0;
    variables.push(`--v-${key2}: ${rgb2 ?? value}`);
  }
  return variables;
}
const firstDay = {
  "001": 1,
  AD: 1,
  AE: 6,
  AF: 6,
  AG: 0,
  AI: 1,
  AL: 1,
  AM: 1,
  AN: 1,
  AR: 1,
  AS: 0,
  AT: 1,
  AU: 1,
  AX: 1,
  AZ: 1,
  BA: 1,
  BD: 0,
  BE: 1,
  BG: 1,
  BH: 6,
  BM: 1,
  BN: 1,
  BR: 0,
  BS: 0,
  BT: 0,
  BW: 0,
  BY: 1,
  BZ: 0,
  CA: 0,
  CH: 1,
  CL: 1,
  CM: 1,
  CN: 1,
  CO: 0,
  CR: 1,
  CY: 1,
  CZ: 1,
  DE: 1,
  DJ: 6,
  DK: 1,
  DM: 0,
  DO: 0,
  DZ: 6,
  EC: 1,
  EE: 1,
  EG: 6,
  ES: 1,
  ET: 0,
  FI: 1,
  FJ: 1,
  FO: 1,
  FR: 1,
  GB: 1,
  "GB-alt-variant": 0,
  GE: 1,
  GF: 1,
  GP: 1,
  GR: 1,
  GT: 0,
  GU: 0,
  HK: 0,
  HN: 0,
  HR: 1,
  HU: 1,
  ID: 0,
  IE: 1,
  IL: 0,
  IN: 0,
  IQ: 6,
  IR: 6,
  IS: 1,
  IT: 1,
  JM: 0,
  JO: 6,
  JP: 0,
  KE: 0,
  KG: 1,
  KH: 0,
  KR: 0,
  KW: 6,
  KZ: 1,
  LA: 0,
  LB: 1,
  LI: 1,
  LK: 1,
  LT: 1,
  LU: 1,
  LV: 1,
  LY: 6,
  MC: 1,
  MD: 1,
  ME: 1,
  MH: 0,
  MK: 1,
  MM: 0,
  MN: 1,
  MO: 0,
  MQ: 1,
  MT: 0,
  MV: 5,
  MX: 0,
  MY: 1,
  MZ: 0,
  NI: 0,
  NL: 1,
  NO: 1,
  NP: 0,
  NZ: 1,
  OM: 6,
  PA: 0,
  PE: 0,
  PH: 0,
  PK: 0,
  PL: 1,
  PR: 0,
  PT: 0,
  PY: 0,
  QA: 6,
  RE: 1,
  RO: 1,
  RS: 1,
  RU: 1,
  SA: 0,
  SD: 6,
  SE: 1,
  SG: 0,
  SI: 1,
  SK: 1,
  SM: 1,
  SV: 0,
  SY: 6,
  TH: 0,
  TJ: 1,
  TM: 1,
  TR: 1,
  TT: 0,
  TW: 0,
  UA: 1,
  UM: 0,
  US: 0,
  UY: 1,
  UZ: 1,
  VA: 1,
  VE: 0,
  VI: 0,
  VN: 1,
  WS: 0,
  XK: 1,
  YE: 0,
  ZA: 0,
  ZW: 0
};
function getWeekArray(date2, locale2) {
  const weeks = [];
  let currentWeek = [];
  const firstDayOfMonth = startOfMonth(date2);
  const lastDayOfMonth = endOfMonth(date2);
  const firstDayWeekIndex = (firstDayOfMonth.getDay() - firstDay[locale2.slice(-2).toUpperCase()] + 7) % 7;
  const lastDayWeekIndex = (lastDayOfMonth.getDay() - firstDay[locale2.slice(-2).toUpperCase()] + 7) % 7;
  for (let i = 0; i < firstDayWeekIndex; i++) {
    const adjacentDay = new Date(firstDayOfMonth);
    adjacentDay.setDate(adjacentDay.getDate() - (firstDayWeekIndex - i));
    currentWeek.push(adjacentDay);
  }
  for (let i = 1; i <= lastDayOfMonth.getDate(); i++) {
    const day = new Date(date2.getFullYear(), date2.getMonth(), i);
    currentWeek.push(day);
    if (currentWeek.length === 7) {
      weeks.push(currentWeek);
      currentWeek = [];
    }
  }
  for (let i = 1; i < 7 - lastDayWeekIndex; i++) {
    const adjacentDay = new Date(lastDayOfMonth);
    adjacentDay.setDate(adjacentDay.getDate() + i);
    currentWeek.push(adjacentDay);
  }
  weeks.push(currentWeek);
  return weeks;
}
function startOfMonth(date2) {
  return new Date(date2.getFullYear(), date2.getMonth(), 1);
}
function endOfMonth(date2) {
  return new Date(date2.getFullYear(), date2.getMonth() + 1, 0);
}
function parseLocalDate(value) {
  const parts = value.split("-").map(Number);
  return new Date(parts[0], parts[1] - 1, parts[2]);
}
const _YYYMMDD = /([12]\d{3}-([1-9]|0[1-9]|1[0-2])-([1-9]|0[1-9]|[12]\d|3[01]))/;
function date(value) {
  if (value == null)
    return /* @__PURE__ */ new Date();
  if (value instanceof Date)
    return value;
  if (typeof value === "string") {
    let parsed;
    if (_YYYMMDD.test(value)) {
      return parseLocalDate(value);
    } else {
      parsed = Date.parse(value);
    }
    if (!isNaN(parsed))
      return new Date(parsed);
  }
  return null;
}
const sundayJanuarySecond2000 = new Date(2e3, 0, 2);
function getWeekdays(locale2) {
  const daysFromSunday = firstDay[locale2.slice(-2).toUpperCase()];
  return createRange(7).map((i) => {
    const weekday = new Date(sundayJanuarySecond2000);
    weekday.setDate(sundayJanuarySecond2000.getDate() + daysFromSunday + i);
    return new Intl.DateTimeFormat(locale2, {
      weekday: "narrow"
    }).format(weekday);
  });
}
function format(value, formatString, locale2) {
  const date2 = new Date(value);
  let options = {};
  switch (formatString) {
    case "fullDateWithWeekday":
      options = {
        weekday: "long",
        day: "numeric",
        month: "long",
        year: "numeric"
      };
      break;
    case "normalDateWithWeekday":
      options = {
        weekday: "short",
        day: "numeric",
        month: "short"
      };
      break;
    case "keyboardDate":
      options = {};
      break;
    case "monthAndDate":
      options = {
        month: "long",
        day: "numeric"
      };
      break;
    case "monthAndYear":
      options = {
        month: "long",
        year: "numeric"
      };
      break;
    case "dayOfMonth":
      options = {
        day: "numeric"
      };
      break;
    case "shortDate":
      options = {
        year: "numeric"
      };
      break;
    default:
      options = {
        timeZone: "UTC",
        timeZoneName: "short"
      };
  }
  return new Intl.DateTimeFormat(locale2, options).format(date2);
}
function toISO$1(adapter, value) {
  const date2 = adapter.toJsDate(value);
  const year = date2.getFullYear();
  const month = padStart(String(date2.getMonth() + 1), 2, "0");
  const day = padStart(String(date2.getDate()), 2, "0");
  return `${year}-${month}-${day}`;
}
function parseISO(value) {
  const [year, month, day] = value.split("-").map(Number);
  return new Date(year, month - 1, day);
}
function addDays(date2, amount) {
  const d = new Date(date2);
  d.setDate(d.getDate() + amount);
  return d;
}
function addMonths(date2, amount) {
  const d = new Date(date2);
  d.setMonth(d.getMonth() + amount);
  return d;
}
function getYear(date2) {
  return date2.getFullYear();
}
function getMonth(date2) {
  return date2.getMonth();
}
function startOfYear(date2) {
  return new Date(date2.getFullYear(), 0, 1);
}
function endOfYear(date2) {
  return new Date(date2.getFullYear(), 11, 31);
}
function isWithinRange(date2, range) {
  return isAfter(date2, range[0]) && isBefore(date2, range[1]);
}
function isValid(date2) {
  if (!date2 || date2 == null)
    return false;
  const d = new Date(date2);
  return d instanceof Date && !isNaN(d.getTime());
}
function isAfter(date2, comparing) {
  return date2.getTime() > comparing.getTime();
}
function isBefore(date2, comparing) {
  return date2.getTime() < comparing.getTime();
}
function isEqual(date2, comparing) {
  return date2.getTime() === comparing.getTime();
}
function isSameDay(date2, comparing) {
  return date2.getDate() === comparing.getDate() && date2.getMonth() === comparing.getMonth() && date2.getFullYear() === comparing.getFullYear();
}
function isSameMonth(date2, comparing) {
  return date2.getMonth() === comparing.getMonth() && date2.getFullYear() === comparing.getFullYear();
}
function getDiff(date2, comparing, unit) {
  const d = new Date(date2);
  const c2 = new Date(comparing);
  if (unit === "month") {
    return d.getMonth() - c2.getMonth() + (d.getFullYear() - c2.getFullYear()) * 12;
  }
  return Math.floor((d.getTime() - c2.getTime()) / (1e3 * 60 * 60 * 24));
}
function setYear(date2, year) {
  const d = new Date(date2);
  d.setFullYear(year);
  return d;
}
function startOfDay(date2) {
  return new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
}
function endOfDay(date2) {
  return new Date(date2.getFullYear(), date2.getMonth(), date2.getDate(), 23, 59, 59, 999);
}
class VuetifyDateAdapter {
  constructor(options) {
    this.locale = options.locale;
  }
  date(value) {
    return date(value);
  }
  toJsDate(date2) {
    return date2;
  }
  toISO(date2) {
    return toISO$1(this, date2);
  }
  parseISO(date2) {
    return parseISO(date2);
  }
  addDays(date2, amount) {
    return addDays(date2, amount);
  }
  addMonths(date2, amount) {
    return addMonths(date2, amount);
  }
  getWeekArray(date2) {
    return getWeekArray(date2, this.locale);
  }
  startOfMonth(date2) {
    return startOfMonth(date2);
  }
  endOfMonth(date2) {
    return endOfMonth(date2);
  }
  format(date2, formatString) {
    return format(date2, formatString, this.locale);
  }
  isEqual(date2, comparing) {
    return isEqual(date2, comparing);
  }
  isValid(date2) {
    return isValid(date2);
  }
  isWithinRange(date2, range) {
    return isWithinRange(date2, range);
  }
  isAfter(date2, comparing) {
    return isAfter(date2, comparing);
  }
  isBefore(date2, comparing) {
    return !isAfter(date2, comparing) && !isEqual(date2, comparing);
  }
  isSameDay(date2, comparing) {
    return isSameDay(date2, comparing);
  }
  isSameMonth(date2, comparing) {
    return isSameMonth(date2, comparing);
  }
  setYear(date2, year) {
    return setYear(date2, year);
  }
  getDiff(date2, comparing, unit) {
    return getDiff(date2, comparing, unit);
  }
  getWeekdays() {
    return getWeekdays(this.locale);
  }
  getYear(date2) {
    return getYear(date2);
  }
  getMonth(date2) {
    return getMonth(date2);
  }
  startOfDay(date2) {
    return startOfDay(date2);
  }
  endOfDay(date2) {
    return endOfDay(date2);
  }
  startOfYear(date2) {
    return startOfYear(date2);
  }
  endOfYear(date2) {
    return endOfYear(date2);
  }
}
const DateAdapterSymbol = Symbol.for("vuetify:date-adapter");
function createDate(options) {
  return mergeDeep({
    adapter: VuetifyDateAdapter,
    locale: {
      af: "af-ZA",
      // ar: '', # not the same value for all variants
      bg: "bg-BG",
      ca: "ca-ES",
      ckb: "",
      cs: "",
      de: "de-DE",
      el: "el-GR",
      en: "en-US",
      // es: '', # not the same value for all variants
      et: "et-EE",
      fa: "fa-IR",
      fi: "fi-FI",
      // fr: '', #not the same value for all variants
      hr: "hr-HR",
      hu: "hu-HU",
      he: "he-IL",
      id: "id-ID",
      it: "it-IT",
      ja: "ja-JP",
      ko: "ko-KR",
      lv: "lv-LV",
      lt: "lt-LT",
      nl: "nl-NL",
      no: "no-NO",
      pl: "pl-PL",
      pt: "pt-PT",
      ro: "ro-RO",
      ru: "ru-RU",
      sk: "sk-SK",
      sl: "sl-SI",
      srCyrl: "sr-SP",
      srLatn: "sr-SP",
      sv: "sv-SE",
      th: "th-TH",
      tr: "tr-TR",
      az: "az-AZ",
      uk: "uk-UA",
      vi: "vi-VN",
      zhHans: "zh-CN",
      zhHant: "zh-TW"
    }
  }, options);
}
function useResizeObserver(callback) {
  let box = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "content";
  const resizeRef = ref();
  const contentRect = ref();
  if (IN_BROWSER) {
    const observer = new ResizeObserver((entries) => {
      callback == null ? void 0 : callback(entries, observer);
      if (!entries.length)
        return;
      if (box === "content") {
        contentRect.value = entries[0].contentRect;
      } else {
        contentRect.value = entries[0].target.getBoundingClientRect();
      }
    });
    onBeforeUnmount(() => {
      observer.disconnect();
    });
    watch(resizeRef, (newValue, oldValue) => {
      if (oldValue) {
        observer.unobserve(refElement(oldValue));
        contentRect.value = void 0;
      }
      if (newValue)
        observer.observe(refElement(newValue));
    }, {
      flush: "post"
    });
  }
  return {
    resizeRef,
    contentRect: readonly(contentRect)
  };
}
const VuetifyLayoutKey = Symbol.for("vuetify:layout");
const VuetifyLayoutItemKey = Symbol.for("vuetify:layout-item");
const ROOT_ZINDEX = 1e3;
const makeLayoutProps = propsFactory({
  overlaps: {
    type: Array,
    default: () => []
  },
  fullHeight: Boolean
}, "layout");
const makeLayoutItemProps = propsFactory({
  name: {
    type: String
  },
  order: {
    type: [Number, String],
    default: 0
  },
  absolute: Boolean
}, "layout-item");
function useLayout() {
  const layout = inject$1(VuetifyLayoutKey);
  if (!layout)
    throw new Error("[Vuetify] Could not find injected layout");
  return {
    getLayoutItem: layout.getLayoutItem,
    mainRect: layout.mainRect,
    mainStyles: layout.mainStyles
  };
}
function useLayoutItem(options) {
  const layout = inject$1(VuetifyLayoutKey);
  if (!layout)
    throw new Error("[Vuetify] Could not find injected layout");
  const id = options.id ?? `layout-item-${getUid()}`;
  const vm = getCurrentInstance("useLayoutItem");
  provide(VuetifyLayoutItemKey, {
    id
  });
  const isKeptAlive = shallowRef(false);
  onDeactivated(() => isKeptAlive.value = true);
  onActivated(() => isKeptAlive.value = false);
  const {
    layoutItemStyles,
    layoutItemScrimStyles
  } = layout.register(vm, {
    ...options,
    active: computed(() => isKeptAlive.value ? false : options.active.value),
    id
  });
  onBeforeUnmount(() => layout.unregister(id));
  return {
    layoutItemStyles,
    layoutRect: layout.layoutRect,
    layoutItemScrimStyles
  };
}
const generateLayers = (layout, positions, layoutSizes, activeItems) => {
  let previousLayer = {
    top: 0,
    left: 0,
    right: 0,
    bottom: 0
  };
  const layers = [{
    id: "",
    layer: {
      ...previousLayer
    }
  }];
  for (const id of layout) {
    const position = positions.get(id);
    const amount = layoutSizes.get(id);
    const active = activeItems.get(id);
    if (!position || !amount || !active)
      continue;
    const layer = {
      ...previousLayer,
      [position.value]: parseInt(previousLayer[position.value], 10) + (active.value ? parseInt(amount.value, 10) : 0)
    };
    layers.push({
      id,
      layer
    });
    previousLayer = layer;
  }
  return layers;
};
function createLayout(props2) {
  const parentLayout = inject$1(VuetifyLayoutKey, null);
  const rootZIndex = computed(() => parentLayout ? parentLayout.rootZIndex.value - 100 : ROOT_ZINDEX);
  const registered = ref([]);
  const positions = reactive(/* @__PURE__ */ new Map());
  const layoutSizes = reactive(/* @__PURE__ */ new Map());
  const priorities = reactive(/* @__PURE__ */ new Map());
  const activeItems = reactive(/* @__PURE__ */ new Map());
  const disabledTransitions = reactive(/* @__PURE__ */ new Map());
  const {
    resizeRef,
    contentRect: layoutRect
  } = useResizeObserver();
  const computedOverlaps = computed(() => {
    const map = /* @__PURE__ */ new Map();
    const overlaps = props2.overlaps ?? [];
    for (const overlap of overlaps.filter((item) => item.includes(":"))) {
      const [top, bottom] = overlap.split(":");
      if (!registered.value.includes(top) || !registered.value.includes(bottom))
        continue;
      const topPosition = positions.get(top);
      const bottomPosition = positions.get(bottom);
      const topAmount = layoutSizes.get(top);
      const bottomAmount = layoutSizes.get(bottom);
      if (!topPosition || !bottomPosition || !topAmount || !bottomAmount)
        continue;
      map.set(bottom, {
        position: topPosition.value,
        amount: parseInt(topAmount.value, 10)
      });
      map.set(top, {
        position: bottomPosition.value,
        amount: -parseInt(bottomAmount.value, 10)
      });
    }
    return map;
  });
  const layers = computed(() => {
    const uniquePriorities = [...new Set([...priorities.values()].map((p2) => p2.value))].sort((a, b2) => a - b2);
    const layout = [];
    for (const p2 of uniquePriorities) {
      const items2 = registered.value.filter((id) => {
        var _a2;
        return ((_a2 = priorities.get(id)) == null ? void 0 : _a2.value) === p2;
      });
      layout.push(...items2);
    }
    return generateLayers(layout, positions, layoutSizes, activeItems);
  });
  const transitionsEnabled = computed(() => {
    return !Array.from(disabledTransitions.values()).some((ref2) => ref2.value);
  });
  const mainRect = computed(() => {
    return layers.value[layers.value.length - 1].layer;
  });
  const mainStyles = computed(() => {
    return {
      "--v-layout-left": convertToUnit(mainRect.value.left),
      "--v-layout-right": convertToUnit(mainRect.value.right),
      "--v-layout-top": convertToUnit(mainRect.value.top),
      "--v-layout-bottom": convertToUnit(mainRect.value.bottom),
      ...transitionsEnabled.value ? void 0 : {
        transition: "none"
      }
    };
  });
  const items = computed(() => {
    return layers.value.slice(1).map((_ref, index2) => {
      let {
        id
      } = _ref;
      const {
        layer
      } = layers.value[index2];
      const size2 = layoutSizes.get(id);
      const position = positions.get(id);
      return {
        id,
        ...layer,
        size: Number(size2.value),
        position: position.value
      };
    });
  });
  const getLayoutItem = (id) => {
    return items.value.find((item) => item.id === id);
  };
  const rootVm = getCurrentInstance("createLayout");
  const isMounted = shallowRef(false);
  onMounted(() => {
    isMounted.value = true;
  });
  provide(VuetifyLayoutKey, {
    register: (vm, _ref2) => {
      let {
        id,
        order,
        position,
        layoutSize,
        elementSize,
        active,
        disableTransitions,
        absolute
      } = _ref2;
      priorities.set(id, order);
      positions.set(id, position);
      layoutSizes.set(id, layoutSize);
      activeItems.set(id, active);
      disableTransitions && disabledTransitions.set(id, disableTransitions);
      const instances = findChildrenWithProvide(VuetifyLayoutItemKey, rootVm == null ? void 0 : rootVm.vnode);
      const instanceIndex = instances.indexOf(vm);
      if (instanceIndex > -1)
        registered.value.splice(instanceIndex, 0, id);
      else
        registered.value.push(id);
      const index2 = computed(() => items.value.findIndex((i) => i.id === id));
      const zIndex = computed(() => rootZIndex.value + layers.value.length * 2 - index2.value * 2);
      const layoutItemStyles = computed(() => {
        const isHorizontal = position.value === "left" || position.value === "right";
        const isOppositeHorizontal = position.value === "right";
        const isOppositeVertical = position.value === "bottom";
        const styles = {
          [position.value]: 0,
          zIndex: zIndex.value,
          transform: `translate${isHorizontal ? "X" : "Y"}(${(active.value ? 0 : -110) * (isOppositeHorizontal || isOppositeVertical ? -1 : 1)}%)`,
          position: absolute.value || rootZIndex.value !== ROOT_ZINDEX ? "absolute" : "fixed",
          ...transitionsEnabled.value ? void 0 : {
            transition: "none"
          }
        };
        if (!isMounted.value)
          return styles;
        const item = items.value[index2.value];
        if (!item)
          throw new Error(`[Vuetify] Could not find layout item "${id}"`);
        const overlap = computedOverlaps.value.get(id);
        if (overlap) {
          item[overlap.position] += overlap.amount;
        }
        return {
          ...styles,
          height: isHorizontal ? `calc(100% - ${item.top}px - ${item.bottom}px)` : elementSize.value ? `${elementSize.value}px` : void 0,
          left: isOppositeHorizontal ? void 0 : `${item.left}px`,
          right: isOppositeHorizontal ? `${item.right}px` : void 0,
          top: position.value !== "bottom" ? `${item.top}px` : void 0,
          bottom: position.value !== "top" ? `${item.bottom}px` : void 0,
          width: !isHorizontal ? `calc(100% - ${item.left}px - ${item.right}px)` : elementSize.value ? `${elementSize.value}px` : void 0
        };
      });
      const layoutItemScrimStyles = computed(() => ({
        zIndex: zIndex.value - 1
      }));
      return {
        layoutItemStyles,
        layoutItemScrimStyles,
        zIndex
      };
    },
    unregister: (id) => {
      priorities.delete(id);
      positions.delete(id);
      layoutSizes.delete(id);
      activeItems.delete(id);
      disabledTransitions.delete(id);
      registered.value = registered.value.filter((v2) => v2 !== id);
    },
    mainRect,
    mainStyles,
    getLayoutItem,
    items,
    layoutRect,
    rootZIndex
  });
  const layoutClasses = computed(() => ["v-layout", {
    "v-layout--full-height": props2.fullHeight
  }]);
  const layoutStyles = computed(() => ({
    zIndex: parentLayout ? rootZIndex.value : void 0,
    position: parentLayout ? "relative" : void 0,
    overflow: parentLayout ? "hidden" : void 0
  }));
  return {
    layoutClasses,
    layoutStyles,
    getLayoutItem,
    items,
    layoutRect,
    layoutRef: resizeRef
  };
}
function createVuetify() {
  let vuetify = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const {
    blueprint,
    ...rest
  } = vuetify;
  const options = mergeDeep(blueprint, rest);
  const {
    aliases: aliases2 = {},
    components: components2 = {},
    directives: directives2 = {}
  } = options;
  const defaults2 = createDefaults(options.defaults);
  const display = createDisplay(options.display, options.ssr);
  const theme = createTheme(options.theme);
  const icons = createIcons(options.icons);
  const locale2 = createLocale(options.locale);
  const date2 = createDate(options.date);
  const install3 = (app) => {
    for (const key2 in directives2) {
      app.directive(key2, directives2[key2]);
    }
    for (const key2 in components2) {
      app.component(key2, components2[key2]);
    }
    for (const key2 in aliases2) {
      app.component(key2, defineComponent({
        ...aliases2[key2],
        name: key2,
        aliasName: aliases2[key2].name
      }));
    }
    theme.install(app);
    app.provide(DefaultsSymbol, defaults2);
    app.provide(DisplaySymbol, display);
    app.provide(ThemeSymbol, theme);
    app.provide(IconSymbol, icons);
    app.provide(LocaleSymbol, locale2);
    app.provide(DateAdapterSymbol, date2);
    if (IN_BROWSER && options.ssr) {
      if (app.$nuxt) {
        app.$nuxt.hook("app:suspense:resolve", () => {
          display.update();
        });
      } else {
        const {
          mount: mount2
        } = app;
        app.mount = function() {
          const vm = mount2(...arguments);
          nextTick(() => display.update());
          app.mount = mount2;
          return vm;
        };
      }
    }
    getUid.reset();
    {
      app.mixin({
        computed: {
          $vuetify() {
            return reactive({
              defaults: inject.call(this, DefaultsSymbol),
              display: inject.call(this, DisplaySymbol),
              theme: inject.call(this, ThemeSymbol),
              icons: inject.call(this, IconSymbol),
              locale: inject.call(this, LocaleSymbol),
              date: inject.call(this, DateAdapterSymbol)
            });
          }
        }
      });
    }
  };
  return {
    install: install3,
    defaults: defaults2,
    display,
    theme,
    icons,
    locale: locale2,
    date: date2
  };
}
const version = "3.3.22";
createVuetify.version = version;
function inject(key2) {
  var _a2, _b;
  const vm = this.$;
  const provides = ((_a2 = vm.parent) == null ? void 0 : _a2.provides) ?? ((_b = vm.vnode.appContext) == null ? void 0 : _b.provides);
  if (provides && key2 in provides) {
    return provides[key2];
  }
}
const VApp$1 = "";
const makeVAppProps = propsFactory({
  ...makeComponentProps(),
  ...makeLayoutProps({
    fullHeight: true
  }),
  ...makeThemeProps()
}, "VApp");
const VApp = genericComponent()({
  name: "VApp",
  props: makeVAppProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const theme = provideTheme(props2);
    const {
      layoutClasses,
      getLayoutItem,
      items,
      layoutRef
    } = createLayout(props2);
    const {
      rtlClasses
    } = useRtl();
    useRender(() => {
      var _a2;
      return createVNode("div", {
        "ref": layoutRef,
        "class": ["v-application", theme.themeClasses.value, layoutClasses.value, rtlClasses.value, props2.class],
        "style": [props2.style]
      }, [createVNode("div", {
        "class": "v-application__wrap"
      }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)])]);
    });
    return {
      getLayoutItem,
      items,
      theme
    };
  }
});
const VAppBar$1 = "";
const VToolbar$1 = "";
const makeTagProps = propsFactory({
  tag: {
    type: String,
    default: "div"
  }
}, "tag");
const makeVToolbarTitleProps = propsFactory({
  text: String,
  ...makeComponentProps(),
  ...makeTagProps()
}, "VToolbarTitle");
const VToolbarTitle = genericComponent()({
  name: "VToolbarTitle",
  props: makeVToolbarTitleProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    useRender(() => {
      const hasText = !!(slots.default || slots.text || props2.text);
      return createVNode(props2.tag, {
        "class": ["v-toolbar-title", props2.class],
        "style": props2.style
      }, {
        default: () => {
          var _a2;
          return [hasText && createVNode("div", {
            "class": "v-toolbar-title__placeholder"
          }, [slots.text ? slots.text() : props2.text, (_a2 = slots.default) == null ? void 0 : _a2.call(slots)])];
        }
      });
    });
    return {};
  }
});
const makeTransitionProps$1 = propsFactory({
  disabled: Boolean,
  group: Boolean,
  hideOnLeave: Boolean,
  leaveAbsolute: Boolean,
  mode: String,
  origin: String
}, "transition");
function createCssTransition(name, origin, mode) {
  return genericComponent()({
    name,
    props: makeTransitionProps$1({
      mode,
      origin
    }),
    setup(props2, _ref) {
      let {
        slots
      } = _ref;
      const functions = {
        onBeforeEnter(el) {
          if (props2.origin) {
            el.style.transformOrigin = props2.origin;
          }
        },
        onLeave(el) {
          if (props2.leaveAbsolute) {
            const {
              offsetTop,
              offsetLeft,
              offsetWidth,
              offsetHeight
            } = el;
            el._transitionInitialStyles = {
              position: el.style.position,
              top: el.style.top,
              left: el.style.left,
              width: el.style.width,
              height: el.style.height
            };
            el.style.position = "absolute";
            el.style.top = `${offsetTop}px`;
            el.style.left = `${offsetLeft}px`;
            el.style.width = `${offsetWidth}px`;
            el.style.height = `${offsetHeight}px`;
          }
          if (props2.hideOnLeave) {
            el.style.setProperty("display", "none", "important");
          }
        },
        onAfterLeave(el) {
          if (props2.leaveAbsolute && (el == null ? void 0 : el._transitionInitialStyles)) {
            const {
              position,
              top,
              left,
              width,
              height
            } = el._transitionInitialStyles;
            delete el._transitionInitialStyles;
            el.style.position = position || "";
            el.style.top = top || "";
            el.style.left = left || "";
            el.style.width = width || "";
            el.style.height = height || "";
          }
        }
      };
      return () => {
        const tag = props2.group ? TransitionGroup : Transition;
        return h(tag, {
          name: props2.disabled ? "" : name,
          css: !props2.disabled,
          ...props2.group ? void 0 : {
            mode: props2.mode
          },
          ...props2.disabled ? {} : functions
        }, slots.default);
      };
    }
  });
}
function createJavascriptTransition(name, functions) {
  let mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "in-out";
  return genericComponent()({
    name,
    props: {
      mode: {
        type: String,
        default: mode
      },
      disabled: Boolean
    },
    setup(props2, _ref2) {
      let {
        slots
      } = _ref2;
      return () => {
        return h(Transition, {
          name: props2.disabled ? "" : name,
          css: !props2.disabled,
          // mode: props.mode, // TODO: vuejs/vue-next#3104
          ...props2.disabled ? {} : functions
        }, slots.default);
      };
    }
  });
}
function ExpandTransitionGenerator() {
  let expandedParentClass = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  let x2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  const sizeProperty = x2 ? "width" : "height";
  const offsetProperty = camelize(`offset-${sizeProperty}`);
  return {
    onBeforeEnter(el) {
      el._parent = el.parentNode;
      el._initialStyle = {
        transition: el.style.transition,
        overflow: el.style.overflow,
        [sizeProperty]: el.style[sizeProperty]
      };
    },
    onEnter(el) {
      const initialStyle = el._initialStyle;
      el.style.setProperty("transition", "none", "important");
      el.style.overflow = "hidden";
      const offset = `${el[offsetProperty]}px`;
      el.style[sizeProperty] = "0";
      void el.offsetHeight;
      el.style.transition = initialStyle.transition;
      if (expandedParentClass && el._parent) {
        el._parent.classList.add(expandedParentClass);
      }
      requestAnimationFrame(() => {
        el.style[sizeProperty] = offset;
      });
    },
    onAfterEnter: resetStyles,
    onEnterCancelled: resetStyles,
    onLeave(el) {
      el._initialStyle = {
        transition: "",
        overflow: el.style.overflow,
        [sizeProperty]: el.style[sizeProperty]
      };
      el.style.overflow = "hidden";
      el.style[sizeProperty] = `${el[offsetProperty]}px`;
      void el.offsetHeight;
      requestAnimationFrame(() => el.style[sizeProperty] = "0");
    },
    onAfterLeave,
    onLeaveCancelled: onAfterLeave
  };
  function onAfterLeave(el) {
    if (expandedParentClass && el._parent) {
      el._parent.classList.remove(expandedParentClass);
    }
    resetStyles(el);
  }
  function resetStyles(el) {
    const size2 = el._initialStyle[sizeProperty];
    el.style.overflow = el._initialStyle.overflow;
    if (size2 != null)
      el.style[sizeProperty] = size2;
    delete el._initialStyle;
  }
}
const makeVDialogTransitionProps = propsFactory({
  target: Object
}, "v-dialog-transition");
const VDialogTransition = genericComponent()({
  name: "VDialogTransition",
  props: makeVDialogTransitionProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const functions = {
      onBeforeEnter(el) {
        el.style.pointerEvents = "none";
        el.style.visibility = "hidden";
      },
      async onEnter(el, done) {
        var _a2;
        await new Promise((resolve2) => requestAnimationFrame(resolve2));
        await new Promise((resolve2) => requestAnimationFrame(resolve2));
        el.style.visibility = "";
        const {
          x: x2,
          y: y2,
          sx,
          sy,
          speed
        } = getDimensions(props2.target, el);
        const animation = animate(el, [{
          transform: `translate(${x2}px, ${y2}px) scale(${sx}, ${sy})`,
          opacity: 0
        }, {}], {
          duration: 225 * speed,
          easing: deceleratedEasing
        });
        (_a2 = getChildren(el)) == null ? void 0 : _a2.forEach((el2) => {
          animate(el2, [{
            opacity: 0
          }, {
            opacity: 0,
            offset: 0.33
          }, {}], {
            duration: 225 * 2 * speed,
            easing: standardEasing
          });
        });
        animation.finished.then(() => done());
      },
      onAfterEnter(el) {
        el.style.removeProperty("pointer-events");
      },
      onBeforeLeave(el) {
        el.style.pointerEvents = "none";
      },
      async onLeave(el, done) {
        var _a2;
        await new Promise((resolve2) => requestAnimationFrame(resolve2));
        const {
          x: x2,
          y: y2,
          sx,
          sy,
          speed
        } = getDimensions(props2.target, el);
        const animation = animate(el, [{}, {
          transform: `translate(${x2}px, ${y2}px) scale(${sx}, ${sy})`,
          opacity: 0
        }], {
          duration: 125 * speed,
          easing: acceleratedEasing
        });
        animation.finished.then(() => done());
        (_a2 = getChildren(el)) == null ? void 0 : _a2.forEach((el2) => {
          animate(el2, [{}, {
            opacity: 0,
            offset: 0.2
          }, {
            opacity: 0
          }], {
            duration: 125 * 2 * speed,
            easing: standardEasing
          });
        });
      },
      onAfterLeave(el) {
        el.style.removeProperty("pointer-events");
      }
    };
    return () => {
      return props2.target ? createVNode(Transition, mergeProps({
        "name": "dialog-transition"
      }, functions, {
        "css": false
      }), slots) : createVNode(Transition, {
        "name": "dialog-transition"
      }, slots);
    };
  }
});
function getChildren(el) {
  var _a2;
  const els = (_a2 = el.querySelector(":scope > .v-card, :scope > .v-sheet, :scope > .v-list")) == null ? void 0 : _a2.children;
  return els && [...els];
}
function getDimensions(target, el) {
  const targetBox = target.getBoundingClientRect();
  const elBox = nullifyTransforms(el);
  const [originX, originY] = getComputedStyle(el).transformOrigin.split(" ").map((v2) => parseFloat(v2));
  const [anchorSide, anchorOffset] = getComputedStyle(el).getPropertyValue("--v-overlay-anchor-origin").split(" ");
  let offsetX = targetBox.left + targetBox.width / 2;
  if (anchorSide === "left" || anchorOffset === "left") {
    offsetX -= targetBox.width / 2;
  } else if (anchorSide === "right" || anchorOffset === "right") {
    offsetX += targetBox.width / 2;
  }
  let offsetY = targetBox.top + targetBox.height / 2;
  if (anchorSide === "top" || anchorOffset === "top") {
    offsetY -= targetBox.height / 2;
  } else if (anchorSide === "bottom" || anchorOffset === "bottom") {
    offsetY += targetBox.height / 2;
  }
  const tsx = targetBox.width / elBox.width;
  const tsy = targetBox.height / elBox.height;
  const maxs = Math.max(1, tsx, tsy);
  const sx = tsx / maxs || 0;
  const sy = tsy / maxs || 0;
  const asa = elBox.width * elBox.height / (window.innerWidth * window.innerHeight);
  const speed = asa > 0.12 ? Math.min(1.5, (asa - 0.12) * 10 + 1) : 1;
  return {
    x: offsetX - (originX + elBox.left),
    y: offsetY - (originY + elBox.top),
    sx,
    sy,
    speed
  };
}
const VFabTransition = createCssTransition("fab-transition", "center center", "out-in");
const VDialogBottomTransition = createCssTransition("dialog-bottom-transition");
const VDialogTopTransition = createCssTransition("dialog-top-transition");
const VFadeTransition = createCssTransition("fade-transition");
const VScaleTransition = createCssTransition("scale-transition");
const VScrollXTransition = createCssTransition("scroll-x-transition");
const VScrollXReverseTransition = createCssTransition("scroll-x-reverse-transition");
const VScrollYTransition = createCssTransition("scroll-y-transition");
const VScrollYReverseTransition = createCssTransition("scroll-y-reverse-transition");
const VSlideXTransition = createCssTransition("slide-x-transition");
const VSlideXReverseTransition = createCssTransition("slide-x-reverse-transition");
const VSlideYTransition = createCssTransition("slide-y-transition");
const VSlideYReverseTransition = createCssTransition("slide-y-reverse-transition");
const VExpandTransition = createJavascriptTransition("expand-transition", ExpandTransitionGenerator());
const VExpandXTransition = createJavascriptTransition("expand-x-transition", ExpandTransitionGenerator("", true));
const makeVDefaultsProviderProps = propsFactory({
  defaults: Object,
  disabled: Boolean,
  reset: [Number, String],
  root: [Boolean, String],
  scoped: Boolean
}, "VDefaultsProvider");
const VDefaultsProvider = genericComponent(false)({
  name: "VDefaultsProvider",
  props: makeVDefaultsProviderProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      defaults: defaults2,
      disabled,
      reset,
      root: root2,
      scoped
    } = toRefs(props2);
    provideDefaults(defaults2, {
      reset,
      root: root2,
      scoped,
      disabled
    });
    return () => {
      var _a2;
      return (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
    };
  }
});
const VImg$1 = "";
const VResponsive$1 = "";
const makeDimensionProps = propsFactory({
  height: [Number, String],
  maxHeight: [Number, String],
  maxWidth: [Number, String],
  minHeight: [Number, String],
  minWidth: [Number, String],
  width: [Number, String]
}, "dimension");
function useDimension(props2) {
  const dimensionStyles = computed(() => ({
    height: convertToUnit(props2.height),
    maxHeight: convertToUnit(props2.maxHeight),
    maxWidth: convertToUnit(props2.maxWidth),
    minHeight: convertToUnit(props2.minHeight),
    minWidth: convertToUnit(props2.minWidth),
    width: convertToUnit(props2.width)
  }));
  return {
    dimensionStyles
  };
}
function useAspectStyles(props2) {
  return {
    aspectStyles: computed(() => {
      const ratio = Number(props2.aspectRatio);
      return ratio ? {
        paddingBottom: String(1 / ratio * 100) + "%"
      } : void 0;
    })
  };
}
const makeVResponsiveProps = propsFactory({
  aspectRatio: [String, Number],
  contentClass: String,
  inline: Boolean,
  ...makeComponentProps(),
  ...makeDimensionProps()
}, "VResponsive");
const VResponsive = genericComponent()({
  name: "VResponsive",
  props: makeVResponsiveProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      aspectStyles
    } = useAspectStyles(props2);
    const {
      dimensionStyles
    } = useDimension(props2);
    useRender(() => {
      var _a2;
      return createVNode("div", {
        "class": ["v-responsive", {
          "v-responsive--inline": props2.inline
        }, props2.class],
        "style": [dimensionStyles.value, props2.style]
      }, [createVNode("div", {
        "class": "v-responsive__sizer",
        "style": aspectStyles.value
      }, null), (_a2 = slots.additional) == null ? void 0 : _a2.call(slots), slots.default && createVNode("div", {
        "class": ["v-responsive__content", props2.contentClass]
      }, [slots.default()])]);
    });
    return {};
  }
});
const makeTransitionProps = propsFactory({
  transition: {
    type: [Boolean, String, Object],
    default: "fade-transition",
    validator: (val) => val !== true
  }
}, "transition");
const MaybeTransition = (props2, _ref) => {
  let {
    slots
  } = _ref;
  const {
    transition,
    disabled,
    ...rest
  } = props2;
  const {
    component = Transition,
    ...customProps
  } = typeof transition === "object" ? transition : {};
  return h(component, mergeProps(typeof transition === "string" ? {
    name: disabled ? "" : transition
  } : customProps, rest, {
    disabled
  }), slots);
};
function mounted$5(el, binding) {
  if (!SUPPORTS_INTERSECTION)
    return;
  const modifiers = binding.modifiers || {};
  const value = binding.value;
  const {
    handler,
    options
  } = typeof value === "object" ? value : {
    handler: value,
    options: {}
  };
  const observer = new IntersectionObserver(function() {
    var _a2;
    let entries = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    let observer2 = arguments.length > 1 ? arguments[1] : void 0;
    const _observe = (_a2 = el._observe) == null ? void 0 : _a2[binding.instance.$.uid];
    if (!_observe)
      return;
    const isIntersecting = entries.some((entry) => entry.isIntersecting);
    if (handler && (!modifiers.quiet || _observe.init) && (!modifiers.once || isIntersecting || _observe.init)) {
      handler(isIntersecting, entries, observer2);
    }
    if (isIntersecting && modifiers.once)
      unmounted$5(el, binding);
    else
      _observe.init = true;
  }, options);
  el._observe = Object(el._observe);
  el._observe[binding.instance.$.uid] = {
    init: false,
    observer
  };
  observer.observe(el);
}
function unmounted$5(el, binding) {
  var _a2;
  const observe = (_a2 = el._observe) == null ? void 0 : _a2[binding.instance.$.uid];
  if (!observe)
    return;
  observe.observer.unobserve(el);
  delete el._observe[binding.instance.$.uid];
}
const Intersect = {
  mounted: mounted$5,
  unmounted: unmounted$5
};
const Intersect$1 = Intersect;
const makeVImgProps = propsFactory({
  alt: String,
  cover: Boolean,
  eager: Boolean,
  gradient: String,
  lazySrc: String,
  options: {
    type: Object,
    // For more information on types, navigate to:
    // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
    default: () => ({
      root: void 0,
      rootMargin: void 0,
      threshold: void 0
    })
  },
  sizes: String,
  src: {
    type: [String, Object],
    default: ""
  },
  srcset: String,
  ...makeVResponsiveProps(),
  ...makeComponentProps(),
  ...makeTransitionProps()
}, "VImg");
const VImg = genericComponent()({
  name: "VImg",
  directives: {
    intersect: Intersect$1
  },
  props: makeVImgProps(),
  emits: {
    loadstart: (value) => true,
    load: (value) => true,
    error: (value) => true
  },
  setup(props2, _ref) {
    let {
      emit: emit2,
      slots
    } = _ref;
    const currentSrc = shallowRef("");
    const image = ref();
    const state = shallowRef(props2.eager ? "loading" : "idle");
    const naturalWidth = shallowRef();
    const naturalHeight = shallowRef();
    const normalisedSrc = computed(() => {
      return props2.src && typeof props2.src === "object" ? {
        src: props2.src.src,
        srcset: props2.srcset || props2.src.srcset,
        lazySrc: props2.lazySrc || props2.src.lazySrc,
        aspect: Number(props2.aspectRatio || props2.src.aspect || 0)
      } : {
        src: props2.src,
        srcset: props2.srcset,
        lazySrc: props2.lazySrc,
        aspect: Number(props2.aspectRatio || 0)
      };
    });
    const aspectRatio = computed(() => {
      return normalisedSrc.value.aspect || naturalWidth.value / naturalHeight.value || 0;
    });
    watch(() => props2.src, () => {
      init(state.value !== "idle");
    });
    watch(aspectRatio, (val, oldVal) => {
      if (!val && oldVal && image.value) {
        pollForSize(image.value);
      }
    });
    onBeforeMount(() => init());
    function init(isIntersecting) {
      if (props2.eager && isIntersecting)
        return;
      if (SUPPORTS_INTERSECTION && !isIntersecting && !props2.eager)
        return;
      state.value = "loading";
      if (normalisedSrc.value.lazySrc) {
        const lazyImg = new Image();
        lazyImg.src = normalisedSrc.value.lazySrc;
        pollForSize(lazyImg, null);
      }
      if (!normalisedSrc.value.src)
        return;
      nextTick(() => {
        var _a2, _b;
        emit2("loadstart", ((_a2 = image.value) == null ? void 0 : _a2.currentSrc) || normalisedSrc.value.src);
        if ((_b = image.value) == null ? void 0 : _b.complete) {
          if (!image.value.naturalWidth) {
            onError();
          }
          if (state.value === "error")
            return;
          if (!aspectRatio.value)
            pollForSize(image.value, null);
          onLoad();
        } else {
          if (!aspectRatio.value)
            pollForSize(image.value);
          getSrc();
        }
      });
    }
    function onLoad() {
      var _a2;
      getSrc();
      state.value = "loaded";
      emit2("load", ((_a2 = image.value) == null ? void 0 : _a2.currentSrc) || normalisedSrc.value.src);
    }
    function onError() {
      var _a2;
      state.value = "error";
      emit2("error", ((_a2 = image.value) == null ? void 0 : _a2.currentSrc) || normalisedSrc.value.src);
    }
    function getSrc() {
      const img = image.value;
      if (img)
        currentSrc.value = img.currentSrc || img.src;
    }
    let timer = -1;
    function pollForSize(img) {
      let timeout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 100;
      const poll = () => {
        clearTimeout(timer);
        const {
          naturalHeight: imgHeight,
          naturalWidth: imgWidth
        } = img;
        if (imgHeight || imgWidth) {
          naturalWidth.value = imgWidth;
          naturalHeight.value = imgHeight;
        } else if (!img.complete && state.value === "loading" && timeout != null) {
          timer = window.setTimeout(poll, timeout);
        } else if (img.currentSrc.endsWith(".svg") || img.currentSrc.startsWith("data:image/svg+xml")) {
          naturalWidth.value = 1;
          naturalHeight.value = 1;
        }
      };
      poll();
    }
    const containClasses = computed(() => ({
      "v-img__img--cover": props2.cover,
      "v-img__img--contain": !props2.cover
    }));
    const __image = () => {
      var _a2;
      if (!normalisedSrc.value.src || state.value === "idle")
        return null;
      const img = createVNode("img", {
        "class": ["v-img__img", containClasses.value],
        "src": normalisedSrc.value.src,
        "srcset": normalisedSrc.value.srcset,
        "alt": props2.alt,
        "sizes": props2.sizes,
        "ref": image,
        "onLoad": onLoad,
        "onError": onError
      }, null);
      const sources = (_a2 = slots.sources) == null ? void 0 : _a2.call(slots);
      return createVNode(MaybeTransition, {
        "transition": props2.transition,
        "appear": true
      }, {
        default: () => [withDirectives(sources ? createVNode("picture", {
          "class": "v-img__picture"
        }, [sources, img]) : img, [[vShow, state.value === "loaded"]])]
      });
    };
    const __preloadImage = () => createVNode(MaybeTransition, {
      "transition": props2.transition
    }, {
      default: () => [normalisedSrc.value.lazySrc && state.value !== "loaded" && createVNode("img", {
        "class": ["v-img__img", "v-img__img--preload", containClasses.value],
        "src": normalisedSrc.value.lazySrc,
        "alt": props2.alt
      }, null)]
    });
    const __placeholder = () => {
      if (!slots.placeholder)
        return null;
      return createVNode(MaybeTransition, {
        "transition": props2.transition,
        "appear": true
      }, {
        default: () => [(state.value === "loading" || state.value === "error" && !slots.error) && createVNode("div", {
          "class": "v-img__placeholder"
        }, [slots.placeholder()])]
      });
    };
    const __error = () => {
      if (!slots.error)
        return null;
      return createVNode(MaybeTransition, {
        "transition": props2.transition,
        "appear": true
      }, {
        default: () => [state.value === "error" && createVNode("div", {
          "class": "v-img__error"
        }, [slots.error()])]
      });
    };
    const __gradient = () => {
      if (!props2.gradient)
        return null;
      return createVNode("div", {
        "class": "v-img__gradient",
        "style": {
          backgroundImage: `linear-gradient(${props2.gradient})`
        }
      }, null);
    };
    const isBooted = shallowRef(false);
    {
      const stop2 = watch(aspectRatio, (val) => {
        if (val) {
          requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              isBooted.value = true;
            });
          });
          stop2();
        }
      });
    }
    useRender(() => {
      const [responsiveProps] = VResponsive.filterProps(props2);
      return withDirectives(createVNode(VResponsive, mergeProps({
        "class": ["v-img", {
          "v-img--booting": !isBooted.value
        }, props2.class],
        "style": [{
          width: convertToUnit(props2.width === "auto" ? naturalWidth.value : props2.width)
        }, props2.style]
      }, responsiveProps, {
        "aspectRatio": aspectRatio.value,
        "aria-label": props2.alt,
        "role": props2.alt ? "img" : void 0
      }), {
        additional: () => createVNode(Fragment, null, [createVNode(__image, null, null), createVNode(__preloadImage, null, null), createVNode(__gradient, null, null), createVNode(__placeholder, null, null), createVNode(__error, null, null)]),
        default: slots.default
      }), [[resolveDirective("intersect"), {
        handler: init,
        options: props2.options
      }, null, {
        once: true
      }]]);
    });
    return {
      currentSrc,
      image,
      state,
      naturalWidth,
      naturalHeight
    };
  }
});
const makeBorderProps = propsFactory({
  border: [Boolean, Number, String]
}, "border");
function useBorder(props2) {
  let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
  const borderClasses = computed(() => {
    const border = isRef(props2) ? props2.value : props2.border;
    const classes = [];
    if (border === true || border === "") {
      classes.push(`${name}--border`);
    } else if (typeof border === "string" || border === 0) {
      for (const value of String(border).split(" ")) {
        classes.push(`border-${value}`);
      }
    }
    return classes;
  });
  return {
    borderClasses
  };
}
function useColor(colors2) {
  return destructComputed(() => {
    const classes = [];
    const styles = {};
    if (colors2.value.background) {
      if (isCssColor(colors2.value.background)) {
        styles.backgroundColor = colors2.value.background;
        if (!colors2.value.text) {
          const backgroundColor = parseColor(colors2.value.background);
          if (backgroundColor.a == null || backgroundColor.a === 1) {
            const textColor = getForeground(backgroundColor);
            styles.color = textColor;
            styles.caretColor = textColor;
          }
        }
      } else {
        classes.push(`bg-${colors2.value.background}`);
      }
    }
    if (colors2.value.text) {
      if (isCssColor(colors2.value.text)) {
        styles.color = colors2.value.text;
        styles.caretColor = colors2.value.text;
      } else {
        classes.push(`text-${colors2.value.text}`);
      }
    }
    return {
      colorClasses: classes,
      colorStyles: styles
    };
  });
}
function useTextColor(props2, name) {
  const colors2 = computed(() => ({
    text: isRef(props2) ? props2.value : name ? props2[name] : null
  }));
  const {
    colorClasses: textColorClasses,
    colorStyles: textColorStyles
  } = useColor(colors2);
  return {
    textColorClasses,
    textColorStyles
  };
}
function useBackgroundColor(props2, name) {
  const colors2 = computed(() => ({
    background: isRef(props2) ? props2.value : name ? props2[name] : null
  }));
  const {
    colorClasses: backgroundColorClasses,
    colorStyles: backgroundColorStyles
  } = useColor(colors2);
  return {
    backgroundColorClasses,
    backgroundColorStyles
  };
}
const makeElevationProps = propsFactory({
  elevation: {
    type: [Number, String],
    validator(v2) {
      const value = parseInt(v2);
      return !isNaN(value) && value >= 0 && // Material Design has a maximum elevation of 24
      // https://material.io/design/environment/elevation.html#default-elevations
      value <= 24;
    }
  }
}, "elevation");
function useElevation(props2) {
  const elevationClasses = computed(() => {
    const elevation = isRef(props2) ? props2.value : props2.elevation;
    const classes = [];
    if (elevation == null)
      return classes;
    classes.push(`elevation-${elevation}`);
    return classes;
  });
  return {
    elevationClasses
  };
}
const makeRoundedProps = propsFactory({
  rounded: {
    type: [Boolean, Number, String],
    default: void 0
  }
}, "rounded");
function useRounded(props2) {
  let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
  const roundedClasses = computed(() => {
    const rounded = isRef(props2) ? props2.value : props2.rounded;
    const classes = [];
    if (rounded === true || rounded === "") {
      classes.push(`${name}--rounded`);
    } else if (typeof rounded === "string" || rounded === 0) {
      for (const value of String(rounded).split(" ")) {
        classes.push(`rounded-${value}`);
      }
    }
    return classes;
  });
  return {
    roundedClasses
  };
}
const allowedDensities$1 = [null, "prominent", "default", "comfortable", "compact"];
const makeVToolbarProps = propsFactory({
  absolute: Boolean,
  collapse: Boolean,
  color: String,
  density: {
    type: String,
    default: "default",
    validator: (v2) => allowedDensities$1.includes(v2)
  },
  extended: Boolean,
  extensionHeight: {
    type: [Number, String],
    default: 48
  },
  flat: Boolean,
  floating: Boolean,
  height: {
    type: [Number, String],
    default: 64
  },
  image: String,
  title: String,
  ...makeBorderProps(),
  ...makeComponentProps(),
  ...makeElevationProps(),
  ...makeRoundedProps(),
  ...makeTagProps({
    tag: "header"
  }),
  ...makeThemeProps()
}, "VToolbar");
const VToolbar = genericComponent()({
  name: "VToolbar",
  props: makeVToolbarProps(),
  setup(props2, _ref) {
    var _a2;
    let {
      slots
    } = _ref;
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props2, "color"));
    const {
      borderClasses
    } = useBorder(props2);
    const {
      elevationClasses
    } = useElevation(props2);
    const {
      roundedClasses
    } = useRounded(props2);
    const {
      themeClasses
    } = provideTheme(props2);
    const {
      rtlClasses
    } = useRtl();
    const isExtended = shallowRef(!!(props2.extended || ((_a2 = slots.extension) == null ? void 0 : _a2.call(slots))));
    const contentHeight = computed(() => parseInt(Number(props2.height) + (props2.density === "prominent" ? Number(props2.height) : 0) - (props2.density === "comfortable" ? 8 : 0) - (props2.density === "compact" ? 16 : 0), 10));
    const extensionHeight = computed(() => isExtended.value ? parseInt(Number(props2.extensionHeight) + (props2.density === "prominent" ? Number(props2.extensionHeight) : 0) - (props2.density === "comfortable" ? 4 : 0) - (props2.density === "compact" ? 8 : 0), 10) : 0);
    provideDefaults({
      VBtn: {
        variant: "text"
      }
    });
    useRender(() => {
      var _a3;
      const hasTitle = !!(props2.title || slots.title);
      const hasImage = !!(slots.image || props2.image);
      const extension = (_a3 = slots.extension) == null ? void 0 : _a3.call(slots);
      isExtended.value = !!(props2.extended || extension);
      return createVNode(props2.tag, {
        "class": ["v-toolbar", {
          "v-toolbar--absolute": props2.absolute,
          "v-toolbar--collapse": props2.collapse,
          "v-toolbar--flat": props2.flat,
          "v-toolbar--floating": props2.floating,
          [`v-toolbar--density-${props2.density}`]: true
        }, backgroundColorClasses.value, borderClasses.value, elevationClasses.value, roundedClasses.value, themeClasses.value, rtlClasses.value, props2.class],
        "style": [backgroundColorStyles.value, props2.style]
      }, {
        default: () => [hasImage && createVNode("div", {
          "key": "image",
          "class": "v-toolbar__image"
        }, [!slots.image ? createVNode(VImg, {
          "key": "image-img",
          "cover": true,
          "src": props2.image
        }, null) : createVNode(VDefaultsProvider, {
          "key": "image-defaults",
          "disabled": !props2.image,
          "defaults": {
            VImg: {
              cover: true,
              src: props2.image
            }
          }
        }, slots.image)]), createVNode(VDefaultsProvider, {
          "defaults": {
            VTabs: {
              height: convertToUnit(contentHeight.value)
            }
          }
        }, {
          default: () => {
            var _a4, _b, _c;
            return [createVNode("div", {
              "class": "v-toolbar__content",
              "style": {
                height: convertToUnit(contentHeight.value)
              }
            }, [slots.prepend && createVNode("div", {
              "class": "v-toolbar__prepend"
            }, [(_a4 = slots.prepend) == null ? void 0 : _a4.call(slots)]), hasTitle && createVNode(VToolbarTitle, {
              "key": "title",
              "text": props2.title
            }, {
              text: slots.title
            }), (_b = slots.default) == null ? void 0 : _b.call(slots), slots.append && createVNode("div", {
              "class": "v-toolbar__append"
            }, [(_c = slots.append) == null ? void 0 : _c.call(slots)])])];
          }
        }), createVNode(VDefaultsProvider, {
          "defaults": {
            VTabs: {
              height: convertToUnit(extensionHeight.value)
            }
          }
        }, {
          default: () => [createVNode(VExpandTransition, null, {
            default: () => [isExtended.value && createVNode("div", {
              "class": "v-toolbar__extension",
              "style": {
                height: convertToUnit(extensionHeight.value)
              }
            }, [extension])]
          })]
        })]
      });
    });
    return {
      contentHeight,
      extensionHeight
    };
  }
});
const makeScrollProps = propsFactory({
  scrollTarget: {
    type: String
  },
  scrollThreshold: {
    type: [String, Number],
    default: 300
  }
}, "scroll");
function useScroll(props2) {
  let args = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    canScroll
  } = args;
  let previousScroll = 0;
  const target = ref(null);
  const currentScroll = shallowRef(0);
  const savedScroll = shallowRef(0);
  const currentThreshold = shallowRef(0);
  const isScrollActive = shallowRef(false);
  const isScrollingUp = shallowRef(false);
  const scrollThreshold = computed(() => {
    return Number(props2.scrollThreshold);
  });
  const scrollRatio = computed(() => {
    return clamp((scrollThreshold.value - currentScroll.value) / scrollThreshold.value || 0);
  });
  const onScroll = () => {
    const targetEl = target.value;
    if (!targetEl || canScroll && !canScroll.value)
      return;
    previousScroll = currentScroll.value;
    currentScroll.value = "window" in targetEl ? targetEl.pageYOffset : targetEl.scrollTop;
    isScrollingUp.value = currentScroll.value < previousScroll;
    currentThreshold.value = Math.abs(currentScroll.value - scrollThreshold.value);
  };
  watch(isScrollingUp, () => {
    savedScroll.value = savedScroll.value || currentScroll.value;
  });
  watch(isScrollActive, () => {
    savedScroll.value = 0;
  });
  onMounted(() => {
    watch(() => props2.scrollTarget, (scrollTarget) => {
      var _a2;
      const newTarget = scrollTarget ? document.querySelector(scrollTarget) : window;
      if (!newTarget) {
        return;
      }
      if (newTarget === target.value)
        return;
      (_a2 = target.value) == null ? void 0 : _a2.removeEventListener("scroll", onScroll);
      target.value = newTarget;
      target.value.addEventListener("scroll", onScroll, {
        passive: true
      });
    }, {
      immediate: true
    });
  });
  onBeforeUnmount(() => {
    var _a2;
    (_a2 = target.value) == null ? void 0 : _a2.removeEventListener("scroll", onScroll);
  });
  canScroll && watch(canScroll, onScroll, {
    immediate: true
  });
  return {
    scrollThreshold,
    currentScroll,
    currentThreshold,
    isScrollActive,
    scrollRatio,
    // required only for testing
    // probably can be removed
    // later (2 chars chlng)
    isScrollingUp,
    savedScroll
  };
}
function useSsrBoot() {
  const isBooted = shallowRef(false);
  onMounted(() => {
    window.requestAnimationFrame(() => {
      isBooted.value = true;
    });
  });
  const ssrBootStyles = computed(() => !isBooted.value ? {
    transition: "none !important"
  } : void 0);
  return {
    ssrBootStyles,
    isBooted: readonly(isBooted)
  };
}
const makeVAppBarProps = propsFactory({
  scrollBehavior: String,
  modelValue: {
    type: Boolean,
    default: true
  },
  location: {
    type: String,
    default: "top",
    validator: (value) => ["top", "bottom"].includes(value)
  },
  ...makeVToolbarProps(),
  ...makeLayoutItemProps(),
  ...makeScrollProps(),
  height: {
    type: [Number, String],
    default: 64
  }
}, "VAppBar");
const VAppBar = genericComponent()({
  name: "VAppBar",
  props: makeVAppBarProps(),
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const vToolbarRef = ref();
    const isActive = useProxiedModel(props2, "modelValue");
    const scrollBehavior = computed(() => {
      var _a2;
      const behavior = new Set(((_a2 = props2.scrollBehavior) == null ? void 0 : _a2.split(" ")) ?? []);
      return {
        hide: behavior.has("hide"),
        // fullyHide: behavior.has('fully-hide'),
        inverted: behavior.has("inverted"),
        collapse: behavior.has("collapse"),
        elevate: behavior.has("elevate"),
        fadeImage: behavior.has("fade-image")
        // shrink: behavior.has('shrink'),
      };
    });
    const canScroll = computed(() => {
      const behavior = scrollBehavior.value;
      return behavior.hide || // behavior.fullyHide ||
      behavior.inverted || behavior.collapse || behavior.elevate || behavior.fadeImage || // behavior.shrink ||
      !isActive.value;
    });
    const {
      currentScroll,
      scrollThreshold,
      isScrollingUp,
      scrollRatio
    } = useScroll(props2, {
      canScroll
    });
    const isCollapsed = computed(() => props2.collapse || scrollBehavior.value.collapse && (scrollBehavior.value.inverted ? scrollRatio.value > 0 : scrollRatio.value === 0));
    const isFlat = computed(() => props2.flat || scrollBehavior.value.elevate && (scrollBehavior.value.inverted ? currentScroll.value > 0 : currentScroll.value === 0));
    const opacity = computed(() => scrollBehavior.value.fadeImage ? scrollBehavior.value.inverted ? 1 - scrollRatio.value : scrollRatio.value : void 0);
    const height = computed(() => {
      var _a2, _b;
      if (scrollBehavior.value.hide && scrollBehavior.value.inverted)
        return 0;
      const height2 = ((_a2 = vToolbarRef.value) == null ? void 0 : _a2.contentHeight) ?? 0;
      const extensionHeight = ((_b = vToolbarRef.value) == null ? void 0 : _b.extensionHeight) ?? 0;
      return height2 + extensionHeight;
    });
    useToggleScope(computed(() => !!props2.scrollBehavior), () => {
      watchEffect(() => {
        if (scrollBehavior.value.hide) {
          if (scrollBehavior.value.inverted) {
            isActive.value = currentScroll.value > scrollThreshold.value;
          } else {
            isActive.value = isScrollingUp.value || currentScroll.value < scrollThreshold.value;
          }
        } else {
          isActive.value = true;
        }
      });
    });
    const {
      ssrBootStyles
    } = useSsrBoot();
    const {
      layoutItemStyles
    } = useLayoutItem({
      id: props2.name,
      order: computed(() => parseInt(props2.order, 10)),
      position: toRef(props2, "location"),
      layoutSize: height,
      elementSize: shallowRef(void 0),
      active: isActive,
      absolute: toRef(props2, "absolute")
    });
    useRender(() => {
      const [toolbarProps] = VToolbar.filterProps(props2);
      return createVNode(VToolbar, mergeProps({
        "ref": vToolbarRef,
        "class": ["v-app-bar", {
          "v-app-bar--bottom": props2.location === "bottom"
        }, props2.class],
        "style": [{
          ...layoutItemStyles.value,
          "--v-toolbar-image-opacity": opacity.value,
          height: void 0,
          ...ssrBootStyles.value
        }, props2.style]
      }, toolbarProps, {
        "collapse": isCollapsed.value,
        "flat": isFlat.value
      }), slots);
    });
    return {};
  }
});
const VBtn$1 = "";
const VBtnToggle$1 = "";
const VBtnGroup$1 = "";
const allowedDensities = [null, "default", "comfortable", "compact"];
const makeDensityProps = propsFactory({
  density: {
    type: String,
    default: "default",
    validator: (v2) => allowedDensities.includes(v2)
  }
}, "density");
function useDensity(props2) {
  let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
  const densityClasses = computed(() => {
    return `${name}--density-${props2.density}`;
  });
  return {
    densityClasses
  };
}
const allowedVariants$2 = ["elevated", "flat", "tonal", "outlined", "text", "plain"];
function genOverlays(isClickable, name) {
  return createVNode(Fragment, null, [isClickable && createVNode("span", {
    "key": "overlay",
    "class": `${name}__overlay`
  }, null), createVNode("span", {
    "key": "underlay",
    "class": `${name}__underlay`
  }, null)]);
}
const makeVariantProps = propsFactory({
  color: String,
  variant: {
    type: String,
    default: "elevated",
    validator: (v2) => allowedVariants$2.includes(v2)
  }
}, "variant");
function useVariant(props2) {
  let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
  const variantClasses = computed(() => {
    const {
      variant
    } = unref(props2);
    return `${name}--variant-${variant}`;
  });
  const {
    colorClasses,
    colorStyles
  } = useColor(computed(() => {
    const {
      variant,
      color
    } = unref(props2);
    return {
      [["elevated", "flat"].includes(variant) ? "background" : "text"]: color
    };
  }));
  return {
    colorClasses,
    colorStyles,
    variantClasses
  };
}
const makeVBtnGroupProps = propsFactory({
  divided: Boolean,
  ...makeBorderProps(),
  ...makeComponentProps(),
  ...makeDensityProps(),
  ...makeElevationProps(),
  ...makeRoundedProps(),
  ...makeTagProps(),
  ...makeThemeProps(),
  ...makeVariantProps()
}, "VBtnGroup");
const VBtnGroup = genericComponent()({
  name: "VBtnGroup",
  props: makeVBtnGroupProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props2);
    const {
      densityClasses
    } = useDensity(props2);
    const {
      borderClasses
    } = useBorder(props2);
    const {
      elevationClasses
    } = useElevation(props2);
    const {
      roundedClasses
    } = useRounded(props2);
    provideDefaults({
      VBtn: {
        height: "auto",
        color: toRef(props2, "color"),
        density: toRef(props2, "density"),
        flat: true,
        variant: toRef(props2, "variant")
      }
    });
    useRender(() => {
      return createVNode(props2.tag, {
        "class": ["v-btn-group", {
          "v-btn-group--divided": props2.divided
        }, themeClasses.value, borderClasses.value, densityClasses.value, elevationClasses.value, roundedClasses.value, props2.class],
        "style": props2.style
      }, slots);
    });
  }
});
const makeGroupProps = propsFactory({
  modelValue: {
    type: null,
    default: void 0
  },
  multiple: Boolean,
  mandatory: [Boolean, String],
  max: Number,
  selectedClass: String,
  disabled: Boolean
}, "group");
const makeGroupItemProps = propsFactory({
  value: null,
  disabled: Boolean,
  selectedClass: String
}, "group-item");
function useGroupItem(props2, injectKey) {
  let required = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  const vm = getCurrentInstance("useGroupItem");
  if (!vm) {
    throw new Error("[Vuetify] useGroupItem composable must be used inside a component setup function");
  }
  const id = getUid();
  provide(Symbol.for(`${injectKey.description}:id`), id);
  const group = inject$1(injectKey, null);
  if (!group) {
    if (!required)
      return group;
    throw new Error(`[Vuetify] Could not find useGroup injection with symbol ${injectKey.description}`);
  }
  const value = toRef(props2, "value");
  const disabled = computed(() => !!(group.disabled.value || props2.disabled));
  group.register({
    id,
    value,
    disabled
  }, vm);
  onBeforeUnmount(() => {
    group.unregister(id);
  });
  const isSelected = computed(() => {
    return group.isSelected(id);
  });
  const selectedClass = computed(() => isSelected.value && [group.selectedClass.value, props2.selectedClass]);
  watch(isSelected, (value2) => {
    vm.emit("group:selected", {
      value: value2
    });
  });
  return {
    id,
    isSelected,
    toggle: () => group.select(id, !isSelected.value),
    select: (value2) => group.select(id, value2),
    selectedClass,
    value,
    disabled,
    group
  };
}
function useGroup(props2, injectKey) {
  let isUnmounted = false;
  const items = reactive([]);
  const selected = useProxiedModel(props2, "modelValue", [], (v2) => {
    if (v2 == null)
      return [];
    return getIds(items, wrapInArray(v2));
  }, (v2) => {
    const arr = getValues(items, v2);
    return props2.multiple ? arr : arr[0];
  });
  const groupVm = getCurrentInstance("useGroup");
  function register(item, vm) {
    const unwrapped = item;
    const key2 = Symbol.for(`${injectKey.description}:id`);
    const children = findChildrenWithProvide(key2, groupVm == null ? void 0 : groupVm.vnode);
    const index2 = children.indexOf(vm);
    if (index2 > -1) {
      items.splice(index2, 0, unwrapped);
    } else {
      items.push(unwrapped);
    }
  }
  function unregister(id) {
    if (isUnmounted)
      return;
    forceMandatoryValue();
    const index2 = items.findIndex((item) => item.id === id);
    items.splice(index2, 1);
  }
  function forceMandatoryValue() {
    const item = items.find((item2) => !item2.disabled);
    if (item && props2.mandatory === "force" && !selected.value.length) {
      selected.value = [item.id];
    }
  }
  onMounted(() => {
    forceMandatoryValue();
  });
  onBeforeUnmount(() => {
    isUnmounted = true;
  });
  function select(id, value) {
    const item = items.find((item2) => item2.id === id);
    if (value && (item == null ? void 0 : item.disabled))
      return;
    if (props2.multiple) {
      const internalValue = selected.value.slice();
      const index2 = internalValue.findIndex((v2) => v2 === id);
      const isSelected = ~index2;
      value = value ?? !isSelected;
      if (isSelected && props2.mandatory && internalValue.length <= 1)
        return;
      if (!isSelected && props2.max != null && internalValue.length + 1 > props2.max)
        return;
      if (index2 < 0 && value)
        internalValue.push(id);
      else if (index2 >= 0 && !value)
        internalValue.splice(index2, 1);
      selected.value = internalValue;
    } else {
      const isSelected = selected.value.includes(id);
      if (props2.mandatory && isSelected)
        return;
      selected.value = value ?? !isSelected ? [id] : [];
    }
  }
  function step(offset) {
    if (props2.multiple)
      ;
    if (!selected.value.length) {
      const item = items.find((item2) => !item2.disabled);
      item && (selected.value = [item.id]);
    } else {
      const currentId = selected.value[0];
      const currentIndex = items.findIndex((i) => i.id === currentId);
      let newIndex2 = (currentIndex + offset) % items.length;
      let newItem = items[newIndex2];
      while (newItem.disabled && newIndex2 !== currentIndex) {
        newIndex2 = (newIndex2 + offset) % items.length;
        newItem = items[newIndex2];
      }
      if (newItem.disabled)
        return;
      selected.value = [items[newIndex2].id];
    }
  }
  const state = {
    register,
    unregister,
    selected,
    select,
    disabled: toRef(props2, "disabled"),
    prev: () => step(items.length - 1),
    next: () => step(1),
    isSelected: (id) => selected.value.includes(id),
    selectedClass: computed(() => props2.selectedClass),
    items: computed(() => items),
    getItemIndex: (value) => getItemIndex(items, value)
  };
  provide(injectKey, state);
  return state;
}
function getItemIndex(items, value) {
  const ids = getIds(items, [value]);
  if (!ids.length)
    return -1;
  return items.findIndex((item) => item.id === ids[0]);
}
function getIds(items, modelValue) {
  const ids = [];
  modelValue.forEach((value) => {
    const item = items.find((item2) => deepEqual(value, item2.value));
    const itemByIndex = items[value];
    if ((item == null ? void 0 : item.value) != null) {
      ids.push(item.id);
    } else if (itemByIndex != null) {
      ids.push(itemByIndex.id);
    }
  });
  return ids;
}
function getValues(items, ids) {
  const values = [];
  ids.forEach((id) => {
    const itemIndex = items.findIndex((item) => item.id === id);
    if (~itemIndex) {
      const item = items[itemIndex];
      values.push(item.value != null ? item.value : itemIndex);
    }
  });
  return values;
}
const VBtnToggleSymbol = Symbol.for("vuetify:v-btn-toggle");
const makeVBtnToggleProps = propsFactory({
  ...makeVBtnGroupProps(),
  ...makeGroupProps()
}, "VBtnToggle");
const VBtnToggle = genericComponent()({
  name: "VBtnToggle",
  props: makeVBtnToggleProps(),
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      isSelected,
      next,
      prev,
      select,
      selected
    } = useGroup(props2, VBtnToggleSymbol);
    useRender(() => {
      const [btnGroupProps] = VBtnGroup.filterProps(props2);
      return createVNode(VBtnGroup, mergeProps({
        "class": ["v-btn-toggle", props2.class]
      }, btnGroupProps, {
        "style": props2.style
      }), {
        default: () => {
          var _a2;
          return [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
            isSelected,
            next,
            prev,
            select,
            selected
          })];
        }
      });
    });
    return {
      next,
      prev,
      select
    };
  }
});
const VIcon$1 = "";
const predefinedSizes = ["x-small", "small", "default", "large", "x-large"];
const makeSizeProps = propsFactory({
  size: {
    type: [String, Number],
    default: "default"
  }
}, "size");
function useSize(props2) {
  let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
  return destructComputed(() => {
    let sizeClasses;
    let sizeStyles;
    if (includes(predefinedSizes, props2.size)) {
      sizeClasses = `${name}--size-${props2.size}`;
    } else if (props2.size) {
      sizeStyles = {
        width: convertToUnit(props2.size),
        height: convertToUnit(props2.size)
      };
    }
    return {
      sizeClasses,
      sizeStyles
    };
  });
}
const makeVIconProps = propsFactory({
  color: String,
  start: Boolean,
  end: Boolean,
  icon: IconValue,
  ...makeComponentProps(),
  ...makeSizeProps(),
  ...makeTagProps({
    tag: "i"
  }),
  ...makeThemeProps()
}, "VIcon");
const VIcon = genericComponent()({
  name: "VIcon",
  props: makeVIconProps(),
  setup(props2, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const slotIcon = ref();
    const {
      themeClasses
    } = provideTheme(props2);
    const {
      iconData
    } = useIcon(computed(() => slotIcon.value || props2.icon));
    const {
      sizeClasses
    } = useSize(props2);
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(toRef(props2, "color"));
    useRender(() => {
      var _a2, _b;
      const slotValue = (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
      if (slotValue) {
        slotIcon.value = (_b = flattenFragments(slotValue).filter((node) => node.type === Text && node.children && typeof node.children === "string")[0]) == null ? void 0 : _b.children;
      }
      return createVNode(iconData.value.component, {
        "tag": props2.tag,
        "icon": iconData.value.icon,
        "class": ["v-icon", "notranslate", themeClasses.value, sizeClasses.value, textColorClasses.value, {
          "v-icon--clickable": !!attrs.onClick,
          "v-icon--start": props2.start,
          "v-icon--end": props2.end
        }, props2.class],
        "style": [!sizeClasses.value ? {
          fontSize: convertToUnit(props2.size),
          height: convertToUnit(props2.size),
          width: convertToUnit(props2.size)
        } : void 0, textColorStyles.value, props2.style],
        "role": attrs.onClick ? "button" : void 0,
        "aria-hidden": !attrs.onClick
      }, {
        default: () => [slotValue]
      });
    });
    return {};
  }
});
const VProgressCircular$1 = "";
function useIntersectionObserver(callback, options) {
  const intersectionRef = ref();
  const isIntersecting = shallowRef(false);
  if (SUPPORTS_INTERSECTION) {
    const observer = new IntersectionObserver((entries) => {
      callback == null ? void 0 : callback(entries, observer);
      isIntersecting.value = !!entries.find((entry) => entry.isIntersecting);
    }, options);
    onBeforeUnmount(() => {
      observer.disconnect();
    });
    watch(intersectionRef, (newValue, oldValue) => {
      if (oldValue) {
        observer.unobserve(oldValue);
        isIntersecting.value = false;
      }
      if (newValue)
        observer.observe(newValue);
    }, {
      flush: "post"
    });
  }
  return {
    intersectionRef,
    isIntersecting
  };
}
const makeVProgressCircularProps = propsFactory({
  bgColor: String,
  color: String,
  indeterminate: [Boolean, String],
  modelValue: {
    type: [Number, String],
    default: 0
  },
  rotate: {
    type: [Number, String],
    default: 0
  },
  width: {
    type: [Number, String],
    default: 4
  },
  ...makeComponentProps(),
  ...makeSizeProps(),
  ...makeTagProps({
    tag: "div"
  }),
  ...makeThemeProps()
}, "VProgressCircular");
const VProgressCircular = genericComponent()({
  name: "VProgressCircular",
  props: makeVProgressCircularProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const MAGIC_RADIUS_CONSTANT = 20;
    const CIRCUMFERENCE = 2 * Math.PI * MAGIC_RADIUS_CONSTANT;
    const root2 = ref();
    const {
      themeClasses
    } = provideTheme(props2);
    const {
      sizeClasses,
      sizeStyles
    } = useSize(props2);
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(toRef(props2, "color"));
    const {
      textColorClasses: underlayColorClasses,
      textColorStyles: underlayColorStyles
    } = useTextColor(toRef(props2, "bgColor"));
    const {
      intersectionRef,
      isIntersecting
    } = useIntersectionObserver();
    const {
      resizeRef,
      contentRect
    } = useResizeObserver();
    const normalizedValue = computed(() => Math.max(0, Math.min(100, parseFloat(props2.modelValue))));
    const width = computed(() => Number(props2.width));
    const size2 = computed(() => {
      return sizeStyles.value ? Number(props2.size) : contentRect.value ? contentRect.value.width : Math.max(width.value, 32);
    });
    const diameter = computed(() => MAGIC_RADIUS_CONSTANT / (1 - width.value / size2.value) * 2);
    const strokeWidth = computed(() => width.value / size2.value * diameter.value);
    const strokeDashOffset = computed(() => convertToUnit((100 - normalizedValue.value) / 100 * CIRCUMFERENCE));
    watchEffect(() => {
      intersectionRef.value = root2.value;
      resizeRef.value = root2.value;
    });
    useRender(() => createVNode(props2.tag, {
      "ref": root2,
      "class": ["v-progress-circular", {
        "v-progress-circular--indeterminate": !!props2.indeterminate,
        "v-progress-circular--visible": isIntersecting.value,
        "v-progress-circular--disable-shrink": props2.indeterminate === "disable-shrink"
      }, themeClasses.value, sizeClasses.value, textColorClasses.value, props2.class],
      "style": [sizeStyles.value, textColorStyles.value, props2.style],
      "role": "progressbar",
      "aria-valuemin": "0",
      "aria-valuemax": "100",
      "aria-valuenow": props2.indeterminate ? void 0 : normalizedValue.value
    }, {
      default: () => [createVNode("svg", {
        "style": {
          transform: `rotate(calc(-90deg + ${Number(props2.rotate)}deg))`
        },
        "xmlns": "http://www.w3.org/2000/svg",
        "viewBox": `0 0 ${diameter.value} ${diameter.value}`
      }, [createVNode("circle", {
        "class": ["v-progress-circular__underlay", underlayColorClasses.value],
        "style": underlayColorStyles.value,
        "fill": "transparent",
        "cx": "50%",
        "cy": "50%",
        "r": MAGIC_RADIUS_CONSTANT,
        "stroke-width": strokeWidth.value,
        "stroke-dasharray": CIRCUMFERENCE,
        "stroke-dashoffset": 0
      }, null), createVNode("circle", {
        "class": "v-progress-circular__overlay",
        "fill": "transparent",
        "cx": "50%",
        "cy": "50%",
        "r": MAGIC_RADIUS_CONSTANT,
        "stroke-width": strokeWidth.value,
        "stroke-dasharray": CIRCUMFERENCE,
        "stroke-dashoffset": strokeDashOffset.value
      }, null)]), slots.default && createVNode("div", {
        "class": "v-progress-circular__content"
      }, [slots.default({
        value: normalizedValue.value
      })])]
    }));
    return {};
  }
});
const VProgressLinear$1 = "";
const oppositeMap = {
  center: "center",
  top: "bottom",
  bottom: "top",
  left: "right",
  right: "left"
};
const makeLocationProps = propsFactory({
  location: String
}, "location");
function useLocation(props2) {
  let opposite = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  let offset = arguments.length > 2 ? arguments[2] : void 0;
  const {
    isRtl
  } = useRtl();
  const locationStyles = computed(() => {
    if (!props2.location)
      return {};
    const {
      side,
      align
    } = parseAnchor(props2.location.split(" ").length > 1 ? props2.location : `${props2.location} center`, isRtl.value);
    function getOffset2(side2) {
      return offset ? offset(side2) : 0;
    }
    const styles = {};
    if (side !== "center") {
      if (opposite)
        styles[oppositeMap[side]] = `calc(100% - ${getOffset2(side)}px)`;
      else
        styles[side] = 0;
    }
    if (align !== "center") {
      if (opposite)
        styles[oppositeMap[align]] = `calc(100% - ${getOffset2(align)}px)`;
      else
        styles[align] = 0;
    } else {
      if (side === "center")
        styles.top = styles.left = "50%";
      else {
        styles[{
          top: "left",
          bottom: "left",
          left: "top",
          right: "top"
        }[side]] = "50%";
      }
      styles.transform = {
        top: "translateX(-50%)",
        bottom: "translateX(-50%)",
        left: "translateY(-50%)",
        right: "translateY(-50%)",
        center: "translate(-50%, -50%)"
      }[side];
    }
    return styles;
  });
  return {
    locationStyles
  };
}
const makeVProgressLinearProps = propsFactory({
  absolute: Boolean,
  active: {
    type: Boolean,
    default: true
  },
  bgColor: String,
  bgOpacity: [Number, String],
  bufferValue: {
    type: [Number, String],
    default: 0
  },
  clickable: Boolean,
  color: String,
  height: {
    type: [Number, String],
    default: 4
  },
  indeterminate: Boolean,
  max: {
    type: [Number, String],
    default: 100
  },
  modelValue: {
    type: [Number, String],
    default: 0
  },
  reverse: Boolean,
  stream: Boolean,
  striped: Boolean,
  roundedBar: Boolean,
  ...makeComponentProps(),
  ...makeLocationProps({
    location: "top"
  }),
  ...makeRoundedProps(),
  ...makeTagProps(),
  ...makeThemeProps()
}, "VProgressLinear");
const VProgressLinear = genericComponent()({
  name: "VProgressLinear",
  props: makeVProgressLinearProps(),
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const progress = useProxiedModel(props2, "modelValue");
    const {
      isRtl,
      rtlClasses
    } = useRtl();
    const {
      themeClasses
    } = provideTheme(props2);
    const {
      locationStyles
    } = useLocation(props2);
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(props2, "color");
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(computed(() => props2.bgColor || props2.color));
    const {
      backgroundColorClasses: barColorClasses,
      backgroundColorStyles: barColorStyles
    } = useBackgroundColor(props2, "color");
    const {
      roundedClasses
    } = useRounded(props2);
    const {
      intersectionRef,
      isIntersecting
    } = useIntersectionObserver();
    const max2 = computed(() => parseInt(props2.max, 10));
    const height = computed(() => parseInt(props2.height, 10));
    const normalizedBuffer = computed(() => parseFloat(props2.bufferValue) / max2.value * 100);
    const normalizedValue = computed(() => parseFloat(progress.value) / max2.value * 100);
    const isReversed = computed(() => isRtl.value !== props2.reverse);
    const transition = computed(() => props2.indeterminate ? "fade-transition" : "slide-x-transition");
    const opacity = computed(() => {
      return props2.bgOpacity == null ? props2.bgOpacity : parseFloat(props2.bgOpacity);
    });
    function handleClick(e) {
      if (!intersectionRef.value)
        return;
      const {
        left,
        right,
        width
      } = intersectionRef.value.getBoundingClientRect();
      const value = isReversed.value ? width - e.clientX + (right - width) : e.clientX - left;
      progress.value = Math.round(value / width * max2.value);
    }
    useRender(() => createVNode(props2.tag, {
      "ref": intersectionRef,
      "class": ["v-progress-linear", {
        "v-progress-linear--absolute": props2.absolute,
        "v-progress-linear--active": props2.active && isIntersecting.value,
        "v-progress-linear--reverse": isReversed.value,
        "v-progress-linear--rounded": props2.rounded,
        "v-progress-linear--rounded-bar": props2.roundedBar,
        "v-progress-linear--striped": props2.striped
      }, roundedClasses.value, themeClasses.value, rtlClasses.value, props2.class],
      "style": [{
        bottom: props2.location === "bottom" ? 0 : void 0,
        top: props2.location === "top" ? 0 : void 0,
        height: props2.active ? convertToUnit(height.value) : 0,
        "--v-progress-linear-height": convertToUnit(height.value),
        ...locationStyles.value
      }, props2.style],
      "role": "progressbar",
      "aria-hidden": props2.active ? "false" : "true",
      "aria-valuemin": "0",
      "aria-valuemax": props2.max,
      "aria-valuenow": props2.indeterminate ? void 0 : normalizedValue.value,
      "onClick": props2.clickable && handleClick
    }, {
      default: () => [props2.stream && createVNode("div", {
        "key": "stream",
        "class": ["v-progress-linear__stream", textColorClasses.value],
        "style": {
          ...textColorStyles.value,
          [isReversed.value ? "left" : "right"]: convertToUnit(-height.value),
          borderTop: `${convertToUnit(height.value / 2)} dotted`,
          opacity: opacity.value,
          top: `calc(50% - ${convertToUnit(height.value / 4)})`,
          width: convertToUnit(100 - normalizedBuffer.value, "%"),
          "--v-progress-linear-stream-to": convertToUnit(height.value * (isReversed.value ? 1 : -1))
        }
      }, null), createVNode("div", {
        "class": ["v-progress-linear__background", backgroundColorClasses.value],
        "style": [backgroundColorStyles.value, {
          opacity: opacity.value,
          width: convertToUnit(!props2.stream ? 100 : normalizedBuffer.value, "%")
        }]
      }, null), createVNode(Transition, {
        "name": transition.value
      }, {
        default: () => [!props2.indeterminate ? createVNode("div", {
          "class": ["v-progress-linear__determinate", barColorClasses.value],
          "style": [barColorStyles.value, {
            width: convertToUnit(normalizedValue.value, "%")
          }]
        }, null) : createVNode("div", {
          "class": "v-progress-linear__indeterminate"
        }, [["long", "short"].map((bar) => createVNode("div", {
          "key": bar,
          "class": ["v-progress-linear__indeterminate", bar, barColorClasses.value],
          "style": barColorStyles.value
        }, null))])]
      }), slots.default && createVNode("div", {
        "class": "v-progress-linear__content"
      }, [slots.default({
        value: normalizedValue.value,
        buffer: normalizedBuffer.value
      })])]
    }));
    return {};
  }
});
const makeLoaderProps = propsFactory({
  loading: [Boolean, String]
}, "loader");
function useLoader(props2) {
  let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
  const loaderClasses = computed(() => ({
    [`${name}--loading`]: props2.loading
  }));
  return {
    loaderClasses
  };
}
function LoaderSlot(props2, _ref) {
  var _a2;
  let {
    slots
  } = _ref;
  return createVNode("div", {
    "class": `${props2.name}__loader`
  }, [((_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
    color: props2.color,
    isActive: props2.active
  })) || createVNode(VProgressLinear, {
    "active": props2.active,
    "color": props2.color,
    "height": "2",
    "indeterminate": true
  }, null)]);
}
const positionValues = ["static", "relative", "fixed", "absolute", "sticky"];
const makePositionProps = propsFactory({
  position: {
    type: String,
    validator: (
      /* istanbul ignore next */
      (v2) => positionValues.includes(v2)
    )
  }
}, "position");
function usePosition(props2) {
  let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
  const positionClasses = computed(() => {
    return props2.position ? `${name}--${props2.position}` : void 0;
  });
  return {
    positionClasses
  };
}
function useRouter() {
  var _a2, _b;
  return (_b = (_a2 = getCurrentInstance("useRouter")) == null ? void 0 : _a2.proxy) == null ? void 0 : _b.$router;
}
function useLink(props2, attrs) {
  const RouterLink2 = resolveDynamicComponent("RouterLink");
  const isLink = computed(() => !!(props2.href || props2.to));
  const isClickable = computed(() => {
    return (isLink == null ? void 0 : isLink.value) || hasEvent(attrs, "click") || hasEvent(props2, "click");
  });
  if (typeof RouterLink2 === "string") {
    return {
      isLink,
      isClickable,
      href: toRef(props2, "href")
    };
  }
  const link = props2.to ? RouterLink2.useLink(props2) : void 0;
  return {
    isLink,
    isClickable,
    route: link == null ? void 0 : link.route,
    navigate: link == null ? void 0 : link.navigate,
    isActive: link && computed(() => {
      var _a2, _b;
      return props2.exact ? (_a2 = link.isExactActive) == null ? void 0 : _a2.value : (_b = link.isActive) == null ? void 0 : _b.value;
    }),
    href: computed(() => props2.to ? link == null ? void 0 : link.route.value.href : props2.href)
  };
}
const makeRouterProps = propsFactory({
  href: String,
  replace: Boolean,
  to: [String, Object],
  exact: Boolean
}, "router");
let inTransition = false;
function useBackButton(router, cb) {
  let popped = false;
  let removeBefore;
  let removeAfter;
  if (IN_BROWSER) {
    nextTick(() => {
      window.addEventListener("popstate", onPopstate);
      removeBefore = router == null ? void 0 : router.beforeEach((to, from, next) => {
        if (!inTransition) {
          setTimeout(() => popped ? cb(next) : next());
        } else {
          popped ? cb(next) : next();
        }
        inTransition = true;
      });
      removeAfter = router == null ? void 0 : router.afterEach(() => {
        inTransition = false;
      });
    });
    onScopeDispose(() => {
      window.removeEventListener("popstate", onPopstate);
      removeBefore == null ? void 0 : removeBefore();
      removeAfter == null ? void 0 : removeAfter();
    });
  }
  function onPopstate(e) {
    var _a2;
    if ((_a2 = e.state) == null ? void 0 : _a2.replaced)
      return;
    popped = true;
    setTimeout(() => popped = false);
  }
}
function useSelectLink(link, select) {
  watch(() => {
    var _a2;
    return (_a2 = link.isActive) == null ? void 0 : _a2.value;
  }, (isActive) => {
    if (link.isLink.value && isActive && select) {
      nextTick(() => {
        select(true);
      });
    }
  }, {
    immediate: true
  });
}
const VRipple = "";
const stopSymbol = Symbol("rippleStop");
const DELAY_RIPPLE = 80;
function transform(el, value) {
  el.style.transform = value;
  el.style.webkitTransform = value;
}
function isTouchEvent(e) {
  return e.constructor.name === "TouchEvent";
}
function isKeyboardEvent(e) {
  return e.constructor.name === "KeyboardEvent";
}
const calculate = function(e, el) {
  var _a2;
  let value = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  let localX = 0;
  let localY = 0;
  if (!isKeyboardEvent(e)) {
    const offset = el.getBoundingClientRect();
    const target = isTouchEvent(e) ? e.touches[e.touches.length - 1] : e;
    localX = target.clientX - offset.left;
    localY = target.clientY - offset.top;
  }
  let radius = 0;
  let scale = 0.3;
  if ((_a2 = el._ripple) == null ? void 0 : _a2.circle) {
    scale = 0.15;
    radius = el.clientWidth / 2;
    radius = value.center ? radius : radius + Math.sqrt((localX - radius) ** 2 + (localY - radius) ** 2) / 4;
  } else {
    radius = Math.sqrt(el.clientWidth ** 2 + el.clientHeight ** 2) / 2;
  }
  const centerX = `${(el.clientWidth - radius * 2) / 2}px`;
  const centerY = `${(el.clientHeight - radius * 2) / 2}px`;
  const x2 = value.center ? centerX : `${localX - radius}px`;
  const y2 = value.center ? centerY : `${localY - radius}px`;
  return {
    radius,
    scale,
    x: x2,
    y: y2,
    centerX,
    centerY
  };
};
const ripples = {
  /* eslint-disable max-statements */
  show(e, el) {
    var _a2;
    let value = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!((_a2 = el == null ? void 0 : el._ripple) == null ? void 0 : _a2.enabled)) {
      return;
    }
    const container = document.createElement("span");
    const animation = document.createElement("span");
    container.appendChild(animation);
    container.className = "v-ripple__container";
    if (value.class) {
      container.className += ` ${value.class}`;
    }
    const {
      radius,
      scale,
      x: x2,
      y: y2,
      centerX,
      centerY
    } = calculate(e, el, value);
    const size2 = `${radius * 2}px`;
    animation.className = "v-ripple__animation";
    animation.style.width = size2;
    animation.style.height = size2;
    el.appendChild(container);
    const computed2 = window.getComputedStyle(el);
    if (computed2 && computed2.position === "static") {
      el.style.position = "relative";
      el.dataset.previousPosition = "static";
    }
    animation.classList.add("v-ripple__animation--enter");
    animation.classList.add("v-ripple__animation--visible");
    transform(animation, `translate(${x2}, ${y2}) scale3d(${scale},${scale},${scale})`);
    animation.dataset.activated = String(performance.now());
    setTimeout(() => {
      animation.classList.remove("v-ripple__animation--enter");
      animation.classList.add("v-ripple__animation--in");
      transform(animation, `translate(${centerX}, ${centerY}) scale3d(1,1,1)`);
    }, 0);
  },
  hide(el) {
    var _a2;
    if (!((_a2 = el == null ? void 0 : el._ripple) == null ? void 0 : _a2.enabled))
      return;
    const ripples2 = el.getElementsByClassName("v-ripple__animation");
    if (ripples2.length === 0)
      return;
    const animation = ripples2[ripples2.length - 1];
    if (animation.dataset.isHiding)
      return;
    else
      animation.dataset.isHiding = "true";
    const diff = performance.now() - Number(animation.dataset.activated);
    const delay = Math.max(250 - diff, 0);
    setTimeout(() => {
      animation.classList.remove("v-ripple__animation--in");
      animation.classList.add("v-ripple__animation--out");
      setTimeout(() => {
        var _a3;
        const ripples3 = el.getElementsByClassName("v-ripple__animation");
        if (ripples3.length === 1 && el.dataset.previousPosition) {
          el.style.position = el.dataset.previousPosition;
          delete el.dataset.previousPosition;
        }
        if (((_a3 = animation.parentNode) == null ? void 0 : _a3.parentNode) === el)
          el.removeChild(animation.parentNode);
      }, 300);
    }, delay);
  }
};
function isRippleEnabled(value) {
  return typeof value === "undefined" || !!value;
}
function rippleShow(e) {
  const value = {};
  const element = e.currentTarget;
  if (!(element == null ? void 0 : element._ripple) || element._ripple.touched || e[stopSymbol])
    return;
  e[stopSymbol] = true;
  if (isTouchEvent(e)) {
    element._ripple.touched = true;
    element._ripple.isTouch = true;
  } else {
    if (element._ripple.isTouch)
      return;
  }
  value.center = element._ripple.centered || isKeyboardEvent(e);
  if (element._ripple.class) {
    value.class = element._ripple.class;
  }
  if (isTouchEvent(e)) {
    if (element._ripple.showTimerCommit)
      return;
    element._ripple.showTimerCommit = () => {
      ripples.show(e, element, value);
    };
    element._ripple.showTimer = window.setTimeout(() => {
      var _a2;
      if ((_a2 = element == null ? void 0 : element._ripple) == null ? void 0 : _a2.showTimerCommit) {
        element._ripple.showTimerCommit();
        element._ripple.showTimerCommit = null;
      }
    }, DELAY_RIPPLE);
  } else {
    ripples.show(e, element, value);
  }
}
function rippleStop(e) {
  e[stopSymbol] = true;
}
function rippleHide(e) {
  const element = e.currentTarget;
  if (!(element == null ? void 0 : element._ripple))
    return;
  window.clearTimeout(element._ripple.showTimer);
  if (e.type === "touchend" && element._ripple.showTimerCommit) {
    element._ripple.showTimerCommit();
    element._ripple.showTimerCommit = null;
    element._ripple.showTimer = window.setTimeout(() => {
      rippleHide(e);
    });
    return;
  }
  window.setTimeout(() => {
    if (element._ripple) {
      element._ripple.touched = false;
    }
  });
  ripples.hide(element);
}
function rippleCancelShow(e) {
  const element = e.currentTarget;
  if (!(element == null ? void 0 : element._ripple))
    return;
  if (element._ripple.showTimerCommit) {
    element._ripple.showTimerCommit = null;
  }
  window.clearTimeout(element._ripple.showTimer);
}
let keyboardRipple = false;
function keyboardRippleShow(e) {
  if (!keyboardRipple && (e.keyCode === keyCodes.enter || e.keyCode === keyCodes.space)) {
    keyboardRipple = true;
    rippleShow(e);
  }
}
function keyboardRippleHide(e) {
  keyboardRipple = false;
  rippleHide(e);
}
function focusRippleHide(e) {
  if (keyboardRipple) {
    keyboardRipple = false;
    rippleHide(e);
  }
}
function updateRipple(el, binding, wasEnabled) {
  const {
    value,
    modifiers
  } = binding;
  const enabled = isRippleEnabled(value);
  if (!enabled) {
    ripples.hide(el);
  }
  el._ripple = el._ripple ?? {};
  el._ripple.enabled = enabled;
  el._ripple.centered = modifiers.center;
  el._ripple.circle = modifiers.circle;
  if (isObject(value) && value.class) {
    el._ripple.class = value.class;
  }
  if (enabled && !wasEnabled) {
    if (modifiers.stop) {
      el.addEventListener("touchstart", rippleStop, {
        passive: true
      });
      el.addEventListener("mousedown", rippleStop);
      return;
    }
    el.addEventListener("touchstart", rippleShow, {
      passive: true
    });
    el.addEventListener("touchend", rippleHide, {
      passive: true
    });
    el.addEventListener("touchmove", rippleCancelShow, {
      passive: true
    });
    el.addEventListener("touchcancel", rippleHide);
    el.addEventListener("mousedown", rippleShow);
    el.addEventListener("mouseup", rippleHide);
    el.addEventListener("mouseleave", rippleHide);
    el.addEventListener("keydown", keyboardRippleShow);
    el.addEventListener("keyup", keyboardRippleHide);
    el.addEventListener("blur", focusRippleHide);
    el.addEventListener("dragstart", rippleHide, {
      passive: true
    });
  } else if (!enabled && wasEnabled) {
    removeListeners(el);
  }
}
function removeListeners(el) {
  el.removeEventListener("mousedown", rippleShow);
  el.removeEventListener("touchstart", rippleShow);
  el.removeEventListener("touchend", rippleHide);
  el.removeEventListener("touchmove", rippleCancelShow);
  el.removeEventListener("touchcancel", rippleHide);
  el.removeEventListener("mouseup", rippleHide);
  el.removeEventListener("mouseleave", rippleHide);
  el.removeEventListener("keydown", keyboardRippleShow);
  el.removeEventListener("keyup", keyboardRippleHide);
  el.removeEventListener("dragstart", rippleHide);
  el.removeEventListener("blur", focusRippleHide);
}
function mounted$4(el, binding) {
  updateRipple(el, binding, false);
}
function unmounted$4(el) {
  delete el._ripple;
  removeListeners(el);
}
function updated$1(el, binding) {
  if (binding.value === binding.oldValue) {
    return;
  }
  const wasEnabled = isRippleEnabled(binding.oldValue);
  updateRipple(el, binding, wasEnabled);
}
const Ripple = {
  mounted: mounted$4,
  unmounted: unmounted$4,
  updated: updated$1
};
const makeVBtnProps = propsFactory({
  active: {
    type: Boolean,
    default: void 0
  },
  symbol: {
    type: null,
    default: VBtnToggleSymbol
  },
  flat: Boolean,
  icon: [Boolean, String, Function, Object],
  prependIcon: IconValue,
  appendIcon: IconValue,
  block: Boolean,
  stacked: Boolean,
  ripple: {
    type: [Boolean, Object],
    default: true
  },
  text: String,
  ...makeBorderProps(),
  ...makeComponentProps(),
  ...makeDensityProps(),
  ...makeDimensionProps(),
  ...makeElevationProps(),
  ...makeGroupItemProps(),
  ...makeLoaderProps(),
  ...makeLocationProps(),
  ...makePositionProps(),
  ...makeRoundedProps(),
  ...makeRouterProps(),
  ...makeSizeProps(),
  ...makeTagProps({
    tag: "button"
  }),
  ...makeThemeProps(),
  ...makeVariantProps({
    variant: "elevated"
  })
}, "VBtn");
const VBtn = genericComponent()({
  name: "VBtn",
  directives: {
    Ripple
  },
  props: makeVBtnProps(),
  emits: {
    "group:selected": (val) => true
  },
  setup(props2, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props2);
    const {
      borderClasses
    } = useBorder(props2);
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(props2);
    const {
      densityClasses
    } = useDensity(props2);
    const {
      dimensionStyles
    } = useDimension(props2);
    const {
      elevationClasses
    } = useElevation(props2);
    const {
      loaderClasses
    } = useLoader(props2);
    const {
      locationStyles
    } = useLocation(props2);
    const {
      positionClasses
    } = usePosition(props2);
    const {
      roundedClasses
    } = useRounded(props2);
    const {
      sizeClasses,
      sizeStyles
    } = useSize(props2);
    const group = useGroupItem(props2, props2.symbol, false);
    const link = useLink(props2, attrs);
    const isActive = computed(() => {
      var _a2;
      if (props2.active !== void 0) {
        return props2.active;
      }
      if (link.isLink.value) {
        return (_a2 = link.isActive) == null ? void 0 : _a2.value;
      }
      return group == null ? void 0 : group.isSelected.value;
    });
    const isDisabled = computed(() => (group == null ? void 0 : group.disabled.value) || props2.disabled);
    const isElevated = computed(() => {
      return props2.variant === "elevated" && !(props2.disabled || props2.flat || props2.border);
    });
    const valueAttr = computed(() => {
      if (props2.value === void 0)
        return void 0;
      return Object(props2.value) === props2.value ? JSON.stringify(props2.value, null, 0) : props2.value;
    });
    function onClick(e) {
      var _a2;
      if (isDisabled.value || link.isLink.value && (e.metaKey || e.ctrlKey || e.shiftKey || e.button !== 0 || attrs.target === "_blank"))
        return;
      (_a2 = link.navigate) == null ? void 0 : _a2.call(link, e);
      group == null ? void 0 : group.toggle();
    }
    useSelectLink(link, group == null ? void 0 : group.select);
    useRender(() => {
      var _a2, _b;
      const Tag = link.isLink.value ? "a" : props2.tag;
      const hasPrepend = !!(props2.prependIcon || slots.prepend);
      const hasAppend = !!(props2.appendIcon || slots.append);
      const hasIcon = !!(props2.icon && props2.icon !== true);
      const hasColor = (group == null ? void 0 : group.isSelected.value) && (!link.isLink.value || ((_a2 = link.isActive) == null ? void 0 : _a2.value)) || !group || ((_b = link.isActive) == null ? void 0 : _b.value);
      return withDirectives(createVNode(Tag, {
        "type": Tag === "a" ? void 0 : "button",
        "class": ["v-btn", group == null ? void 0 : group.selectedClass.value, {
          "v-btn--active": isActive.value,
          "v-btn--block": props2.block,
          "v-btn--disabled": isDisabled.value,
          "v-btn--elevated": isElevated.value,
          "v-btn--flat": props2.flat,
          "v-btn--icon": !!props2.icon,
          "v-btn--loading": props2.loading,
          "v-btn--stacked": props2.stacked
        }, themeClasses.value, borderClasses.value, hasColor ? colorClasses.value : void 0, densityClasses.value, elevationClasses.value, loaderClasses.value, positionClasses.value, roundedClasses.value, sizeClasses.value, variantClasses.value, props2.class],
        "style": [hasColor ? colorStyles.value : void 0, dimensionStyles.value, locationStyles.value, sizeStyles.value, props2.style],
        "disabled": isDisabled.value || void 0,
        "href": link.href.value,
        "onClick": onClick,
        "value": valueAttr.value
      }, {
        default: () => {
          var _a3;
          return [genOverlays(true, "v-btn"), !props2.icon && hasPrepend && createVNode("span", {
            "key": "prepend",
            "class": "v-btn__prepend"
          }, [!slots.prepend ? createVNode(VIcon, {
            "key": "prepend-icon",
            "icon": props2.prependIcon
          }, null) : createVNode(VDefaultsProvider, {
            "key": "prepend-defaults",
            "disabled": !props2.prependIcon,
            "defaults": {
              VIcon: {
                icon: props2.prependIcon
              }
            }
          }, slots.prepend)]), createVNode("span", {
            "class": "v-btn__content",
            "data-no-activator": ""
          }, [!slots.default && hasIcon ? createVNode(VIcon, {
            "key": "content-icon",
            "icon": props2.icon
          }, null) : createVNode(VDefaultsProvider, {
            "key": "content-defaults",
            "disabled": !hasIcon,
            "defaults": {
              VIcon: {
                icon: props2.icon
              }
            }
          }, {
            default: () => {
              var _a4;
              return [((_a4 = slots.default) == null ? void 0 : _a4.call(slots)) ?? props2.text];
            }
          })]), !props2.icon && hasAppend && createVNode("span", {
            "key": "append",
            "class": "v-btn__append"
          }, [!slots.append ? createVNode(VIcon, {
            "key": "append-icon",
            "icon": props2.appendIcon
          }, null) : createVNode(VDefaultsProvider, {
            "key": "append-defaults",
            "disabled": !props2.appendIcon,
            "defaults": {
              VIcon: {
                icon: props2.appendIcon
              }
            }
          }, slots.append)]), !!props2.loading && createVNode("span", {
            "key": "loader",
            "class": "v-btn__loader"
          }, [((_a3 = slots.loader) == null ? void 0 : _a3.call(slots)) ?? createVNode(VProgressCircular, {
            "color": typeof props2.loading === "boolean" ? void 0 : props2.loading,
            "indeterminate": true,
            "size": "23",
            "width": "2"
          }, null)])];
        }
      }), [[resolveDirective("ripple"), !isDisabled.value && props2.ripple, null]]);
    });
    return {};
  }
});
const makeVAppBarNavIconProps = propsFactory({
  ...makeVBtnProps({
    icon: "$menu",
    variant: "text"
  })
}, "VAppBarNavIcon");
const VAppBarNavIcon = genericComponent()({
  name: "VAppBarNavIcon",
  props: makeVAppBarNavIconProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    useRender(() => createVNode(VBtn, mergeProps(props2, {
      "class": ["v-app-bar-nav-icon"]
    }), slots));
    return {};
  }
});
const VAppBarTitle = genericComponent()({
  name: "VAppBarTitle",
  props: makeVToolbarTitleProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    useRender(() => createVNode(VToolbarTitle, mergeProps(props2, {
      "class": "v-app-bar-title"
    }), slots));
    return {};
  }
});
const VAlert$1 = "";
const VAlertTitle = createSimpleFunctional("v-alert-title");
const allowedTypes = ["success", "info", "warning", "error"];
const makeVAlertProps = propsFactory({
  border: {
    type: [Boolean, String],
    validator: (val) => {
      return typeof val === "boolean" || ["top", "end", "bottom", "start"].includes(val);
    }
  },
  borderColor: String,
  closable: Boolean,
  closeIcon: {
    type: IconValue,
    default: "$close"
  },
  closeLabel: {
    type: String,
    default: "$vuetify.close"
  },
  icon: {
    type: [Boolean, String, Function, Object],
    default: null
  },
  modelValue: {
    type: Boolean,
    default: true
  },
  prominent: Boolean,
  title: String,
  text: String,
  type: {
    type: String,
    validator: (val) => allowedTypes.includes(val)
  },
  ...makeComponentProps(),
  ...makeDensityProps(),
  ...makeDimensionProps(),
  ...makeElevationProps(),
  ...makeLocationProps(),
  ...makePositionProps(),
  ...makeRoundedProps(),
  ...makeTagProps(),
  ...makeThemeProps(),
  ...makeVariantProps({
    variant: "flat"
  })
}, "VAlert");
const VAlert = genericComponent()({
  name: "VAlert",
  props: makeVAlertProps(),
  emits: {
    "click:close": (e) => true,
    "update:modelValue": (value) => true
  },
  setup(props2, _ref) {
    let {
      emit: emit2,
      slots
    } = _ref;
    const isActive = useProxiedModel(props2, "modelValue");
    const icon = computed(() => {
      if (props2.icon === false)
        return void 0;
      if (!props2.type)
        return props2.icon;
      return props2.icon ?? `$${props2.type}`;
    });
    const variantProps = computed(() => ({
      color: props2.color ?? props2.type,
      variant: props2.variant
    }));
    const {
      themeClasses
    } = provideTheme(props2);
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(variantProps);
    const {
      densityClasses
    } = useDensity(props2);
    const {
      dimensionStyles
    } = useDimension(props2);
    const {
      elevationClasses
    } = useElevation(props2);
    const {
      locationStyles
    } = useLocation(props2);
    const {
      positionClasses
    } = usePosition(props2);
    const {
      roundedClasses
    } = useRounded(props2);
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(toRef(props2, "borderColor"));
    const {
      t
    } = useLocale();
    const closeProps = computed(() => ({
      "aria-label": t(props2.closeLabel),
      onClick(e) {
        isActive.value = false;
        emit2("click:close", e);
      }
    }));
    return () => {
      const hasPrepend = !!(slots.prepend || icon.value);
      const hasTitle = !!(slots.title || props2.title);
      const hasClose = !!(slots.close || props2.closable);
      return isActive.value && createVNode(props2.tag, {
        "class": ["v-alert", props2.border && {
          "v-alert--border": !!props2.border,
          [`v-alert--border-${props2.border === true ? "start" : props2.border}`]: true
        }, {
          "v-alert--prominent": props2.prominent
        }, themeClasses.value, colorClasses.value, densityClasses.value, elevationClasses.value, positionClasses.value, roundedClasses.value, variantClasses.value, props2.class],
        "style": [colorStyles.value, dimensionStyles.value, locationStyles.value, props2.style],
        "role": "alert"
      }, {
        default: () => {
          var _a2, _b;
          return [genOverlays(false, "v-alert"), props2.border && createVNode("div", {
            "key": "border",
            "class": ["v-alert__border", textColorClasses.value],
            "style": textColorStyles.value
          }, null), hasPrepend && createVNode("div", {
            "key": "prepend",
            "class": "v-alert__prepend"
          }, [!slots.prepend ? createVNode(VIcon, {
            "key": "prepend-icon",
            "density": props2.density,
            "icon": icon.value,
            "size": props2.prominent ? 44 : 28
          }, null) : createVNode(VDefaultsProvider, {
            "key": "prepend-defaults",
            "disabled": !icon.value,
            "defaults": {
              VIcon: {
                density: props2.density,
                icon: icon.value,
                size: props2.prominent ? 44 : 28
              }
            }
          }, slots.prepend)]), createVNode("div", {
            "class": "v-alert__content"
          }, [hasTitle && createVNode(VAlertTitle, {
            "key": "title"
          }, {
            default: () => {
              var _a3;
              return [((_a3 = slots.title) == null ? void 0 : _a3.call(slots)) ?? props2.title];
            }
          }), ((_a2 = slots.text) == null ? void 0 : _a2.call(slots)) ?? props2.text, (_b = slots.default) == null ? void 0 : _b.call(slots)]), slots.append && createVNode("div", {
            "key": "append",
            "class": "v-alert__append"
          }, [slots.append()]), hasClose && createVNode("div", {
            "key": "close",
            "class": "v-alert__close"
          }, [!slots.close ? createVNode(VBtn, mergeProps({
            "key": "close-btn",
            "icon": props2.closeIcon,
            "size": "x-small",
            "variant": "text"
          }, closeProps.value), null) : createVNode(VDefaultsProvider, {
            "key": "close-defaults",
            "defaults": {
              VBtn: {
                icon: props2.closeIcon,
                size: "x-small",
                variant: "text"
              }
            }
          }, {
            default: () => {
              var _a3;
              return [(_a3 = slots.close) == null ? void 0 : _a3.call(slots, {
                props: closeProps.value
              })];
            }
          })])];
        }
      });
    };
  }
});
const VAutocomplete$1 = "";
const VCheckbox$1 = "";
const VSelectionControl$1 = "";
const VLabel$1 = "";
const makeVLabelProps = propsFactory({
  text: String,
  clickable: Boolean,
  ...makeComponentProps(),
  ...makeThemeProps()
}, "VLabel");
const VLabel = genericComponent()({
  name: "VLabel",
  props: makeVLabelProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    useRender(() => {
      var _a2;
      return createVNode("label", {
        "class": ["v-label", {
          "v-label--clickable": props2.clickable
        }, props2.class],
        "style": props2.style
      }, [props2.text, (_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
    });
    return {};
  }
});
const VSelectionControlGroup$1 = "";
const VSelectionControlGroupSymbol = Symbol.for("vuetify:selection-control-group");
const makeSelectionControlGroupProps = propsFactory({
  color: String,
  disabled: {
    type: Boolean,
    default: null
  },
  defaultsTarget: String,
  error: Boolean,
  id: String,
  inline: Boolean,
  falseIcon: IconValue,
  trueIcon: IconValue,
  ripple: {
    type: Boolean,
    default: true
  },
  multiple: {
    type: Boolean,
    default: null
  },
  name: String,
  readonly: Boolean,
  modelValue: null,
  type: String,
  valueComparator: {
    type: Function,
    default: deepEqual
  },
  ...makeComponentProps(),
  ...makeDensityProps(),
  ...makeThemeProps()
}, "SelectionControlGroup");
const makeVSelectionControlGroupProps = propsFactory({
  ...makeSelectionControlGroupProps({
    defaultsTarget: "VSelectionControl"
  })
}, "VSelectionControlGroup");
const VSelectionControlGroup = genericComponent()({
  name: "VSelectionControlGroup",
  props: makeVSelectionControlGroupProps(),
  emits: {
    "update:modelValue": (val) => true
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const modelValue = useProxiedModel(props2, "modelValue");
    const uid2 = getUid();
    const id = computed(() => props2.id || `v-selection-control-group-${uid2}`);
    const name = computed(() => props2.name || id.value);
    const updateHandlers = /* @__PURE__ */ new Set();
    provide(VSelectionControlGroupSymbol, {
      modelValue,
      forceUpdate: () => {
        updateHandlers.forEach((fn) => fn());
      },
      onForceUpdate: (cb) => {
        updateHandlers.add(cb);
        onScopeDispose(() => {
          updateHandlers.delete(cb);
        });
      }
    });
    provideDefaults({
      [props2.defaultsTarget]: {
        color: toRef(props2, "color"),
        disabled: toRef(props2, "disabled"),
        density: toRef(props2, "density"),
        error: toRef(props2, "error"),
        inline: toRef(props2, "inline"),
        modelValue,
        multiple: computed(() => !!props2.multiple || props2.multiple == null && Array.isArray(modelValue.value)),
        name,
        falseIcon: toRef(props2, "falseIcon"),
        trueIcon: toRef(props2, "trueIcon"),
        readonly: toRef(props2, "readonly"),
        ripple: toRef(props2, "ripple"),
        type: toRef(props2, "type"),
        valueComparator: toRef(props2, "valueComparator")
      }
    });
    useRender(() => {
      var _a2;
      return createVNode("div", {
        "class": ["v-selection-control-group", {
          "v-selection-control-group--inline": props2.inline
        }, props2.class],
        "style": props2.style,
        "role": props2.type === "radio" ? "radiogroup" : void 0
      }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
    });
    return {};
  }
});
const makeVSelectionControlProps = propsFactory({
  label: String,
  trueValue: null,
  falseValue: null,
  value: null,
  ...makeComponentProps(),
  ...makeSelectionControlGroupProps()
}, "VSelectionControl");
function useSelectionControl(props2) {
  const group = inject$1(VSelectionControlGroupSymbol, void 0);
  const {
    densityClasses
  } = useDensity(props2);
  const modelValue = useProxiedModel(props2, "modelValue");
  const trueValue = computed(() => props2.trueValue !== void 0 ? props2.trueValue : props2.value !== void 0 ? props2.value : true);
  const falseValue = computed(() => props2.falseValue !== void 0 ? props2.falseValue : false);
  const isMultiple = computed(() => !!props2.multiple || props2.multiple == null && Array.isArray(modelValue.value));
  const model = computed({
    get() {
      const val = group ? group.modelValue.value : modelValue.value;
      return isMultiple.value ? val.some((v2) => props2.valueComparator(v2, trueValue.value)) : props2.valueComparator(val, trueValue.value);
    },
    set(val) {
      if (props2.readonly)
        return;
      const currentValue = val ? trueValue.value : falseValue.value;
      let newVal = currentValue;
      if (isMultiple.value) {
        newVal = val ? [...wrapInArray(modelValue.value), currentValue] : wrapInArray(modelValue.value).filter((item) => !props2.valueComparator(item, trueValue.value));
      }
      if (group) {
        group.modelValue.value = newVal;
      } else {
        modelValue.value = newVal;
      }
    }
  });
  const {
    textColorClasses,
    textColorStyles
  } = useTextColor(computed(() => {
    return model.value && !props2.error && !props2.disabled ? props2.color : void 0;
  }));
  const {
    backgroundColorClasses,
    backgroundColorStyles
  } = useBackgroundColor(computed(() => {
    return model.value && !props2.error && !props2.disabled ? props2.color : void 0;
  }));
  const icon = computed(() => model.value ? props2.trueIcon : props2.falseIcon);
  return {
    group,
    densityClasses,
    trueValue,
    falseValue,
    model,
    textColorClasses,
    textColorStyles,
    backgroundColorClasses,
    backgroundColorStyles,
    icon
  };
}
const VSelectionControl = genericComponent()({
  name: "VSelectionControl",
  directives: {
    Ripple
  },
  inheritAttrs: false,
  props: makeVSelectionControlProps(),
  emits: {
    "update:modelValue": (val) => true
  },
  setup(props2, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const {
      group,
      densityClasses,
      icon,
      model,
      textColorClasses,
      textColorStyles,
      backgroundColorClasses,
      backgroundColorStyles,
      trueValue
    } = useSelectionControl(props2);
    const uid2 = getUid();
    const id = computed(() => props2.id || `input-${uid2}`);
    const isFocused = shallowRef(false);
    const isFocusVisible = shallowRef(false);
    const input = ref();
    group == null ? void 0 : group.onForceUpdate(() => {
      if (input.value) {
        input.value.checked = model.value;
      }
    });
    function onFocus(e) {
      isFocused.value = true;
      if (matchesSelector(e.target, ":focus-visible") !== false) {
        isFocusVisible.value = true;
      }
    }
    function onBlur() {
      isFocused.value = false;
      isFocusVisible.value = false;
    }
    function onInput(e) {
      if (props2.readonly && group) {
        nextTick(() => group.forceUpdate());
      }
      model.value = e.target.checked;
    }
    useRender(() => {
      var _a2, _b;
      const label = slots.label ? slots.label({
        label: props2.label,
        props: {
          for: id.value
        }
      }) : props2.label;
      const [rootAttrs, inputAttrs] = filterInputAttrs(attrs);
      const inputNode = createVNode("input", mergeProps({
        "ref": input,
        "checked": model.value,
        "disabled": !!(props2.readonly || props2.disabled),
        "id": id.value,
        "onBlur": onBlur,
        "onFocus": onFocus,
        "onInput": onInput,
        "aria-disabled": !!(props2.readonly || props2.disabled),
        "type": props2.type,
        "value": trueValue.value,
        "name": props2.name,
        "aria-checked": props2.type === "checkbox" ? model.value : void 0
      }, inputAttrs), null);
      return createVNode("div", mergeProps({
        "class": ["v-selection-control", {
          "v-selection-control--dirty": model.value,
          "v-selection-control--disabled": props2.disabled,
          "v-selection-control--error": props2.error,
          "v-selection-control--focused": isFocused.value,
          "v-selection-control--focus-visible": isFocusVisible.value,
          "v-selection-control--inline": props2.inline
        }, densityClasses.value, props2.class]
      }, rootAttrs, {
        "style": props2.style
      }), [createVNode("div", {
        "class": ["v-selection-control__wrapper", textColorClasses.value],
        "style": textColorStyles.value
      }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
        backgroundColorClasses,
        backgroundColorStyles
      }), withDirectives(createVNode("div", {
        "class": ["v-selection-control__input"]
      }, [((_b = slots.input) == null ? void 0 : _b.call(slots, {
        model,
        textColorClasses,
        textColorStyles,
        backgroundColorClasses,
        backgroundColorStyles,
        inputNode,
        icon: icon.value,
        props: {
          onFocus,
          onBlur,
          id: id.value
        }
      })) ?? createVNode(Fragment, null, [icon.value && createVNode(VIcon, {
        "key": "icon",
        "icon": icon.value
      }, null), inputNode])]), [[resolveDirective("ripple"), props2.ripple && [!props2.disabled && !props2.readonly, null, ["center", "circle"]]]])]), label && createVNode(VLabel, {
        "for": id.value,
        "clickable": true,
        "onClick": (e) => e.stopPropagation()
      }, {
        default: () => [label]
      })]);
    });
    return {
      isFocused,
      input
    };
  }
});
const makeVCheckboxBtnProps = propsFactory({
  indeterminate: Boolean,
  indeterminateIcon: {
    type: IconValue,
    default: "$checkboxIndeterminate"
  },
  ...makeVSelectionControlProps({
    falseIcon: "$checkboxOff",
    trueIcon: "$checkboxOn"
  })
}, "VCheckboxBtn");
const VCheckboxBtn = genericComponent()({
  name: "VCheckboxBtn",
  props: makeVCheckboxBtnProps(),
  emits: {
    "update:modelValue": (value) => true,
    "update:indeterminate": (val) => true
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const indeterminate = useProxiedModel(props2, "indeterminate");
    const model = useProxiedModel(props2, "modelValue");
    function onChange(v2) {
      if (indeterminate.value) {
        indeterminate.value = false;
      }
    }
    const falseIcon = computed(() => {
      return indeterminate.value ? props2.indeterminateIcon : props2.falseIcon;
    });
    const trueIcon = computed(() => {
      return indeterminate.value ? props2.indeterminateIcon : props2.trueIcon;
    });
    useRender(() => {
      const controlProps = omit(VSelectionControl.filterProps(props2)[0], ["modelValue"]);
      return createVNode(VSelectionControl, mergeProps(controlProps, {
        "modelValue": model.value,
        "onUpdate:modelValue": [($event) => model.value = $event, onChange],
        "class": ["v-checkbox-btn", props2.class],
        "style": props2.style,
        "type": "checkbox",
        "falseIcon": falseIcon.value,
        "trueIcon": trueIcon.value,
        "aria-checked": indeterminate.value ? "mixed" : void 0
      }), slots);
    });
    return {};
  }
});
const VInput$1 = "";
function useInputIcon(props2) {
  const {
    t
  } = useLocale();
  function InputIcon(_ref) {
    let {
      name
    } = _ref;
    const localeKey = {
      prepend: "prependAction",
      prependInner: "prependAction",
      append: "appendAction",
      appendInner: "appendAction",
      clear: "clear"
    }[name];
    const listener = props2[`onClick:${name}`];
    const label = listener && localeKey ? t(`$vuetify.input.${localeKey}`, props2.label ?? "") : void 0;
    return createVNode(VIcon, {
      "icon": props2[`${name}Icon`],
      "aria-label": label,
      "onClick": listener
    }, null);
  }
  return {
    InputIcon
  };
}
const VMessages$1 = "";
const makeVMessagesProps = propsFactory({
  active: Boolean,
  color: String,
  messages: {
    type: [Array, String],
    default: () => []
  },
  ...makeComponentProps(),
  ...makeTransitionProps({
    transition: {
      component: VSlideYTransition,
      leaveAbsolute: true,
      group: true
    }
  })
}, "VMessages");
const VMessages = genericComponent()({
  name: "VMessages",
  props: makeVMessagesProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const messages = computed(() => wrapInArray(props2.messages));
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(computed(() => props2.color));
    useRender(() => createVNode(MaybeTransition, {
      "transition": props2.transition,
      "tag": "div",
      "class": ["v-messages", textColorClasses.value, props2.class],
      "style": [textColorStyles.value, props2.style],
      "role": "alert",
      "aria-live": "polite"
    }, {
      default: () => [props2.active && messages.value.map((message, i) => createVNode("div", {
        "class": "v-messages__message",
        "key": `${i}-${messages.value}`
      }, [slots.message ? slots.message({
        message
      }) : message]))]
    }));
    return {};
  }
});
const makeFocusProps = propsFactory({
  focused: Boolean,
  "onUpdate:focused": EventProp()
}, "focus");
function useFocus(props2) {
  let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
  const isFocused = useProxiedModel(props2, "focused");
  const focusClasses = computed(() => {
    return {
      [`${name}--focused`]: isFocused.value
    };
  });
  function focus() {
    isFocused.value = true;
  }
  function blur() {
    isFocused.value = false;
  }
  return {
    focusClasses,
    isFocused,
    focus,
    blur
  };
}
const FormKey = Symbol.for("vuetify:form");
const makeFormProps = propsFactory({
  disabled: Boolean,
  fastFail: Boolean,
  readonly: Boolean,
  modelValue: {
    type: Boolean,
    default: null
  },
  validateOn: {
    type: String,
    default: "input"
  }
}, "form");
function createForm(props2) {
  const model = useProxiedModel(props2, "modelValue");
  const isDisabled = computed(() => props2.disabled);
  const isReadonly2 = computed(() => props2.readonly);
  const isValidating = shallowRef(false);
  const items = ref([]);
  const errors = ref([]);
  async function validate() {
    const results = [];
    let valid = true;
    errors.value = [];
    isValidating.value = true;
    for (const item of items.value) {
      const itemErrorMessages = await item.validate();
      if (itemErrorMessages.length > 0) {
        valid = false;
        results.push({
          id: item.id,
          errorMessages: itemErrorMessages
        });
      }
      if (!valid && props2.fastFail)
        break;
    }
    errors.value = results;
    isValidating.value = false;
    return {
      valid,
      errors: errors.value
    };
  }
  function reset() {
    items.value.forEach((item) => item.reset());
  }
  function resetValidation() {
    items.value.forEach((item) => item.resetValidation());
  }
  watch(items, () => {
    let valid = 0;
    let invalid = 0;
    const results = [];
    for (const item of items.value) {
      if (item.isValid === false) {
        invalid++;
        results.push({
          id: item.id,
          errorMessages: item.errorMessages
        });
      } else if (item.isValid === true)
        valid++;
    }
    errors.value = results;
    model.value = invalid > 0 ? false : valid === items.value.length ? true : null;
  }, {
    deep: true
  });
  provide(FormKey, {
    register: (_ref) => {
      let {
        id,
        validate: validate2,
        reset: reset2,
        resetValidation: resetValidation2
      } = _ref;
      if (items.value.some((item) => item.id === id))
        ;
      items.value.push({
        id,
        validate: validate2,
        reset: reset2,
        resetValidation: resetValidation2,
        isValid: null,
        errorMessages: []
      });
    },
    unregister: (id) => {
      items.value = items.value.filter((item) => {
        return item.id !== id;
      });
    },
    update: (id, isValid2, errorMessages) => {
      const found = items.value.find((item) => item.id === id);
      if (!found)
        return;
      found.isValid = isValid2;
      found.errorMessages = errorMessages;
    },
    isDisabled,
    isReadonly: isReadonly2,
    isValidating,
    isValid: model,
    items,
    validateOn: toRef(props2, "validateOn")
  });
  return {
    errors,
    isDisabled,
    isReadonly: isReadonly2,
    isValidating,
    isValid: model,
    items,
    validate,
    reset,
    resetValidation
  };
}
function useForm() {
  return inject$1(FormKey, null);
}
const makeValidationProps = propsFactory({
  disabled: {
    type: Boolean,
    default: null
  },
  error: Boolean,
  errorMessages: {
    type: [Array, String],
    default: () => []
  },
  maxErrors: {
    type: [Number, String],
    default: 1
  },
  name: String,
  label: String,
  readonly: {
    type: Boolean,
    default: null
  },
  rules: {
    type: Array,
    default: () => []
  },
  modelValue: null,
  validateOn: String,
  validationValue: null,
  ...makeFocusProps()
}, "validation");
function useValidation(props2) {
  let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
  let id = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : getUid();
  const model = useProxiedModel(props2, "modelValue");
  const validationModel = computed(() => props2.validationValue === void 0 ? model.value : props2.validationValue);
  const form = useForm();
  const internalErrorMessages = ref([]);
  const isPristine = shallowRef(true);
  const isDirty = computed(() => !!(wrapInArray(model.value === "" ? null : model.value).length || wrapInArray(validationModel.value === "" ? null : validationModel.value).length));
  const isDisabled = computed(() => !!(props2.disabled ?? (form == null ? void 0 : form.isDisabled.value)));
  const isReadonly2 = computed(() => !!(props2.readonly ?? (form == null ? void 0 : form.isReadonly.value)));
  const errorMessages = computed(() => {
    var _a2;
    return ((_a2 = props2.errorMessages) == null ? void 0 : _a2.length) ? wrapInArray(props2.errorMessages).slice(0, Math.max(0, +props2.maxErrors)) : internalErrorMessages.value;
  });
  const validateOn = computed(() => {
    let value = (props2.validateOn ?? (form == null ? void 0 : form.validateOn.value)) || "input";
    if (value === "lazy")
      value = "input lazy";
    const set2 = new Set((value == null ? void 0 : value.split(" ")) ?? []);
    return {
      blur: set2.has("blur") || set2.has("input"),
      input: set2.has("input"),
      submit: set2.has("submit"),
      lazy: set2.has("lazy")
    };
  });
  const isValid2 = computed(() => {
    var _a2;
    if (props2.error || ((_a2 = props2.errorMessages) == null ? void 0 : _a2.length))
      return false;
    if (!props2.rules.length)
      return true;
    if (isPristine.value) {
      return internalErrorMessages.value.length || validateOn.value.lazy ? null : true;
    } else {
      return !internalErrorMessages.value.length;
    }
  });
  const isValidating = shallowRef(false);
  const validationClasses = computed(() => {
    return {
      [`${name}--error`]: isValid2.value === false,
      [`${name}--dirty`]: isDirty.value,
      [`${name}--disabled`]: isDisabled.value,
      [`${name}--readonly`]: isReadonly2.value
    };
  });
  const uid2 = computed(() => props2.name ?? unref(id));
  onBeforeMount(() => {
    form == null ? void 0 : form.register({
      id: uid2.value,
      validate,
      reset,
      resetValidation
    });
  });
  onBeforeUnmount(() => {
    form == null ? void 0 : form.unregister(uid2.value);
  });
  onMounted(async () => {
    if (!validateOn.value.lazy) {
      await validate(true);
    }
    form == null ? void 0 : form.update(uid2.value, isValid2.value, errorMessages.value);
  });
  useToggleScope(() => validateOn.value.input, () => {
    watch(validationModel, () => {
      if (validationModel.value != null) {
        validate();
      } else if (props2.focused) {
        const unwatch = watch(() => props2.focused, (val) => {
          if (!val)
            validate();
          unwatch();
        });
      }
    });
  });
  useToggleScope(() => validateOn.value.blur, () => {
    watch(() => props2.focused, (val) => {
      if (!val)
        validate();
    });
  });
  watch(isValid2, () => {
    form == null ? void 0 : form.update(uid2.value, isValid2.value, errorMessages.value);
  });
  function reset() {
    model.value = null;
    nextTick(resetValidation);
  }
  function resetValidation() {
    isPristine.value = true;
    if (!validateOn.value.lazy) {
      validate(true);
    } else {
      internalErrorMessages.value = [];
    }
  }
  async function validate() {
    let silent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    const results = [];
    isValidating.value = true;
    for (const rule of props2.rules) {
      if (results.length >= +(props2.maxErrors ?? 1)) {
        break;
      }
      const handler = typeof rule === "function" ? rule : () => rule;
      const result = await handler(validationModel.value);
      if (result === true)
        continue;
      if (result !== false && typeof result !== "string") {
        console.warn(`${result} is not a valid value. Rule functions must return boolean true or a string.`);
        continue;
      }
      results.push(result || "");
    }
    internalErrorMessages.value = results;
    isValidating.value = false;
    isPristine.value = silent;
    return internalErrorMessages.value;
  }
  return {
    errorMessages,
    isDirty,
    isDisabled,
    isReadonly: isReadonly2,
    isPristine,
    isValid: isValid2,
    isValidating,
    reset,
    resetValidation,
    validate,
    validationClasses
  };
}
const makeVInputProps = propsFactory({
  id: String,
  appendIcon: IconValue,
  centerAffix: {
    type: Boolean,
    default: true
  },
  prependIcon: IconValue,
  hideDetails: [Boolean, String],
  hint: String,
  persistentHint: Boolean,
  messages: {
    type: [Array, String],
    default: () => []
  },
  direction: {
    type: String,
    default: "horizontal",
    validator: (v2) => ["horizontal", "vertical"].includes(v2)
  },
  "onClick:prepend": EventProp(),
  "onClick:append": EventProp(),
  ...makeComponentProps(),
  ...makeDensityProps(),
  ...makeValidationProps()
}, "VInput");
const VInput = genericComponent()({
  name: "VInput",
  props: {
    ...makeVInputProps()
  },
  emits: {
    "update:modelValue": (val) => true
  },
  setup(props2, _ref) {
    let {
      attrs,
      slots,
      emit: emit2
    } = _ref;
    const {
      densityClasses
    } = useDensity(props2);
    const {
      rtlClasses
    } = useRtl();
    const {
      InputIcon
    } = useInputIcon(props2);
    const uid2 = getUid();
    const id = computed(() => props2.id || `input-${uid2}`);
    const messagesId = computed(() => `${id.value}-messages`);
    const {
      errorMessages,
      isDirty,
      isDisabled,
      isReadonly: isReadonly2,
      isPristine,
      isValid: isValid2,
      isValidating,
      reset,
      resetValidation,
      validate,
      validationClasses
    } = useValidation(props2, "v-input", id);
    const slotProps = computed(() => ({
      id,
      messagesId,
      isDirty,
      isDisabled,
      isReadonly: isReadonly2,
      isPristine,
      isValid: isValid2,
      isValidating,
      reset,
      resetValidation,
      validate
    }));
    const messages = computed(() => {
      var _a2;
      if (((_a2 = props2.errorMessages) == null ? void 0 : _a2.length) || !isPristine.value && errorMessages.value.length) {
        return errorMessages.value;
      } else if (props2.hint && (props2.persistentHint || props2.focused)) {
        return props2.hint;
      } else {
        return props2.messages;
      }
    });
    useRender(() => {
      var _a2, _b, _c, _d;
      const hasPrepend = !!(slots.prepend || props2.prependIcon);
      const hasAppend = !!(slots.append || props2.appendIcon);
      const hasMessages = messages.value.length > 0;
      const hasDetails = !props2.hideDetails || props2.hideDetails === "auto" && (hasMessages || !!slots.details);
      return createVNode("div", {
        "class": ["v-input", `v-input--${props2.direction}`, {
          "v-input--center-affix": props2.centerAffix
        }, densityClasses.value, rtlClasses.value, validationClasses.value, props2.class],
        "style": props2.style
      }, [hasPrepend && createVNode("div", {
        "key": "prepend",
        "class": "v-input__prepend"
      }, [(_a2 = slots.prepend) == null ? void 0 : _a2.call(slots, slotProps.value), props2.prependIcon && createVNode(InputIcon, {
        "key": "prepend-icon",
        "name": "prepend"
      }, null)]), slots.default && createVNode("div", {
        "class": "v-input__control"
      }, [(_b = slots.default) == null ? void 0 : _b.call(slots, slotProps.value)]), hasAppend && createVNode("div", {
        "key": "append",
        "class": "v-input__append"
      }, [props2.appendIcon && createVNode(InputIcon, {
        "key": "append-icon",
        "name": "append"
      }, null), (_c = slots.append) == null ? void 0 : _c.call(slots, slotProps.value)]), hasDetails && createVNode("div", {
        "class": "v-input__details"
      }, [createVNode(VMessages, {
        "id": messagesId.value,
        "active": hasMessages,
        "messages": messages.value
      }, {
        message: slots.message
      }), (_d = slots.details) == null ? void 0 : _d.call(slots, slotProps.value)])]);
    });
    return {
      reset,
      resetValidation,
      validate
    };
  }
});
const makeVCheckboxProps = propsFactory({
  ...makeVInputProps(),
  ...omit(makeVCheckboxBtnProps(), ["inline"])
}, "VCheckbox");
const VCheckbox = genericComponent()({
  name: "VCheckbox",
  inheritAttrs: false,
  props: makeVCheckboxProps(),
  emits: {
    "update:modelValue": (value) => true,
    "update:focused": (focused) => true
  },
  setup(props2, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const model = useProxiedModel(props2, "modelValue");
    const {
      isFocused,
      focus,
      blur
    } = useFocus(props2);
    const uid2 = getUid();
    const id = computed(() => props2.id || `checkbox-${uid2}`);
    useRender(() => {
      const [rootAttrs, controlAttrs] = filterInputAttrs(attrs);
      const [inputProps, _1] = VInput.filterProps(props2);
      const [checkboxProps, _2] = VCheckboxBtn.filterProps(props2);
      return createVNode(VInput, mergeProps({
        "class": ["v-checkbox", props2.class]
      }, rootAttrs, inputProps, {
        "modelValue": model.value,
        "onUpdate:modelValue": ($event) => model.value = $event,
        "id": id.value,
        "focused": isFocused.value,
        "style": props2.style
      }), {
        ...slots,
        default: (_ref2) => {
          let {
            id: id2,
            messagesId,
            isDisabled,
            isReadonly: isReadonly2
          } = _ref2;
          return createVNode(VCheckboxBtn, mergeProps(checkboxProps, {
            "id": id2.value,
            "aria-describedby": messagesId.value,
            "disabled": isDisabled.value,
            "readonly": isReadonly2.value
          }, controlAttrs, {
            "modelValue": model.value,
            "onUpdate:modelValue": ($event) => model.value = $event,
            "onFocus": focus,
            "onBlur": blur
          }), slots);
        }
      });
    });
    return {};
  }
});
const VChip$1 = "";
const VAvatar$1 = "";
const makeVAvatarProps = propsFactory({
  start: Boolean,
  end: Boolean,
  icon: IconValue,
  image: String,
  ...makeComponentProps(),
  ...makeDensityProps(),
  ...makeRoundedProps(),
  ...makeSizeProps(),
  ...makeTagProps(),
  ...makeThemeProps(),
  ...makeVariantProps({
    variant: "flat"
  })
}, "VAvatar");
const VAvatar = genericComponent()({
  name: "VAvatar",
  props: makeVAvatarProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props2);
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(props2);
    const {
      densityClasses
    } = useDensity(props2);
    const {
      roundedClasses
    } = useRounded(props2);
    const {
      sizeClasses,
      sizeStyles
    } = useSize(props2);
    useRender(() => createVNode(props2.tag, {
      "class": ["v-avatar", {
        "v-avatar--start": props2.start,
        "v-avatar--end": props2.end
      }, themeClasses.value, colorClasses.value, densityClasses.value, roundedClasses.value, sizeClasses.value, variantClasses.value, props2.class],
      "style": [colorStyles.value, sizeStyles.value, props2.style]
    }, {
      default: () => {
        var _a2;
        return [props2.image ? createVNode(VImg, {
          "key": "image",
          "src": props2.image,
          "alt": "",
          "cover": true
        }, null) : props2.icon ? createVNode(VIcon, {
          "key": "icon",
          "icon": props2.icon
        }, null) : (_a2 = slots.default) == null ? void 0 : _a2.call(slots), genOverlays(false, "v-avatar")];
      }
    }));
    return {};
  }
});
const VChipGroup$1 = "";
const VChipGroupSymbol = Symbol.for("vuetify:v-chip-group");
const makeVChipGroupProps = propsFactory({
  column: Boolean,
  filter: Boolean,
  valueComparator: {
    type: Function,
    default: deepEqual
  },
  ...makeComponentProps(),
  ...makeGroupProps({
    selectedClass: "v-chip--selected"
  }),
  ...makeTagProps(),
  ...makeThemeProps(),
  ...makeVariantProps({
    variant: "tonal"
  })
}, "VChipGroup");
const VChipGroup = genericComponent()({
  name: "VChipGroup",
  props: makeVChipGroupProps(),
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props2);
    const {
      isSelected,
      select,
      next,
      prev,
      selected
    } = useGroup(props2, VChipGroupSymbol);
    provideDefaults({
      VChip: {
        color: toRef(props2, "color"),
        disabled: toRef(props2, "disabled"),
        filter: toRef(props2, "filter"),
        variant: toRef(props2, "variant")
      }
    });
    useRender(() => createVNode(props2.tag, {
      "class": ["v-chip-group", {
        "v-chip-group--column": props2.column
      }, themeClasses.value, props2.class],
      "style": props2.style
    }, {
      default: () => {
        var _a2;
        return [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
          isSelected,
          select,
          next,
          prev,
          selected: selected.value
        })];
      }
    }));
    return {};
  }
});
const makeVChipProps = propsFactory({
  activeClass: String,
  appendAvatar: String,
  appendIcon: IconValue,
  closable: Boolean,
  closeIcon: {
    type: IconValue,
    default: "$delete"
  },
  closeLabel: {
    type: String,
    default: "$vuetify.close"
  },
  draggable: Boolean,
  filter: Boolean,
  filterIcon: {
    type: String,
    default: "$complete"
  },
  label: Boolean,
  link: {
    type: Boolean,
    default: void 0
  },
  pill: Boolean,
  prependAvatar: String,
  prependIcon: IconValue,
  ripple: {
    type: [Boolean, Object],
    default: true
  },
  text: String,
  modelValue: {
    type: Boolean,
    default: true
  },
  onClick: EventProp(),
  onClickOnce: EventProp(),
  ...makeBorderProps(),
  ...makeComponentProps(),
  ...makeDensityProps(),
  ...makeElevationProps(),
  ...makeGroupItemProps(),
  ...makeRoundedProps(),
  ...makeRouterProps(),
  ...makeSizeProps(),
  ...makeTagProps({
    tag: "span"
  }),
  ...makeThemeProps(),
  ...makeVariantProps({
    variant: "tonal"
  })
}, "VChip");
const VChip = genericComponent()({
  name: "VChip",
  directives: {
    Ripple
  },
  props: makeVChipProps(),
  emits: {
    "click:close": (e) => true,
    "update:modelValue": (value) => true,
    "group:selected": (val) => true,
    click: (e) => true
  },
  setup(props2, _ref) {
    let {
      attrs,
      emit: emit2,
      slots
    } = _ref;
    const {
      t
    } = useLocale();
    const {
      borderClasses
    } = useBorder(props2);
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(props2);
    const {
      densityClasses
    } = useDensity(props2);
    const {
      elevationClasses
    } = useElevation(props2);
    const {
      roundedClasses
    } = useRounded(props2);
    const {
      sizeClasses
    } = useSize(props2);
    const {
      themeClasses
    } = provideTheme(props2);
    const isActive = useProxiedModel(props2, "modelValue");
    const group = useGroupItem(props2, VChipGroupSymbol, false);
    const link = useLink(props2, attrs);
    const isLink = computed(() => props2.link !== false && link.isLink.value);
    const isClickable = computed(() => !props2.disabled && props2.link !== false && (!!group || props2.link || link.isClickable.value));
    const closeProps = computed(() => ({
      "aria-label": t(props2.closeLabel),
      onClick(e) {
        e.stopPropagation();
        isActive.value = false;
        emit2("click:close", e);
      }
    }));
    function onClick(e) {
      var _a2;
      emit2("click", e);
      if (!isClickable.value)
        return;
      (_a2 = link.navigate) == null ? void 0 : _a2.call(link, e);
      group == null ? void 0 : group.toggle();
    }
    function onKeyDown(e) {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        onClick(e);
      }
    }
    return () => {
      const Tag = link.isLink.value ? "a" : props2.tag;
      const hasAppendMedia = !!(props2.appendIcon || props2.appendAvatar);
      const hasAppend = !!(hasAppendMedia || slots.append);
      const hasClose = !!(slots.close || props2.closable);
      const hasFilter = !!(slots.filter || props2.filter) && group;
      const hasPrependMedia = !!(props2.prependIcon || props2.prependAvatar);
      const hasPrepend = !!(hasPrependMedia || slots.prepend);
      const hasColor = !group || group.isSelected.value;
      return isActive.value && withDirectives(createVNode(Tag, {
        "class": ["v-chip", {
          "v-chip--disabled": props2.disabled,
          "v-chip--label": props2.label,
          "v-chip--link": isClickable.value,
          "v-chip--filter": hasFilter,
          "v-chip--pill": props2.pill
        }, themeClasses.value, borderClasses.value, hasColor ? colorClasses.value : void 0, densityClasses.value, elevationClasses.value, roundedClasses.value, sizeClasses.value, variantClasses.value, group == null ? void 0 : group.selectedClass.value, props2.class],
        "style": [hasColor ? colorStyles.value : void 0, props2.style],
        "disabled": props2.disabled || void 0,
        "draggable": props2.draggable,
        "href": link.href.value,
        "tabindex": isClickable.value ? 0 : void 0,
        "onClick": onClick,
        "onKeydown": isClickable.value && !isLink.value && onKeyDown
      }, {
        default: () => {
          var _a2;
          return [genOverlays(isClickable.value, "v-chip"), hasFilter && createVNode(VExpandXTransition, {
            "key": "filter"
          }, {
            default: () => [withDirectives(createVNode("div", {
              "class": "v-chip__filter"
            }, [!slots.filter ? createVNode(VIcon, {
              "key": "filter-icon",
              "icon": props2.filterIcon
            }, null) : createVNode(VDefaultsProvider, {
              "key": "filter-defaults",
              "disabled": !props2.filterIcon,
              "defaults": {
                VIcon: {
                  icon: props2.filterIcon
                }
              }
            }, slots.filter)]), [[vShow, group.isSelected.value]])]
          }), hasPrepend && createVNode("div", {
            "key": "prepend",
            "class": "v-chip__prepend"
          }, [!slots.prepend ? createVNode(Fragment, null, [props2.prependIcon && createVNode(VIcon, {
            "key": "prepend-icon",
            "icon": props2.prependIcon,
            "start": true
          }, null), props2.prependAvatar && createVNode(VAvatar, {
            "key": "prepend-avatar",
            "image": props2.prependAvatar,
            "start": true
          }, null)]) : createVNode(VDefaultsProvider, {
            "key": "prepend-defaults",
            "disabled": !hasPrependMedia,
            "defaults": {
              VAvatar: {
                image: props2.prependAvatar,
                start: true
              },
              VIcon: {
                icon: props2.prependIcon,
                start: true
              }
            }
          }, slots.prepend)]), createVNode("div", {
            "class": "v-chip__content"
          }, [((_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
            isSelected: group == null ? void 0 : group.isSelected.value,
            selectedClass: group == null ? void 0 : group.selectedClass.value,
            select: group == null ? void 0 : group.select,
            toggle: group == null ? void 0 : group.toggle,
            value: group == null ? void 0 : group.value.value,
            disabled: props2.disabled
          })) ?? props2.text]), hasAppend && createVNode("div", {
            "key": "append",
            "class": "v-chip__append"
          }, [!slots.append ? createVNode(Fragment, null, [props2.appendIcon && createVNode(VIcon, {
            "key": "append-icon",
            "end": true,
            "icon": props2.appendIcon
          }, null), props2.appendAvatar && createVNode(VAvatar, {
            "key": "append-avatar",
            "end": true,
            "image": props2.appendAvatar
          }, null)]) : createVNode(VDefaultsProvider, {
            "key": "append-defaults",
            "disabled": !hasAppendMedia,
            "defaults": {
              VAvatar: {
                end: true,
                image: props2.appendAvatar
              },
              VIcon: {
                end: true,
                icon: props2.appendIcon
              }
            }
          }, slots.append)]), hasClose && createVNode("div", mergeProps({
            "key": "close",
            "class": "v-chip__close"
          }, closeProps.value), [!slots.close ? createVNode(VIcon, {
            "key": "close-icon",
            "icon": props2.closeIcon,
            "size": "x-small"
          }, null) : createVNode(VDefaultsProvider, {
            "key": "close-defaults",
            "defaults": {
              VIcon: {
                icon: props2.closeIcon,
                size: "x-small"
              }
            }
          }, slots.close)])];
        }
      }), [[resolveDirective("ripple"), isClickable.value && props2.ripple, null]]);
    };
  }
});
const VList$1 = "";
const ListKey = Symbol.for("vuetify:list");
function createList() {
  const parent = inject$1(ListKey, {
    hasPrepend: shallowRef(false),
    updateHasPrepend: () => null
  });
  const data = {
    hasPrepend: shallowRef(false),
    updateHasPrepend: (value) => {
      if (value)
        data.hasPrepend.value = value;
    }
  };
  provide(ListKey, data);
  return parent;
}
function useList() {
  return inject$1(ListKey, null);
}
const singleOpenStrategy = {
  open: (_ref) => {
    let {
      id,
      value,
      opened,
      parents: parents2
    } = _ref;
    if (value) {
      const newOpened = /* @__PURE__ */ new Set();
      newOpened.add(id);
      let parent = parents2.get(id);
      while (parent != null) {
        newOpened.add(parent);
        parent = parents2.get(parent);
      }
      return newOpened;
    } else {
      opened.delete(id);
      return opened;
    }
  },
  select: () => null
};
const multipleOpenStrategy = {
  open: (_ref2) => {
    let {
      id,
      value,
      opened,
      parents: parents2
    } = _ref2;
    if (value) {
      let parent = parents2.get(id);
      opened.add(id);
      while (parent != null && parent !== id) {
        opened.add(parent);
        parent = parents2.get(parent);
      }
      return opened;
    } else {
      opened.delete(id);
    }
    return opened;
  },
  select: () => null
};
const listOpenStrategy = {
  open: multipleOpenStrategy.open,
  select: (_ref3) => {
    let {
      id,
      value,
      opened,
      parents: parents2
    } = _ref3;
    if (!value)
      return opened;
    const path = [];
    let parent = parents2.get(id);
    while (parent != null) {
      path.push(parent);
      parent = parents2.get(parent);
    }
    return new Set(path);
  }
};
const independentSelectStrategy = (mandatory) => {
  const strategy = {
    select: (_ref) => {
      let {
        id,
        value,
        selected
      } = _ref;
      id = toRaw(id);
      if (mandatory && !value) {
        const on2 = Array.from(selected.entries()).reduce((arr, _ref2) => {
          let [key2, value2] = _ref2;
          return value2 === "on" ? [...arr, key2] : arr;
        }, []);
        if (on2.length === 1 && on2[0] === id)
          return selected;
      }
      selected.set(id, value ? "on" : "off");
      return selected;
    },
    in: (v2, children, parents2) => {
      let map = /* @__PURE__ */ new Map();
      for (const id of v2 || []) {
        map = strategy.select({
          id,
          value: true,
          selected: new Map(map),
          children,
          parents: parents2
        });
      }
      return map;
    },
    out: (v2) => {
      const arr = [];
      for (const [key2, value] of v2.entries()) {
        if (value === "on")
          arr.push(key2);
      }
      return arr;
    }
  };
  return strategy;
};
const independentSingleSelectStrategy = (mandatory) => {
  const parentStrategy = independentSelectStrategy(mandatory);
  const strategy = {
    select: (_ref3) => {
      let {
        selected,
        id,
        ...rest
      } = _ref3;
      id = toRaw(id);
      const singleSelected = selected.has(id) ? /* @__PURE__ */ new Map([[id, selected.get(id)]]) : /* @__PURE__ */ new Map();
      return parentStrategy.select({
        ...rest,
        id,
        selected: singleSelected
      });
    },
    in: (v2, children, parents2) => {
      let map = /* @__PURE__ */ new Map();
      if (v2 == null ? void 0 : v2.length) {
        map = parentStrategy.in(v2.slice(0, 1), children, parents2);
      }
      return map;
    },
    out: (v2, children, parents2) => {
      return parentStrategy.out(v2, children, parents2);
    }
  };
  return strategy;
};
const leafSelectStrategy = (mandatory) => {
  const parentStrategy = independentSelectStrategy(mandatory);
  const strategy = {
    select: (_ref4) => {
      let {
        id,
        selected,
        children,
        ...rest
      } = _ref4;
      id = toRaw(id);
      if (children.has(id))
        return selected;
      return parentStrategy.select({
        id,
        selected,
        children,
        ...rest
      });
    },
    in: parentStrategy.in,
    out: parentStrategy.out
  };
  return strategy;
};
const leafSingleSelectStrategy = (mandatory) => {
  const parentStrategy = independentSingleSelectStrategy(mandatory);
  const strategy = {
    select: (_ref5) => {
      let {
        id,
        selected,
        children,
        ...rest
      } = _ref5;
      id = toRaw(id);
      if (children.has(id))
        return selected;
      return parentStrategy.select({
        id,
        selected,
        children,
        ...rest
      });
    },
    in: parentStrategy.in,
    out: parentStrategy.out
  };
  return strategy;
};
const classicSelectStrategy = (mandatory) => {
  const strategy = {
    select: (_ref6) => {
      let {
        id,
        value,
        selected,
        children,
        parents: parents2
      } = _ref6;
      id = toRaw(id);
      const original = new Map(selected);
      const items = [id];
      while (items.length) {
        const item = items.shift();
        selected.set(item, value ? "on" : "off");
        if (children.has(item)) {
          items.push(...children.get(item));
        }
      }
      let parent = parents2.get(id);
      while (parent) {
        const childrenIds = children.get(parent);
        const everySelected = childrenIds.every((cid) => selected.get(cid) === "on");
        const noneSelected = childrenIds.every((cid) => !selected.has(cid) || selected.get(cid) === "off");
        selected.set(parent, everySelected ? "on" : noneSelected ? "off" : "indeterminate");
        parent = parents2.get(parent);
      }
      if (mandatory && !value) {
        const on2 = Array.from(selected.entries()).reduce((arr, _ref7) => {
          let [key2, value2] = _ref7;
          return value2 === "on" ? [...arr, key2] : arr;
        }, []);
        if (on2.length === 0)
          return original;
      }
      return selected;
    },
    in: (v2, children, parents2) => {
      let map = /* @__PURE__ */ new Map();
      for (const id of v2 || []) {
        map = strategy.select({
          id,
          value: true,
          selected: new Map(map),
          children,
          parents: parents2
        });
      }
      return map;
    },
    out: (v2, children) => {
      const arr = [];
      for (const [key2, value] of v2.entries()) {
        if (value === "on" && !children.has(key2))
          arr.push(key2);
      }
      return arr;
    }
  };
  return strategy;
};
const VNestedSymbol = Symbol.for("vuetify:nested");
const emptyNested = {
  id: shallowRef(),
  root: {
    register: () => null,
    unregister: () => null,
    parents: ref(/* @__PURE__ */ new Map()),
    children: ref(/* @__PURE__ */ new Map()),
    open: () => null,
    openOnSelect: () => null,
    select: () => null,
    opened: ref(/* @__PURE__ */ new Set()),
    selected: ref(/* @__PURE__ */ new Map()),
    selectedValues: ref([])
  }
};
const makeNestedProps = propsFactory({
  selectStrategy: [String, Function],
  openStrategy: [String, Object],
  opened: Array,
  selected: Array,
  mandatory: Boolean
}, "nested");
const useNested = (props2) => {
  let isUnmounted = false;
  const children = ref(/* @__PURE__ */ new Map());
  const parents2 = ref(/* @__PURE__ */ new Map());
  const opened = useProxiedModel(props2, "opened", props2.opened, (v2) => new Set(v2), (v2) => [...v2.values()]);
  const selectStrategy = computed(() => {
    if (typeof props2.selectStrategy === "object")
      return props2.selectStrategy;
    switch (props2.selectStrategy) {
      case "single-leaf":
        return leafSingleSelectStrategy(props2.mandatory);
      case "leaf":
        return leafSelectStrategy(props2.mandatory);
      case "independent":
        return independentSelectStrategy(props2.mandatory);
      case "single-independent":
        return independentSingleSelectStrategy(props2.mandatory);
      case "classic":
      default:
        return classicSelectStrategy(props2.mandatory);
    }
  });
  const openStrategy = computed(() => {
    if (typeof props2.openStrategy === "object")
      return props2.openStrategy;
    switch (props2.openStrategy) {
      case "list":
        return listOpenStrategy;
      case "single":
        return singleOpenStrategy;
      case "multiple":
      default:
        return multipleOpenStrategy;
    }
  });
  const selected = useProxiedModel(props2, "selected", props2.selected, (v2) => selectStrategy.value.in(v2, children.value, parents2.value), (v2) => selectStrategy.value.out(v2, children.value, parents2.value));
  onBeforeUnmount(() => {
    isUnmounted = true;
  });
  function getPath(id) {
    const path = [];
    let parent = id;
    while (parent != null) {
      path.unshift(parent);
      parent = parents2.value.get(parent);
    }
    return path;
  }
  const vm = getCurrentInstance("nested");
  const nested = {
    id: shallowRef(),
    root: {
      opened,
      selected,
      selectedValues: computed(() => {
        const arr = [];
        for (const [key2, value] of selected.value.entries()) {
          if (value === "on")
            arr.push(key2);
        }
        return arr;
      }),
      register: (id, parentId, isGroup) => {
        parentId && id !== parentId && parents2.value.set(id, parentId);
        isGroup && children.value.set(id, []);
        if (parentId != null) {
          children.value.set(parentId, [...children.value.get(parentId) || [], id]);
        }
      },
      unregister: (id) => {
        if (isUnmounted)
          return;
        children.value.delete(id);
        const parent = parents2.value.get(id);
        if (parent) {
          const list = children.value.get(parent) ?? [];
          children.value.set(parent, list.filter((child) => child !== id));
        }
        parents2.value.delete(id);
        opened.value.delete(id);
      },
      open: (id, value, event) => {
        vm.emit("click:open", {
          id,
          value,
          path: getPath(id),
          event
        });
        const newOpened = openStrategy.value.open({
          id,
          value,
          opened: new Set(opened.value),
          children: children.value,
          parents: parents2.value,
          event
        });
        newOpened && (opened.value = newOpened);
      },
      openOnSelect: (id, value, event) => {
        const newOpened = openStrategy.value.select({
          id,
          value,
          selected: new Map(selected.value),
          opened: new Set(opened.value),
          children: children.value,
          parents: parents2.value,
          event
        });
        newOpened && (opened.value = newOpened);
      },
      select: (id, value, event) => {
        vm.emit("click:select", {
          id,
          value,
          path: getPath(id),
          event
        });
        const newSelected = selectStrategy.value.select({
          id,
          value,
          selected: new Map(selected.value),
          children: children.value,
          parents: parents2.value,
          event
        });
        newSelected && (selected.value = newSelected);
        nested.root.openOnSelect(id, value, event);
      },
      children,
      parents: parents2
    }
  };
  provide(VNestedSymbol, nested);
  return nested.root;
};
const useNestedItem = (id, isGroup) => {
  const parent = inject$1(VNestedSymbol, emptyNested);
  const uidSymbol = Symbol(getUid());
  const computedId = computed(() => id.value !== void 0 ? id.value : uidSymbol);
  const item = {
    ...parent,
    id: computedId,
    open: (open, e) => parent.root.open(computedId.value, open, e),
    openOnSelect: (open, e) => parent.root.openOnSelect(computedId.value, open, e),
    isOpen: computed(() => parent.root.opened.value.has(computedId.value)),
    parent: computed(() => parent.root.parents.value.get(computedId.value)),
    select: (selected, e) => parent.root.select(computedId.value, selected, e),
    isSelected: computed(() => parent.root.selected.value.get(toRaw(computedId.value)) === "on"),
    isIndeterminate: computed(() => parent.root.selected.value.get(computedId.value) === "indeterminate"),
    isLeaf: computed(() => !parent.root.children.value.get(computedId.value)),
    isGroupActivator: parent.isGroupActivator
  };
  !parent.isGroupActivator && parent.root.register(computedId.value, parent.id.value, isGroup);
  onBeforeUnmount(() => {
    !parent.isGroupActivator && parent.root.unregister(computedId.value);
  });
  isGroup && provide(VNestedSymbol, item);
  return item;
};
const useNestedGroupActivator = () => {
  const parent = inject$1(VNestedSymbol, emptyNested);
  provide(VNestedSymbol, {
    ...parent,
    isGroupActivator: true
  });
};
const VListGroupActivator = defineComponent({
  name: "VListGroupActivator",
  setup(_2, _ref) {
    let {
      slots
    } = _ref;
    useNestedGroupActivator();
    return () => {
      var _a2;
      return (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
    };
  }
});
const makeVListGroupProps = propsFactory({
  /* @deprecated */
  activeColor: String,
  baseColor: String,
  color: String,
  collapseIcon: {
    type: IconValue,
    default: "$collapse"
  },
  expandIcon: {
    type: IconValue,
    default: "$expand"
  },
  prependIcon: IconValue,
  appendIcon: IconValue,
  fluid: Boolean,
  subgroup: Boolean,
  title: String,
  value: null,
  ...makeComponentProps(),
  ...makeTagProps()
}, "VListGroup");
const VListGroup = genericComponent()({
  name: "VListGroup",
  props: makeVListGroupProps(),
  setup(props2, _ref2) {
    let {
      slots
    } = _ref2;
    const {
      isOpen,
      open,
      id: _id
    } = useNestedItem(toRef(props2, "value"), true);
    const id = computed(() => `v-list-group--id-${String(_id.value)}`);
    const list = useList();
    const {
      isBooted
    } = useSsrBoot();
    function onClick(e) {
      open(!isOpen.value, e);
    }
    const activatorProps = computed(() => ({
      onClick,
      class: "v-list-group__header",
      id: id.value
    }));
    const toggleIcon = computed(() => isOpen.value ? props2.collapseIcon : props2.expandIcon);
    const activatorDefaults = computed(() => ({
      VListItem: {
        active: isOpen.value,
        activeColor: props2.activeColor,
        baseColor: props2.baseColor,
        color: props2.color,
        prependIcon: props2.prependIcon || props2.subgroup && toggleIcon.value,
        appendIcon: props2.appendIcon || !props2.subgroup && toggleIcon.value,
        title: props2.title,
        value: props2.value
      }
    }));
    useRender(() => createVNode(props2.tag, {
      "class": ["v-list-group", {
        "v-list-group--prepend": list == null ? void 0 : list.hasPrepend.value,
        "v-list-group--fluid": props2.fluid,
        "v-list-group--subgroup": props2.subgroup,
        "v-list-group--open": isOpen.value
      }, props2.class],
      "style": props2.style
    }, {
      default: () => [slots.activator && createVNode(VDefaultsProvider, {
        "defaults": activatorDefaults.value
      }, {
        default: () => [createVNode(VListGroupActivator, null, {
          default: () => [slots.activator({
            props: activatorProps.value,
            isOpen: isOpen.value
          })]
        })]
      }), createVNode(MaybeTransition, {
        "transition": {
          component: VExpandTransition
        },
        "disabled": !isBooted.value
      }, {
        default: () => {
          var _a2;
          return [withDirectives(createVNode("div", {
            "class": "v-list-group__items",
            "role": "group",
            "aria-labelledby": id.value
          }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]), [[vShow, isOpen.value]])];
        }
      })]
    }));
    return {};
  }
});
const VListItem$1 = "";
const VListItemSubtitle = createSimpleFunctional("v-list-item-subtitle");
const VListItemTitle = createSimpleFunctional("v-list-item-title");
const makeVListItemProps = propsFactory({
  active: {
    type: Boolean,
    default: void 0
  },
  activeClass: String,
  /* @deprecated */
  activeColor: String,
  appendAvatar: String,
  appendIcon: IconValue,
  baseColor: String,
  disabled: Boolean,
  lines: String,
  link: {
    type: Boolean,
    default: void 0
  },
  nav: Boolean,
  prependAvatar: String,
  prependIcon: IconValue,
  ripple: {
    type: [Boolean, Object],
    default: true
  },
  subtitle: [String, Number, Boolean],
  title: [String, Number, Boolean],
  value: null,
  onClick: EventProp(),
  onClickOnce: EventProp(),
  ...makeBorderProps(),
  ...makeComponentProps(),
  ...makeDensityProps(),
  ...makeDimensionProps(),
  ...makeElevationProps(),
  ...makeRoundedProps(),
  ...makeRouterProps(),
  ...makeTagProps(),
  ...makeThemeProps(),
  ...makeVariantProps({
    variant: "text"
  })
}, "VListItem");
const VListItem = genericComponent()({
  name: "VListItem",
  directives: {
    Ripple
  },
  props: makeVListItemProps(),
  emits: {
    click: (e) => true
  },
  setup(props2, _ref) {
    let {
      attrs,
      slots,
      emit: emit2
    } = _ref;
    const link = useLink(props2, attrs);
    const id = computed(() => props2.value === void 0 ? link.href.value : props2.value);
    const {
      select,
      isSelected,
      isIndeterminate,
      isGroupActivator,
      root: root2,
      parent,
      openOnSelect
    } = useNestedItem(id, false);
    const list = useList();
    const isActive = computed(() => {
      var _a2;
      return props2.active !== false && (props2.active || ((_a2 = link.isActive) == null ? void 0 : _a2.value) || isSelected.value);
    });
    const isLink = computed(() => props2.link !== false && link.isLink.value);
    const isClickable = computed(() => !props2.disabled && props2.link !== false && (props2.link || link.isClickable.value || props2.value != null && !!list));
    const roundedProps = computed(() => props2.rounded || props2.nav);
    const color = computed(() => props2.color ?? props2.activeColor);
    const variantProps = computed(() => ({
      color: isActive.value ? color.value ?? props2.baseColor : props2.baseColor,
      variant: props2.variant
    }));
    watch(() => {
      var _a2;
      return (_a2 = link.isActive) == null ? void 0 : _a2.value;
    }, (val) => {
      if (val && parent.value != null) {
        root2.open(parent.value, true);
      }
      if (val) {
        openOnSelect(val);
      }
    }, {
      immediate: true
    });
    const {
      themeClasses
    } = provideTheme(props2);
    const {
      borderClasses
    } = useBorder(props2);
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(variantProps);
    const {
      densityClasses
    } = useDensity(props2);
    const {
      dimensionStyles
    } = useDimension(props2);
    const {
      elevationClasses
    } = useElevation(props2);
    const {
      roundedClasses
    } = useRounded(roundedProps);
    const lineClasses = computed(() => props2.lines ? `v-list-item--${props2.lines}-line` : void 0);
    const slotProps = computed(() => ({
      isActive: isActive.value,
      select,
      isSelected: isSelected.value,
      isIndeterminate: isIndeterminate.value
    }));
    function onClick(e) {
      var _a2;
      emit2("click", e);
      if (isGroupActivator || !isClickable.value)
        return;
      (_a2 = link.navigate) == null ? void 0 : _a2.call(link, e);
      props2.value != null && select(!isSelected.value, e);
    }
    function onKeyDown(e) {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        onClick(e);
      }
    }
    useRender(() => {
      const Tag = isLink.value ? "a" : props2.tag;
      const hasTitle = slots.title || props2.title;
      const hasSubtitle = slots.subtitle || props2.subtitle;
      const hasAppendMedia = !!(props2.appendAvatar || props2.appendIcon);
      const hasAppend = !!(hasAppendMedia || slots.append);
      const hasPrependMedia = !!(props2.prependAvatar || props2.prependIcon);
      const hasPrepend = !!(hasPrependMedia || slots.prepend);
      list == null ? void 0 : list.updateHasPrepend(hasPrepend);
      if (props2.activeColor) {
        deprecate("active-color", ["color", "base-color"]);
      }
      return withDirectives(createVNode(Tag, {
        "class": ["v-list-item", {
          "v-list-item--active": isActive.value,
          "v-list-item--disabled": props2.disabled,
          "v-list-item--link": isClickable.value,
          "v-list-item--nav": props2.nav,
          "v-list-item--prepend": !hasPrepend && (list == null ? void 0 : list.hasPrepend.value),
          [`${props2.activeClass}`]: props2.activeClass && isActive.value
        }, themeClasses.value, borderClasses.value, colorClasses.value, densityClasses.value, elevationClasses.value, lineClasses.value, roundedClasses.value, variantClasses.value, props2.class],
        "style": [colorStyles.value, dimensionStyles.value, props2.style],
        "href": link.href.value,
        "tabindex": isClickable.value ? list ? -2 : 0 : void 0,
        "onClick": onClick,
        "onKeydown": isClickable.value && !isLink.value && onKeyDown
      }, {
        default: () => {
          var _a2;
          return [genOverlays(isClickable.value || isActive.value, "v-list-item"), hasPrepend && createVNode("div", {
            "key": "prepend",
            "class": "v-list-item__prepend"
          }, [!slots.prepend ? createVNode(Fragment, null, [props2.prependAvatar && createVNode(VAvatar, {
            "key": "prepend-avatar",
            "density": props2.density,
            "image": props2.prependAvatar
          }, null), props2.prependIcon && createVNode(VIcon, {
            "key": "prepend-icon",
            "density": props2.density,
            "icon": props2.prependIcon
          }, null)]) : createVNode(VDefaultsProvider, {
            "key": "prepend-defaults",
            "disabled": !hasPrependMedia,
            "defaults": {
              VAvatar: {
                density: props2.density,
                image: props2.prependAvatar
              },
              VIcon: {
                density: props2.density,
                icon: props2.prependIcon
              },
              VListItemAction: {
                start: true
              }
            }
          }, {
            default: () => {
              var _a3;
              return [(_a3 = slots.prepend) == null ? void 0 : _a3.call(slots, slotProps.value)];
            }
          }), createVNode("div", {
            "class": "v-list-item__spacer"
          }, null)]), createVNode("div", {
            "class": "v-list-item__content",
            "data-no-activator": ""
          }, [hasTitle && createVNode(VListItemTitle, {
            "key": "title"
          }, {
            default: () => {
              var _a3;
              return [((_a3 = slots.title) == null ? void 0 : _a3.call(slots, {
                title: props2.title
              })) ?? props2.title];
            }
          }), hasSubtitle && createVNode(VListItemSubtitle, {
            "key": "subtitle"
          }, {
            default: () => {
              var _a3;
              return [((_a3 = slots.subtitle) == null ? void 0 : _a3.call(slots, {
                subtitle: props2.subtitle
              })) ?? props2.subtitle];
            }
          }), (_a2 = slots.default) == null ? void 0 : _a2.call(slots, slotProps.value)]), hasAppend && createVNode("div", {
            "key": "append",
            "class": "v-list-item__append"
          }, [!slots.append ? createVNode(Fragment, null, [props2.appendIcon && createVNode(VIcon, {
            "key": "append-icon",
            "density": props2.density,
            "icon": props2.appendIcon
          }, null), props2.appendAvatar && createVNode(VAvatar, {
            "key": "append-avatar",
            "density": props2.density,
            "image": props2.appendAvatar
          }, null)]) : createVNode(VDefaultsProvider, {
            "key": "append-defaults",
            "disabled": !hasAppendMedia,
            "defaults": {
              VAvatar: {
                density: props2.density,
                image: props2.appendAvatar
              },
              VIcon: {
                density: props2.density,
                icon: props2.appendIcon
              },
              VListItemAction: {
                end: true
              }
            }
          }, {
            default: () => {
              var _a3;
              return [(_a3 = slots.append) == null ? void 0 : _a3.call(slots, slotProps.value)];
            }
          }), createVNode("div", {
            "class": "v-list-item__spacer"
          }, null)])];
        }
      }), [[resolveDirective("ripple"), isClickable.value && props2.ripple]]);
    });
    return {};
  }
});
const makeVListSubheaderProps = propsFactory({
  color: String,
  inset: Boolean,
  sticky: Boolean,
  title: String,
  ...makeComponentProps(),
  ...makeTagProps()
}, "VListSubheader");
const VListSubheader = genericComponent()({
  name: "VListSubheader",
  props: makeVListSubheaderProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(toRef(props2, "color"));
    useRender(() => {
      const hasText = !!(slots.default || props2.title);
      return createVNode(props2.tag, {
        "class": ["v-list-subheader", {
          "v-list-subheader--inset": props2.inset,
          "v-list-subheader--sticky": props2.sticky
        }, textColorClasses.value, props2.class],
        "style": [{
          textColorStyles
        }, props2.style]
      }, {
        default: () => {
          var _a2;
          return [hasText && createVNode("div", {
            "class": "v-list-subheader__text"
          }, [((_a2 = slots.default) == null ? void 0 : _a2.call(slots)) ?? props2.title])];
        }
      });
    });
    return {};
  }
});
const VDivider$1 = "";
const makeVDividerProps = propsFactory({
  color: String,
  inset: Boolean,
  length: [Number, String],
  thickness: [Number, String],
  vertical: Boolean,
  ...makeComponentProps(),
  ...makeThemeProps()
}, "VDivider");
const VDivider = genericComponent()({
  name: "VDivider",
  props: makeVDividerProps(),
  setup(props2, _ref) {
    let {
      attrs
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props2);
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(toRef(props2, "color"));
    const dividerStyles = computed(() => {
      const styles = {};
      if (props2.length) {
        styles[props2.vertical ? "maxHeight" : "maxWidth"] = convertToUnit(props2.length);
      }
      if (props2.thickness) {
        styles[props2.vertical ? "borderRightWidth" : "borderTopWidth"] = convertToUnit(props2.thickness);
      }
      return styles;
    });
    useRender(() => createVNode("hr", {
      "class": [{
        "v-divider": true,
        "v-divider--inset": props2.inset,
        "v-divider--vertical": props2.vertical
      }, themeClasses.value, textColorClasses.value, props2.class],
      "style": [dividerStyles.value, textColorStyles.value, props2.style],
      "aria-orientation": !attrs.role || attrs.role === "separator" ? props2.vertical ? "vertical" : "horizontal" : void 0,
      "role": `${attrs.role || "separator"}`
    }, null));
    return {};
  }
});
const makeVListChildrenProps = propsFactory({
  items: Array,
  returnObject: Boolean
}, "VListChildren");
const VListChildren = genericComponent()({
  name: "VListChildren",
  props: makeVListChildrenProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    createList();
    return () => {
      var _a2, _b;
      return ((_a2 = slots.default) == null ? void 0 : _a2.call(slots)) ?? ((_b = props2.items) == null ? void 0 : _b.map((_ref2) => {
        var _a3, _b2;
        let {
          children,
          props: itemProps,
          type: type2,
          raw: item
        } = _ref2;
        if (type2 === "divider") {
          return ((_a3 = slots.divider) == null ? void 0 : _a3.call(slots, {
            props: itemProps
          })) ?? createVNode(VDivider, itemProps, null);
        }
        if (type2 === "subheader") {
          return ((_b2 = slots.subheader) == null ? void 0 : _b2.call(slots, {
            props: itemProps
          })) ?? createVNode(VListSubheader, itemProps, null);
        }
        const slotsWithItem = {
          subtitle: slots.subtitle ? (slotProps) => {
            var _a4;
            return (_a4 = slots.subtitle) == null ? void 0 : _a4.call(slots, {
              ...slotProps,
              item
            });
          } : void 0,
          prepend: slots.prepend ? (slotProps) => {
            var _a4;
            return (_a4 = slots.prepend) == null ? void 0 : _a4.call(slots, {
              ...slotProps,
              item
            });
          } : void 0,
          append: slots.append ? (slotProps) => {
            var _a4;
            return (_a4 = slots.append) == null ? void 0 : _a4.call(slots, {
              ...slotProps,
              item
            });
          } : void 0,
          title: slots.title ? (slotProps) => {
            var _a4;
            return (_a4 = slots.title) == null ? void 0 : _a4.call(slots, {
              ...slotProps,
              item
            });
          } : void 0
        };
        const [listGroupProps, _1] = VListGroup.filterProps(itemProps);
        return children ? createVNode(VListGroup, mergeProps({
          "value": itemProps == null ? void 0 : itemProps.value
        }, listGroupProps), {
          activator: (_ref3) => {
            let {
              props: activatorProps
            } = _ref3;
            const listItemProps = {
              ...itemProps,
              ...activatorProps,
              value: props2.returnObject ? item : itemProps.value
            };
            return slots.header ? slots.header({
              props: listItemProps
            }) : createVNode(VListItem, listItemProps, slotsWithItem);
          },
          default: () => createVNode(VListChildren, {
            "items": children
          }, slots)
        }) : slots.item ? slots.item({
          props: itemProps
        }) : createVNode(VListItem, mergeProps(itemProps, {
          "value": props2.returnObject ? item : itemProps.value
        }), slotsWithItem);
      }));
    };
  }
});
const makeItemsProps = propsFactory({
  items: {
    type: Array,
    default: () => []
  },
  itemTitle: {
    type: [String, Array, Function],
    default: "title"
  },
  itemValue: {
    type: [String, Array, Function],
    default: "value"
  },
  itemChildren: {
    type: [Boolean, String, Array, Function],
    default: "children"
  },
  itemProps: {
    type: [Boolean, String, Array, Function],
    default: "props"
  },
  returnObject: Boolean,
  valueComparator: {
    type: Function,
    default: deepEqual
  }
}, "list-items");
function transformItem$1(props2, item) {
  const title = getPropertyFromItem(item, props2.itemTitle, item);
  const value = getPropertyFromItem(item, props2.itemValue, title);
  const children = getPropertyFromItem(item, props2.itemChildren);
  const itemProps = props2.itemProps === true ? typeof item === "object" && item != null && !Array.isArray(item) ? "children" in item ? pick(item, ["children"])[1] : item : void 0 : getPropertyFromItem(item, props2.itemProps);
  const _props = {
    title,
    value,
    ...itemProps
  };
  return {
    title: String(_props.title ?? ""),
    value: _props.value,
    props: _props,
    children: Array.isArray(children) ? transformItems$1(props2, children) : void 0,
    raw: item
  };
}
function transformItems$1(props2, items) {
  const array = [];
  for (const item of items) {
    array.push(transformItem$1(props2, item));
  }
  return array;
}
function useItems(props2) {
  const items = computed(() => transformItems$1(props2, props2.items));
  const hasNullItem = computed(() => items.value.some((item) => item.value === null));
  function transformIn(value) {
    if (!hasNullItem.value) {
      value = value.filter((v2) => v2 !== null);
    }
    return value.map((v2) => {
      if (props2.returnObject && typeof v2 === "string") {
        return transformItem$1(props2, v2);
      }
      return items.value.find((item) => props2.valueComparator(v2, item.value)) || transformItem$1(props2, v2);
    });
  }
  function transformOut(value) {
    return props2.returnObject ? value.map((_ref) => {
      let {
        raw
      } = _ref;
      return raw;
    }) : value.map((_ref2) => {
      let {
        value: value2
      } = _ref2;
      return value2;
    });
  }
  return {
    items,
    transformIn,
    transformOut
  };
}
function isPrimitive(value) {
  return typeof value === "string" || typeof value === "number" || typeof value === "boolean";
}
function transformItem(props2, item) {
  const type2 = getPropertyFromItem(item, props2.itemType, "item");
  const title = isPrimitive(item) ? item : getPropertyFromItem(item, props2.itemTitle);
  const value = getPropertyFromItem(item, props2.itemValue, void 0);
  const children = getPropertyFromItem(item, props2.itemChildren);
  const itemProps = props2.itemProps === true ? pick(item, ["children"])[1] : getPropertyFromItem(item, props2.itemProps);
  const _props = {
    title,
    value,
    ...itemProps
  };
  return {
    type: type2,
    title: _props.title,
    value: _props.value,
    props: _props,
    children: type2 === "item" && children ? transformItems(props2, children) : void 0,
    raw: item
  };
}
function transformItems(props2, items) {
  const array = [];
  for (const item of items) {
    array.push(transformItem(props2, item));
  }
  return array;
}
function useListItems(props2) {
  const items = computed(() => transformItems(props2, props2.items));
  return {
    items
  };
}
const makeVListProps = propsFactory({
  baseColor: String,
  /* @deprecated */
  activeColor: String,
  activeClass: String,
  bgColor: String,
  disabled: Boolean,
  lines: {
    type: [Boolean, String],
    default: "one"
  },
  nav: Boolean,
  ...makeNestedProps({
    selectStrategy: "single-leaf",
    openStrategy: "list"
  }),
  ...makeBorderProps(),
  ...makeComponentProps(),
  ...makeDensityProps(),
  ...makeDimensionProps(),
  ...makeElevationProps(),
  itemType: {
    type: String,
    default: "type"
  },
  ...makeItemsProps(),
  ...makeRoundedProps(),
  ...makeTagProps(),
  ...makeThemeProps(),
  ...makeVariantProps({
    variant: "text"
  })
}, "VList");
const VList = genericComponent()({
  name: "VList",
  props: makeVListProps(),
  emits: {
    "update:selected": (val) => true,
    "update:opened": (val) => true,
    "click:open": (value) => true,
    "click:select": (value) => true
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      items
    } = useListItems(props2);
    const {
      themeClasses
    } = provideTheme(props2);
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props2, "bgColor"));
    const {
      borderClasses
    } = useBorder(props2);
    const {
      densityClasses
    } = useDensity(props2);
    const {
      dimensionStyles
    } = useDimension(props2);
    const {
      elevationClasses
    } = useElevation(props2);
    const {
      roundedClasses
    } = useRounded(props2);
    const {
      open,
      select
    } = useNested(props2);
    const lineClasses = computed(() => props2.lines ? `v-list--${props2.lines}-line` : void 0);
    const activeColor = toRef(props2, "activeColor");
    const baseColor = toRef(props2, "baseColor");
    const color = toRef(props2, "color");
    createList();
    provideDefaults({
      VListGroup: {
        activeColor,
        baseColor,
        color
      },
      VListItem: {
        activeClass: toRef(props2, "activeClass"),
        activeColor,
        baseColor,
        color,
        density: toRef(props2, "density"),
        disabled: toRef(props2, "disabled"),
        lines: toRef(props2, "lines"),
        nav: toRef(props2, "nav"),
        variant: toRef(props2, "variant")
      }
    });
    const isFocused = shallowRef(false);
    const contentRef = ref();
    function onFocusin(e) {
      isFocused.value = true;
    }
    function onFocusout(e) {
      isFocused.value = false;
    }
    function onFocus(e) {
      var _a2;
      if (!isFocused.value && !(e.relatedTarget && ((_a2 = contentRef.value) == null ? void 0 : _a2.contains(e.relatedTarget))))
        focus();
    }
    function onKeydown(e) {
      if (!contentRef.value)
        return;
      if (e.key === "ArrowDown") {
        focus("next");
      } else if (e.key === "ArrowUp") {
        focus("prev");
      } else if (e.key === "Home") {
        focus("first");
      } else if (e.key === "End") {
        focus("last");
      } else {
        return;
      }
      e.preventDefault();
    }
    function focus(location2) {
      if (contentRef.value) {
        return focusChild(contentRef.value, location2);
      }
    }
    useRender(() => {
      return createVNode(props2.tag, {
        "ref": contentRef,
        "class": ["v-list", {
          "v-list--disabled": props2.disabled,
          "v-list--nav": props2.nav
        }, themeClasses.value, backgroundColorClasses.value, borderClasses.value, densityClasses.value, elevationClasses.value, lineClasses.value, roundedClasses.value, props2.class],
        "style": [backgroundColorStyles.value, dimensionStyles.value, props2.style],
        "tabindex": props2.disabled || isFocused.value ? -1 : 0,
        "role": "listbox",
        "aria-activedescendant": void 0,
        "onFocusin": onFocusin,
        "onFocusout": onFocusout,
        "onFocus": onFocus,
        "onKeydown": onKeydown
      }, {
        default: () => [createVNode(VListChildren, {
          "items": items.value,
          "returnObject": props2.returnObject
        }, slots)]
      });
    });
    return {
      open,
      select,
      focus
    };
  }
});
const VListImg = createSimpleFunctional("v-list-img");
const makeVListItemActionProps = propsFactory({
  start: Boolean,
  end: Boolean,
  ...makeComponentProps(),
  ...makeTagProps()
}, "VListItemAction");
const VListItemAction = genericComponent()({
  name: "VListItemAction",
  props: makeVListItemActionProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    useRender(() => createVNode(props2.tag, {
      "class": ["v-list-item-action", {
        "v-list-item-action--start": props2.start,
        "v-list-item-action--end": props2.end
      }, props2.class],
      "style": props2.style
    }, slots));
    return {};
  }
});
const makeVListItemMediaProps = propsFactory({
  start: Boolean,
  end: Boolean,
  ...makeComponentProps(),
  ...makeTagProps()
}, "VListItemMedia");
const VListItemMedia = genericComponent()({
  name: "VListItemMedia",
  props: makeVListItemMediaProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    useRender(() => {
      return createVNode(props2.tag, {
        "class": ["v-list-item-media", {
          "v-list-item-media--start": props2.start,
          "v-list-item-media--end": props2.end
        }, props2.class],
        "style": props2.style
      }, slots);
    });
    return {};
  }
});
const VMenu$1 = "";
const VOverlay$1 = "";
function elementToViewport(point, offset) {
  return {
    x: point.x + offset.x,
    y: point.y + offset.y
  };
}
function getOffset$1(a, b2) {
  return {
    x: a.x - b2.x,
    y: a.y - b2.y
  };
}
function anchorToPoint(anchor, box) {
  if (anchor.side === "top" || anchor.side === "bottom") {
    const {
      side,
      align
    } = anchor;
    const x2 = align === "left" ? 0 : align === "center" ? box.width / 2 : align === "right" ? box.width : align;
    const y2 = side === "top" ? 0 : side === "bottom" ? box.height : side;
    return elementToViewport({
      x: x2,
      y: y2
    }, box);
  } else if (anchor.side === "left" || anchor.side === "right") {
    const {
      side,
      align
    } = anchor;
    const x2 = side === "left" ? 0 : side === "right" ? box.width : side;
    const y2 = align === "top" ? 0 : align === "center" ? box.height / 2 : align === "bottom" ? box.height : align;
    return elementToViewport({
      x: x2,
      y: y2
    }, box);
  }
  return elementToViewport({
    x: box.width / 2,
    y: box.height / 2
  }, box);
}
const locationStrategies = {
  static: staticLocationStrategy,
  // specific viewport position, usually centered
  connected: connectedLocationStrategy
  // connected to a certain element
};
const makeLocationStrategyProps = propsFactory({
  locationStrategy: {
    type: [String, Function],
    default: "static",
    validator: (val) => typeof val === "function" || val in locationStrategies
  },
  location: {
    type: String,
    default: "bottom"
  },
  origin: {
    type: String,
    default: "auto"
  },
  offset: [Number, String, Array]
}, "VOverlay-location-strategies");
function useLocationStrategies(props2, data) {
  const contentStyles = ref({});
  const updateLocation = ref();
  if (IN_BROWSER) {
    useToggleScope(() => !!(data.isActive.value && props2.locationStrategy), (reset) => {
      var _a2, _b;
      watch(() => props2.locationStrategy, reset);
      onScopeDispose(() => {
        updateLocation.value = void 0;
      });
      if (typeof props2.locationStrategy === "function") {
        updateLocation.value = (_a2 = props2.locationStrategy(data, props2, contentStyles)) == null ? void 0 : _a2.updateLocation;
      } else {
        updateLocation.value = (_b = locationStrategies[props2.locationStrategy](data, props2, contentStyles)) == null ? void 0 : _b.updateLocation;
      }
    });
    window.addEventListener("resize", onResize, {
      passive: true
    });
    onScopeDispose(() => {
      window.removeEventListener("resize", onResize);
      updateLocation.value = void 0;
    });
  }
  function onResize(e) {
    var _a2;
    (_a2 = updateLocation.value) == null ? void 0 : _a2.call(updateLocation, e);
  }
  return {
    contentStyles,
    updateLocation
  };
}
function staticLocationStrategy() {
}
function getIntrinsicSize(el, isRtl) {
  if (isRtl) {
    el.style.removeProperty("left");
  } else {
    el.style.removeProperty("right");
  }
  const contentBox = nullifyTransforms(el);
  if (isRtl) {
    contentBox.x += parseFloat(el.style.right || 0);
  } else {
    contentBox.x -= parseFloat(el.style.left || 0);
  }
  contentBox.y -= parseFloat(el.style.top || 0);
  return contentBox;
}
function connectedLocationStrategy(data, props2, contentStyles) {
  const activatorFixed = isFixedPosition(data.activatorEl.value);
  if (activatorFixed) {
    Object.assign(contentStyles.value, {
      position: "fixed",
      top: 0,
      [data.isRtl.value ? "right" : "left"]: 0
    });
  }
  const {
    preferredAnchor,
    preferredOrigin
  } = destructComputed(() => {
    const parsedAnchor = parseAnchor(props2.location, data.isRtl.value);
    const parsedOrigin = props2.origin === "overlap" ? parsedAnchor : props2.origin === "auto" ? flipSide(parsedAnchor) : parseAnchor(props2.origin, data.isRtl.value);
    if (parsedAnchor.side === parsedOrigin.side && parsedAnchor.align === flipAlign(parsedOrigin).align) {
      return {
        preferredAnchor: flipCorner(parsedAnchor),
        preferredOrigin: flipCorner(parsedOrigin)
      };
    } else {
      return {
        preferredAnchor: parsedAnchor,
        preferredOrigin: parsedOrigin
      };
    }
  });
  const [minWidth, minHeight, maxWidth, maxHeight] = ["minWidth", "minHeight", "maxWidth", "maxHeight"].map((key2) => {
    return computed(() => {
      const val = parseFloat(props2[key2]);
      return isNaN(val) ? Infinity : val;
    });
  });
  const offset = computed(() => {
    if (Array.isArray(props2.offset)) {
      return props2.offset;
    }
    if (typeof props2.offset === "string") {
      const offset2 = props2.offset.split(" ").map(parseFloat);
      if (offset2.length < 2)
        offset2.push(0);
      return offset2;
    }
    return typeof props2.offset === "number" ? [props2.offset, 0] : [0, 0];
  });
  let observe = false;
  const observer = new ResizeObserver(() => {
    if (observe)
      updateLocation();
  });
  watch([data.activatorEl, data.contentEl], (_ref, _ref2) => {
    let [newActivatorEl, newContentEl] = _ref;
    let [oldActivatorEl, oldContentEl] = _ref2;
    if (oldActivatorEl)
      observer.unobserve(oldActivatorEl);
    if (newActivatorEl)
      observer.observe(newActivatorEl);
    if (oldContentEl)
      observer.unobserve(oldContentEl);
    if (newContentEl)
      observer.observe(newContentEl);
  }, {
    immediate: true
  });
  onScopeDispose(() => {
    observer.disconnect();
  });
  function updateLocation() {
    observe = false;
    requestAnimationFrame(() => {
      requestAnimationFrame(() => observe = true);
    });
    if (!data.activatorEl.value || !data.contentEl.value)
      return;
    const targetBox = data.activatorEl.value.getBoundingClientRect();
    const contentBox = getIntrinsicSize(data.contentEl.value, data.isRtl.value);
    const scrollParents = getScrollParents(data.contentEl.value);
    const viewportMargin = 12;
    if (!scrollParents.length) {
      scrollParents.push(document.documentElement);
      if (!(data.contentEl.value.style.top && data.contentEl.value.style.left)) {
        contentBox.x -= parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-x") || 0);
        contentBox.y -= parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-y") || 0);
      }
    }
    const viewport = scrollParents.reduce((box, el) => {
      const rect = el.getBoundingClientRect();
      const scrollBox = new Box({
        x: el === document.documentElement ? 0 : rect.x,
        y: el === document.documentElement ? 0 : rect.y,
        width: el.clientWidth,
        height: el.clientHeight
      });
      if (box) {
        return new Box({
          x: Math.max(box.left, scrollBox.left),
          y: Math.max(box.top, scrollBox.top),
          width: Math.min(box.right, scrollBox.right) - Math.max(box.left, scrollBox.left),
          height: Math.min(box.bottom, scrollBox.bottom) - Math.max(box.top, scrollBox.top)
        });
      }
      return scrollBox;
    }, void 0);
    viewport.x += viewportMargin;
    viewport.y += viewportMargin;
    viewport.width -= viewportMargin * 2;
    viewport.height -= viewportMargin * 2;
    let placement = {
      anchor: preferredAnchor.value,
      origin: preferredOrigin.value
    };
    function checkOverflow(_placement) {
      const box = new Box(contentBox);
      const targetPoint = anchorToPoint(_placement.anchor, targetBox);
      const contentPoint = anchorToPoint(_placement.origin, box);
      let {
        x: x3,
        y: y3
      } = getOffset$1(targetPoint, contentPoint);
      switch (_placement.anchor.side) {
        case "top":
          y3 -= offset.value[0];
          break;
        case "bottom":
          y3 += offset.value[0];
          break;
        case "left":
          x3 -= offset.value[0];
          break;
        case "right":
          x3 += offset.value[0];
          break;
      }
      switch (_placement.anchor.align) {
        case "top":
          y3 -= offset.value[1];
          break;
        case "bottom":
          y3 += offset.value[1];
          break;
        case "left":
          x3 -= offset.value[1];
          break;
        case "right":
          x3 += offset.value[1];
          break;
      }
      box.x += x3;
      box.y += y3;
      box.width = Math.min(box.width, maxWidth.value);
      box.height = Math.min(box.height, maxHeight.value);
      const overflows = getOverflow(box, viewport);
      return {
        overflows,
        x: x3,
        y: y3
      };
    }
    let x2 = 0;
    let y2 = 0;
    const available = {
      x: 0,
      y: 0
    };
    const flipped = {
      x: false,
      y: false
    };
    let resets = -1;
    while (true) {
      if (resets++ > 10) {
        break;
      }
      const {
        x: _x,
        y: _y,
        overflows
      } = checkOverflow(placement);
      x2 += _x;
      y2 += _y;
      contentBox.x += _x;
      contentBox.y += _y;
      {
        const axis2 = getAxis(placement.anchor);
        const hasOverflowX = overflows.x.before || overflows.x.after;
        const hasOverflowY = overflows.y.before || overflows.y.after;
        let reset = false;
        ["x", "y"].forEach((key2) => {
          if (key2 === "x" && hasOverflowX && !flipped.x || key2 === "y" && hasOverflowY && !flipped.y) {
            const newPlacement = {
              anchor: {
                ...placement.anchor
              },
              origin: {
                ...placement.origin
              }
            };
            const flip = key2 === "x" ? axis2 === "y" ? flipAlign : flipSide : axis2 === "y" ? flipSide : flipAlign;
            newPlacement.anchor = flip(newPlacement.anchor);
            newPlacement.origin = flip(newPlacement.origin);
            const {
              overflows: newOverflows
            } = checkOverflow(newPlacement);
            if (newOverflows[key2].before <= overflows[key2].before && newOverflows[key2].after <= overflows[key2].after || newOverflows[key2].before + newOverflows[key2].after < (overflows[key2].before + overflows[key2].after) / 2) {
              placement = newPlacement;
              reset = flipped[key2] = true;
            }
          }
        });
        if (reset)
          continue;
      }
      if (overflows.x.before) {
        x2 += overflows.x.before;
        contentBox.x += overflows.x.before;
      }
      if (overflows.x.after) {
        x2 -= overflows.x.after;
        contentBox.x -= overflows.x.after;
      }
      if (overflows.y.before) {
        y2 += overflows.y.before;
        contentBox.y += overflows.y.before;
      }
      if (overflows.y.after) {
        y2 -= overflows.y.after;
        contentBox.y -= overflows.y.after;
      }
      {
        const overflows2 = getOverflow(contentBox, viewport);
        available.x = viewport.width - overflows2.x.before - overflows2.x.after;
        available.y = viewport.height - overflows2.y.before - overflows2.y.after;
        x2 += overflows2.x.before;
        contentBox.x += overflows2.x.before;
        y2 += overflows2.y.before;
        contentBox.y += overflows2.y.before;
      }
      break;
    }
    const axis = getAxis(placement.anchor);
    Object.assign(contentStyles.value, {
      "--v-overlay-anchor-origin": `${placement.anchor.side} ${placement.anchor.align}`,
      transformOrigin: `${placement.origin.side} ${placement.origin.align}`,
      // transform: `translate(${pixelRound(x)}px, ${pixelRound(y)}px)`,
      top: convertToUnit(pixelRound(y2)),
      left: data.isRtl.value ? void 0 : convertToUnit(pixelRound(x2)),
      right: data.isRtl.value ? convertToUnit(pixelRound(-x2)) : void 0,
      minWidth: convertToUnit(axis === "y" ? Math.min(minWidth.value, targetBox.width) : minWidth.value),
      maxWidth: convertToUnit(pixelCeil(clamp(available.x, minWidth.value === Infinity ? 0 : minWidth.value, maxWidth.value))),
      maxHeight: convertToUnit(pixelCeil(clamp(available.y, minHeight.value === Infinity ? 0 : minHeight.value, maxHeight.value)))
    });
    return {
      available,
      contentBox
    };
  }
  watch(() => [preferredAnchor.value, preferredOrigin.value, props2.offset, props2.minWidth, props2.minHeight, props2.maxWidth, props2.maxHeight], () => updateLocation());
  nextTick(() => {
    const result = updateLocation();
    if (!result)
      return;
    const {
      available,
      contentBox
    } = result;
    if (contentBox.height > available.y) {
      requestAnimationFrame(() => {
        updateLocation();
        requestAnimationFrame(() => {
          updateLocation();
        });
      });
    }
  });
  return {
    updateLocation
  };
}
function pixelRound(val) {
  return Math.round(val * devicePixelRatio) / devicePixelRatio;
}
function pixelCeil(val) {
  return Math.ceil(val * devicePixelRatio) / devicePixelRatio;
}
let clean = true;
const frames = [];
function requestNewFrame(cb) {
  if (!clean || frames.length) {
    frames.push(cb);
    run();
  } else {
    clean = false;
    cb();
    run();
  }
}
let raf = -1;
function run() {
  cancelAnimationFrame(raf);
  raf = requestAnimationFrame(() => {
    const frame = frames.shift();
    if (frame)
      frame();
    if (frames.length)
      run();
    else
      clean = true;
  });
}
const scrollStrategies = {
  none: null,
  close: closeScrollStrategy,
  block: blockScrollStrategy,
  reposition: repositionScrollStrategy
};
const makeScrollStrategyProps = propsFactory({
  scrollStrategy: {
    type: [String, Function],
    default: "block",
    validator: (val) => typeof val === "function" || val in scrollStrategies
  }
}, "VOverlay-scroll-strategies");
function useScrollStrategies(props2, data) {
  if (!IN_BROWSER)
    return;
  let scope;
  watchEffect(async () => {
    scope == null ? void 0 : scope.stop();
    if (!(data.isActive.value && props2.scrollStrategy))
      return;
    scope = effectScope();
    await nextTick();
    scope.active && scope.run(() => {
      var _a2;
      if (typeof props2.scrollStrategy === "function") {
        props2.scrollStrategy(data, props2, scope);
      } else {
        (_a2 = scrollStrategies[props2.scrollStrategy]) == null ? void 0 : _a2.call(scrollStrategies, data, props2, scope);
      }
    });
  });
  onScopeDispose(() => {
    scope == null ? void 0 : scope.stop();
  });
}
function closeScrollStrategy(data) {
  function onScroll(e) {
    data.isActive.value = false;
  }
  bindScroll(data.activatorEl.value ?? data.contentEl.value, onScroll);
}
function blockScrollStrategy(data, props2) {
  var _a2;
  const offsetParent = (_a2 = data.root.value) == null ? void 0 : _a2.offsetParent;
  const scrollElements = [.../* @__PURE__ */ new Set([...getScrollParents(data.activatorEl.value, props2.contained ? offsetParent : void 0), ...getScrollParents(data.contentEl.value, props2.contained ? offsetParent : void 0)])].filter((el) => !el.classList.contains("v-overlay-scroll-blocked"));
  const scrollbarWidth = window.innerWidth - document.documentElement.offsetWidth;
  const scrollableParent = ((el) => hasScrollbar(el) && el)(offsetParent || document.documentElement);
  if (scrollableParent) {
    data.root.value.classList.add("v-overlay--scroll-blocked");
  }
  scrollElements.forEach((el, i) => {
    el.style.setProperty("--v-body-scroll-x", convertToUnit(-el.scrollLeft));
    el.style.setProperty("--v-body-scroll-y", convertToUnit(-el.scrollTop));
    if (el !== document.documentElement) {
      el.style.setProperty("--v-scrollbar-offset", convertToUnit(scrollbarWidth));
    }
    el.classList.add("v-overlay-scroll-blocked");
  });
  onScopeDispose(() => {
    scrollElements.forEach((el, i) => {
      const x2 = parseFloat(el.style.getPropertyValue("--v-body-scroll-x"));
      const y2 = parseFloat(el.style.getPropertyValue("--v-body-scroll-y"));
      el.style.removeProperty("--v-body-scroll-x");
      el.style.removeProperty("--v-body-scroll-y");
      el.style.removeProperty("--v-scrollbar-offset");
      el.classList.remove("v-overlay-scroll-blocked");
      el.scrollLeft = -x2;
      el.scrollTop = -y2;
    });
    if (scrollableParent) {
      data.root.value.classList.remove("v-overlay--scroll-blocked");
    }
  });
}
function repositionScrollStrategy(data, props2, scope) {
  let slow = false;
  let raf2 = -1;
  let ric = -1;
  function update(e) {
    requestNewFrame(() => {
      var _a2, _b;
      const start = performance.now();
      (_b = (_a2 = data.updateLocation).value) == null ? void 0 : _b.call(_a2, e);
      const time = performance.now() - start;
      slow = time / (1e3 / 60) > 2;
    });
  }
  ric = (typeof requestIdleCallback === "undefined" ? (cb) => cb() : requestIdleCallback)(() => {
    scope.run(() => {
      bindScroll(data.activatorEl.value ?? data.contentEl.value, (e) => {
        if (slow) {
          cancelAnimationFrame(raf2);
          raf2 = requestAnimationFrame(() => {
            raf2 = requestAnimationFrame(() => {
              update(e);
            });
          });
        } else {
          update(e);
        }
      });
    });
  });
  onScopeDispose(() => {
    typeof cancelIdleCallback !== "undefined" && cancelIdleCallback(ric);
    cancelAnimationFrame(raf2);
  });
}
function bindScroll(el, onScroll) {
  const scrollElements = [document, ...getScrollParents(el)];
  scrollElements.forEach((el2) => {
    el2.addEventListener("scroll", onScroll, {
      passive: true
    });
  });
  onScopeDispose(() => {
    scrollElements.forEach((el2) => {
      el2.removeEventListener("scroll", onScroll);
    });
  });
}
const VMenuSymbol = Symbol.for("vuetify:v-menu");
const makeDelayProps = propsFactory({
  closeDelay: [Number, String],
  openDelay: [Number, String]
}, "delay");
function useDelay(props2, cb) {
  const delays = {};
  const runDelayFactory = (prop) => () => {
    if (!IN_BROWSER)
      return Promise.resolve(true);
    const active = prop === "openDelay";
    delays.closeDelay && window.clearTimeout(delays.closeDelay);
    delete delays.closeDelay;
    delays.openDelay && window.clearTimeout(delays.openDelay);
    delete delays.openDelay;
    return new Promise((resolve2) => {
      const delay = parseInt(props2[prop] ?? 0, 10);
      delays[prop] = window.setTimeout(() => {
        cb == null ? void 0 : cb(active);
        resolve2(active);
      }, delay);
    });
  };
  return {
    runCloseDelay: runDelayFactory("closeDelay"),
    runOpenDelay: runDelayFactory("openDelay")
  };
}
const makeActivatorProps = propsFactory({
  activator: [String, Object],
  activatorProps: {
    type: Object,
    default: () => ({})
  },
  openOnClick: {
    type: Boolean,
    default: void 0
  },
  openOnHover: Boolean,
  openOnFocus: {
    type: Boolean,
    default: void 0
  },
  closeOnContentClick: Boolean,
  ...makeDelayProps()
}, "VOverlay-activator");
function useActivator(props2, _ref) {
  let {
    isActive,
    isTop
  } = _ref;
  const activatorEl = ref();
  let isHovered = false;
  let isFocused = false;
  let firstEnter = true;
  const openOnFocus = computed(() => props2.openOnFocus || props2.openOnFocus == null && props2.openOnHover);
  const openOnClick = computed(() => props2.openOnClick || props2.openOnClick == null && !props2.openOnHover && !openOnFocus.value);
  const {
    runOpenDelay,
    runCloseDelay
  } = useDelay(props2, (value) => {
    if (value === (props2.openOnHover && isHovered || openOnFocus.value && isFocused) && !(props2.openOnHover && isActive.value && !isTop.value)) {
      if (isActive.value !== value) {
        firstEnter = true;
      }
      isActive.value = value;
    }
  });
  const availableEvents = {
    onClick: (e) => {
      e.stopPropagation();
      activatorEl.value = e.currentTarget || e.target;
      isActive.value = !isActive.value;
    },
    onMouseenter: (e) => {
      var _a2;
      if ((_a2 = e.sourceCapabilities) == null ? void 0 : _a2.firesTouchEvents)
        return;
      isHovered = true;
      activatorEl.value = e.currentTarget || e.target;
      runOpenDelay();
    },
    onMouseleave: (e) => {
      isHovered = false;
      runCloseDelay();
    },
    onFocus: (e) => {
      if (matchesSelector(e.target, ":focus-visible") === false)
        return;
      isFocused = true;
      e.stopPropagation();
      activatorEl.value = e.currentTarget || e.target;
      runOpenDelay();
    },
    onBlur: (e) => {
      isFocused = false;
      e.stopPropagation();
      runCloseDelay();
    }
  };
  const activatorEvents = computed(() => {
    const events = {};
    if (openOnClick.value) {
      events.onClick = availableEvents.onClick;
    }
    if (props2.openOnHover) {
      events.onMouseenter = availableEvents.onMouseenter;
      events.onMouseleave = availableEvents.onMouseleave;
    }
    if (openOnFocus.value) {
      events.onFocus = availableEvents.onFocus;
      events.onBlur = availableEvents.onBlur;
    }
    return events;
  });
  const contentEvents = computed(() => {
    const events = {};
    if (props2.openOnHover) {
      events.onMouseenter = () => {
        isHovered = true;
        runOpenDelay();
      };
      events.onMouseleave = () => {
        isHovered = false;
        runCloseDelay();
      };
    }
    if (openOnFocus.value) {
      events.onFocusin = () => {
        isFocused = true;
        runOpenDelay();
      };
      events.onFocusout = () => {
        isFocused = false;
        runCloseDelay();
      };
    }
    if (props2.closeOnContentClick) {
      const menu = inject$1(VMenuSymbol, null);
      events.onClick = () => {
        isActive.value = false;
        menu == null ? void 0 : menu.closeParents();
      };
    }
    return events;
  });
  const scrimEvents = computed(() => {
    const events = {};
    if (props2.openOnHover) {
      events.onMouseenter = () => {
        if (firstEnter) {
          isHovered = true;
          firstEnter = false;
          runOpenDelay();
        }
      };
      events.onMouseleave = () => {
        isHovered = false;
        runCloseDelay();
      };
    }
    return events;
  });
  watch(isTop, (val) => {
    if (val && (props2.openOnHover && !isHovered && (!openOnFocus.value || !isFocused) || openOnFocus.value && !isFocused && (!props2.openOnHover || !isHovered))) {
      isActive.value = false;
    }
  });
  const activatorRef = ref();
  watchEffect(() => {
    if (!activatorRef.value)
      return;
    nextTick(() => {
      activatorEl.value = refElement(activatorRef.value);
    });
  });
  const vm = getCurrentInstance("useActivator");
  let scope;
  watch(() => !!props2.activator, (val) => {
    if (val && IN_BROWSER) {
      scope = effectScope();
      scope.run(() => {
        _useActivator(props2, vm, {
          activatorEl,
          activatorEvents
        });
      });
    } else if (scope) {
      scope.stop();
    }
  }, {
    flush: "post",
    immediate: true
  });
  onScopeDispose(() => {
    scope == null ? void 0 : scope.stop();
  });
  return {
    activatorEl,
    activatorRef,
    activatorEvents,
    contentEvents,
    scrimEvents
  };
}
function _useActivator(props2, vm, _ref2) {
  let {
    activatorEl,
    activatorEvents
  } = _ref2;
  watch(() => props2.activator, (val, oldVal) => {
    if (oldVal && val !== oldVal) {
      const activator = getActivator(oldVal);
      activator && unbindActivatorProps(activator);
    }
    if (val) {
      nextTick(() => bindActivatorProps());
    }
  }, {
    immediate: true
  });
  watch(() => props2.activatorProps, () => {
    bindActivatorProps();
  });
  onScopeDispose(() => {
    unbindActivatorProps();
  });
  function bindActivatorProps() {
    let el = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getActivator();
    let _props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : props2.activatorProps;
    if (!el)
      return;
    bindProps(el, mergeProps(activatorEvents.value, _props));
  }
  function unbindActivatorProps() {
    let el = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getActivator();
    let _props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : props2.activatorProps;
    if (!el)
      return;
    unbindProps(el, mergeProps(activatorEvents.value, _props));
  }
  function getActivator() {
    var _a2, _b;
    let selector = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : props2.activator;
    let activator;
    if (selector) {
      if (selector === "parent") {
        let el = (_b = (_a2 = vm == null ? void 0 : vm.proxy) == null ? void 0 : _a2.$el) == null ? void 0 : _b.parentNode;
        while (el == null ? void 0 : el.hasAttribute("data-no-activator")) {
          el = el.parentNode;
        }
        activator = el;
      } else if (typeof selector === "string") {
        activator = document.querySelector(selector);
      } else if ("$el" in selector) {
        activator = selector.$el;
      } else {
        activator = selector;
      }
    }
    activatorEl.value = (activator == null ? void 0 : activator.nodeType) === Node.ELEMENT_NODE ? activator : null;
    return activatorEl.value;
  }
}
function useHydration() {
  if (!IN_BROWSER)
    return shallowRef(false);
  const {
    ssr
  } = useDisplay();
  if (ssr) {
    const isMounted = shallowRef(false);
    onMounted(() => {
      isMounted.value = true;
    });
    return isMounted;
  } else {
    return shallowRef(true);
  }
}
const makeLazyProps = propsFactory({
  eager: Boolean
}, "lazy");
function useLazy(props2, active) {
  const isBooted = shallowRef(false);
  const hasContent = computed(() => isBooted.value || props2.eager || active.value);
  watch(active, () => isBooted.value = true);
  function onAfterLeave() {
    if (!props2.eager)
      isBooted.value = false;
  }
  return {
    isBooted,
    hasContent,
    onAfterLeave
  };
}
function useScopeId() {
  const vm = getCurrentInstance("useScopeId");
  const scopeId = vm.vnode.scopeId;
  return {
    scopeId: scopeId ? {
      [scopeId]: ""
    } : void 0
  };
}
const StackSymbol = Symbol.for("vuetify:stack");
const globalStack = reactive([]);
function useStack(isActive, zIndex, disableGlobalStack) {
  const vm = getCurrentInstance("useStack");
  const createStackEntry = !disableGlobalStack;
  const parent = inject$1(StackSymbol, void 0);
  const stack2 = reactive({
    activeChildren: /* @__PURE__ */ new Set()
  });
  provide(StackSymbol, stack2);
  const _zIndex = shallowRef(+zIndex.value);
  useToggleScope(isActive, () => {
    var _a2;
    const lastZIndex = (_a2 = globalStack.at(-1)) == null ? void 0 : _a2[1];
    _zIndex.value = lastZIndex ? lastZIndex + 10 : +zIndex.value;
    if (createStackEntry) {
      globalStack.push([vm.uid, _zIndex.value]);
    }
    parent == null ? void 0 : parent.activeChildren.add(vm.uid);
    onScopeDispose(() => {
      if (createStackEntry) {
        const idx = toRaw(globalStack).findIndex((v2) => v2[0] === vm.uid);
        globalStack.splice(idx, 1);
      }
      parent == null ? void 0 : parent.activeChildren.delete(vm.uid);
    });
  });
  const globalTop = shallowRef(true);
  if (createStackEntry) {
    watchEffect(() => {
      var _a2;
      const _isTop = ((_a2 = globalStack.at(-1)) == null ? void 0 : _a2[0]) === vm.uid;
      setTimeout(() => globalTop.value = _isTop);
    });
  }
  const localTop = computed(() => !stack2.activeChildren.size);
  return {
    globalTop: readonly(globalTop),
    localTop,
    stackStyles: computed(() => ({
      zIndex: _zIndex.value
    }))
  };
}
function useTeleport(target) {
  const teleportTarget = computed(() => {
    const _target = target.value;
    if (_target === true || !IN_BROWSER)
      return void 0;
    const targetElement = _target === false ? document.body : typeof _target === "string" ? document.querySelector(_target) : _target;
    if (targetElement == null) {
      return void 0;
    }
    let container = targetElement.querySelector(":scope > .v-overlay-container");
    if (!container) {
      container = document.createElement("div");
      container.className = "v-overlay-container";
      targetElement.appendChild(container);
    }
    return container;
  });
  return {
    teleportTarget
  };
}
function defaultConditional() {
  return true;
}
function checkEvent(e, el, binding) {
  if (!e || checkIsActive(e, binding) === false)
    return false;
  const root2 = attachedRoot(el);
  if (typeof ShadowRoot !== "undefined" && root2 instanceof ShadowRoot && root2.host === e.target)
    return false;
  const elements = (typeof binding.value === "object" && binding.value.include || (() => []))();
  elements.push(el);
  return !elements.some((el2) => el2 == null ? void 0 : el2.contains(e.target));
}
function checkIsActive(e, binding) {
  const isActive = typeof binding.value === "object" && binding.value.closeConditional || defaultConditional;
  return isActive(e);
}
function directive(e, el, binding) {
  const handler = typeof binding.value === "function" ? binding.value : binding.value.handler;
  el._clickOutside.lastMousedownWasOutside && checkEvent(e, el, binding) && setTimeout(() => {
    checkIsActive(e, binding) && handler && handler(e);
  }, 0);
}
function handleShadow(el, callback) {
  const root2 = attachedRoot(el);
  callback(document);
  if (typeof ShadowRoot !== "undefined" && root2 instanceof ShadowRoot) {
    callback(root2);
  }
}
const ClickOutside = {
  // [data-app] may not be found
  // if using bind, inserted makes
  // sure that the root element is
  // available, iOS does not support
  // clicks on body
  mounted(el, binding) {
    const onClick = (e) => directive(e, el, binding);
    const onMousedown = (e) => {
      el._clickOutside.lastMousedownWasOutside = checkEvent(e, el, binding);
    };
    handleShadow(el, (app) => {
      app.addEventListener("click", onClick, true);
      app.addEventListener("mousedown", onMousedown, true);
    });
    if (!el._clickOutside) {
      el._clickOutside = {
        lastMousedownWasOutside: false
      };
    }
    el._clickOutside[binding.instance.$.uid] = {
      onClick,
      onMousedown
    };
  },
  unmounted(el, binding) {
    if (!el._clickOutside)
      return;
    handleShadow(el, (app) => {
      var _a2;
      if (!app || !((_a2 = el._clickOutside) == null ? void 0 : _a2[binding.instance.$.uid]))
        return;
      const {
        onClick,
        onMousedown
      } = el._clickOutside[binding.instance.$.uid];
      app.removeEventListener("click", onClick, true);
      app.removeEventListener("mousedown", onMousedown, true);
    });
    delete el._clickOutside[binding.instance.$.uid];
  }
};
function Scrim(props2) {
  const {
    modelValue,
    color,
    ...rest
  } = props2;
  return createVNode(Transition, {
    "name": "fade-transition",
    "appear": true
  }, {
    default: () => [props2.modelValue && createVNode("div", mergeProps({
      "class": ["v-overlay__scrim", props2.color.backgroundColorClasses.value],
      "style": props2.color.backgroundColorStyles.value
    }, rest), null)]
  });
}
const makeVOverlayProps = propsFactory({
  absolute: Boolean,
  attach: [Boolean, String, Object],
  closeOnBack: {
    type: Boolean,
    default: true
  },
  contained: Boolean,
  contentClass: null,
  contentProps: null,
  disabled: Boolean,
  noClickAnimation: Boolean,
  modelValue: Boolean,
  persistent: Boolean,
  scrim: {
    type: [Boolean, String],
    default: true
  },
  zIndex: {
    type: [Number, String],
    default: 2e3
  },
  ...makeActivatorProps(),
  ...makeComponentProps(),
  ...makeDimensionProps(),
  ...makeLazyProps(),
  ...makeLocationStrategyProps(),
  ...makeScrollStrategyProps(),
  ...makeThemeProps(),
  ...makeTransitionProps()
}, "VOverlay");
const VOverlay = genericComponent()({
  name: "VOverlay",
  directives: {
    ClickOutside
  },
  inheritAttrs: false,
  props: {
    _disableGlobalStack: Boolean,
    ...makeVOverlayProps()
  },
  emits: {
    "click:outside": (e) => true,
    "update:modelValue": (value) => true,
    afterLeave: () => true
  },
  setup(props2, _ref) {
    let {
      slots,
      attrs,
      emit: emit2
    } = _ref;
    const model = useProxiedModel(props2, "modelValue");
    const isActive = computed({
      get: () => model.value,
      set: (v2) => {
        if (!(v2 && props2.disabled))
          model.value = v2;
      }
    });
    const {
      teleportTarget
    } = useTeleport(computed(() => props2.attach || props2.contained));
    const {
      themeClasses
    } = provideTheme(props2);
    const {
      rtlClasses,
      isRtl
    } = useRtl();
    const {
      hasContent,
      onAfterLeave
    } = useLazy(props2, isActive);
    const scrimColor = useBackgroundColor(computed(() => {
      return typeof props2.scrim === "string" ? props2.scrim : null;
    }));
    const {
      globalTop,
      localTop,
      stackStyles
    } = useStack(isActive, toRef(props2, "zIndex"), props2._disableGlobalStack);
    const {
      activatorEl,
      activatorRef,
      activatorEvents,
      contentEvents,
      scrimEvents
    } = useActivator(props2, {
      isActive,
      isTop: localTop
    });
    const {
      dimensionStyles
    } = useDimension(props2);
    const isMounted = useHydration();
    const {
      scopeId
    } = useScopeId();
    watch(() => props2.disabled, (v2) => {
      if (v2)
        isActive.value = false;
    });
    const root2 = ref();
    const contentEl = ref();
    const {
      contentStyles,
      updateLocation
    } = useLocationStrategies(props2, {
      isRtl,
      contentEl,
      activatorEl,
      isActive
    });
    useScrollStrategies(props2, {
      root: root2,
      contentEl,
      activatorEl,
      isActive,
      updateLocation
    });
    function onClickOutside(e) {
      emit2("click:outside", e);
      if (!props2.persistent)
        isActive.value = false;
      else
        animateClick();
    }
    function closeConditional() {
      return isActive.value && globalTop.value;
    }
    IN_BROWSER && watch(isActive, (val) => {
      if (val) {
        window.addEventListener("keydown", onKeydown);
      } else {
        window.removeEventListener("keydown", onKeydown);
      }
    }, {
      immediate: true
    });
    function onKeydown(e) {
      var _a2, _b;
      if (e.key === "Escape" && globalTop.value) {
        if (!props2.persistent) {
          isActive.value = false;
          if ((_a2 = contentEl.value) == null ? void 0 : _a2.contains(document.activeElement)) {
            (_b = activatorEl.value) == null ? void 0 : _b.focus();
          }
        } else
          animateClick();
      }
    }
    const router = useRouter();
    useToggleScope(() => props2.closeOnBack, () => {
      useBackButton(router, (next) => {
        if (globalTop.value && isActive.value) {
          next(false);
          if (!props2.persistent)
            isActive.value = false;
          else
            animateClick();
        } else {
          next();
        }
      });
    });
    const top = ref();
    watch(() => isActive.value && (props2.absolute || props2.contained) && teleportTarget.value == null, (val) => {
      if (val) {
        const scrollParent = getScrollParent(root2.value);
        if (scrollParent && scrollParent !== document.scrollingElement) {
          top.value = scrollParent.scrollTop;
        }
      }
    });
    function animateClick() {
      if (props2.noClickAnimation)
        return;
      contentEl.value && animate(contentEl.value, [{
        transformOrigin: "center"
      }, {
        transform: "scale(1.03)"
      }, {
        transformOrigin: "center"
      }], {
        duration: 150,
        easing: standardEasing
      });
    }
    useRender(() => {
      var _a2;
      return createVNode(Fragment, null, [(_a2 = slots.activator) == null ? void 0 : _a2.call(slots, {
        isActive: isActive.value,
        props: mergeProps({
          ref: activatorRef
        }, activatorEvents.value, props2.activatorProps)
      }), isMounted.value && hasContent.value && createVNode(Teleport, {
        "disabled": !teleportTarget.value,
        "to": teleportTarget.value
      }, {
        default: () => [createVNode("div", mergeProps({
          "class": ["v-overlay", {
            "v-overlay--absolute": props2.absolute || props2.contained,
            "v-overlay--active": isActive.value,
            "v-overlay--contained": props2.contained
          }, themeClasses.value, rtlClasses.value, props2.class],
          "style": [stackStyles.value, {
            top: convertToUnit(top.value)
          }, props2.style],
          "ref": root2
        }, scopeId, attrs), [createVNode(Scrim, mergeProps({
          "color": scrimColor,
          "modelValue": isActive.value && !!props2.scrim
        }, scrimEvents.value), null), createVNode(MaybeTransition, {
          "appear": true,
          "persisted": true,
          "transition": props2.transition,
          "target": activatorEl.value,
          "onAfterLeave": () => {
            onAfterLeave();
            emit2("afterLeave");
          }
        }, {
          default: () => {
            var _a3;
            return [withDirectives(createVNode("div", mergeProps({
              "ref": contentEl,
              "class": ["v-overlay__content", props2.contentClass],
              "style": [dimensionStyles.value, contentStyles.value]
            }, contentEvents.value, props2.contentProps), [(_a3 = slots.default) == null ? void 0 : _a3.call(slots, {
              isActive
            })]), [[vShow, isActive.value], [resolveDirective("click-outside"), {
              handler: onClickOutside,
              closeConditional,
              include: () => [activatorEl.value]
            }]])];
          }
        })])]
      })]);
    });
    return {
      activatorEl,
      animateClick,
      contentEl,
      globalTop,
      localTop,
      updateLocation
    };
  }
});
const Refs = Symbol("Forwarded refs");
function getDescriptor(obj, key2) {
  let currentObj = obj;
  while (currentObj) {
    const descriptor = Reflect.getOwnPropertyDescriptor(currentObj, key2);
    if (descriptor)
      return descriptor;
    currentObj = Object.getPrototypeOf(currentObj);
  }
  return void 0;
}
function forwardRefs(target) {
  for (var _len = arguments.length, refs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    refs[_key - 1] = arguments[_key];
  }
  target[Refs] = refs;
  return new Proxy(target, {
    get(target2, key2) {
      if (Reflect.has(target2, key2)) {
        return Reflect.get(target2, key2);
      }
      if (typeof key2 === "symbol" || key2.startsWith("$") || key2.startsWith("__"))
        return;
      for (const ref2 of refs) {
        if (ref2.value && Reflect.has(ref2.value, key2)) {
          const val = Reflect.get(ref2.value, key2);
          return typeof val === "function" ? val.bind(ref2.value) : val;
        }
      }
    },
    has(target2, key2) {
      if (Reflect.has(target2, key2)) {
        return true;
      }
      if (typeof key2 === "symbol" || key2.startsWith("$") || key2.startsWith("__"))
        return false;
      for (const ref2 of refs) {
        if (ref2.value && Reflect.has(ref2.value, key2)) {
          return true;
        }
      }
      return false;
    },
    set(target2, key2, value) {
      if (Reflect.has(target2, key2)) {
        return Reflect.set(target2, key2, value);
      }
      if (typeof key2 === "symbol" || key2.startsWith("$") || key2.startsWith("__"))
        return false;
      for (const ref2 of refs) {
        if (ref2.value && Reflect.has(ref2.value, key2)) {
          return Reflect.set(ref2.value, key2, value);
        }
      }
      return false;
    },
    getOwnPropertyDescriptor(target2, key2) {
      var _a2;
      const descriptor = Reflect.getOwnPropertyDescriptor(target2, key2);
      if (descriptor)
        return descriptor;
      if (typeof key2 === "symbol" || key2.startsWith("$") || key2.startsWith("__"))
        return;
      for (const ref2 of refs) {
        if (!ref2.value)
          continue;
        const descriptor2 = getDescriptor(ref2.value, key2) ?? ("_" in ref2.value ? getDescriptor((_a2 = ref2.value._) == null ? void 0 : _a2.setupState, key2) : void 0);
        if (descriptor2)
          return descriptor2;
      }
      for (const ref2 of refs) {
        const childRefs = ref2.value && ref2.value[Refs];
        if (!childRefs)
          continue;
        const queue2 = childRefs.slice();
        while (queue2.length) {
          const ref3 = queue2.shift();
          const descriptor2 = getDescriptor(ref3.value, key2);
          if (descriptor2)
            return descriptor2;
          const childRefs2 = ref3.value && ref3.value[Refs];
          if (childRefs2)
            queue2.push(...childRefs2);
        }
      }
      return void 0;
    }
  });
}
const makeVMenuProps = propsFactory({
  // TODO
  // disableKeys: Boolean,
  id: String,
  ...omit(makeVOverlayProps({
    closeDelay: 250,
    closeOnContentClick: true,
    locationStrategy: "connected",
    openDelay: 300,
    scrim: false,
    scrollStrategy: "reposition",
    transition: {
      component: VDialogTransition
    }
  }), ["absolute"])
}, "VMenu");
const VMenu = genericComponent()({
  name: "VMenu",
  props: makeVMenuProps(),
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const isActive = useProxiedModel(props2, "modelValue");
    const {
      scopeId
    } = useScopeId();
    const uid2 = getUid();
    const id = computed(() => props2.id || `v-menu-${uid2}`);
    const overlay = ref();
    const parent = inject$1(VMenuSymbol, null);
    const openChildren = shallowRef(0);
    provide(VMenuSymbol, {
      register() {
        ++openChildren.value;
      },
      unregister() {
        --openChildren.value;
      },
      closeParents() {
        setTimeout(() => {
          if (!openChildren.value) {
            isActive.value = false;
            parent == null ? void 0 : parent.closeParents();
          }
        }, 40);
      }
    });
    async function onFocusIn(e) {
      var _a2, _b, _c;
      const before = e.relatedTarget;
      const after = e.target;
      await nextTick();
      if (isActive.value && before !== after && ((_a2 = overlay.value) == null ? void 0 : _a2.contentEl) && // We're the topmost menu
      ((_b = overlay.value) == null ? void 0 : _b.globalTop) && // It isn't the document or the menu body
      ![document, overlay.value.contentEl].includes(after) && // It isn't inside the menu body
      !overlay.value.contentEl.contains(after)) {
        const focusable = focusableChildren(overlay.value.contentEl);
        (_c = focusable[0]) == null ? void 0 : _c.focus();
      }
    }
    watch(isActive, (val) => {
      if (val) {
        parent == null ? void 0 : parent.register();
        document.addEventListener("focusin", onFocusIn, {
          once: true
        });
      } else {
        parent == null ? void 0 : parent.unregister();
        document.removeEventListener("focusin", onFocusIn);
      }
    });
    function onClickOutside() {
      parent == null ? void 0 : parent.closeParents();
    }
    function onKeydown(e) {
      var _a2, _b, _c;
      if (props2.disabled)
        return;
      if (e.key === "Tab") {
        const nextElement = getNextElement(focusableChildren((_a2 = overlay.value) == null ? void 0 : _a2.contentEl, false), e.shiftKey ? "prev" : "next", (el) => el.tabIndex >= 0);
        if (!nextElement) {
          isActive.value = false;
          (_c = (_b = overlay.value) == null ? void 0 : _b.activatorEl) == null ? void 0 : _c.focus();
        }
      }
    }
    function onActivatorKeydown(e) {
      var _a2;
      if (props2.disabled)
        return;
      const el = (_a2 = overlay.value) == null ? void 0 : _a2.contentEl;
      if (el && isActive.value) {
        if (e.key === "ArrowDown") {
          e.preventDefault();
          focusChild(el, "next");
        } else if (e.key === "ArrowUp") {
          e.preventDefault();
          focusChild(el, "prev");
        }
      } else if (["ArrowDown", "ArrowUp"].includes(e.key)) {
        isActive.value = true;
        e.preventDefault();
        setTimeout(() => setTimeout(() => onActivatorKeydown(e)));
      }
    }
    const activatorProps = computed(() => mergeProps({
      "aria-haspopup": "menu",
      "aria-expanded": String(isActive.value),
      "aria-owns": id.value,
      onKeydown: onActivatorKeydown
    }, props2.activatorProps));
    useRender(() => {
      const [overlayProps] = VOverlay.filterProps(props2);
      return createVNode(VOverlay, mergeProps({
        "ref": overlay,
        "class": ["v-menu", props2.class],
        "style": props2.style
      }, overlayProps, {
        "modelValue": isActive.value,
        "onUpdate:modelValue": ($event) => isActive.value = $event,
        "absolute": true,
        "activatorProps": activatorProps.value,
        "onClick:outside": onClickOutside,
        "onKeydown": onKeydown
      }, scopeId), {
        activator: slots.activator,
        default: function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return createVNode(VDefaultsProvider, {
            "root": "VMenu"
          }, {
            default: () => {
              var _a2;
              return [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, ...args)];
            }
          });
        }
      });
    });
    return forwardRefs({
      id,
      ΨopenChildren: openChildren
    }, overlay);
  }
});
const VSelect$1 = "";
const VTextField$1 = "";
const VCounter$1 = "";
const makeVCounterProps = propsFactory({
  active: Boolean,
  max: [Number, String],
  value: {
    type: [Number, String],
    default: 0
  },
  ...makeComponentProps(),
  ...makeTransitionProps({
    transition: {
      component: VSlideYTransition
    }
  })
}, "VCounter");
const VCounter = genericComponent()({
  name: "VCounter",
  functional: true,
  props: makeVCounterProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const counter = computed(() => {
      return props2.max ? `${props2.value} / ${props2.max}` : String(props2.value);
    });
    useRender(() => createVNode(MaybeTransition, {
      "transition": props2.transition
    }, {
      default: () => [withDirectives(createVNode("div", {
        "class": ["v-counter", props2.class],
        "style": props2.style
      }, [slots.default ? slots.default({
        counter: counter.value,
        max: props2.max,
        value: props2.value
      }) : counter.value]), [[vShow, props2.active]])]
    }));
    return {};
  }
});
const VField$1 = "";
const makeVFieldLabelProps = propsFactory({
  floating: Boolean,
  ...makeComponentProps()
}, "VFieldLabel");
const VFieldLabel = genericComponent()({
  name: "VFieldLabel",
  props: makeVFieldLabelProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    useRender(() => createVNode(VLabel, {
      "class": ["v-field-label", {
        "v-field-label--floating": props2.floating
      }, props2.class],
      "style": props2.style,
      "aria-hidden": props2.floating || void 0
    }, slots));
    return {};
  }
});
const allowedVariants$1 = ["underlined", "outlined", "filled", "solo", "solo-inverted", "solo-filled", "plain"];
const makeVFieldProps = propsFactory({
  appendInnerIcon: IconValue,
  bgColor: String,
  clearable: Boolean,
  clearIcon: {
    type: IconValue,
    default: "$clear"
  },
  active: Boolean,
  centerAffix: {
    type: Boolean,
    default: void 0
  },
  color: String,
  baseColor: String,
  dirty: Boolean,
  disabled: {
    type: Boolean,
    default: null
  },
  error: Boolean,
  flat: Boolean,
  label: String,
  persistentClear: Boolean,
  prependInnerIcon: IconValue,
  reverse: Boolean,
  singleLine: Boolean,
  variant: {
    type: String,
    default: "filled",
    validator: (v2) => allowedVariants$1.includes(v2)
  },
  "onClick:clear": EventProp(),
  "onClick:appendInner": EventProp(),
  "onClick:prependInner": EventProp(),
  ...makeComponentProps(),
  ...makeLoaderProps(),
  ...makeRoundedProps(),
  ...makeThemeProps()
}, "VField");
const VField = genericComponent()({
  name: "VField",
  inheritAttrs: false,
  props: {
    id: String,
    ...makeFocusProps(),
    ...makeVFieldProps()
  },
  emits: {
    "update:focused": (focused) => true,
    "update:modelValue": (val) => true
  },
  setup(props2, _ref) {
    let {
      attrs,
      emit: emit2,
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props2);
    const {
      loaderClasses
    } = useLoader(props2);
    const {
      focusClasses,
      isFocused,
      focus,
      blur
    } = useFocus(props2);
    const {
      InputIcon
    } = useInputIcon(props2);
    const {
      roundedClasses
    } = useRounded(props2);
    const {
      rtlClasses
    } = useRtl();
    const isActive = computed(() => props2.dirty || props2.active);
    const hasLabel = computed(() => !props2.singleLine && !!(props2.label || slots.label));
    const uid2 = getUid();
    const id = computed(() => props2.id || `input-${uid2}`);
    const messagesId = computed(() => `${id.value}-messages`);
    const labelRef = ref();
    const floatingLabelRef = ref();
    const controlRef = ref();
    const isPlainOrUnderlined = computed(() => ["plain", "underlined"].includes(props2.variant));
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props2, "bgColor"));
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(computed(() => {
      return props2.error || props2.disabled ? void 0 : isActive.value && isFocused.value ? props2.color : props2.baseColor;
    }));
    watch(isActive, (val) => {
      if (hasLabel.value) {
        const el = labelRef.value.$el;
        const targetEl = floatingLabelRef.value.$el;
        requestAnimationFrame(() => {
          const rect = nullifyTransforms(el);
          const targetRect = targetEl.getBoundingClientRect();
          const x2 = targetRect.x - rect.x;
          const y2 = targetRect.y - rect.y - (rect.height / 2 - targetRect.height / 2);
          const targetWidth = targetRect.width / 0.75;
          const width = Math.abs(targetWidth - rect.width) > 1 ? {
            maxWidth: convertToUnit(targetWidth)
          } : void 0;
          const style3 = getComputedStyle(el);
          const targetStyle = getComputedStyle(targetEl);
          const duration = parseFloat(style3.transitionDuration) * 1e3 || 150;
          const scale = parseFloat(targetStyle.getPropertyValue("--v-field-label-scale"));
          const color = targetStyle.getPropertyValue("color");
          el.style.visibility = "visible";
          targetEl.style.visibility = "hidden";
          animate(el, {
            transform: `translate(${x2}px, ${y2}px) scale(${scale})`,
            color,
            ...width
          }, {
            duration,
            easing: standardEasing,
            direction: val ? "normal" : "reverse"
          }).finished.then(() => {
            el.style.removeProperty("visibility");
            targetEl.style.removeProperty("visibility");
          });
        });
      }
    }, {
      flush: "post"
    });
    const slotProps = computed(() => ({
      isActive,
      isFocused,
      controlRef,
      blur,
      focus
    }));
    function onClick(e) {
      if (e.target !== document.activeElement) {
        e.preventDefault();
      }
    }
    useRender(() => {
      var _a2, _b, _c;
      const isOutlined = props2.variant === "outlined";
      const hasPrepend = slots["prepend-inner"] || props2.prependInnerIcon;
      const hasClear = !!(props2.clearable || slots.clear);
      const hasAppend = !!(slots["append-inner"] || props2.appendInnerIcon || hasClear);
      const label = slots.label ? slots.label({
        ...slotProps.value,
        label: props2.label,
        props: {
          for: id.value
        }
      }) : props2.label;
      return createVNode("div", mergeProps({
        "class": ["v-field", {
          "v-field--active": isActive.value,
          "v-field--appended": hasAppend,
          "v-field--center-affix": props2.centerAffix ?? !isPlainOrUnderlined.value,
          "v-field--disabled": props2.disabled,
          "v-field--dirty": props2.dirty,
          "v-field--error": props2.error,
          "v-field--flat": props2.flat,
          "v-field--has-background": !!props2.bgColor,
          "v-field--persistent-clear": props2.persistentClear,
          "v-field--prepended": hasPrepend,
          "v-field--reverse": props2.reverse,
          "v-field--single-line": props2.singleLine,
          "v-field--no-label": !label,
          [`v-field--variant-${props2.variant}`]: true
        }, themeClasses.value, backgroundColorClasses.value, focusClasses.value, loaderClasses.value, roundedClasses.value, rtlClasses.value, props2.class],
        "style": [backgroundColorStyles.value, props2.style],
        "onClick": onClick
      }, attrs), [createVNode("div", {
        "class": "v-field__overlay"
      }, null), createVNode(LoaderSlot, {
        "name": "v-field",
        "active": !!props2.loading,
        "color": props2.error ? "error" : typeof props2.loading === "string" ? props2.loading : props2.color
      }, {
        default: slots.loader
      }), hasPrepend && createVNode("div", {
        "key": "prepend",
        "class": "v-field__prepend-inner"
      }, [props2.prependInnerIcon && createVNode(InputIcon, {
        "key": "prepend-icon",
        "name": "prependInner"
      }, null), (_a2 = slots["prepend-inner"]) == null ? void 0 : _a2.call(slots, slotProps.value)]), createVNode("div", {
        "class": "v-field__field",
        "data-no-activator": ""
      }, [["filled", "solo", "solo-inverted", "solo-filled"].includes(props2.variant) && hasLabel.value && createVNode(VFieldLabel, {
        "key": "floating-label",
        "ref": floatingLabelRef,
        "class": [textColorClasses.value],
        "floating": true,
        "for": id.value,
        "style": textColorStyles.value
      }, {
        default: () => [label]
      }), createVNode(VFieldLabel, {
        "ref": labelRef,
        "for": id.value
      }, {
        default: () => [label]
      }), (_b = slots.default) == null ? void 0 : _b.call(slots, {
        ...slotProps.value,
        props: {
          id: id.value,
          class: "v-field__input",
          "aria-describedby": messagesId.value
        },
        focus,
        blur
      })]), hasClear && createVNode(VExpandXTransition, {
        "key": "clear"
      }, {
        default: () => [withDirectives(createVNode("div", {
          "class": "v-field__clearable",
          "onMousedown": (e) => {
            e.preventDefault();
            e.stopPropagation();
          }
        }, [slots.clear ? slots.clear() : createVNode(InputIcon, {
          "name": "clear"
        }, null)]), [[vShow, props2.dirty]])]
      }), hasAppend && createVNode("div", {
        "key": "append",
        "class": "v-field__append-inner"
      }, [(_c = slots["append-inner"]) == null ? void 0 : _c.call(slots, slotProps.value), props2.appendInnerIcon && createVNode(InputIcon, {
        "key": "append-icon",
        "name": "appendInner"
      }, null)]), createVNode("div", {
        "class": ["v-field__outline", textColorClasses.value],
        "style": textColorStyles.value
      }, [isOutlined && createVNode(Fragment, null, [createVNode("div", {
        "class": "v-field__outline__start"
      }, null), hasLabel.value && createVNode("div", {
        "class": "v-field__outline__notch"
      }, [createVNode(VFieldLabel, {
        "ref": floatingLabelRef,
        "floating": true,
        "for": id.value
      }, {
        default: () => [label]
      })]), createVNode("div", {
        "class": "v-field__outline__end"
      }, null)]), isPlainOrUnderlined.value && hasLabel.value && createVNode(VFieldLabel, {
        "ref": floatingLabelRef,
        "floating": true,
        "for": id.value
      }, {
        default: () => [label]
      })])]);
    });
    return {
      controlRef
    };
  }
});
function filterFieldProps(attrs) {
  const keys2 = Object.keys(VField.props).filter((k2) => !isOn(k2) && k2 !== "class" && k2 !== "style");
  return pick(attrs, keys2);
}
const activeTypes = ["color", "file", "time", "date", "datetime-local", "week", "month"];
const makeVTextFieldProps = propsFactory({
  autofocus: Boolean,
  counter: [Boolean, Number, String],
  counterValue: [Number, Function],
  prefix: String,
  placeholder: String,
  persistentPlaceholder: Boolean,
  persistentCounter: Boolean,
  suffix: String,
  role: String,
  type: {
    type: String,
    default: "text"
  },
  modelModifiers: Object,
  ...makeVInputProps(),
  ...makeVFieldProps()
}, "VTextField");
const VTextField = genericComponent()({
  name: "VTextField",
  directives: {
    Intersect: Intersect$1
  },
  inheritAttrs: false,
  props: makeVTextFieldProps(),
  emits: {
    "click:control": (e) => true,
    "mousedown:control": (e) => true,
    "update:focused": (focused) => true,
    "update:modelValue": (val) => true
  },
  setup(props2, _ref) {
    let {
      attrs,
      emit: emit2,
      slots
    } = _ref;
    const model = useProxiedModel(props2, "modelValue");
    const {
      isFocused,
      focus,
      blur
    } = useFocus(props2);
    const counterValue = computed(() => {
      return typeof props2.counterValue === "function" ? props2.counterValue(model.value) : typeof props2.counterValue === "number" ? props2.counterValue : (model.value ?? "").toString().length;
    });
    const max2 = computed(() => {
      if (attrs.maxlength)
        return attrs.maxlength;
      if (!props2.counter || typeof props2.counter !== "number" && typeof props2.counter !== "string")
        return void 0;
      return props2.counter;
    });
    const isPlainOrUnderlined = computed(() => ["plain", "underlined"].includes(props2.variant));
    function onIntersect(isIntersecting, entries) {
      var _a2, _b;
      if (!props2.autofocus || !isIntersecting)
        return;
      (_b = (_a2 = entries[0].target) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
    }
    const vInputRef = ref();
    const vFieldRef = ref();
    const inputRef = ref();
    const isActive = computed(() => activeTypes.includes(props2.type) || props2.persistentPlaceholder || isFocused.value || props2.active);
    function onFocus() {
      var _a2;
      if (inputRef.value !== document.activeElement) {
        (_a2 = inputRef.value) == null ? void 0 : _a2.focus();
      }
      if (!isFocused.value)
        focus();
    }
    function onControlMousedown(e) {
      emit2("mousedown:control", e);
      if (e.target === inputRef.value)
        return;
      onFocus();
      e.preventDefault();
    }
    function onControlClick(e) {
      onFocus();
      emit2("click:control", e);
    }
    function onClear(e) {
      e.stopPropagation();
      onFocus();
      nextTick(() => {
        model.value = null;
        callEvent(props2["onClick:clear"], e);
      });
    }
    function onInput(e) {
      var _a2;
      const el = e.target;
      model.value = el.value;
      if (((_a2 = props2.modelModifiers) == null ? void 0 : _a2.trim) && ["text", "search", "password", "tel", "url"].includes(props2.type)) {
        const caretPosition = [el.selectionStart, el.selectionEnd];
        nextTick(() => {
          el.selectionStart = caretPosition[0];
          el.selectionEnd = caretPosition[1];
        });
      }
    }
    useRender(() => {
      const hasCounter = !!(slots.counter || props2.counter !== false && props2.counter != null);
      const hasDetails = !!(hasCounter || slots.details);
      const [rootAttrs, inputAttrs] = filterInputAttrs(attrs);
      const [{
        modelValue: _2,
        ...inputProps
      }] = VInput.filterProps(props2);
      const [fieldProps] = filterFieldProps(props2);
      return createVNode(VInput, mergeProps({
        "ref": vInputRef,
        "modelValue": model.value,
        "onUpdate:modelValue": ($event) => model.value = $event,
        "class": ["v-text-field", {
          "v-text-field--prefixed": props2.prefix,
          "v-text-field--suffixed": props2.suffix,
          "v-text-field--plain-underlined": ["plain", "underlined"].includes(props2.variant)
        }, props2.class],
        "style": props2.style
      }, rootAttrs, inputProps, {
        "centerAffix": !isPlainOrUnderlined.value,
        "focused": isFocused.value
      }), {
        ...slots,
        default: (_ref2) => {
          let {
            id,
            isDisabled,
            isDirty,
            isReadonly: isReadonly2,
            isValid: isValid2
          } = _ref2;
          return createVNode(VField, mergeProps({
            "ref": vFieldRef,
            "onMousedown": onControlMousedown,
            "onClick": onControlClick,
            "onClick:clear": onClear,
            "onClick:prependInner": props2["onClick:prependInner"],
            "onClick:appendInner": props2["onClick:appendInner"],
            "role": props2.role
          }, fieldProps, {
            "id": id.value,
            "active": isActive.value || isDirty.value,
            "dirty": isDirty.value || props2.dirty,
            "disabled": isDisabled.value,
            "focused": isFocused.value,
            "error": isValid2.value === false
          }), {
            ...slots,
            default: (_ref3) => {
              let {
                props: {
                  class: fieldClass,
                  ...slotProps
                }
              } = _ref3;
              const inputNode = withDirectives(createVNode("input", mergeProps({
                "ref": inputRef,
                "value": model.value,
                "onInput": onInput,
                "autofocus": props2.autofocus,
                "readonly": isReadonly2.value,
                "disabled": isDisabled.value,
                "name": props2.name,
                "placeholder": props2.placeholder,
                "size": 1,
                "type": props2.type,
                "onFocus": onFocus,
                "onBlur": blur
              }, slotProps, inputAttrs), null), [[resolveDirective("intersect"), {
                handler: onIntersect
              }, null, {
                once: true
              }]]);
              return createVNode(Fragment, null, [props2.prefix && createVNode("span", {
                "class": "v-text-field__prefix"
              }, [createVNode("span", {
                "class": "v-text-field__prefix__text"
              }, [props2.prefix])]), slots.default ? createVNode("div", {
                "class": fieldClass,
                "data-no-activator": ""
              }, [slots.default(), inputNode]) : cloneVNode(inputNode, {
                class: fieldClass
              }), props2.suffix && createVNode("span", {
                "class": "v-text-field__suffix"
              }, [createVNode("span", {
                "class": "v-text-field__suffix__text"
              }, [props2.suffix])])]);
            }
          });
        },
        details: hasDetails ? (slotProps) => {
          var _a2;
          return createVNode(Fragment, null, [(_a2 = slots.details) == null ? void 0 : _a2.call(slots, slotProps), hasCounter && createVNode(Fragment, null, [createVNode("span", null, null), createVNode(VCounter, {
            "active": props2.persistentCounter || isFocused.value,
            "value": counterValue.value,
            "max": max2.value
          }, slots.counter)])]);
        } : void 0
      });
    });
    return forwardRefs({}, vInputRef, vFieldRef, inputRef);
  }
});
const VVirtualScroll$1 = "";
const makeVVirtualScrollItemProps = propsFactory({
  renderless: Boolean,
  ...makeComponentProps()
}, "VVirtualScrollItem");
const VVirtualScrollItem = genericComponent()({
  name: "VVirtualScrollItem",
  inheritAttrs: false,
  props: makeVVirtualScrollItemProps(),
  emits: {
    "update:height": (height) => true
  },
  setup(props2, _ref) {
    let {
      attrs,
      emit: emit2,
      slots
    } = _ref;
    const {
      resizeRef,
      contentRect
    } = useResizeObserver(void 0, "border");
    watch(() => {
      var _a2;
      return (_a2 = contentRect.value) == null ? void 0 : _a2.height;
    }, (height) => {
      if (height != null)
        emit2("update:height", height);
    });
    useRender(() => {
      var _a2, _b;
      return props2.renderless ? createVNode(Fragment, null, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
        itemRef: resizeRef
      })]) : createVNode("div", mergeProps({
        "ref": resizeRef,
        "class": ["v-virtual-scroll__item", props2.class],
        "style": props2.style
      }, attrs), [(_b = slots.default) == null ? void 0 : _b.call(slots)]);
    });
  }
});
const UP = -1;
const DOWN = 1;
const makeVirtualProps = propsFactory({
  itemHeight: {
    type: [Number, String],
    default: 48
  }
}, "virtual");
function useVirtual(props2, items, offset) {
  const first = shallowRef(0);
  const baseItemHeight = shallowRef(props2.itemHeight);
  const itemHeight = computed({
    get: () => parseInt(baseItemHeight.value ?? 0, 10),
    set(val) {
      baseItemHeight.value = val;
    }
  });
  const containerRef = ref();
  const {
    resizeRef,
    contentRect
  } = useResizeObserver();
  watchEffect(() => {
    resizeRef.value = containerRef.value;
  });
  const display = useDisplay();
  const sizeMap = /* @__PURE__ */ new Map();
  let sizes = Array.from({
    length: items.value.length
  });
  const visibleItems = computed(() => {
    const height = (!contentRect.value || containerRef.value === document.documentElement ? display.height.value : contentRect.value.height) - ((offset == null ? void 0 : offset.value) ?? 0);
    return Math.ceil(height / itemHeight.value * 1.7 + 1);
  });
  function handleItemResize(index2, height) {
    itemHeight.value = Math.max(itemHeight.value, height);
    sizes[index2] = height;
    sizeMap.set(items.value[index2], height);
  }
  function calculateOffset(index2) {
    return sizes.slice(0, index2).reduce((acc, val) => acc + (val || itemHeight.value), 0);
  }
  function calculateMidPointIndex(scrollTop) {
    const end = items.value.length;
    let middle = 0;
    let middleOffset = 0;
    while (middleOffset < scrollTop && middle < end) {
      middleOffset += sizes[middle++] || itemHeight.value;
    }
    return middle - 1;
  }
  let lastScrollTop = 0;
  function handleScroll() {
    if (!containerRef.value || !contentRect.value)
      return;
    const height = contentRect.value.height - 56;
    const scrollTop = containerRef.value.scrollTop;
    const direction = scrollTop < lastScrollTop ? UP : DOWN;
    const midPointIndex = calculateMidPointIndex(scrollTop + height / 2);
    const buffer2 = Math.round(visibleItems.value / 3);
    const firstIndex = midPointIndex - buffer2;
    const lastIndex = first.value + buffer2 * 2 - 1;
    if (direction === UP && midPointIndex <= lastIndex) {
      first.value = clamp(firstIndex, 0, items.value.length);
    } else if (direction === DOWN && midPointIndex >= lastIndex) {
      first.value = clamp(firstIndex, 0, items.value.length - visibleItems.value);
    }
    lastScrollTop = scrollTop;
  }
  function scrollToIndex(index2) {
    if (!containerRef.value)
      return;
    const offset2 = calculateOffset(index2);
    containerRef.value.scrollTop = offset2;
  }
  const last = computed(() => Math.min(items.value.length, first.value + visibleItems.value));
  const computedItems = computed(() => {
    return items.value.slice(first.value, last.value).map((item, index2) => ({
      raw: item,
      index: index2 + first.value
    }));
  });
  const paddingTop = computed(() => calculateOffset(first.value));
  const paddingBottom = computed(() => calculateOffset(items.value.length) - calculateOffset(last.value));
  watch(() => items.value.length, () => {
    sizes = createRange(items.value.length).map(() => itemHeight.value);
    sizeMap.forEach((height, item) => {
      const index2 = items.value.indexOf(item);
      if (index2 === -1) {
        sizeMap.delete(item);
      } else {
        sizes[index2] = height;
      }
    });
  });
  return {
    containerRef,
    computedItems,
    itemHeight,
    paddingTop,
    paddingBottom,
    scrollToIndex,
    handleScroll,
    handleItemResize
  };
}
const makeVVirtualScrollProps = propsFactory({
  items: {
    type: Array,
    default: () => []
  },
  renderless: Boolean,
  ...makeVirtualProps(),
  ...makeComponentProps(),
  ...makeDimensionProps()
}, "VVirtualScroll");
const VVirtualScroll = genericComponent()({
  name: "VVirtualScroll",
  props: makeVVirtualScrollProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const vm = getCurrentInstance("VVirtualScroll");
    const {
      dimensionStyles
    } = useDimension(props2);
    const {
      containerRef,
      handleScroll,
      handleItemResize,
      scrollToIndex,
      paddingTop,
      paddingBottom,
      computedItems
    } = useVirtual(props2, toRef(props2, "items"));
    useToggleScope(() => props2.renderless, () => {
      onMounted(() => {
        var _a2;
        containerRef.value = getScrollParent(vm.vnode.el, true);
        (_a2 = containerRef.value) == null ? void 0 : _a2.addEventListener("scroll", handleScroll);
      });
      onScopeDispose(() => {
        var _a2;
        (_a2 = containerRef.value) == null ? void 0 : _a2.removeEventListener("scroll", handleScroll);
      });
    });
    useRender(() => {
      const children = computedItems.value.map((item) => createVNode(VVirtualScrollItem, {
        "key": item.index,
        "renderless": props2.renderless,
        "onUpdate:height": (height) => handleItemResize(item.index, height)
      }, {
        default: (slotProps) => {
          var _a2;
          return (_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
            item: item.raw,
            index: item.index,
            ...slotProps
          });
        }
      }));
      return props2.renderless ? createVNode(Fragment, null, [createVNode("div", {
        "class": "v-virtual-scroll__spacer",
        "style": {
          paddingTop: convertToUnit(paddingTop.value)
        }
      }, null), children, createVNode("div", {
        "class": "v-virtual-scroll__spacer",
        "style": {
          paddingBottom: convertToUnit(paddingBottom.value)
        }
      }, null)]) : createVNode("div", {
        "ref": containerRef,
        "class": ["v-virtual-scroll", props2.class],
        "onScroll": handleScroll,
        "style": [dimensionStyles.value, props2.style]
      }, [createVNode("div", {
        "class": "v-virtual-scroll__container",
        "style": {
          paddingTop: convertToUnit(paddingTop.value),
          paddingBottom: convertToUnit(paddingBottom.value)
        }
      }, [children])]);
    });
    return {
      scrollToIndex
    };
  }
});
function useScrolling(listRef, textFieldRef) {
  const isScrolling = shallowRef(false);
  let scrollTimeout;
  function onListScroll(e) {
    cancelAnimationFrame(scrollTimeout);
    isScrolling.value = true;
    scrollTimeout = requestAnimationFrame(() => {
      scrollTimeout = requestAnimationFrame(() => {
        isScrolling.value = false;
      });
    });
  }
  async function finishScrolling() {
    await new Promise((resolve2) => requestAnimationFrame(resolve2));
    await new Promise((resolve2) => requestAnimationFrame(resolve2));
    await new Promise((resolve2) => requestAnimationFrame(resolve2));
    await new Promise((resolve2) => {
      if (isScrolling.value) {
        const stop2 = watch(isScrolling, () => {
          stop2();
          resolve2();
        });
      } else
        resolve2();
    });
  }
  async function onListKeydown(e) {
    var _a2, _b;
    if (e.key === "Tab") {
      (_a2 = textFieldRef.value) == null ? void 0 : _a2.focus();
    }
    if (!["PageDown", "PageUp", "Home", "End"].includes(e.key))
      return;
    const el = (_b = listRef.value) == null ? void 0 : _b.$el;
    if (!el)
      return;
    if (e.key === "Home" || e.key === "End") {
      el.scrollTo({
        top: e.key === "Home" ? 0 : el.scrollHeight,
        behavior: "smooth"
      });
    }
    await finishScrolling();
    const children = el.querySelectorAll(":scope > :not(.v-virtual-scroll__spacer)");
    if (e.key === "PageDown" || e.key === "Home") {
      const top = el.getBoundingClientRect().top;
      for (const child of children) {
        if (child.getBoundingClientRect().top >= top) {
          child.focus();
          break;
        }
      }
    } else {
      const bottom = el.getBoundingClientRect().bottom;
      for (const child of [...children].reverse()) {
        if (child.getBoundingClientRect().bottom <= bottom) {
          child.focus();
          break;
        }
      }
    }
  }
  return {
    onListScroll,
    onListKeydown
  };
}
const makeSelectProps = propsFactory({
  chips: Boolean,
  closableChips: Boolean,
  closeText: {
    type: String,
    default: "$vuetify.close"
  },
  openText: {
    type: String,
    default: "$vuetify.open"
  },
  eager: Boolean,
  hideNoData: Boolean,
  hideSelected: Boolean,
  menu: Boolean,
  menuIcon: {
    type: IconValue,
    default: "$dropdown"
  },
  menuProps: {
    type: Object
  },
  multiple: Boolean,
  noDataText: {
    type: String,
    default: "$vuetify.noDataText"
  },
  openOnClear: Boolean,
  itemColor: String,
  ...makeItemsProps({
    itemChildren: false
  })
}, "Select");
const makeVSelectProps = propsFactory({
  ...makeSelectProps(),
  ...omit(makeVTextFieldProps({
    modelValue: null,
    role: "button"
  }), ["validationValue", "dirty", "appendInnerIcon"]),
  ...makeTransitionProps({
    transition: {
      component: VDialogTransition
    }
  })
}, "VSelect");
const VSelect = genericComponent()({
  name: "VSelect",
  props: makeVSelectProps(),
  emits: {
    "update:focused": (focused) => true,
    "update:modelValue": (val) => true,
    "update:menu": (val) => true
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      t
    } = useLocale();
    const vTextFieldRef = ref();
    const vMenuRef = ref();
    const vVirtualScrollRef = ref();
    const _menu = useProxiedModel(props2, "menu");
    const menu = computed({
      get: () => _menu.value,
      set: (v2) => {
        var _a2;
        if (_menu.value && !v2 && ((_a2 = vMenuRef.value) == null ? void 0 : _a2.ΨopenChildren))
          return;
        _menu.value = v2;
      }
    });
    const {
      items,
      transformIn,
      transformOut
    } = useItems(props2);
    const model = useProxiedModel(props2, "modelValue", [], (v2) => transformIn(v2 === null ? [null] : wrapInArray(v2)), (v2) => {
      const transformed = transformOut(v2);
      return props2.multiple ? transformed : transformed[0] ?? null;
    });
    const form = useForm();
    const selectedValues = computed(() => model.value.map((selection) => selection.value));
    const isFocused = shallowRef(false);
    const label = computed(() => menu.value ? props2.closeText : props2.openText);
    let keyboardLookupPrefix = "";
    let keyboardLookupLastTime;
    const displayItems = computed(() => {
      if (props2.hideSelected) {
        return items.value.filter((item) => !model.value.some((s) => s === item));
      }
      return items.value;
    });
    const menuDisabled = computed(() => props2.hideNoData && !items.value.length || props2.readonly || (form == null ? void 0 : form.isReadonly.value));
    const listRef = ref();
    const {
      onListScroll,
      onListKeydown
    } = useScrolling(listRef, vTextFieldRef);
    function onClear(e) {
      if (props2.openOnClear) {
        menu.value = true;
      }
    }
    function onMousedownControl() {
      if (menuDisabled.value)
        return;
      menu.value = !menu.value;
    }
    function onKeydown(e) {
      var _a2, _b;
      if (!e.key || props2.readonly || (form == null ? void 0 : form.isReadonly.value))
        return;
      if (["Enter", " ", "ArrowDown", "ArrowUp", "Home", "End"].includes(e.key)) {
        e.preventDefault();
      }
      if (["Enter", "ArrowDown", " "].includes(e.key)) {
        menu.value = true;
      }
      if (["Escape", "Tab"].includes(e.key)) {
        menu.value = false;
      }
      if (e.key === "Home") {
        (_a2 = listRef.value) == null ? void 0 : _a2.focus("first");
      } else if (e.key === "End") {
        (_b = listRef.value) == null ? void 0 : _b.focus("last");
      }
      const KEYBOARD_LOOKUP_THRESHOLD = 1e3;
      function checkPrintable(e2) {
        const isPrintableChar = e2.key.length === 1;
        const noModifier = !e2.ctrlKey && !e2.metaKey && !e2.altKey;
        return isPrintableChar && noModifier;
      }
      if (props2.multiple || !checkPrintable(e))
        return;
      const now = performance.now();
      if (now - keyboardLookupLastTime > KEYBOARD_LOOKUP_THRESHOLD) {
        keyboardLookupPrefix = "";
      }
      keyboardLookupPrefix += e.key.toLowerCase();
      keyboardLookupLastTime = now;
      const item = items.value.find((item2) => item2.title.toLowerCase().startsWith(keyboardLookupPrefix));
      if (item !== void 0) {
        model.value = [item];
      }
    }
    function select(item) {
      if (props2.multiple) {
        const index2 = model.value.findIndex((selection) => props2.valueComparator(selection.value, item.value));
        if (index2 === -1) {
          model.value = [...model.value, item];
        } else {
          const value = [...model.value];
          value.splice(index2, 1);
          model.value = value;
        }
      } else {
        model.value = [item];
        menu.value = false;
      }
    }
    function onBlur(e) {
      var _a2;
      if (!((_a2 = listRef.value) == null ? void 0 : _a2.$el.contains(e.relatedTarget))) {
        menu.value = false;
      }
    }
    function onAfterLeave() {
      var _a2;
      if (isFocused.value) {
        (_a2 = vTextFieldRef.value) == null ? void 0 : _a2.focus();
      }
    }
    function onFocusin(e) {
      isFocused.value = true;
    }
    function onModelUpdate(v2) {
      if (v2 == null)
        model.value = [];
      else if (matchesSelector(vTextFieldRef.value, ":autofill") || matchesSelector(vTextFieldRef.value, ":-webkit-autofill")) {
        const item = items.value.find((item2) => item2.title === v2);
        if (item) {
          select(item);
        }
      } else if (vTextFieldRef.value) {
        vTextFieldRef.value.value = "";
      }
    }
    watch(menu, () => {
      if (!props2.hideSelected && menu.value && model.value.length) {
        const index2 = displayItems.value.findIndex((item) => model.value.some((s) => props2.valueComparator(s.value, item.value)));
        IN_BROWSER && window.requestAnimationFrame(() => {
          var _a2;
          index2 >= 0 && ((_a2 = vVirtualScrollRef.value) == null ? void 0 : _a2.scrollToIndex(index2));
        });
      }
    });
    useRender(() => {
      const hasChips = !!(props2.chips || slots.chip);
      const hasList = !!(!props2.hideNoData || displayItems.value.length || slots["prepend-item"] || slots["append-item"] || slots["no-data"]);
      const isDirty = model.value.length > 0;
      const [textFieldProps] = VTextField.filterProps(props2);
      const placeholder = isDirty || !isFocused.value && props2.label && !props2.persistentPlaceholder ? void 0 : props2.placeholder;
      return createVNode(VTextField, mergeProps({
        "ref": vTextFieldRef
      }, textFieldProps, {
        "modelValue": model.value.map((v2) => v2.props.value).join(", "),
        "onUpdate:modelValue": onModelUpdate,
        "focused": isFocused.value,
        "onUpdate:focused": ($event) => isFocused.value = $event,
        "validationValue": model.externalValue,
        "counterValue": model.value.length,
        "dirty": isDirty,
        "class": ["v-select", {
          "v-select--active-menu": menu.value,
          "v-select--chips": !!props2.chips,
          [`v-select--${props2.multiple ? "multiple" : "single"}`]: true,
          "v-select--selected": model.value.length,
          "v-select--selection-slot": !!slots.selection
        }, props2.class],
        "style": props2.style,
        "inputmode": "none",
        "placeholder": placeholder,
        "onClick:clear": onClear,
        "onMousedown:control": onMousedownControl,
        "onBlur": onBlur,
        "onKeydown": onKeydown,
        "aria-label": t(label.value),
        "title": t(label.value)
      }), {
        ...slots,
        default: () => createVNode(Fragment, null, [createVNode(VMenu, mergeProps({
          "ref": vMenuRef,
          "modelValue": menu.value,
          "onUpdate:modelValue": ($event) => menu.value = $event,
          "activator": "parent",
          "contentClass": "v-select__content",
          "disabled": menuDisabled.value,
          "eager": props2.eager,
          "maxHeight": 310,
          "openOnClick": false,
          "closeOnContentClick": false,
          "transition": props2.transition,
          "onAfterLeave": onAfterLeave
        }, props2.menuProps), {
          default: () => [hasList && createVNode(VList, {
            "ref": listRef,
            "selected": selectedValues.value,
            "selectStrategy": props2.multiple ? "independent" : "single-independent",
            "onMousedown": (e) => e.preventDefault(),
            "onKeydown": onListKeydown,
            "onFocusin": onFocusin,
            "onScrollPassive": onListScroll,
            "tabindex": "-1",
            "color": props2.itemColor ?? props2.color
          }, {
            default: () => {
              var _a2, _b, _c;
              return [(_a2 = slots["prepend-item"]) == null ? void 0 : _a2.call(slots), !displayItems.value.length && !props2.hideNoData && (((_b = slots["no-data"]) == null ? void 0 : _b.call(slots)) ?? createVNode(VListItem, {
                "title": t(props2.noDataText)
              }, null)), createVNode(VVirtualScroll, {
                "ref": vVirtualScrollRef,
                "renderless": true,
                "items": displayItems.value
              }, {
                default: (_ref2) => {
                  var _a3;
                  let {
                    item,
                    index: index2,
                    itemRef
                  } = _ref2;
                  const itemProps = mergeProps(item.props, {
                    ref: itemRef,
                    key: index2,
                    onClick: () => select(item)
                  });
                  return ((_a3 = slots.item) == null ? void 0 : _a3.call(slots, {
                    item,
                    index: index2,
                    props: itemProps
                  })) ?? createVNode(VListItem, itemProps, {
                    prepend: (_ref3) => {
                      let {
                        isSelected
                      } = _ref3;
                      return createVNode(Fragment, null, [props2.multiple && !props2.hideSelected ? createVNode(VCheckboxBtn, {
                        "key": item.value,
                        "modelValue": isSelected,
                        "ripple": false,
                        "tabindex": "-1"
                      }, null) : void 0, item.props.prependIcon && createVNode(VIcon, {
                        "icon": item.props.prependIcon
                      }, null)]);
                    }
                  });
                }
              }), (_c = slots["append-item"]) == null ? void 0 : _c.call(slots)];
            }
          })]
        }), model.value.map((item, index2) => {
          var _a2;
          function onChipClose(e) {
            e.stopPropagation();
            e.preventDefault();
            select(item);
          }
          const slotProps = {
            "onClick:close": onChipClose,
            onMousedown(e) {
              e.preventDefault();
              e.stopPropagation();
            },
            modelValue: true,
            "onUpdate:modelValue": void 0
          };
          return createVNode("div", {
            "key": item.value,
            "class": "v-select__selection"
          }, [hasChips ? !slots.chip ? createVNode(VChip, mergeProps({
            "key": "chip",
            "closable": props2.closableChips,
            "size": "small",
            "text": item.title,
            "disabled": item.props.disabled
          }, slotProps), null) : createVNode(VDefaultsProvider, {
            "key": "chip-defaults",
            "defaults": {
              VChip: {
                closable: props2.closableChips,
                size: "small",
                text: item.title
              }
            }
          }, {
            default: () => {
              var _a3;
              return [(_a3 = slots.chip) == null ? void 0 : _a3.call(slots, {
                item,
                index: index2,
                props: slotProps
              })];
            }
          }) : ((_a2 = slots.selection) == null ? void 0 : _a2.call(slots, {
            item,
            index: index2
          })) ?? createVNode("span", {
            "class": "v-select__selection-text"
          }, [item.title, props2.multiple && index2 < model.value.length - 1 && createVNode("span", {
            "class": "v-select__selection-comma"
          }, [createTextVNode(",")])])]);
        })]),
        "append-inner": function() {
          var _a2;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return createVNode(Fragment, null, [(_a2 = slots["append-inner"]) == null ? void 0 : _a2.call(slots, ...args), props2.menuIcon ? createVNode(VIcon, {
            "class": "v-select__menu-icon",
            "icon": props2.menuIcon
          }, null) : void 0]);
        }
      });
    });
    return forwardRefs({
      isFocused,
      menu,
      select
    }, vTextFieldRef);
  }
});
const defaultFilter = (value, query, item) => {
  if (value == null || query == null)
    return -1;
  return value.toString().toLocaleLowerCase().indexOf(query.toString().toLocaleLowerCase());
};
const makeFilterProps = propsFactory({
  customFilter: Function,
  customKeyFilter: Object,
  filterKeys: [Array, String],
  filterMode: {
    type: String,
    default: "intersection"
  },
  noFilter: Boolean
}, "filter");
function filterItems(items, query, options) {
  var _a2;
  const array = [];
  const filter = (options == null ? void 0 : options.default) ?? defaultFilter;
  const keys2 = (options == null ? void 0 : options.filterKeys) ? wrapInArray(options.filterKeys) : false;
  const customFiltersLength = Object.keys((options == null ? void 0 : options.customKeyFilter) ?? {}).length;
  if (!(items == null ? void 0 : items.length))
    return array;
  loop:
    for (let i = 0; i < items.length; i++) {
      const [item, transformed = item] = wrapInArray(items[i]);
      const customMatches = {};
      const defaultMatches = {};
      let match2 = -1;
      if (query && !(options == null ? void 0 : options.noFilter)) {
        if (typeof item === "object") {
          const filterKeys = keys2 || Object.keys(transformed);
          for (const key2 of filterKeys) {
            const value = getPropertyFromItem(transformed, key2, transformed);
            const keyFilter = (_a2 = options == null ? void 0 : options.customKeyFilter) == null ? void 0 : _a2[key2];
            match2 = keyFilter ? keyFilter(value, query, item) : filter(value, query, item);
            if (match2 !== -1 && match2 !== false) {
              if (keyFilter)
                customMatches[key2] = match2;
              else
                defaultMatches[key2] = match2;
            } else if ((options == null ? void 0 : options.filterMode) === "every") {
              continue loop;
            }
          }
        } else {
          match2 = filter(item, query, item);
          if (match2 !== -1 && match2 !== false) {
            defaultMatches.title = match2;
          }
        }
        const defaultMatchesLength = Object.keys(defaultMatches).length;
        const customMatchesLength = Object.keys(customMatches).length;
        if (!defaultMatchesLength && !customMatchesLength)
          continue;
        if ((options == null ? void 0 : options.filterMode) === "union" && customMatchesLength !== customFiltersLength && !defaultMatchesLength)
          continue;
        if ((options == null ? void 0 : options.filterMode) === "intersection" && (customMatchesLength !== customFiltersLength || !defaultMatchesLength))
          continue;
      }
      array.push({
        index: i,
        matches: {
          ...defaultMatches,
          ...customMatches
        }
      });
    }
  return array;
}
function useFilter(props2, items, query, options) {
  const filteredItems = ref([]);
  const filteredMatches = ref(/* @__PURE__ */ new Map());
  const transformedItems = computed(() => (options == null ? void 0 : options.transform) ? unref(items).map((item) => [item, options.transform(item)]) : unref(items));
  watchEffect(() => {
    const _query = typeof query === "function" ? query() : unref(query);
    const strQuery = typeof _query !== "string" && typeof _query !== "number" ? "" : String(_query);
    const results = filterItems(transformedItems.value, strQuery, {
      customKeyFilter: props2.customKeyFilter,
      default: props2.customFilter,
      filterKeys: props2.filterKeys,
      filterMode: props2.filterMode,
      noFilter: props2.noFilter
    });
    const originalItems = unref(items);
    const _filteredItems = [];
    const _filteredMatches = /* @__PURE__ */ new Map();
    results.forEach((_ref) => {
      let {
        index: index2,
        matches: matches2
      } = _ref;
      const item = originalItems[index2];
      _filteredItems.push(item);
      _filteredMatches.set(item.value, matches2);
    });
    filteredItems.value = _filteredItems;
    filteredMatches.value = _filteredMatches;
  });
  function getMatches(item) {
    return filteredMatches.value.get(item.value);
  }
  return {
    filteredItems,
    filteredMatches,
    getMatches
  };
}
function highlightResult$1(text, matches2, length) {
  if (matches2 == null)
    return text;
  if (Array.isArray(matches2))
    throw new Error("Multiple matches is not implemented");
  return typeof matches2 === "number" && ~matches2 ? createVNode(Fragment, null, [createVNode("span", {
    "class": "v-autocomplete__unmask"
  }, [text.substr(0, matches2)]), createVNode("span", {
    "class": "v-autocomplete__mask"
  }, [text.substr(matches2, length)]), createVNode("span", {
    "class": "v-autocomplete__unmask"
  }, [text.substr(matches2 + length)])]) : text;
}
const makeVAutocompleteProps = propsFactory({
  autoSelectFirst: {
    type: [Boolean, String]
  },
  search: String,
  ...makeFilterProps({
    filterKeys: ["title"]
  }),
  ...makeSelectProps(),
  ...omit(makeVTextFieldProps({
    modelValue: null,
    role: "combobox"
  }), ["validationValue", "dirty", "appendInnerIcon"]),
  ...makeTransitionProps({
    transition: false
  })
}, "VAutocomplete");
const VAutocomplete = genericComponent()({
  name: "VAutocomplete",
  props: makeVAutocompleteProps(),
  emits: {
    "update:focused": (focused) => true,
    "update:search": (val) => true,
    "update:modelValue": (val) => true,
    "update:menu": (val) => true
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      t
    } = useLocale();
    const vTextFieldRef = ref();
    const isFocused = shallowRef(false);
    const isPristine = shallowRef(true);
    const listHasFocus = shallowRef(false);
    const vMenuRef = ref();
    const vVirtualScrollRef = ref();
    const _menu = useProxiedModel(props2, "menu");
    const menu = computed({
      get: () => _menu.value,
      set: (v2) => {
        var _a2;
        if (_menu.value && !v2 && ((_a2 = vMenuRef.value) == null ? void 0 : _a2.ΨopenChildren))
          return;
        _menu.value = v2;
      }
    });
    const selectionIndex = shallowRef(-1);
    const color = computed(() => {
      var _a2;
      return (_a2 = vTextFieldRef.value) == null ? void 0 : _a2.color;
    });
    const label = computed(() => menu.value ? props2.closeText : props2.openText);
    const {
      items,
      transformIn,
      transformOut
    } = useItems(props2);
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(color);
    const search = useProxiedModel(props2, "search", "");
    const model = useProxiedModel(props2, "modelValue", [], (v2) => transformIn(v2 === null ? [null] : wrapInArray(v2)), (v2) => {
      const transformed = transformOut(v2);
      return props2.multiple ? transformed : transformed[0] ?? null;
    });
    const form = useForm();
    const {
      filteredItems,
      getMatches
    } = useFilter(props2, items, () => isPristine.value ? "" : search.value);
    const displayItems = computed(() => {
      if (props2.hideSelected) {
        return filteredItems.value.filter((filteredItem) => !model.value.some((s) => s.value === filteredItem.value));
      }
      return filteredItems.value;
    });
    const selectedValues = computed(() => model.value.map((selection) => selection.props.value));
    const highlightFirst = computed(() => {
      var _a2;
      const selectFirst = props2.autoSelectFirst === true || props2.autoSelectFirst === "exact" && search.value === ((_a2 = displayItems.value[0]) == null ? void 0 : _a2.title);
      return selectFirst && displayItems.value.length > 0 && !isPristine.value && !listHasFocus.value;
    });
    const menuDisabled = computed(() => props2.hideNoData && !items.value.length || props2.readonly || (form == null ? void 0 : form.isReadonly.value));
    const listRef = ref();
    const {
      onListScroll,
      onListKeydown
    } = useScrolling(listRef, vTextFieldRef);
    function onClear(e) {
      if (props2.openOnClear) {
        menu.value = true;
      }
      search.value = "";
    }
    function onMousedownControl() {
      if (menuDisabled.value)
        return;
      menu.value = true;
    }
    function onMousedownMenuIcon(e) {
      if (menuDisabled.value)
        return;
      if (isFocused.value) {
        e.preventDefault();
        e.stopPropagation();
      }
      menu.value = !menu.value;
    }
    function onKeydown(e) {
      var _a2, _b, _c;
      if (props2.readonly || (form == null ? void 0 : form.isReadonly.value))
        return;
      const selectionStart = vTextFieldRef.value.selectionStart;
      const length = model.value.length;
      if (selectionIndex.value > -1 || ["Enter", "ArrowDown", "ArrowUp"].includes(e.key)) {
        e.preventDefault();
      }
      if (["Enter", "ArrowDown"].includes(e.key)) {
        menu.value = true;
      }
      if (["Escape"].includes(e.key)) {
        menu.value = false;
      }
      if (highlightFirst.value && ["Enter", "Tab"].includes(e.key)) {
        select(displayItems.value[0]);
      }
      if (e.key === "ArrowDown" && highlightFirst.value) {
        (_a2 = listRef.value) == null ? void 0 : _a2.focus("next");
      }
      if (!props2.multiple)
        return;
      if (["Backspace", "Delete"].includes(e.key)) {
        if (selectionIndex.value < 0) {
          if (e.key === "Backspace" && !search.value) {
            selectionIndex.value = length - 1;
          }
          return;
        }
        const originalSelectionIndex = selectionIndex.value;
        const selectedItem = model.value[selectionIndex.value];
        if (selectedItem && !selectedItem.props.disabled)
          select(selectedItem);
        selectionIndex.value = originalSelectionIndex >= length - 1 ? length - 2 : originalSelectionIndex;
      }
      if (e.key === "ArrowLeft") {
        if (selectionIndex.value < 0 && selectionStart > 0)
          return;
        const prev = selectionIndex.value > -1 ? selectionIndex.value - 1 : length - 1;
        if (model.value[prev]) {
          selectionIndex.value = prev;
        } else {
          selectionIndex.value = -1;
          vTextFieldRef.value.setSelectionRange((_b = search.value) == null ? void 0 : _b.length, (_c = search.value) == null ? void 0 : _c.length);
        }
      }
      if (e.key === "ArrowRight") {
        if (selectionIndex.value < 0)
          return;
        const next = selectionIndex.value + 1;
        if (model.value[next]) {
          selectionIndex.value = next;
        } else {
          selectionIndex.value = -1;
          vTextFieldRef.value.setSelectionRange(0, 0);
        }
      }
    }
    function onInput(e) {
      search.value = e.target.value;
    }
    function onChange(e) {
      if (matchesSelector(vTextFieldRef.value, ":autofill") || matchesSelector(vTextFieldRef.value, ":-webkit-autofill")) {
        const item = items.value.find((item2) => item2.title === e.target.value);
        if (item) {
          select(item);
        }
      }
    }
    function onAfterLeave() {
      var _a2;
      if (isFocused.value) {
        isPristine.value = true;
        (_a2 = vTextFieldRef.value) == null ? void 0 : _a2.focus();
      }
    }
    function onFocusin(e) {
      isFocused.value = true;
      setTimeout(() => {
        listHasFocus.value = true;
      });
    }
    function onFocusout(e) {
      listHasFocus.value = false;
    }
    function onUpdateModelValue(v2) {
      if (v2 == null || v2 === "" && !props2.multiple)
        model.value = [];
    }
    const isSelecting = shallowRef(false);
    function select(item) {
      if (props2.multiple) {
        const index2 = model.value.findIndex((selection) => props2.valueComparator(selection.value, item.value));
        if (index2 === -1) {
          model.value = [...model.value, item];
        } else {
          const value = [...model.value];
          value.splice(index2, 1);
          model.value = value;
        }
      } else {
        model.value = [item];
        isSelecting.value = true;
        search.value = item.title;
        menu.value = false;
        isPristine.value = true;
        nextTick(() => isSelecting.value = false);
      }
    }
    watch(isFocused, (val, oldVal) => {
      var _a2;
      if (val === oldVal)
        return;
      if (val) {
        isSelecting.value = true;
        search.value = props2.multiple ? "" : String(((_a2 = model.value.at(-1)) == null ? void 0 : _a2.props.title) ?? "");
        isPristine.value = true;
        nextTick(() => isSelecting.value = false);
      } else {
        if (!props2.multiple && !search.value)
          model.value = [];
        else if (highlightFirst.value && !listHasFocus.value && !model.value.some((_ref2) => {
          let {
            value
          } = _ref2;
          return value === displayItems.value[0].value;
        })) {
          select(displayItems.value[0]);
        }
        menu.value = false;
        search.value = "";
        selectionIndex.value = -1;
      }
    });
    watch(search, (val) => {
      if (!isFocused.value || isSelecting.value)
        return;
      if (val)
        menu.value = true;
      isPristine.value = !val;
    });
    watch(menu, () => {
      if (!props2.hideSelected && menu.value && model.value.length) {
        const index2 = displayItems.value.findIndex((item) => model.value.some((s) => item.value === s.value));
        IN_BROWSER && window.requestAnimationFrame(() => {
          var _a2;
          index2 >= 0 && ((_a2 = vVirtualScrollRef.value) == null ? void 0 : _a2.scrollToIndex(index2));
        });
      }
    });
    useRender(() => {
      const hasChips = !!(props2.chips || slots.chip);
      const hasList = !!(!props2.hideNoData || displayItems.value.length || slots["prepend-item"] || slots["append-item"] || slots["no-data"]);
      const isDirty = model.value.length > 0;
      const [textFieldProps] = VTextField.filterProps(props2);
      return createVNode(VTextField, mergeProps({
        "ref": vTextFieldRef
      }, textFieldProps, {
        "modelValue": search.value,
        "onUpdate:modelValue": onUpdateModelValue,
        "focused": isFocused.value,
        "onUpdate:focused": ($event) => isFocused.value = $event,
        "validationValue": model.externalValue,
        "counterValue": model.value.length,
        "dirty": isDirty,
        "onInput": onInput,
        "onChange": onChange,
        "class": ["v-autocomplete", `v-autocomplete--${props2.multiple ? "multiple" : "single"}`, {
          "v-autocomplete--active-menu": menu.value,
          "v-autocomplete--chips": !!props2.chips,
          "v-autocomplete--selection-slot": !!slots.selection,
          "v-autocomplete--selecting-index": selectionIndex.value > -1
        }, props2.class],
        "style": props2.style,
        "readonly": props2.readonly,
        "placeholder": isDirty ? void 0 : props2.placeholder,
        "onClick:clear": onClear,
        "onMousedown:control": onMousedownControl,
        "onKeydown": onKeydown
      }), {
        ...slots,
        default: () => createVNode(Fragment, null, [createVNode(VMenu, mergeProps({
          "ref": vMenuRef,
          "modelValue": menu.value,
          "onUpdate:modelValue": ($event) => menu.value = $event,
          "activator": "parent",
          "contentClass": "v-autocomplete__content",
          "disabled": menuDisabled.value,
          "eager": props2.eager,
          "maxHeight": 310,
          "openOnClick": false,
          "closeOnContentClick": false,
          "transition": props2.transition,
          "onAfterLeave": onAfterLeave
        }, props2.menuProps), {
          default: () => [hasList && createVNode(VList, {
            "ref": listRef,
            "selected": selectedValues.value,
            "selectStrategy": props2.multiple ? "independent" : "single-independent",
            "onMousedown": (e) => e.preventDefault(),
            "onKeydown": onListKeydown,
            "onFocusin": onFocusin,
            "onFocusout": onFocusout,
            "onScrollPassive": onListScroll,
            "tabindex": "-1",
            "color": props2.itemColor ?? props2.color
          }, {
            default: () => {
              var _a2, _b, _c;
              return [(_a2 = slots["prepend-item"]) == null ? void 0 : _a2.call(slots), !displayItems.value.length && !props2.hideNoData && (((_b = slots["no-data"]) == null ? void 0 : _b.call(slots)) ?? createVNode(VListItem, {
                "title": t(props2.noDataText)
              }, null)), createVNode(VVirtualScroll, {
                "ref": vVirtualScrollRef,
                "renderless": true,
                "items": displayItems.value
              }, {
                default: (_ref3) => {
                  var _a3;
                  let {
                    item,
                    index: index2,
                    itemRef
                  } = _ref3;
                  const itemProps = mergeProps(item.props, {
                    ref: itemRef,
                    key: index2,
                    active: highlightFirst.value && index2 === 0 ? true : void 0,
                    onClick: () => select(item)
                  });
                  return ((_a3 = slots.item) == null ? void 0 : _a3.call(slots, {
                    item,
                    index: index2,
                    props: itemProps
                  })) ?? createVNode(VListItem, itemProps, {
                    prepend: (_ref4) => {
                      let {
                        isSelected
                      } = _ref4;
                      return createVNode(Fragment, null, [props2.multiple && !props2.hideSelected ? createVNode(VCheckboxBtn, {
                        "key": item.value,
                        "modelValue": isSelected,
                        "ripple": false,
                        "tabindex": "-1"
                      }, null) : void 0, item.props.prependIcon && createVNode(VIcon, {
                        "icon": item.props.prependIcon
                      }, null)]);
                    },
                    title: () => {
                      var _a4, _b2;
                      return isPristine.value ? item.title : highlightResult$1(item.title, (_a4 = getMatches(item)) == null ? void 0 : _a4.title, ((_b2 = search.value) == null ? void 0 : _b2.length) ?? 0);
                    }
                  });
                }
              }), (_c = slots["append-item"]) == null ? void 0 : _c.call(slots)];
            }
          })]
        }), model.value.map((item, index2) => {
          var _a2;
          function onChipClose(e) {
            e.stopPropagation();
            e.preventDefault();
            select(item);
          }
          const slotProps = {
            "onClick:close": onChipClose,
            onMousedown(e) {
              e.preventDefault();
              e.stopPropagation();
            },
            modelValue: true,
            "onUpdate:modelValue": void 0
          };
          return createVNode("div", {
            "key": item.value,
            "class": ["v-autocomplete__selection", index2 === selectionIndex.value && ["v-autocomplete__selection--selected", textColorClasses.value]],
            "style": index2 === selectionIndex.value ? textColorStyles.value : {}
          }, [hasChips ? !slots.chip ? createVNode(VChip, mergeProps({
            "key": "chip",
            "closable": props2.closableChips,
            "size": "small",
            "text": item.title,
            "disabled": item.props.disabled
          }, slotProps), null) : createVNode(VDefaultsProvider, {
            "key": "chip-defaults",
            "defaults": {
              VChip: {
                closable: props2.closableChips,
                size: "small",
                text: item.title
              }
            }
          }, {
            default: () => {
              var _a3;
              return [(_a3 = slots.chip) == null ? void 0 : _a3.call(slots, {
                item,
                index: index2,
                props: slotProps
              })];
            }
          }) : ((_a2 = slots.selection) == null ? void 0 : _a2.call(slots, {
            item,
            index: index2
          })) ?? createVNode("span", {
            "class": "v-autocomplete__selection-text"
          }, [item.title, props2.multiple && index2 < model.value.length - 1 && createVNode("span", {
            "class": "v-autocomplete__selection-comma"
          }, [createTextVNode(",")])])]);
        })]),
        "append-inner": function() {
          var _a2;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return createVNode(Fragment, null, [(_a2 = slots["append-inner"]) == null ? void 0 : _a2.call(slots, ...args), props2.menuIcon ? createVNode(VIcon, {
            "class": "v-autocomplete__menu-icon",
            "icon": props2.menuIcon,
            "onMousedown": onMousedownMenuIcon,
            "onClick": noop,
            "aria-label": t(label.value),
            "title": t(label.value)
          }, null) : void 0]);
        }
      });
    });
    return forwardRefs({
      isFocused,
      isPristine,
      menu,
      search,
      filteredItems,
      select
    }, vTextFieldRef);
  }
});
const VBadge$1 = "";
const makeVBadgeProps = propsFactory({
  bordered: Boolean,
  color: String,
  content: [Number, String],
  dot: Boolean,
  floating: Boolean,
  icon: IconValue,
  inline: Boolean,
  label: {
    type: String,
    default: "$vuetify.badge"
  },
  max: [Number, String],
  modelValue: {
    type: Boolean,
    default: true
  },
  offsetX: [Number, String],
  offsetY: [Number, String],
  textColor: String,
  ...makeComponentProps(),
  ...makeLocationProps({
    location: "top end"
  }),
  ...makeRoundedProps(),
  ...makeTagProps(),
  ...makeThemeProps(),
  ...makeTransitionProps({
    transition: "scale-rotate-transition"
  })
}, "VBadge");
const VBadge = genericComponent()({
  name: "VBadge",
  inheritAttrs: false,
  props: makeVBadgeProps(),
  setup(props2, ctx) {
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props2, "color"));
    const {
      roundedClasses
    } = useRounded(props2);
    const {
      t
    } = useLocale();
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(toRef(props2, "textColor"));
    const {
      themeClasses
    } = useTheme();
    const {
      locationStyles
    } = useLocation(props2, true, (side) => {
      const base = props2.floating ? props2.dot ? 2 : 4 : props2.dot ? 8 : 12;
      return base + (["top", "bottom"].includes(side) ? +(props2.offsetY ?? 0) : ["left", "right"].includes(side) ? +(props2.offsetX ?? 0) : 0);
    });
    useRender(() => {
      const value = Number(props2.content);
      const content = !props2.max || isNaN(value) ? props2.content : value <= +props2.max ? value : `${props2.max}+`;
      const [badgeAttrs, attrs] = pick(ctx.attrs, ["aria-atomic", "aria-label", "aria-live", "role", "title"]);
      return createVNode(props2.tag, mergeProps({
        "class": ["v-badge", {
          "v-badge--bordered": props2.bordered,
          "v-badge--dot": props2.dot,
          "v-badge--floating": props2.floating,
          "v-badge--inline": props2.inline
        }, props2.class]
      }, attrs, {
        "style": props2.style
      }), {
        default: () => {
          var _a2, _b;
          return [createVNode("div", {
            "class": "v-badge__wrapper"
          }, [(_b = (_a2 = ctx.slots).default) == null ? void 0 : _b.call(_a2), createVNode(MaybeTransition, {
            "transition": props2.transition
          }, {
            default: () => {
              var _a3, _b2;
              return [withDirectives(createVNode("span", mergeProps({
                "class": ["v-badge__badge", themeClasses.value, backgroundColorClasses.value, roundedClasses.value, textColorClasses.value],
                "style": [backgroundColorStyles.value, textColorStyles.value, props2.inline ? {} : locationStyles.value],
                "aria-atomic": "true",
                "aria-label": t(props2.label, value),
                "aria-live": "polite",
                "role": "status"
              }, badgeAttrs), [props2.dot ? void 0 : ctx.slots.badge ? (_b2 = (_a3 = ctx.slots).badge) == null ? void 0 : _b2.call(_a3) : props2.icon ? createVNode(VIcon, {
                "icon": props2.icon
              }, null) : content]), [[vShow, props2.modelValue]])];
            }
          })])];
        }
      });
    });
    return {};
  }
});
const VBanner$1 = "";
const makeVBannerActionsProps = propsFactory({
  color: String,
  density: String,
  ...makeComponentProps()
}, "VBannerActions");
const VBannerActions = genericComponent()({
  name: "VBannerActions",
  props: makeVBannerActionsProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    provideDefaults({
      VBtn: {
        color: props2.color,
        density: props2.density,
        variant: "text"
      }
    });
    useRender(() => {
      var _a2;
      return createVNode("div", {
        "class": ["v-banner-actions", props2.class],
        "style": props2.style
      }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
    });
    return {};
  }
});
const VBannerText = createSimpleFunctional("v-banner-text");
const makeVBannerProps = propsFactory({
  avatar: String,
  color: String,
  icon: IconValue,
  lines: String,
  stacked: Boolean,
  sticky: Boolean,
  text: String,
  ...makeBorderProps(),
  ...makeComponentProps(),
  ...makeDensityProps(),
  ...makeDimensionProps(),
  ...makeElevationProps(),
  ...makeLocationProps(),
  ...makePositionProps(),
  ...makeRoundedProps(),
  ...makeTagProps(),
  ...makeThemeProps()
}, "VBanner");
const VBanner = genericComponent()({
  name: "VBanner",
  props: makeVBannerProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      borderClasses
    } = useBorder(props2);
    const {
      densityClasses
    } = useDensity(props2);
    const {
      mobile
    } = useDisplay();
    const {
      dimensionStyles
    } = useDimension(props2);
    const {
      elevationClasses
    } = useElevation(props2);
    const {
      locationStyles
    } = useLocation(props2);
    const {
      positionClasses
    } = usePosition(props2);
    const {
      roundedClasses
    } = useRounded(props2);
    const {
      themeClasses
    } = provideTheme(props2);
    const color = toRef(props2, "color");
    const density = toRef(props2, "density");
    provideDefaults({
      VBannerActions: {
        color,
        density
      }
    });
    useRender(() => {
      const hasText = !!(props2.text || slots.text);
      const hasPrependMedia = !!(props2.avatar || props2.icon);
      const hasPrepend = !!(hasPrependMedia || slots.prepend);
      return createVNode(props2.tag, {
        "class": ["v-banner", {
          "v-banner--stacked": props2.stacked || mobile.value,
          "v-banner--sticky": props2.sticky,
          [`v-banner--${props2.lines}-line`]: !!props2.lines
        }, borderClasses.value, densityClasses.value, elevationClasses.value, positionClasses.value, roundedClasses.value, themeClasses.value, props2.class],
        "style": [dimensionStyles.value, locationStyles.value, props2.style],
        "role": "banner"
      }, {
        default: () => {
          var _a2;
          return [hasPrepend && createVNode("div", {
            "key": "prepend",
            "class": "v-banner__prepend"
          }, [!slots.prepend ? createVNode(VAvatar, {
            "key": "prepend-avatar",
            "color": color.value,
            "density": density.value,
            "icon": props2.icon,
            "image": props2.avatar
          }, null) : createVNode(VDefaultsProvider, {
            "key": "prepend-defaults",
            "disabled": !hasPrependMedia,
            "defaults": {
              VAvatar: {
                color: color.value,
                density: density.value,
                icon: props2.icon,
                image: props2.avatar
              }
            }
          }, slots.prepend)]), createVNode("div", {
            "class": "v-banner__content"
          }, [hasText && createVNode(VBannerText, {
            "key": "text"
          }, {
            default: () => {
              var _a3;
              return [((_a3 = slots.text) == null ? void 0 : _a3.call(slots)) ?? props2.text];
            }
          }), (_a2 = slots.default) == null ? void 0 : _a2.call(slots)]), slots.actions && createVNode(VBannerActions, {
            "key": "actions"
          }, slots.actions)];
        }
      });
    });
  }
});
const VBottomNavigation$1 = "";
const makeVBottomNavigationProps = propsFactory({
  bgColor: String,
  color: String,
  grow: Boolean,
  mode: {
    type: String,
    validator: (v2) => !v2 || ["horizontal", "shift"].includes(v2)
  },
  height: {
    type: [Number, String],
    default: 56
  },
  active: {
    type: Boolean,
    default: true
  },
  ...makeBorderProps(),
  ...makeComponentProps(),
  ...makeDensityProps(),
  ...makeElevationProps(),
  ...makeRoundedProps(),
  ...makeLayoutItemProps({
    name: "bottom-navigation"
  }),
  ...makeTagProps({
    tag: "header"
  }),
  ...makeGroupProps({
    modelValue: true,
    selectedClass: "v-btn--selected"
  }),
  ...makeThemeProps()
}, "VBottomNavigation");
const VBottomNavigation = genericComponent()({
  name: "VBottomNavigation",
  props: makeVBottomNavigationProps(),
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      themeClasses
    } = useTheme();
    const {
      borderClasses
    } = useBorder(props2);
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props2, "bgColor"));
    const {
      densityClasses
    } = useDensity(props2);
    const {
      elevationClasses
    } = useElevation(props2);
    const {
      roundedClasses
    } = useRounded(props2);
    const {
      ssrBootStyles
    } = useSsrBoot();
    const height = computed(() => Number(props2.height) - (props2.density === "comfortable" ? 8 : 0) - (props2.density === "compact" ? 16 : 0));
    const isActive = toRef(props2, "active");
    const {
      layoutItemStyles
    } = useLayoutItem({
      id: props2.name,
      order: computed(() => parseInt(props2.order, 10)),
      position: computed(() => "bottom"),
      layoutSize: computed(() => isActive.value ? height.value : 0),
      elementSize: height,
      active: isActive,
      absolute: toRef(props2, "absolute")
    });
    useGroup(props2, VBtnToggleSymbol);
    provideDefaults({
      VBtn: {
        color: toRef(props2, "color"),
        density: toRef(props2, "density"),
        stacked: computed(() => props2.mode !== "horizontal"),
        variant: "text"
      }
    }, {
      scoped: true
    });
    useRender(() => {
      return createVNode(props2.tag, {
        "class": ["v-bottom-navigation", {
          "v-bottom-navigation--active": isActive.value,
          "v-bottom-navigation--grow": props2.grow,
          "v-bottom-navigation--shift": props2.mode === "shift"
        }, themeClasses.value, backgroundColorClasses.value, borderClasses.value, densityClasses.value, elevationClasses.value, roundedClasses.value, props2.class],
        "style": [backgroundColorStyles.value, layoutItemStyles.value, {
          height: convertToUnit(height.value),
          transform: `translateY(${convertToUnit(!isActive.value ? 100 : 0, "%")})`
        }, ssrBootStyles.value, props2.style]
      }, {
        default: () => [slots.default && createVNode("div", {
          "class": "v-bottom-navigation__content"
        }, [slots.default()])]
      });
    });
    return {};
  }
});
const VBreadcrumbs$1 = "";
const makeVBreadcrumbsDividerProps = propsFactory({
  divider: [Number, String],
  ...makeComponentProps()
}, "VBreadcrumbsDivider");
const VBreadcrumbsDivider = genericComponent()({
  name: "VBreadcrumbsDivider",
  props: makeVBreadcrumbsDividerProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    useRender(() => {
      var _a2;
      return createVNode("li", {
        "class": ["v-breadcrumbs-divider", props2.class],
        "style": props2.style
      }, [((_a2 = slots == null ? void 0 : slots.default) == null ? void 0 : _a2.call(slots)) ?? props2.divider]);
    });
    return {};
  }
});
const makeVBreadcrumbsItemProps = propsFactory({
  active: Boolean,
  activeClass: String,
  activeColor: String,
  color: String,
  disabled: Boolean,
  title: String,
  ...makeComponentProps(),
  ...makeRouterProps(),
  ...makeTagProps({
    tag: "li"
  })
}, "VBreadcrumbsItem");
const VBreadcrumbsItem = genericComponent()({
  name: "VBreadcrumbsItem",
  props: makeVBreadcrumbsItemProps(),
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const link = useLink(props2, attrs);
    const isActive = computed(() => {
      var _a2;
      return props2.active || ((_a2 = link.isActive) == null ? void 0 : _a2.value);
    });
    const color = computed(() => isActive.value ? props2.activeColor : props2.color);
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(color);
    useRender(() => {
      return createVNode(props2.tag, {
        "class": ["v-breadcrumbs-item", {
          "v-breadcrumbs-item--active": isActive.value,
          "v-breadcrumbs-item--disabled": props2.disabled,
          [`${props2.activeClass}`]: isActive.value && props2.activeClass
        }, textColorClasses.value, props2.class],
        "style": [textColorStyles.value, props2.style],
        "aria-current": isActive.value ? "page" : void 0
      }, {
        default: () => {
          var _a2, _b;
          return [!link.isLink.value ? ((_a2 = slots.default) == null ? void 0 : _a2.call(slots)) ?? props2.title : createVNode("a", {
            "class": "v-breadcrumbs-item--link",
            "href": link.href.value,
            "aria-current": isActive.value ? "page" : void 0,
            "onClick": link.navigate
          }, [((_b = slots.default) == null ? void 0 : _b.call(slots)) ?? props2.title])];
        }
      });
    });
    return {};
  }
});
const makeVBreadcrumbsProps = propsFactory({
  activeClass: String,
  activeColor: String,
  bgColor: String,
  color: String,
  disabled: Boolean,
  divider: {
    type: String,
    default: "/"
  },
  icon: IconValue,
  items: {
    type: Array,
    default: () => []
  },
  ...makeComponentProps(),
  ...makeDensityProps(),
  ...makeRoundedProps(),
  ...makeTagProps({
    tag: "ul"
  })
}, "VBreadcrumbs");
const VBreadcrumbs = genericComponent()({
  name: "VBreadcrumbs",
  props: makeVBreadcrumbsProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props2, "bgColor"));
    const {
      densityClasses
    } = useDensity(props2);
    const {
      roundedClasses
    } = useRounded(props2);
    provideDefaults({
      VBreadcrumbsDivider: {
        divider: toRef(props2, "divider")
      },
      VBreadcrumbsItem: {
        activeClass: toRef(props2, "activeClass"),
        activeColor: toRef(props2, "activeColor"),
        color: toRef(props2, "color"),
        disabled: toRef(props2, "disabled")
      }
    });
    const items = computed(() => props2.items.map((item) => {
      return typeof item === "string" ? {
        item: {
          title: item
        },
        raw: item
      } : {
        item,
        raw: item
      };
    }));
    useRender(() => {
      const hasPrepend = !!(slots.prepend || props2.icon);
      return createVNode(props2.tag, {
        "class": ["v-breadcrumbs", backgroundColorClasses.value, densityClasses.value, roundedClasses.value, props2.class],
        "style": [backgroundColorStyles.value, props2.style]
      }, {
        default: () => {
          var _a2;
          return [hasPrepend && createVNode("li", {
            "key": "prepend",
            "class": "v-breadcrumbs__prepend"
          }, [!slots.prepend ? createVNode(VIcon, {
            "key": "prepend-icon",
            "start": true,
            "icon": props2.icon
          }, null) : createVNode(VDefaultsProvider, {
            "key": "prepend-defaults",
            "disabled": !props2.icon,
            "defaults": {
              VIcon: {
                icon: props2.icon,
                start: true
              }
            }
          }, slots.prepend)]), items.value.map((_ref2, index2, array) => {
            let {
              item,
              raw
            } = _ref2;
            return createVNode(Fragment, null, [createVNode(VBreadcrumbsItem, mergeProps({
              "key": item.title,
              "disabled": index2 >= array.length - 1
            }, item), {
              default: slots.title ? () => {
                var _a3;
                return (_a3 = slots.title) == null ? void 0 : _a3.call(slots, {
                  item: raw,
                  index: index2
                });
              } : void 0
            }), index2 < array.length - 1 && createVNode(VBreadcrumbsDivider, null, {
              default: slots.divider ? () => {
                var _a3;
                return (_a3 = slots.divider) == null ? void 0 : _a3.call(slots, {
                  item: raw,
                  index: index2
                });
              } : void 0
            })]);
          }), (_a2 = slots.default) == null ? void 0 : _a2.call(slots)];
        }
      });
    });
    return {};
  }
});
const VCard$1 = "";
const VCardActions = genericComponent()({
  name: "VCardActions",
  props: makeComponentProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    provideDefaults({
      VBtn: {
        variant: "text"
      }
    });
    useRender(() => {
      var _a2;
      return createVNode("div", {
        "class": ["v-card-actions", props2.class],
        "style": props2.style
      }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
    });
    return {};
  }
});
const VCardSubtitle = createSimpleFunctional("v-card-subtitle");
const VCardTitle = createSimpleFunctional("v-card-title");
const makeCardItemProps = propsFactory({
  appendAvatar: String,
  appendIcon: IconValue,
  prependAvatar: String,
  prependIcon: IconValue,
  subtitle: String,
  title: String,
  ...makeComponentProps(),
  ...makeDensityProps()
}, "VCardItem");
const VCardItem = genericComponent()({
  name: "VCardItem",
  props: makeCardItemProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    useRender(() => {
      var _a2;
      const hasPrependMedia = !!(props2.prependAvatar || props2.prependIcon);
      const hasPrepend = !!(hasPrependMedia || slots.prepend);
      const hasAppendMedia = !!(props2.appendAvatar || props2.appendIcon);
      const hasAppend = !!(hasAppendMedia || slots.append);
      const hasTitle = !!(props2.title || slots.title);
      const hasSubtitle = !!(props2.subtitle || slots.subtitle);
      return createVNode("div", {
        "class": ["v-card-item", props2.class],
        "style": props2.style
      }, [hasPrepend && createVNode("div", {
        "key": "prepend",
        "class": "v-card-item__prepend"
      }, [!slots.prepend ? hasPrependMedia && createVNode(VAvatar, {
        "key": "prepend-avatar",
        "density": props2.density,
        "icon": props2.prependIcon,
        "image": props2.prependAvatar
      }, null) : createVNode(VDefaultsProvider, {
        "key": "prepend-defaults",
        "disabled": !hasPrependMedia,
        "defaults": {
          VAvatar: {
            density: props2.density,
            icon: props2.prependIcon,
            image: props2.prependAvatar
          }
        }
      }, slots.prepend)]), createVNode("div", {
        "class": "v-card-item__content"
      }, [hasTitle && createVNode(VCardTitle, {
        "key": "title"
      }, {
        default: () => {
          var _a3;
          return [((_a3 = slots.title) == null ? void 0 : _a3.call(slots)) ?? props2.title];
        }
      }), hasSubtitle && createVNode(VCardSubtitle, {
        "key": "subtitle"
      }, {
        default: () => {
          var _a3;
          return [((_a3 = slots.subtitle) == null ? void 0 : _a3.call(slots)) ?? props2.subtitle];
        }
      }), (_a2 = slots.default) == null ? void 0 : _a2.call(slots)]), hasAppend && createVNode("div", {
        "key": "append",
        "class": "v-card-item__append"
      }, [!slots.append ? hasAppendMedia && createVNode(VAvatar, {
        "key": "append-avatar",
        "density": props2.density,
        "icon": props2.appendIcon,
        "image": props2.appendAvatar
      }, null) : createVNode(VDefaultsProvider, {
        "key": "append-defaults",
        "disabled": !hasAppendMedia,
        "defaults": {
          VAvatar: {
            density: props2.density,
            icon: props2.appendIcon,
            image: props2.appendAvatar
          }
        }
      }, slots.append)])]);
    });
    return {};
  }
});
const VCardText = createSimpleFunctional("v-card-text");
const makeVCardProps = propsFactory({
  appendAvatar: String,
  appendIcon: IconValue,
  disabled: Boolean,
  flat: Boolean,
  hover: Boolean,
  image: String,
  link: {
    type: Boolean,
    default: void 0
  },
  prependAvatar: String,
  prependIcon: IconValue,
  ripple: {
    type: [Boolean, Object],
    default: true
  },
  subtitle: String,
  text: String,
  title: String,
  ...makeBorderProps(),
  ...makeComponentProps(),
  ...makeDensityProps(),
  ...makeDimensionProps(),
  ...makeElevationProps(),
  ...makeLoaderProps(),
  ...makeLocationProps(),
  ...makePositionProps(),
  ...makeRoundedProps(),
  ...makeRouterProps(),
  ...makeTagProps(),
  ...makeThemeProps(),
  ...makeVariantProps({
    variant: "elevated"
  })
}, "VCard");
const VCard = genericComponent()({
  name: "VCard",
  directives: {
    Ripple
  },
  props: makeVCardProps(),
  setup(props2, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props2);
    const {
      borderClasses
    } = useBorder(props2);
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(props2);
    const {
      densityClasses
    } = useDensity(props2);
    const {
      dimensionStyles
    } = useDimension(props2);
    const {
      elevationClasses
    } = useElevation(props2);
    const {
      loaderClasses
    } = useLoader(props2);
    const {
      locationStyles
    } = useLocation(props2);
    const {
      positionClasses
    } = usePosition(props2);
    const {
      roundedClasses
    } = useRounded(props2);
    const link = useLink(props2, attrs);
    const isLink = computed(() => props2.link !== false && link.isLink.value);
    const isClickable = computed(() => !props2.disabled && props2.link !== false && (props2.link || link.isClickable.value));
    useRender(() => {
      const Tag = isLink.value ? "a" : props2.tag;
      const hasTitle = !!(slots.title || props2.title);
      const hasSubtitle = !!(slots.subtitle || props2.subtitle);
      const hasHeader = hasTitle || hasSubtitle;
      const hasAppend = !!(slots.append || props2.appendAvatar || props2.appendIcon);
      const hasPrepend = !!(slots.prepend || props2.prependAvatar || props2.prependIcon);
      const hasImage = !!(slots.image || props2.image);
      const hasCardItem = hasHeader || hasPrepend || hasAppend;
      const hasText = !!(slots.text || props2.text);
      return withDirectives(createVNode(Tag, {
        "class": ["v-card", {
          "v-card--disabled": props2.disabled,
          "v-card--flat": props2.flat,
          "v-card--hover": props2.hover && !(props2.disabled || props2.flat),
          "v-card--link": isClickable.value
        }, themeClasses.value, borderClasses.value, colorClasses.value, densityClasses.value, elevationClasses.value, loaderClasses.value, positionClasses.value, roundedClasses.value, variantClasses.value, props2.class],
        "style": [colorStyles.value, dimensionStyles.value, locationStyles.value, props2.style],
        "href": link.href.value,
        "onClick": isClickable.value && link.navigate,
        "tabindex": props2.disabled ? -1 : void 0
      }, {
        default: () => {
          var _a2;
          return [hasImage && createVNode("div", {
            "key": "image",
            "class": "v-card__image"
          }, [!slots.image ? createVNode(VImg, {
            "key": "image-img",
            "cover": true,
            "src": props2.image
          }, null) : createVNode(VDefaultsProvider, {
            "key": "image-defaults",
            "disabled": !props2.image,
            "defaults": {
              VImg: {
                cover: true,
                src: props2.image
              }
            }
          }, slots.image)]), createVNode(LoaderSlot, {
            "name": "v-card",
            "active": !!props2.loading,
            "color": typeof props2.loading === "boolean" ? void 0 : props2.loading
          }, {
            default: slots.loader
          }), hasCardItem && createVNode(VCardItem, {
            "key": "item",
            "prependAvatar": props2.prependAvatar,
            "prependIcon": props2.prependIcon,
            "title": props2.title,
            "subtitle": props2.subtitle,
            "appendAvatar": props2.appendAvatar,
            "appendIcon": props2.appendIcon
          }, {
            default: slots.item,
            prepend: slots.prepend,
            title: slots.title,
            subtitle: slots.subtitle,
            append: slots.append
          }), hasText && createVNode(VCardText, {
            "key": "text"
          }, {
            default: () => {
              var _a3;
              return [((_a3 = slots.text) == null ? void 0 : _a3.call(slots)) ?? props2.text];
            }
          }), (_a2 = slots.default) == null ? void 0 : _a2.call(slots), slots.actions && createVNode(VCardActions, null, {
            default: slots.actions
          }), genOverlays(isClickable.value, "v-card")];
        }
      }), [[resolveDirective("ripple"), isClickable.value && props2.ripple]]);
    });
    return {};
  }
});
const VCarousel$1 = "";
const VWindow$1 = "";
const handleGesture = (wrapper) => {
  const {
    touchstartX,
    touchendX,
    touchstartY,
    touchendY
  } = wrapper;
  const dirRatio = 0.5;
  const minDistance = 16;
  wrapper.offsetX = touchendX - touchstartX;
  wrapper.offsetY = touchendY - touchstartY;
  if (Math.abs(wrapper.offsetY) < dirRatio * Math.abs(wrapper.offsetX)) {
    wrapper.left && touchendX < touchstartX - minDistance && wrapper.left(wrapper);
    wrapper.right && touchendX > touchstartX + minDistance && wrapper.right(wrapper);
  }
  if (Math.abs(wrapper.offsetX) < dirRatio * Math.abs(wrapper.offsetY)) {
    wrapper.up && touchendY < touchstartY - minDistance && wrapper.up(wrapper);
    wrapper.down && touchendY > touchstartY + minDistance && wrapper.down(wrapper);
  }
};
function touchstart(event, wrapper) {
  var _a2;
  const touch = event.changedTouches[0];
  wrapper.touchstartX = touch.clientX;
  wrapper.touchstartY = touch.clientY;
  (_a2 = wrapper.start) == null ? void 0 : _a2.call(wrapper, {
    originalEvent: event,
    ...wrapper
  });
}
function touchend(event, wrapper) {
  var _a2;
  const touch = event.changedTouches[0];
  wrapper.touchendX = touch.clientX;
  wrapper.touchendY = touch.clientY;
  (_a2 = wrapper.end) == null ? void 0 : _a2.call(wrapper, {
    originalEvent: event,
    ...wrapper
  });
  handleGesture(wrapper);
}
function touchmove(event, wrapper) {
  var _a2;
  const touch = event.changedTouches[0];
  wrapper.touchmoveX = touch.clientX;
  wrapper.touchmoveY = touch.clientY;
  (_a2 = wrapper.move) == null ? void 0 : _a2.call(wrapper, {
    originalEvent: event,
    ...wrapper
  });
}
function createHandlers() {
  let value = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const wrapper = {
    touchstartX: 0,
    touchstartY: 0,
    touchendX: 0,
    touchendY: 0,
    touchmoveX: 0,
    touchmoveY: 0,
    offsetX: 0,
    offsetY: 0,
    left: value.left,
    right: value.right,
    up: value.up,
    down: value.down,
    start: value.start,
    move: value.move,
    end: value.end
  };
  return {
    touchstart: (e) => touchstart(e, wrapper),
    touchend: (e) => touchend(e, wrapper),
    touchmove: (e) => touchmove(e, wrapper)
  };
}
function mounted$3(el, binding) {
  var _a2;
  const value = binding.value;
  const target = (value == null ? void 0 : value.parent) ? el.parentElement : el;
  const options = (value == null ? void 0 : value.options) ?? {
    passive: true
  };
  const uid2 = (_a2 = binding.instance) == null ? void 0 : _a2.$.uid;
  if (!target || !uid2)
    return;
  const handlers2 = createHandlers(binding.value);
  target._touchHandlers = target._touchHandlers ?? /* @__PURE__ */ Object.create(null);
  target._touchHandlers[uid2] = handlers2;
  keys(handlers2).forEach((eventName2) => {
    target.addEventListener(eventName2, handlers2[eventName2], options);
  });
}
function unmounted$3(el, binding) {
  var _a2, _b;
  const target = ((_a2 = binding.value) == null ? void 0 : _a2.parent) ? el.parentElement : el;
  const uid2 = (_b = binding.instance) == null ? void 0 : _b.$.uid;
  if (!(target == null ? void 0 : target._touchHandlers) || !uid2)
    return;
  const handlers2 = target._touchHandlers[uid2];
  keys(handlers2).forEach((eventName2) => {
    target.removeEventListener(eventName2, handlers2[eventName2]);
  });
  delete target._touchHandlers[uid2];
}
const Touch = {
  mounted: mounted$3,
  unmounted: unmounted$3
};
const VWindowSymbol = Symbol.for("vuetify:v-window");
const VWindowGroupSymbol = Symbol.for("vuetify:v-window-group");
const makeVWindowProps = propsFactory({
  continuous: Boolean,
  nextIcon: {
    type: [Boolean, String, Function, Object],
    default: "$next"
  },
  prevIcon: {
    type: [Boolean, String, Function, Object],
    default: "$prev"
  },
  reverse: Boolean,
  showArrows: {
    type: [Boolean, String],
    validator: (v2) => typeof v2 === "boolean" || v2 === "hover"
  },
  touch: {
    type: [Object, Boolean],
    default: void 0
  },
  direction: {
    type: String,
    default: "horizontal"
  },
  modelValue: null,
  disabled: Boolean,
  selectedClass: {
    type: String,
    default: "v-window-item--active"
  },
  // TODO: mandatory should probably not be exposed but do this for now
  mandatory: {
    type: [Boolean, String],
    default: "force"
  },
  ...makeComponentProps(),
  ...makeTagProps(),
  ...makeThemeProps()
}, "VWindow");
const VWindow = genericComponent()({
  name: "VWindow",
  directives: {
    Touch
  },
  props: makeVWindowProps(),
  emits: {
    "update:modelValue": (v2) => true
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props2);
    const {
      isRtl
    } = useRtl();
    const {
      t
    } = useLocale();
    const group = useGroup(props2, VWindowGroupSymbol);
    const rootRef = ref();
    const isRtlReverse = computed(() => isRtl.value ? !props2.reverse : props2.reverse);
    const isReversed = shallowRef(false);
    const transition = computed(() => {
      const axis = props2.direction === "vertical" ? "y" : "x";
      const reverse = isRtlReverse.value ? !isReversed.value : isReversed.value;
      const direction = reverse ? "-reverse" : "";
      return `v-window-${axis}${direction}-transition`;
    });
    const transitionCount = shallowRef(0);
    const transitionHeight = ref(void 0);
    const activeIndex = computed(() => {
      return group.items.value.findIndex((item) => group.selected.value.includes(item.id));
    });
    watch(activeIndex, (newVal, oldVal) => {
      const itemsLength = group.items.value.length;
      const lastIndex = itemsLength - 1;
      if (itemsLength <= 2) {
        isReversed.value = newVal < oldVal;
      } else if (newVal === lastIndex && oldVal === 0) {
        isReversed.value = true;
      } else if (newVal === 0 && oldVal === lastIndex) {
        isReversed.value = false;
      } else {
        isReversed.value = newVal < oldVal;
      }
    });
    provide(VWindowSymbol, {
      transition,
      isReversed,
      transitionCount,
      transitionHeight,
      rootRef
    });
    const canMoveBack = computed(() => props2.continuous || activeIndex.value !== 0);
    const canMoveForward = computed(() => props2.continuous || activeIndex.value !== group.items.value.length - 1);
    function prev() {
      canMoveBack.value && group.prev();
    }
    function next() {
      canMoveForward.value && group.next();
    }
    const arrows = computed(() => {
      const arrows2 = [];
      const prevProps = {
        icon: isRtl.value ? props2.nextIcon : props2.prevIcon,
        class: `v-window__${isRtlReverse.value ? "right" : "left"}`,
        onClick: group.prev,
        ariaLabel: t("$vuetify.carousel.prev")
      };
      arrows2.push(canMoveBack.value ? slots.prev ? slots.prev({
        props: prevProps
      }) : createVNode(VBtn, prevProps, null) : createVNode("div", null, null));
      const nextProps = {
        icon: isRtl.value ? props2.prevIcon : props2.nextIcon,
        class: `v-window__${isRtlReverse.value ? "left" : "right"}`,
        onClick: group.next,
        ariaLabel: t("$vuetify.carousel.next")
      };
      arrows2.push(canMoveForward.value ? slots.next ? slots.next({
        props: nextProps
      }) : createVNode(VBtn, nextProps, null) : createVNode("div", null, null));
      return arrows2;
    });
    const touchOptions = computed(() => {
      if (props2.touch === false)
        return props2.touch;
      const options = {
        left: () => {
          isRtlReverse.value ? prev() : next();
        },
        right: () => {
          isRtlReverse.value ? next() : prev();
        },
        start: (_ref2) => {
          let {
            originalEvent
          } = _ref2;
          originalEvent.stopPropagation();
        }
      };
      return {
        ...options,
        ...props2.touch === true ? {} : props2.touch
      };
    });
    useRender(() => withDirectives(createVNode(props2.tag, {
      "ref": rootRef,
      "class": ["v-window", {
        "v-window--show-arrows-on-hover": props2.showArrows === "hover"
      }, themeClasses.value, props2.class],
      "style": props2.style
    }, {
      default: () => {
        var _a2, _b;
        return [createVNode("div", {
          "class": "v-window__container",
          "style": {
            height: transitionHeight.value
          }
        }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
          group
        }), props2.showArrows !== false && createVNode("div", {
          "class": "v-window__controls"
        }, [arrows.value])]), (_b = slots.additional) == null ? void 0 : _b.call(slots, {
          group
        })];
      }
    }), [[resolveDirective("touch"), touchOptions.value]]));
    return {
      group
    };
  }
});
const makeVCarouselProps = propsFactory({
  color: String,
  cycle: Boolean,
  delimiterIcon: {
    type: IconValue,
    default: "$delimiter"
  },
  height: {
    type: [Number, String],
    default: 500
  },
  hideDelimiters: Boolean,
  hideDelimiterBackground: Boolean,
  interval: {
    type: [Number, String],
    default: 6e3,
    validator: (value) => Number(value) > 0
  },
  progress: [Boolean, String],
  verticalDelimiters: [Boolean, String],
  ...makeVWindowProps({
    continuous: true,
    mandatory: "force",
    showArrows: true
  })
}, "VCarousel");
const VCarousel = genericComponent()({
  name: "VCarousel",
  props: makeVCarouselProps(),
  emits: {
    "update:modelValue": (val) => true
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const model = useProxiedModel(props2, "modelValue");
    const {
      t
    } = useLocale();
    const windowRef = ref();
    let slideTimeout = -1;
    watch(model, restartTimeout);
    watch(() => props2.interval, restartTimeout);
    watch(() => props2.cycle, (val) => {
      if (val)
        restartTimeout();
      else
        window.clearTimeout(slideTimeout);
    });
    onMounted(startTimeout);
    function startTimeout() {
      if (!props2.cycle || !windowRef.value)
        return;
      slideTimeout = window.setTimeout(windowRef.value.group.next, +props2.interval > 0 ? +props2.interval : 6e3);
    }
    function restartTimeout() {
      window.clearTimeout(slideTimeout);
      window.requestAnimationFrame(startTimeout);
    }
    useRender(() => {
      const [windowProps] = VWindow.filterProps(props2);
      return createVNode(VWindow, mergeProps({
        "ref": windowRef
      }, windowProps, {
        "modelValue": model.value,
        "onUpdate:modelValue": ($event) => model.value = $event,
        "class": ["v-carousel", {
          "v-carousel--hide-delimiter-background": props2.hideDelimiterBackground,
          "v-carousel--vertical-delimiters": props2.verticalDelimiters
        }, props2.class],
        "style": [{
          height: convertToUnit(props2.height)
        }, props2.style]
      }), {
        default: slots.default,
        additional: (_ref2) => {
          let {
            group
          } = _ref2;
          return createVNode(Fragment, null, [!props2.hideDelimiters && createVNode("div", {
            "class": "v-carousel__controls",
            "style": {
              left: props2.verticalDelimiters === "left" && props2.verticalDelimiters ? 0 : "auto",
              right: props2.verticalDelimiters === "right" ? 0 : "auto"
            }
          }, [group.items.value.length > 0 && createVNode(VDefaultsProvider, {
            "defaults": {
              VBtn: {
                color: props2.color,
                icon: props2.delimiterIcon,
                size: "x-small",
                variant: "text"
              }
            },
            "scoped": true
          }, {
            default: () => [group.items.value.map((item, index2) => {
              const props3 = {
                id: `carousel-item-${item.id}`,
                "aria-label": t("$vuetify.carousel.ariaLabel.delimiter", index2 + 1, group.items.value.length),
                class: [group.isSelected(item.id) && "v-btn--active"],
                onClick: () => group.select(item.id, true)
              };
              return slots.item ? slots.item({
                props: props3,
                item
              }) : createVNode(VBtn, mergeProps(item, props3), null);
            })]
          })]), props2.progress && createVNode(VProgressLinear, {
            "class": "v-carousel__progress",
            "color": typeof props2.progress === "string" ? props2.progress : void 0,
            "modelValue": (group.getItemIndex(model.value) + 1) / group.items.value.length * 100
          }, null)]);
        },
        prev: slots.prev,
        next: slots.next
      });
    });
    return {};
  }
});
const makeVWindowItemProps = propsFactory({
  reverseTransition: {
    type: [Boolean, String],
    default: void 0
  },
  transition: {
    type: [Boolean, String],
    default: void 0
  },
  ...makeComponentProps(),
  ...makeGroupItemProps(),
  ...makeLazyProps()
}, "VWindowItem");
const VWindowItem = genericComponent()({
  name: "VWindowItem",
  directives: {
    Touch
  },
  props: makeVWindowItemProps(),
  emits: {
    "group:selected": (val) => true
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const window2 = inject$1(VWindowSymbol);
    const groupItem = useGroupItem(props2, VWindowGroupSymbol);
    const {
      isBooted
    } = useSsrBoot();
    if (!window2 || !groupItem)
      throw new Error("[Vuetify] VWindowItem must be used inside VWindow");
    const isTransitioning = shallowRef(false);
    const hasTransition = computed(() => isBooted.value && (window2.isReversed.value ? props2.reverseTransition !== false : props2.transition !== false));
    function onAfterTransition() {
      if (!isTransitioning.value || !window2) {
        return;
      }
      isTransitioning.value = false;
      if (window2.transitionCount.value > 0) {
        window2.transitionCount.value -= 1;
        if (window2.transitionCount.value === 0) {
          window2.transitionHeight.value = void 0;
        }
      }
    }
    function onBeforeTransition() {
      var _a2;
      if (isTransitioning.value || !window2) {
        return;
      }
      isTransitioning.value = true;
      if (window2.transitionCount.value === 0) {
        window2.transitionHeight.value = convertToUnit((_a2 = window2.rootRef.value) == null ? void 0 : _a2.clientHeight);
      }
      window2.transitionCount.value += 1;
    }
    function onTransitionCancelled() {
      onAfterTransition();
    }
    function onEnterTransition(el) {
      if (!isTransitioning.value) {
        return;
      }
      nextTick(() => {
        if (!hasTransition.value || !isTransitioning.value || !window2) {
          return;
        }
        window2.transitionHeight.value = convertToUnit(el.clientHeight);
      });
    }
    const transition = computed(() => {
      const name = window2.isReversed.value ? props2.reverseTransition : props2.transition;
      return !hasTransition.value ? false : {
        name: typeof name !== "string" ? window2.transition.value : name,
        onBeforeEnter: onBeforeTransition,
        onAfterEnter: onAfterTransition,
        onEnterCancelled: onTransitionCancelled,
        onBeforeLeave: onBeforeTransition,
        onAfterLeave: onAfterTransition,
        onLeaveCancelled: onTransitionCancelled,
        onEnter: onEnterTransition
      };
    });
    const {
      hasContent
    } = useLazy(props2, groupItem.isSelected);
    useRender(() => createVNode(MaybeTransition, {
      "transition": transition.value,
      "disabled": !isBooted.value
    }, {
      default: () => {
        var _a2;
        return [withDirectives(createVNode("div", {
          "class": ["v-window-item", groupItem.selectedClass.value, props2.class],
          "style": props2.style
        }, [hasContent.value && ((_a2 = slots.default) == null ? void 0 : _a2.call(slots))]), [[vShow, groupItem.isSelected.value]])];
      }
    }));
    return {
      groupItem
    };
  }
});
const makeVCarouselItemProps = propsFactory({
  ...makeVImgProps(),
  ...makeVWindowItemProps()
}, "VCarouselItem");
const VCarouselItem = genericComponent()({
  name: "VCarouselItem",
  inheritAttrs: false,
  props: makeVCarouselItemProps(),
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    useRender(() => {
      const [imgProps] = VImg.filterProps(props2);
      const [windowItemProps] = VWindowItem.filterProps(props2);
      return createVNode(VWindowItem, mergeProps({
        "class": "v-carousel-item"
      }, windowItemProps), {
        default: () => [createVNode(VImg, mergeProps(attrs, imgProps), slots)]
      });
    });
  }
});
const VCode$1 = "";
const VCode = createSimpleFunctional("v-code");
const VColorPicker$1 = "";
const VColorPickerCanvas$1 = "";
const makeVColorPickerCanvasProps = propsFactory({
  color: {
    type: Object
  },
  disabled: Boolean,
  dotSize: {
    type: [Number, String],
    default: 10
  },
  height: {
    type: [Number, String],
    default: 150
  },
  width: {
    type: [Number, String],
    default: 300
  },
  ...makeComponentProps()
}, "VColorPickerCanvas");
const VColorPickerCanvas = defineComponent({
  name: "VColorPickerCanvas",
  props: makeVColorPickerCanvasProps(),
  emits: {
    "update:color": (color) => true,
    "update:position": (hue) => true
  },
  setup(props2, _ref) {
    let {
      emit: emit2
    } = _ref;
    const isInteracting = shallowRef(false);
    const canvasRef = ref();
    const canvasWidth = shallowRef(parseFloat(props2.width));
    const canvasHeight = shallowRef(parseFloat(props2.height));
    const _dotPosition = ref({
      x: 0,
      y: 0
    });
    const dotPosition = computed({
      get: () => _dotPosition.value,
      set(val) {
        var _a2, _b;
        if (!canvasRef.value)
          return;
        const {
          x: x2,
          y: y2
        } = val;
        _dotPosition.value = val;
        emit2("update:color", {
          h: ((_a2 = props2.color) == null ? void 0 : _a2.h) ?? 0,
          s: clamp(x2, 0, canvasWidth.value) / canvasWidth.value,
          v: 1 - clamp(y2, 0, canvasHeight.value) / canvasHeight.value,
          a: ((_b = props2.color) == null ? void 0 : _b.a) ?? 1
        });
      }
    });
    const dotStyles = computed(() => {
      const {
        x: x2,
        y: y2
      } = dotPosition.value;
      const radius = parseInt(props2.dotSize, 10) / 2;
      return {
        width: convertToUnit(props2.dotSize),
        height: convertToUnit(props2.dotSize),
        transform: `translate(${convertToUnit(x2 - radius)}, ${convertToUnit(y2 - radius)})`
      };
    });
    const {
      resizeRef
    } = useResizeObserver((entries) => {
      var _a2;
      if (!((_a2 = resizeRef.value) == null ? void 0 : _a2.offsetParent))
        return;
      const {
        width,
        height
      } = entries[0].contentRect;
      canvasWidth.value = width;
      canvasHeight.value = height;
    });
    function updateDotPosition(x2, y2, rect) {
      const {
        left,
        top,
        width,
        height
      } = rect;
      dotPosition.value = {
        x: clamp(x2 - left, 0, width),
        y: clamp(y2 - top, 0, height)
      };
    }
    function handleMouseDown(e) {
      if (e.type === "mousedown") {
        e.preventDefault();
      }
      if (props2.disabled)
        return;
      handleMouseMove(e);
      window.addEventListener("mousemove", handleMouseMove);
      window.addEventListener("mouseup", handleMouseUp);
      window.addEventListener("touchmove", handleMouseMove);
      window.addEventListener("touchend", handleMouseUp);
    }
    function handleMouseMove(e) {
      if (props2.disabled || !canvasRef.value)
        return;
      isInteracting.value = true;
      const coords = getEventCoordinates(e);
      updateDotPosition(coords.clientX, coords.clientY, canvasRef.value.getBoundingClientRect());
    }
    function handleMouseUp() {
      window.removeEventListener("mousemove", handleMouseMove);
      window.removeEventListener("mouseup", handleMouseUp);
      window.removeEventListener("touchmove", handleMouseMove);
      window.removeEventListener("touchend", handleMouseUp);
    }
    function updateCanvas() {
      var _a2;
      if (!canvasRef.value)
        return;
      const canvas = canvasRef.value;
      const ctx = canvas.getContext("2d");
      if (!ctx)
        return;
      const saturationGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
      saturationGradient.addColorStop(0, "hsla(0, 0%, 100%, 1)");
      saturationGradient.addColorStop(1, `hsla(${((_a2 = props2.color) == null ? void 0 : _a2.h) ?? 0}, 100%, 50%, 1)`);
      ctx.fillStyle = saturationGradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      const valueGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      valueGradient.addColorStop(0, "hsla(0, 0%, 100%, 0)");
      valueGradient.addColorStop(1, "hsla(0, 0%, 0%, 1)");
      ctx.fillStyle = valueGradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
    watch(() => {
      var _a2;
      return (_a2 = props2.color) == null ? void 0 : _a2.h;
    }, updateCanvas, {
      immediate: true
    });
    watch(() => [canvasWidth.value, canvasHeight.value], (newVal, oldVal) => {
      updateCanvas();
      _dotPosition.value = {
        x: dotPosition.value.x * newVal[0] / oldVal[0],
        y: dotPosition.value.y * newVal[1] / oldVal[1]
      };
    }, {
      flush: "post"
    });
    watch(() => props2.color, () => {
      if (isInteracting.value) {
        isInteracting.value = false;
        return;
      }
      _dotPosition.value = props2.color ? {
        x: props2.color.s * canvasWidth.value,
        y: (1 - props2.color.v) * canvasHeight.value
      } : {
        x: 0,
        y: 0
      };
    }, {
      deep: true,
      immediate: true
    });
    onMounted(() => updateCanvas());
    useRender(() => createVNode("div", {
      "ref": resizeRef,
      "class": ["v-color-picker-canvas", props2.class],
      "style": props2.style,
      "onMousedown": handleMouseDown,
      "onTouchstartPassive": handleMouseDown
    }, [createVNode("canvas", {
      "ref": canvasRef,
      "width": canvasWidth.value,
      "height": canvasHeight.value
    }, null), props2.color && createVNode("div", {
      "class": ["v-color-picker-canvas__dot", {
        "v-color-picker-canvas__dot--disabled": props2.disabled
      }],
      "style": dotStyles.value
    }, null)]));
    return {};
  }
});
const VColorPickerEdit$1 = "";
function stripAlpha(color, stripAlpha2) {
  if (stripAlpha2) {
    const {
      a,
      ...rest
    } = color;
    return rest;
  }
  return color;
}
function extractColor(color, input) {
  if (input == null || typeof input === "string") {
    const hex2 = HSVtoHex(color);
    if (color.a === 1)
      return hex2.slice(0, 7);
    else
      return hex2;
  }
  if (typeof input === "object") {
    let converted;
    if (has$4(input, ["r", "g", "b"]))
      converted = HSVtoRGB(color);
    else if (has$4(input, ["h", "s", "l"]))
      converted = HSVtoHSL(color);
    else if (has$4(input, ["h", "s", "v"]))
      converted = color;
    return stripAlpha(converted, !has$4(input, ["a"]) && color.a === 1);
  }
  return color;
}
const nullColor = {
  h: 0,
  s: 0,
  v: 1,
  a: 1
};
const rgba = {
  inputProps: {
    type: "number",
    min: 0
  },
  inputs: [{
    label: "R",
    max: 255,
    step: 1,
    getValue: (c2) => Math.round(c2.r),
    getColor: (c2, v2) => ({
      ...c2,
      r: Number(v2)
    })
  }, {
    label: "G",
    max: 255,
    step: 1,
    getValue: (c2) => Math.round(c2.g),
    getColor: (c2, v2) => ({
      ...c2,
      g: Number(v2)
    })
  }, {
    label: "B",
    max: 255,
    step: 1,
    getValue: (c2) => Math.round(c2.b),
    getColor: (c2, v2) => ({
      ...c2,
      b: Number(v2)
    })
  }, {
    label: "A",
    max: 1,
    step: 0.01,
    getValue: (_ref) => {
      let {
        a
      } = _ref;
      return a != null ? Math.round(a * 100) / 100 : 1;
    },
    getColor: (c2, v2) => ({
      ...c2,
      a: Number(v2)
    })
  }],
  to: HSVtoRGB,
  from: RGBtoHSV
};
const rgb = {
  ...rgba,
  inputs: (_a = rgba.inputs) == null ? void 0 : _a.slice(0, 3)
};
const hsla = {
  inputProps: {
    type: "number",
    min: 0
  },
  inputs: [{
    label: "H",
    max: 360,
    step: 1,
    getValue: (c2) => Math.round(c2.h),
    getColor: (c2, v2) => ({
      ...c2,
      h: Number(v2)
    })
  }, {
    label: "S",
    max: 1,
    step: 0.01,
    getValue: (c2) => Math.round(c2.s * 100) / 100,
    getColor: (c2, v2) => ({
      ...c2,
      s: Number(v2)
    })
  }, {
    label: "L",
    max: 1,
    step: 0.01,
    getValue: (c2) => Math.round(c2.l * 100) / 100,
    getColor: (c2, v2) => ({
      ...c2,
      l: Number(v2)
    })
  }, {
    label: "A",
    max: 1,
    step: 0.01,
    getValue: (_ref2) => {
      let {
        a
      } = _ref2;
      return a != null ? Math.round(a * 100) / 100 : 1;
    },
    getColor: (c2, v2) => ({
      ...c2,
      a: Number(v2)
    })
  }],
  to: HSVtoHSL,
  from: HSLtoHSV
};
const hsl = {
  ...hsla,
  inputs: hsla.inputs.slice(0, 3)
};
const hexa = {
  inputProps: {
    type: "text"
  },
  inputs: [{
    label: "HEXA",
    getValue: (c2) => c2,
    getColor: (c2, v2) => v2
  }],
  to: HSVtoHex,
  from: HexToHSV
};
const hex = {
  ...hexa,
  inputs: [{
    label: "HEX",
    getValue: (c2) => c2.slice(0, 7),
    getColor: (c2, v2) => v2
  }]
};
const modes = {
  rgb,
  rgba,
  hsl,
  hsla,
  hex,
  hexa
};
const VColorPickerInput = (_ref) => {
  let {
    label,
    ...rest
  } = _ref;
  return createVNode("div", {
    "class": "v-color-picker-edit__input"
  }, [createVNode("input", rest, null), createVNode("span", null, [label])]);
};
const makeVColorPickerEditProps = propsFactory({
  color: Object,
  disabled: Boolean,
  mode: {
    type: String,
    default: "rgba",
    validator: (v2) => Object.keys(modes).includes(v2)
  },
  modes: {
    type: Array,
    default: () => Object.keys(modes),
    validator: (v2) => Array.isArray(v2) && v2.every((m) => Object.keys(modes).includes(m))
  },
  ...makeComponentProps()
}, "VColorPickerEdit");
const VColorPickerEdit = defineComponent({
  name: "VColorPickerEdit",
  props: makeVColorPickerEditProps(),
  emits: {
    "update:color": (color) => true,
    "update:mode": (mode) => true
  },
  setup(props2, _ref2) {
    let {
      emit: emit2
    } = _ref2;
    const enabledModes = computed(() => {
      return props2.modes.map((key2) => ({
        ...modes[key2],
        name: key2
      }));
    });
    const inputs = computed(() => {
      var _a2;
      const mode = enabledModes.value.find((m) => m.name === props2.mode);
      if (!mode)
        return [];
      const color = props2.color ? mode.to(props2.color) : null;
      return (_a2 = mode.inputs) == null ? void 0 : _a2.map((_ref3) => {
        let {
          getValue: getValue2,
          getColor,
          ...inputProps
        } = _ref3;
        return {
          ...mode.inputProps,
          ...inputProps,
          disabled: props2.disabled,
          value: color && getValue2(color),
          onChange: (e) => {
            const target = e.target;
            if (!target)
              return;
            emit2("update:color", mode.from(getColor(color ?? nullColor, target.value)));
          }
        };
      });
    });
    useRender(() => {
      var _a2;
      return createVNode("div", {
        "class": ["v-color-picker-edit", props2.class],
        "style": props2.style
      }, [(_a2 = inputs.value) == null ? void 0 : _a2.map((props3) => createVNode(VColorPickerInput, props3, null)), enabledModes.value.length > 1 && createVNode(VBtn, {
        "icon": "$unfold",
        "size": "x-small",
        "variant": "plain",
        "onClick": () => {
          const mi = enabledModes.value.findIndex((m) => m.name === props2.mode);
          emit2("update:mode", enabledModes.value[(mi + 1) % enabledModes.value.length].name);
        }
      }, null)]);
    });
    return {};
  }
});
const VColorPickerPreview$1 = "";
const VSlider$1 = "";
const VSliderThumb$1 = "";
const VSliderSymbol = Symbol.for("vuetify:v-slider");
function getOffset(e, el, direction) {
  const vertical = direction === "vertical";
  const rect = el.getBoundingClientRect();
  const touch = "touches" in e ? e.touches[0] : e;
  return vertical ? touch.clientY - (rect.top + rect.height / 2) : touch.clientX - (rect.left + rect.width / 2);
}
function getPosition(e, position) {
  if ("touches" in e && e.touches.length)
    return e.touches[0][position];
  else if ("changedTouches" in e && e.changedTouches.length)
    return e.changedTouches[0][position];
  else
    return e[position];
}
const makeSliderProps = propsFactory({
  disabled: {
    type: Boolean,
    default: null
  },
  error: Boolean,
  readonly: {
    type: Boolean,
    default: null
  },
  max: {
    type: [Number, String],
    default: 100
  },
  min: {
    type: [Number, String],
    default: 0
  },
  step: {
    type: [Number, String],
    default: 0
  },
  thumbColor: String,
  thumbLabel: {
    type: [Boolean, String],
    default: void 0,
    validator: (v2) => typeof v2 === "boolean" || v2 === "always"
  },
  thumbSize: {
    type: [Number, String],
    default: 20
  },
  showTicks: {
    type: [Boolean, String],
    default: false,
    validator: (v2) => typeof v2 === "boolean" || v2 === "always"
  },
  ticks: {
    type: [Array, Object]
  },
  tickSize: {
    type: [Number, String],
    default: 2
  },
  color: String,
  trackColor: String,
  trackFillColor: String,
  trackSize: {
    type: [Number, String],
    default: 4
  },
  direction: {
    type: String,
    default: "horizontal",
    validator: (v2) => ["vertical", "horizontal"].includes(v2)
  },
  reverse: Boolean,
  ...makeRoundedProps(),
  ...makeElevationProps({
    elevation: 2
  })
}, "Slider");
const useSteps = (props2) => {
  const min = computed(() => parseFloat(props2.min));
  const max2 = computed(() => parseFloat(props2.max));
  const step = computed(() => +props2.step > 0 ? parseFloat(props2.step) : 0);
  const decimals = computed(() => Math.max(getDecimals(step.value), getDecimals(min.value)));
  function roundValue(value) {
    value = parseFloat(value);
    if (step.value <= 0)
      return value;
    const clamped = clamp(value, min.value, max2.value);
    const offset = min.value % step.value;
    const newValue = Math.round((clamped - offset) / step.value) * step.value + offset;
    return parseFloat(Math.min(newValue, max2.value).toFixed(decimals.value));
  }
  return {
    min,
    max: max2,
    step,
    decimals,
    roundValue
  };
};
const useSlider = (_ref) => {
  let {
    props: props2,
    steps,
    onSliderStart,
    onSliderMove,
    onSliderEnd,
    getActiveThumb
  } = _ref;
  const {
    isRtl
  } = useRtl();
  const isReversed = toRef(props2, "reverse");
  const vertical = computed(() => props2.direction === "vertical");
  const indexFromEnd = computed(() => vertical.value !== isReversed.value);
  const {
    min,
    max: max2,
    step,
    decimals,
    roundValue
  } = steps;
  const thumbSize = computed(() => parseInt(props2.thumbSize, 10));
  const tickSize = computed(() => parseInt(props2.tickSize, 10));
  const trackSize = computed(() => parseInt(props2.trackSize, 10));
  const numTicks = computed(() => (max2.value - min.value) / step.value);
  const disabled = toRef(props2, "disabled");
  const thumbColor = computed(() => props2.error || props2.disabled ? void 0 : props2.thumbColor ?? props2.color);
  const trackColor = computed(() => props2.error || props2.disabled ? void 0 : props2.trackColor ?? props2.color);
  const trackFillColor = computed(() => props2.error || props2.disabled ? void 0 : props2.trackFillColor ?? props2.color);
  const mousePressed = shallowRef(false);
  const startOffset = shallowRef(0);
  const trackContainerRef = ref();
  const activeThumbRef = ref();
  function parseMouseMove(e) {
    var _a2;
    const vertical2 = props2.direction === "vertical";
    const start = vertical2 ? "top" : "left";
    const length = vertical2 ? "height" : "width";
    const position2 = vertical2 ? "clientY" : "clientX";
    const {
      [start]: trackStart,
      [length]: trackLength
    } = (_a2 = trackContainerRef.value) == null ? void 0 : _a2.$el.getBoundingClientRect();
    const clickOffset = getPosition(e, position2);
    let clickPos = Math.min(Math.max((clickOffset - trackStart - startOffset.value) / trackLength, 0), 1) || 0;
    if (vertical2 ? indexFromEnd.value : indexFromEnd.value !== isRtl.value)
      clickPos = 1 - clickPos;
    return roundValue(min.value + clickPos * (max2.value - min.value));
  }
  const handleStop = (e) => {
    onSliderEnd({
      value: parseMouseMove(e)
    });
    mousePressed.value = false;
    startOffset.value = 0;
  };
  const handleStart = (e) => {
    activeThumbRef.value = getActiveThumb(e);
    if (!activeThumbRef.value)
      return;
    activeThumbRef.value.focus();
    mousePressed.value = true;
    if (activeThumbRef.value.contains(e.target)) {
      startOffset.value = getOffset(e, activeThumbRef.value, props2.direction);
    } else {
      startOffset.value = 0;
      onSliderMove({
        value: parseMouseMove(e)
      });
    }
    onSliderStart({
      value: parseMouseMove(e)
    });
  };
  const moveListenerOptions = {
    passive: true,
    capture: true
  };
  function onMouseMove(e) {
    onSliderMove({
      value: parseMouseMove(e)
    });
  }
  function onSliderMouseUp(e) {
    e.stopPropagation();
    e.preventDefault();
    handleStop(e);
    window.removeEventListener("mousemove", onMouseMove, moveListenerOptions);
    window.removeEventListener("mouseup", onSliderMouseUp);
  }
  function onSliderTouchend(e) {
    var _a2;
    handleStop(e);
    window.removeEventListener("touchmove", onMouseMove, moveListenerOptions);
    (_a2 = e.target) == null ? void 0 : _a2.removeEventListener("touchend", onSliderTouchend);
  }
  function onSliderTouchstart(e) {
    var _a2;
    handleStart(e);
    window.addEventListener("touchmove", onMouseMove, moveListenerOptions);
    (_a2 = e.target) == null ? void 0 : _a2.addEventListener("touchend", onSliderTouchend, {
      passive: false
    });
  }
  function onSliderMousedown(e) {
    e.preventDefault();
    handleStart(e);
    window.addEventListener("mousemove", onMouseMove, moveListenerOptions);
    window.addEventListener("mouseup", onSliderMouseUp, {
      passive: false
    });
  }
  const position = (val) => {
    const percentage = (val - min.value) / (max2.value - min.value) * 100;
    return clamp(isNaN(percentage) ? 0 : percentage, 0, 100);
  };
  const showTicks = toRef(props2, "showTicks");
  const parsedTicks = computed(() => {
    if (!showTicks.value)
      return [];
    if (!props2.ticks) {
      return numTicks.value !== Infinity ? createRange(numTicks.value + 1).map((t) => {
        const value = min.value + t * step.value;
        return {
          value,
          position: position(value)
        };
      }) : [];
    }
    if (Array.isArray(props2.ticks))
      return props2.ticks.map((t) => ({
        value: t,
        position: position(t),
        label: t.toString()
      }));
    return Object.keys(props2.ticks).map((key2) => ({
      value: parseFloat(key2),
      position: position(parseFloat(key2)),
      label: props2.ticks[key2]
    }));
  });
  const hasLabels = computed(() => parsedTicks.value.some((_ref2) => {
    let {
      label
    } = _ref2;
    return !!label;
  }));
  const data = {
    activeThumbRef,
    color: toRef(props2, "color"),
    decimals,
    disabled,
    direction: toRef(props2, "direction"),
    elevation: toRef(props2, "elevation"),
    hasLabels,
    isReversed,
    indexFromEnd,
    min,
    max: max2,
    mousePressed,
    numTicks,
    onSliderMousedown,
    onSliderTouchstart,
    parsedTicks,
    parseMouseMove,
    position,
    readonly: toRef(props2, "readonly"),
    rounded: toRef(props2, "rounded"),
    roundValue,
    showTicks,
    startOffset,
    step,
    thumbSize,
    thumbColor,
    thumbLabel: toRef(props2, "thumbLabel"),
    ticks: toRef(props2, "ticks"),
    tickSize,
    trackColor,
    trackContainerRef,
    trackFillColor,
    trackSize,
    vertical
  };
  provide(VSliderSymbol, data);
  return data;
};
const makeVSliderThumbProps = propsFactory({
  focused: Boolean,
  max: {
    type: Number,
    required: true
  },
  min: {
    type: Number,
    required: true
  },
  modelValue: {
    type: Number,
    required: true
  },
  position: {
    type: Number,
    required: true
  },
  ripple: {
    type: [Boolean, Object],
    default: true
  },
  ...makeComponentProps()
}, "VSliderThumb");
const VSliderThumb = genericComponent()({
  name: "VSliderThumb",
  directives: {
    Ripple
  },
  props: makeVSliderThumbProps(),
  emits: {
    "update:modelValue": (v2) => true
  },
  setup(props2, _ref) {
    let {
      slots,
      emit: emit2
    } = _ref;
    const slider = inject$1(VSliderSymbol);
    const {
      isRtl,
      rtlClasses
    } = useRtl();
    if (!slider)
      throw new Error("[Vuetify] v-slider-thumb must be used inside v-slider or v-range-slider");
    const {
      thumbColor,
      step,
      disabled,
      thumbSize,
      thumbLabel,
      direction,
      isReversed,
      vertical,
      readonly: readonly2,
      elevation,
      mousePressed,
      decimals,
      indexFromEnd
    } = slider;
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(thumbColor);
    const {
      pageup,
      pagedown,
      end,
      home,
      left,
      right,
      down,
      up
    } = keyValues;
    const relevantKeys = [pageup, pagedown, end, home, left, right, down, up];
    const multipliers = computed(() => {
      if (step.value)
        return [1, 2, 3];
      else
        return [1, 5, 10];
    });
    function parseKeydown(e, value) {
      if (!relevantKeys.includes(e.key))
        return;
      e.preventDefault();
      const _step = step.value || 0.1;
      const steps = (props2.max - props2.min) / _step;
      if ([left, right, down, up].includes(e.key)) {
        const increase = vertical.value ? [isRtl.value ? left : right, isReversed.value ? down : up] : indexFromEnd.value !== isRtl.value ? [left, up] : [right, up];
        const direction2 = increase.includes(e.key) ? 1 : -1;
        const multiplier = e.shiftKey ? 2 : e.ctrlKey ? 1 : 0;
        value = value + direction2 * _step * multipliers.value[multiplier];
      } else if (e.key === home) {
        value = props2.min;
      } else if (e.key === end) {
        value = props2.max;
      } else {
        const direction2 = e.key === pagedown ? 1 : -1;
        value = value - direction2 * _step * (steps > 100 ? steps / 10 : 10);
      }
      return Math.max(props2.min, Math.min(props2.max, value));
    }
    function onKeydown(e) {
      const newValue = parseKeydown(e, props2.modelValue);
      newValue != null && emit2("update:modelValue", newValue);
    }
    useRender(() => {
      const positionPercentage = convertToUnit(indexFromEnd.value ? 100 - props2.position : props2.position, "%");
      const {
        elevationClasses
      } = useElevation(computed(() => !disabled.value ? elevation.value : void 0));
      return createVNode("div", {
        "class": ["v-slider-thumb", {
          "v-slider-thumb--focused": props2.focused,
          "v-slider-thumb--pressed": props2.focused && mousePressed.value
        }, props2.class, rtlClasses.value],
        "style": [{
          "--v-slider-thumb-position": positionPercentage,
          "--v-slider-thumb-size": convertToUnit(thumbSize.value)
        }, props2.style],
        "role": "slider",
        "tabindex": disabled.value ? -1 : 0,
        "aria-valuemin": props2.min,
        "aria-valuemax": props2.max,
        "aria-valuenow": props2.modelValue,
        "aria-readonly": !!readonly2.value,
        "aria-orientation": direction.value,
        "onKeydown": !readonly2.value ? onKeydown : void 0
      }, [createVNode("div", {
        "class": ["v-slider-thumb__surface", textColorClasses.value, elevationClasses.value],
        "style": {
          ...textColorStyles.value
        }
      }, null), withDirectives(createVNode("div", {
        "class": ["v-slider-thumb__ripple", textColorClasses.value],
        "style": textColorStyles.value
      }, null), [[resolveDirective("ripple"), props2.ripple, null, {
        circle: true,
        center: true
      }]]), createVNode(VScaleTransition, {
        "origin": "bottom center"
      }, {
        default: () => {
          var _a2;
          return [withDirectives(createVNode("div", {
            "class": "v-slider-thumb__label-container"
          }, [createVNode("div", {
            "class": ["v-slider-thumb__label"]
          }, [createVNode("div", null, [((_a2 = slots["thumb-label"]) == null ? void 0 : _a2.call(slots, {
            modelValue: props2.modelValue
          })) ?? props2.modelValue.toFixed(step.value ? decimals.value : 1)])])]), [[vShow, thumbLabel.value && props2.focused || thumbLabel.value === "always"]])];
        }
      })]);
    });
    return {};
  }
});
const VSliderTrack$1 = "";
const makeVSliderTrackProps = propsFactory({
  start: {
    type: Number,
    required: true
  },
  stop: {
    type: Number,
    required: true
  },
  ...makeComponentProps()
}, "VSliderTrack");
const VSliderTrack = genericComponent()({
  name: "VSliderTrack",
  props: makeVSliderTrackProps(),
  emits: {},
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const slider = inject$1(VSliderSymbol);
    if (!slider)
      throw new Error("[Vuetify] v-slider-track must be inside v-slider or v-range-slider");
    const {
      color,
      parsedTicks,
      rounded,
      showTicks,
      tickSize,
      trackColor,
      trackFillColor,
      trackSize,
      vertical,
      min,
      max: max2,
      indexFromEnd
    } = slider;
    const {
      roundedClasses
    } = useRounded(rounded);
    const {
      backgroundColorClasses: trackFillColorClasses,
      backgroundColorStyles: trackFillColorStyles
    } = useBackgroundColor(trackFillColor);
    const {
      backgroundColorClasses: trackColorClasses,
      backgroundColorStyles: trackColorStyles
    } = useBackgroundColor(trackColor);
    const startDir = computed(() => `inset-${vertical.value ? "block" : "inline"}-${indexFromEnd.value ? "end" : "start"}`);
    const endDir = computed(() => vertical.value ? "height" : "width");
    const backgroundStyles = computed(() => {
      return {
        [startDir.value]: "0%",
        [endDir.value]: "100%"
      };
    });
    const trackFillWidth = computed(() => props2.stop - props2.start);
    const trackFillStyles = computed(() => {
      return {
        [startDir.value]: convertToUnit(props2.start, "%"),
        [endDir.value]: convertToUnit(trackFillWidth.value, "%")
      };
    });
    const computedTicks = computed(() => {
      if (!showTicks.value)
        return [];
      const ticks = vertical.value ? parsedTicks.value.slice().reverse() : parsedTicks.value;
      return ticks.map((tick, index2) => {
        var _a2;
        const directionValue = tick.value !== min.value && tick.value !== max2.value ? convertToUnit(tick.position, "%") : void 0;
        return createVNode("div", {
          "key": tick.value,
          "class": ["v-slider-track__tick", {
            "v-slider-track__tick--filled": tick.position >= props2.start && tick.position <= props2.stop,
            "v-slider-track__tick--first": tick.value === min.value,
            "v-slider-track__tick--last": tick.value === max2.value
          }],
          "style": {
            [startDir.value]: directionValue
          }
        }, [(tick.label || slots["tick-label"]) && createVNode("div", {
          "class": "v-slider-track__tick-label"
        }, [((_a2 = slots["tick-label"]) == null ? void 0 : _a2.call(slots, {
          tick,
          index: index2
        })) ?? tick.label])]);
      });
    });
    useRender(() => {
      return createVNode("div", {
        "class": ["v-slider-track", roundedClasses.value, props2.class],
        "style": [{
          "--v-slider-track-size": convertToUnit(trackSize.value),
          "--v-slider-tick-size": convertToUnit(tickSize.value)
        }, props2.style]
      }, [createVNode("div", {
        "class": ["v-slider-track__background", trackColorClasses.value, {
          "v-slider-track__background--opacity": !!color.value || !trackFillColor.value
        }],
        "style": {
          ...backgroundStyles.value,
          ...trackColorStyles.value
        }
      }, null), createVNode("div", {
        "class": ["v-slider-track__fill", trackFillColorClasses.value],
        "style": {
          ...trackFillStyles.value,
          ...trackFillColorStyles.value
        }
      }, null), showTicks.value && createVNode("div", {
        "class": ["v-slider-track__ticks", {
          "v-slider-track__ticks--always-show": showTicks.value === "always"
        }]
      }, [computedTicks.value])]);
    });
    return {};
  }
});
const makeVSliderProps = propsFactory({
  ...makeFocusProps(),
  ...makeSliderProps(),
  ...makeVInputProps(),
  modelValue: {
    type: [Number, String],
    default: 0
  }
}, "VSlider");
const VSlider = genericComponent()({
  name: "VSlider",
  props: makeVSliderProps(),
  emits: {
    "update:focused": (value) => true,
    "update:modelValue": (v2) => true,
    start: (value) => true,
    end: (value) => true
  },
  setup(props2, _ref) {
    let {
      slots,
      emit: emit2
    } = _ref;
    const thumbContainerRef = ref();
    const {
      rtlClasses
    } = useRtl();
    const steps = useSteps(props2);
    const model = useProxiedModel(props2, "modelValue", void 0, (value) => {
      return steps.roundValue(value == null ? steps.min.value : value);
    });
    const {
      min,
      max: max2,
      mousePressed,
      roundValue,
      onSliderMousedown,
      onSliderTouchstart,
      trackContainerRef,
      position,
      hasLabels,
      readonly: readonly2
    } = useSlider({
      props: props2,
      steps,
      onSliderStart: () => {
        emit2("start", model.value);
      },
      onSliderEnd: (_ref2) => {
        let {
          value
        } = _ref2;
        const roundedValue = roundValue(value);
        model.value = roundedValue;
        emit2("end", roundedValue);
      },
      onSliderMove: (_ref3) => {
        let {
          value
        } = _ref3;
        return model.value = roundValue(value);
      },
      getActiveThumb: () => {
        var _a2;
        return (_a2 = thumbContainerRef.value) == null ? void 0 : _a2.$el;
      }
    });
    const {
      isFocused,
      focus,
      blur
    } = useFocus(props2);
    const trackStop = computed(() => position(model.value));
    useRender(() => {
      const [inputProps, _2] = VInput.filterProps(props2);
      const hasPrepend = !!(props2.label || slots.label || slots.prepend);
      return createVNode(VInput, mergeProps({
        "class": ["v-slider", {
          "v-slider--has-labels": !!slots["tick-label"] || hasLabels.value,
          "v-slider--focused": isFocused.value,
          "v-slider--pressed": mousePressed.value,
          "v-slider--disabled": props2.disabled
        }, rtlClasses.value, props2.class],
        "style": props2.style
      }, inputProps, {
        "focused": isFocused.value
      }), {
        ...slots,
        prepend: hasPrepend ? (slotProps) => {
          var _a2, _b;
          return createVNode(Fragment, null, [((_a2 = slots.label) == null ? void 0 : _a2.call(slots, slotProps)) ?? (props2.label ? createVNode(VLabel, {
            "id": slotProps.id.value,
            "class": "v-slider__label",
            "text": props2.label
          }, null) : void 0), (_b = slots.prepend) == null ? void 0 : _b.call(slots, slotProps)]);
        } : void 0,
        default: (_ref4) => {
          let {
            id,
            messagesId
          } = _ref4;
          return createVNode("div", {
            "class": "v-slider__container",
            "onMousedown": !readonly2.value ? onSliderMousedown : void 0,
            "onTouchstartPassive": !readonly2.value ? onSliderTouchstart : void 0
          }, [createVNode("input", {
            "id": id.value,
            "name": props2.name || id.value,
            "disabled": !!props2.disabled,
            "readonly": !!props2.readonly,
            "tabindex": "-1",
            "value": model.value
          }, null), createVNode(VSliderTrack, {
            "ref": trackContainerRef,
            "start": 0,
            "stop": trackStop.value
          }, {
            "tick-label": slots["tick-label"]
          }), createVNode(VSliderThumb, {
            "ref": thumbContainerRef,
            "aria-describedby": messagesId.value,
            "focused": isFocused.value,
            "min": min.value,
            "max": max2.value,
            "modelValue": model.value,
            "onUpdate:modelValue": (v2) => model.value = v2,
            "position": trackStop.value,
            "elevation": props2.elevation,
            "onFocus": focus,
            "onBlur": blur
          }, {
            "thumb-label": slots["thumb-label"]
          })]);
        }
      });
    });
    return {};
  }
});
const makeVColorPickerPreviewProps = propsFactory({
  color: {
    type: Object
  },
  disabled: Boolean,
  hideAlpha: Boolean,
  ...makeComponentProps()
}, "VColorPickerPreview");
const VColorPickerPreview = defineComponent({
  name: "VColorPickerPreview",
  props: makeVColorPickerPreviewProps(),
  emits: {
    "update:color": (color) => true
  },
  setup(props2, _ref) {
    let {
      emit: emit2
    } = _ref;
    useRender(() => {
      var _a2, _b;
      return createVNode("div", {
        "class": ["v-color-picker-preview", {
          "v-color-picker-preview--hide-alpha": props2.hideAlpha
        }, props2.class],
        "style": props2.style
      }, [createVNode("div", {
        "class": "v-color-picker-preview__dot"
      }, [createVNode("div", {
        "style": {
          background: HSVtoCSS(props2.color ?? nullColor)
        }
      }, null)]), createVNode("div", {
        "class": "v-color-picker-preview__sliders"
      }, [createVNode(VSlider, {
        "class": "v-color-picker-preview__track v-color-picker-preview__hue",
        "modelValue": (_a2 = props2.color) == null ? void 0 : _a2.h,
        "onUpdate:modelValue": (h2) => emit2("update:color", {
          ...props2.color ?? nullColor,
          h: h2
        }),
        "step": 0,
        "min": 0,
        "max": 360,
        "disabled": props2.disabled,
        "thumbSize": 14,
        "trackSize": 8,
        "trackFillColor": "white",
        "hideDetails": true
      }, null), !props2.hideAlpha && createVNode(VSlider, {
        "class": "v-color-picker-preview__track v-color-picker-preview__alpha",
        "modelValue": ((_b = props2.color) == null ? void 0 : _b.a) ?? 1,
        "onUpdate:modelValue": (a) => emit2("update:color", {
          ...props2.color ?? nullColor,
          a
        }),
        "step": 1 / 256,
        "min": 0,
        "max": 1,
        "disabled": props2.disabled,
        "thumbSize": 14,
        "trackSize": 8,
        "trackFillColor": "white",
        "hideDetails": true
      }, null)])]);
    });
    return {};
  }
});
const VColorPickerSwatches$1 = "";
const red = Object.freeze({
  base: "#f44336",
  lighten5: "#ffebee",
  lighten4: "#ffcdd2",
  lighten3: "#ef9a9a",
  lighten2: "#e57373",
  lighten1: "#ef5350",
  darken1: "#e53935",
  darken2: "#d32f2f",
  darken3: "#c62828",
  darken4: "#b71c1c",
  accent1: "#ff8a80",
  accent2: "#ff5252",
  accent3: "#ff1744",
  accent4: "#d50000"
});
const pink = Object.freeze({
  base: "#e91e63",
  lighten5: "#fce4ec",
  lighten4: "#f8bbd0",
  lighten3: "#f48fb1",
  lighten2: "#f06292",
  lighten1: "#ec407a",
  darken1: "#d81b60",
  darken2: "#c2185b",
  darken3: "#ad1457",
  darken4: "#880e4f",
  accent1: "#ff80ab",
  accent2: "#ff4081",
  accent3: "#f50057",
  accent4: "#c51162"
});
const purple = Object.freeze({
  base: "#9c27b0",
  lighten5: "#f3e5f5",
  lighten4: "#e1bee7",
  lighten3: "#ce93d8",
  lighten2: "#ba68c8",
  lighten1: "#ab47bc",
  darken1: "#8e24aa",
  darken2: "#7b1fa2",
  darken3: "#6a1b9a",
  darken4: "#4a148c",
  accent1: "#ea80fc",
  accent2: "#e040fb",
  accent3: "#d500f9",
  accent4: "#aa00ff"
});
const deepPurple = Object.freeze({
  base: "#673ab7",
  lighten5: "#ede7f6",
  lighten4: "#d1c4e9",
  lighten3: "#b39ddb",
  lighten2: "#9575cd",
  lighten1: "#7e57c2",
  darken1: "#5e35b1",
  darken2: "#512da8",
  darken3: "#4527a0",
  darken4: "#311b92",
  accent1: "#b388ff",
  accent2: "#7c4dff",
  accent3: "#651fff",
  accent4: "#6200ea"
});
const indigo = Object.freeze({
  base: "#3f51b5",
  lighten5: "#e8eaf6",
  lighten4: "#c5cae9",
  lighten3: "#9fa8da",
  lighten2: "#7986cb",
  lighten1: "#5c6bc0",
  darken1: "#3949ab",
  darken2: "#303f9f",
  darken3: "#283593",
  darken4: "#1a237e",
  accent1: "#8c9eff",
  accent2: "#536dfe",
  accent3: "#3d5afe",
  accent4: "#304ffe"
});
const blue = Object.freeze({
  base: "#2196f3",
  lighten5: "#e3f2fd",
  lighten4: "#bbdefb",
  lighten3: "#90caf9",
  lighten2: "#64b5f6",
  lighten1: "#42a5f5",
  darken1: "#1e88e5",
  darken2: "#1976d2",
  darken3: "#1565c0",
  darken4: "#0d47a1",
  accent1: "#82b1ff",
  accent2: "#448aff",
  accent3: "#2979ff",
  accent4: "#2962ff"
});
const lightBlue = Object.freeze({
  base: "#03a9f4",
  lighten5: "#e1f5fe",
  lighten4: "#b3e5fc",
  lighten3: "#81d4fa",
  lighten2: "#4fc3f7",
  lighten1: "#29b6f6",
  darken1: "#039be5",
  darken2: "#0288d1",
  darken3: "#0277bd",
  darken4: "#01579b",
  accent1: "#80d8ff",
  accent2: "#40c4ff",
  accent3: "#00b0ff",
  accent4: "#0091ea"
});
const cyan = Object.freeze({
  base: "#00bcd4",
  lighten5: "#e0f7fa",
  lighten4: "#b2ebf2",
  lighten3: "#80deea",
  lighten2: "#4dd0e1",
  lighten1: "#26c6da",
  darken1: "#00acc1",
  darken2: "#0097a7",
  darken3: "#00838f",
  darken4: "#006064",
  accent1: "#84ffff",
  accent2: "#18ffff",
  accent3: "#00e5ff",
  accent4: "#00b8d4"
});
const teal = Object.freeze({
  base: "#009688",
  lighten5: "#e0f2f1",
  lighten4: "#b2dfdb",
  lighten3: "#80cbc4",
  lighten2: "#4db6ac",
  lighten1: "#26a69a",
  darken1: "#00897b",
  darken2: "#00796b",
  darken3: "#00695c",
  darken4: "#004d40",
  accent1: "#a7ffeb",
  accent2: "#64ffda",
  accent3: "#1de9b6",
  accent4: "#00bfa5"
});
const green = Object.freeze({
  base: "#4caf50",
  lighten5: "#e8f5e9",
  lighten4: "#c8e6c9",
  lighten3: "#a5d6a7",
  lighten2: "#81c784",
  lighten1: "#66bb6a",
  darken1: "#43a047",
  darken2: "#388e3c",
  darken3: "#2e7d32",
  darken4: "#1b5e20",
  accent1: "#b9f6ca",
  accent2: "#69f0ae",
  accent3: "#00e676",
  accent4: "#00c853"
});
const lightGreen = Object.freeze({
  base: "#8bc34a",
  lighten5: "#f1f8e9",
  lighten4: "#dcedc8",
  lighten3: "#c5e1a5",
  lighten2: "#aed581",
  lighten1: "#9ccc65",
  darken1: "#7cb342",
  darken2: "#689f38",
  darken3: "#558b2f",
  darken4: "#33691e",
  accent1: "#ccff90",
  accent2: "#b2ff59",
  accent3: "#76ff03",
  accent4: "#64dd17"
});
const lime = Object.freeze({
  base: "#cddc39",
  lighten5: "#f9fbe7",
  lighten4: "#f0f4c3",
  lighten3: "#e6ee9c",
  lighten2: "#dce775",
  lighten1: "#d4e157",
  darken1: "#c0ca33",
  darken2: "#afb42b",
  darken3: "#9e9d24",
  darken4: "#827717",
  accent1: "#f4ff81",
  accent2: "#eeff41",
  accent3: "#c6ff00",
  accent4: "#aeea00"
});
const yellow = Object.freeze({
  base: "#ffeb3b",
  lighten5: "#fffde7",
  lighten4: "#fff9c4",
  lighten3: "#fff59d",
  lighten2: "#fff176",
  lighten1: "#ffee58",
  darken1: "#fdd835",
  darken2: "#fbc02d",
  darken3: "#f9a825",
  darken4: "#f57f17",
  accent1: "#ffff8d",
  accent2: "#ffff00",
  accent3: "#ffea00",
  accent4: "#ffd600"
});
const amber = Object.freeze({
  base: "#ffc107",
  lighten5: "#fff8e1",
  lighten4: "#ffecb3",
  lighten3: "#ffe082",
  lighten2: "#ffd54f",
  lighten1: "#ffca28",
  darken1: "#ffb300",
  darken2: "#ffa000",
  darken3: "#ff8f00",
  darken4: "#ff6f00",
  accent1: "#ffe57f",
  accent2: "#ffd740",
  accent3: "#ffc400",
  accent4: "#ffab00"
});
const orange = Object.freeze({
  base: "#ff9800",
  lighten5: "#fff3e0",
  lighten4: "#ffe0b2",
  lighten3: "#ffcc80",
  lighten2: "#ffb74d",
  lighten1: "#ffa726",
  darken1: "#fb8c00",
  darken2: "#f57c00",
  darken3: "#ef6c00",
  darken4: "#e65100",
  accent1: "#ffd180",
  accent2: "#ffab40",
  accent3: "#ff9100",
  accent4: "#ff6d00"
});
const deepOrange = Object.freeze({
  base: "#ff5722",
  lighten5: "#fbe9e7",
  lighten4: "#ffccbc",
  lighten3: "#ffab91",
  lighten2: "#ff8a65",
  lighten1: "#ff7043",
  darken1: "#f4511e",
  darken2: "#e64a19",
  darken3: "#d84315",
  darken4: "#bf360c",
  accent1: "#ff9e80",
  accent2: "#ff6e40",
  accent3: "#ff3d00",
  accent4: "#dd2c00"
});
const brown = Object.freeze({
  base: "#795548",
  lighten5: "#efebe9",
  lighten4: "#d7ccc8",
  lighten3: "#bcaaa4",
  lighten2: "#a1887f",
  lighten1: "#8d6e63",
  darken1: "#6d4c41",
  darken2: "#5d4037",
  darken3: "#4e342e",
  darken4: "#3e2723"
});
const blueGrey = Object.freeze({
  base: "#607d8b",
  lighten5: "#eceff1",
  lighten4: "#cfd8dc",
  lighten3: "#b0bec5",
  lighten2: "#90a4ae",
  lighten1: "#78909c",
  darken1: "#546e7a",
  darken2: "#455a64",
  darken3: "#37474f",
  darken4: "#263238"
});
const grey = Object.freeze({
  base: "#9e9e9e",
  lighten5: "#fafafa",
  lighten4: "#f5f5f5",
  lighten3: "#eeeeee",
  lighten2: "#e0e0e0",
  lighten1: "#bdbdbd",
  darken1: "#757575",
  darken2: "#616161",
  darken3: "#424242",
  darken4: "#212121"
});
const shades = Object.freeze({
  black: "#000000",
  white: "#ffffff",
  transparent: "#ffffff00"
});
const colors = Object.freeze({
  red,
  pink,
  purple,
  deepPurple,
  indigo,
  blue,
  lightBlue,
  cyan,
  teal,
  green,
  lightGreen,
  lime,
  yellow,
  amber,
  orange,
  deepOrange,
  brown,
  blueGrey,
  grey,
  shades
});
const makeVColorPickerSwatchesProps = propsFactory({
  swatches: {
    type: Array,
    default: () => parseDefaultColors(colors)
  },
  disabled: Boolean,
  color: Object,
  maxHeight: [Number, String],
  ...makeComponentProps()
}, "VColorPickerSwatches");
function parseDefaultColors(colors2) {
  return Object.keys(colors2).map((key2) => {
    const color = colors2[key2];
    return color.base ? [color.base, color.darken4, color.darken3, color.darken2, color.darken1, color.lighten1, color.lighten2, color.lighten3, color.lighten4, color.lighten5] : [color.black, color.white, color.transparent];
  });
}
const VColorPickerSwatches = defineComponent({
  name: "VColorPickerSwatches",
  props: makeVColorPickerSwatchesProps(),
  emits: {
    "update:color": (color) => true
  },
  setup(props2, _ref) {
    let {
      emit: emit2
    } = _ref;
    useRender(() => createVNode("div", {
      "class": ["v-color-picker-swatches", props2.class],
      "style": [{
        maxHeight: convertToUnit(props2.maxHeight)
      }, props2.style]
    }, [createVNode("div", null, [props2.swatches.map((swatch) => createVNode("div", {
      "class": "v-color-picker-swatches__swatch"
    }, [swatch.map((color) => {
      const rgba2 = parseColor(color);
      const hsva = RGBtoHSV(rgba2);
      const background = RGBtoCSS(rgba2);
      return createVNode("div", {
        "class": "v-color-picker-swatches__color",
        "onClick": () => hsva && emit2("update:color", hsva)
      }, [createVNode("div", {
        "style": {
          background
        }
      }, [props2.color && deepEqual(props2.color, hsva) ? createVNode(VIcon, {
        "size": "x-small",
        "icon": "$success",
        "color": getContrast(color, "#FFFFFF") > 2 ? "white" : "black"
      }, null) : void 0])]);
    })]))])]));
    return {};
  }
});
const VSheet$1 = "";
const makeVSheetProps = propsFactory({
  color: String,
  ...makeBorderProps(),
  ...makeComponentProps(),
  ...makeDimensionProps(),
  ...makeElevationProps(),
  ...makeLocationProps(),
  ...makePositionProps(),
  ...makeRoundedProps(),
  ...makeTagProps(),
  ...makeThemeProps()
}, "VSheet");
const VSheet = genericComponent()({
  name: "VSheet",
  props: makeVSheetProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props2);
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props2, "color"));
    const {
      borderClasses
    } = useBorder(props2);
    const {
      dimensionStyles
    } = useDimension(props2);
    const {
      elevationClasses
    } = useElevation(props2);
    const {
      locationStyles
    } = useLocation(props2);
    const {
      positionClasses
    } = usePosition(props2);
    const {
      roundedClasses
    } = useRounded(props2);
    useRender(() => createVNode(props2.tag, {
      "class": ["v-sheet", themeClasses.value, backgroundColorClasses.value, borderClasses.value, elevationClasses.value, positionClasses.value, roundedClasses.value, props2.class],
      "style": [backgroundColorStyles.value, dimensionStyles.value, locationStyles.value, props2.style]
    }, slots));
    return {};
  }
});
const makeVColorPickerProps = propsFactory({
  canvasHeight: {
    type: [String, Number],
    default: 150
  },
  disabled: Boolean,
  dotSize: {
    type: [Number, String],
    default: 10
  },
  hideCanvas: Boolean,
  hideSliders: Boolean,
  hideInputs: Boolean,
  mode: {
    type: String,
    default: "rgba",
    validator: (v2) => Object.keys(modes).includes(v2)
  },
  modes: {
    type: Array,
    default: () => Object.keys(modes),
    validator: (v2) => Array.isArray(v2) && v2.every((m) => Object.keys(modes).includes(m))
  },
  showSwatches: Boolean,
  swatches: Array,
  swatchesMaxHeight: {
    type: [Number, String],
    default: 150
  },
  modelValue: {
    type: [Object, String]
  },
  ...omit(makeVSheetProps({
    width: 300
  }), ["height", "location", "minHeight", "maxHeight", "minWidth", "maxWidth"])
}, "VColorPicker");
const VColorPicker = defineComponent({
  name: "VColorPicker",
  props: makeVColorPickerProps(),
  emits: {
    "update:modelValue": (color) => true,
    "update:mode": (mode) => true
  },
  setup(props2) {
    const mode = useProxiedModel(props2, "mode");
    const lastPickedColor = ref(null);
    const currentColor = useProxiedModel(props2, "modelValue", void 0, (v2) => {
      if (v2 == null || v2 === "")
        return null;
      let c2;
      try {
        c2 = RGBtoHSV(parseColor(v2));
      } catch (err) {
        return null;
      }
      if (lastPickedColor.value) {
        c2 = {
          ...c2,
          h: lastPickedColor.value.h
        };
        lastPickedColor.value = null;
      }
      return c2;
    }, (v2) => {
      if (!v2)
        return null;
      return extractColor(v2, props2.modelValue);
    });
    const {
      rtlClasses
    } = useRtl();
    const updateColor = (hsva) => {
      currentColor.value = hsva;
      lastPickedColor.value = hsva;
    };
    onMounted(() => {
      if (!props2.modes.includes(mode.value))
        mode.value = props2.modes[0];
    });
    provideDefaults({
      VSlider: {
        color: void 0,
        trackColor: void 0,
        trackFillColor: void 0
      }
    });
    useRender(() => {
      const [sheetProps] = VSheet.filterProps(props2);
      return createVNode(VSheet, mergeProps({
        "rounded": props2.rounded,
        "elevation": props2.elevation,
        "theme": props2.theme,
        "class": ["v-color-picker", rtlClasses.value, props2.class],
        "style": [{
          "--v-color-picker-color-hsv": HSVtoCSS({
            ...currentColor.value ?? nullColor,
            a: 1
          })
        }, props2.style]
      }, sheetProps, {
        "maxWidth": props2.width
      }), {
        default: () => [!props2.hideCanvas && createVNode(VColorPickerCanvas, {
          "key": "canvas",
          "color": currentColor.value,
          "onUpdate:color": updateColor,
          "disabled": props2.disabled,
          "dotSize": props2.dotSize,
          "width": props2.width,
          "height": props2.canvasHeight
        }, null), (!props2.hideSliders || !props2.hideInputs) && createVNode("div", {
          "key": "controls",
          "class": "v-color-picker__controls"
        }, [!props2.hideSliders && createVNode(VColorPickerPreview, {
          "key": "preview",
          "color": currentColor.value,
          "onUpdate:color": updateColor,
          "hideAlpha": !mode.value.endsWith("a"),
          "disabled": props2.disabled
        }, null), !props2.hideInputs && createVNode(VColorPickerEdit, {
          "key": "edit",
          "modes": props2.modes,
          "mode": mode.value,
          "onUpdate:mode": (m) => mode.value = m,
          "color": currentColor.value,
          "onUpdate:color": updateColor,
          "disabled": props2.disabled
        }, null)]), props2.showSwatches && createVNode(VColorPickerSwatches, {
          "key": "swatches",
          "color": currentColor.value,
          "onUpdate:color": updateColor,
          "maxHeight": props2.swatchesMaxHeight,
          "swatches": props2.swatches,
          "disabled": props2.disabled
        }, null)]
      });
    });
    return {};
  }
});
const VCombobox$1 = "";
function highlightResult(text, matches2, length) {
  if (matches2 == null)
    return text;
  if (Array.isArray(matches2))
    throw new Error("Multiple matches is not implemented");
  return typeof matches2 === "number" && ~matches2 ? createVNode(Fragment, null, [createVNode("span", {
    "class": "v-combobox__unmask"
  }, [text.substr(0, matches2)]), createVNode("span", {
    "class": "v-combobox__mask"
  }, [text.substr(matches2, length)]), createVNode("span", {
    "class": "v-combobox__unmask"
  }, [text.substr(matches2 + length)])]) : text;
}
const makeVComboboxProps = propsFactory({
  autoSelectFirst: {
    type: [Boolean, String]
  },
  delimiters: Array,
  ...makeFilterProps({
    filterKeys: ["title"]
  }),
  ...makeSelectProps({
    hideNoData: true,
    returnObject: true
  }),
  ...omit(makeVTextFieldProps({
    modelValue: null,
    role: "combobox"
  }), ["validationValue", "dirty", "appendInnerIcon"]),
  ...makeTransitionProps({
    transition: false
  })
}, "VCombobox");
const VCombobox = genericComponent()({
  name: "VCombobox",
  props: makeVComboboxProps(),
  emits: {
    "update:focused": (focused) => true,
    "update:modelValue": (val) => true,
    "update:search": (val) => true,
    "update:menu": (val) => true
  },
  setup(props2, _ref) {
    var _a2;
    let {
      emit: emit2,
      slots
    } = _ref;
    const {
      t
    } = useLocale();
    const vTextFieldRef = ref();
    const isFocused = shallowRef(false);
    const isPristine = shallowRef(true);
    const listHasFocus = shallowRef(false);
    const vMenuRef = ref();
    const vVirtualScrollRef = ref();
    const _menu = useProxiedModel(props2, "menu");
    const menu = computed({
      get: () => _menu.value,
      set: (v2) => {
        var _a3;
        if (_menu.value && !v2 && ((_a3 = vMenuRef.value) == null ? void 0 : _a3.ΨopenChildren))
          return;
        _menu.value = v2;
      }
    });
    const selectionIndex = shallowRef(-1);
    let cleared = false;
    const color = computed(() => {
      var _a3;
      return (_a3 = vTextFieldRef.value) == null ? void 0 : _a3.color;
    });
    const label = computed(() => menu.value ? props2.closeText : props2.openText);
    const {
      items,
      transformIn,
      transformOut
    } = useItems(props2);
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(color);
    const model = useProxiedModel(props2, "modelValue", [], (v2) => transformIn(wrapInArray(v2)), (v2) => {
      const transformed = transformOut(v2);
      return props2.multiple ? transformed : transformed[0] ?? null;
    });
    const form = useForm();
    const _search = shallowRef(!props2.multiple ? ((_a2 = model.value[0]) == null ? void 0 : _a2.title) ?? "" : "");
    const search = computed({
      get: () => {
        return _search.value;
      },
      set: (val) => {
        var _a3;
        _search.value = val ?? "";
        if (!props2.multiple) {
          model.value = [transformItem$1(props2, val)];
        }
        if (val && props2.multiple && ((_a3 = props2.delimiters) == null ? void 0 : _a3.length)) {
          const values = val.split(new RegExp(`(?:${props2.delimiters.join("|")})+`));
          if (values.length > 1) {
            values.forEach((v2) => {
              v2 = v2.trim();
              if (v2)
                select(transformItem$1(props2, v2));
            });
            _search.value = "";
          }
        }
        if (!val)
          selectionIndex.value = -1;
        isPristine.value = !val;
      }
    });
    watch(_search, (value) => {
      if (cleared) {
        nextTick(() => cleared = false);
      } else if (isFocused.value && !menu.value) {
        menu.value = true;
      }
      emit2("update:search", value);
    });
    watch(model, (value) => {
      var _a3;
      if (!props2.multiple) {
        _search.value = ((_a3 = value[0]) == null ? void 0 : _a3.title) ?? "";
      }
    });
    const {
      filteredItems,
      getMatches
    } = useFilter(props2, items, () => isPristine.value ? "" : search.value);
    const displayItems = computed(() => {
      if (props2.hideSelected) {
        return filteredItems.value.filter((filteredItem) => !model.value.some((s) => s.value === filteredItem.value));
      }
      return filteredItems.value;
    });
    const selectedValues = computed(() => model.value.map((selection) => selection.value));
    const highlightFirst = computed(() => {
      var _a3;
      const selectFirst = props2.autoSelectFirst === true || props2.autoSelectFirst === "exact" && search.value === ((_a3 = displayItems.value[0]) == null ? void 0 : _a3.title);
      return selectFirst && displayItems.value.length > 0 && !isPristine.value && !listHasFocus.value;
    });
    const menuDisabled = computed(() => props2.hideNoData && !items.value.length || props2.readonly || (form == null ? void 0 : form.isReadonly.value));
    const listRef = ref();
    const {
      onListScroll,
      onListKeydown
    } = useScrolling(listRef, vTextFieldRef);
    function onClear(e) {
      cleared = true;
      if (props2.openOnClear) {
        menu.value = true;
      }
    }
    function onMousedownControl() {
      if (menuDisabled.value)
        return;
      menu.value = true;
    }
    function onMousedownMenuIcon(e) {
      if (menuDisabled.value)
        return;
      if (isFocused.value) {
        e.preventDefault();
        e.stopPropagation();
      }
      menu.value = !menu.value;
    }
    function onKeydown(e) {
      var _a3;
      if (isComposingIgnoreKey(e) || props2.readonly || (form == null ? void 0 : form.isReadonly.value))
        return;
      const selectionStart = vTextFieldRef.value.selectionStart;
      const length = model.value.length;
      if (selectionIndex.value > -1 || ["Enter", "ArrowDown", "ArrowUp"].includes(e.key)) {
        e.preventDefault();
      }
      if (["Enter", "ArrowDown"].includes(e.key)) {
        menu.value = true;
      }
      if (["Escape"].includes(e.key)) {
        menu.value = false;
      }
      if (["Enter", "Escape", "Tab"].includes(e.key)) {
        if (highlightFirst.value && ["Enter", "Tab"].includes(e.key)) {
          select(filteredItems.value[0]);
        }
        isPristine.value = true;
      }
      if (e.key === "ArrowDown" && highlightFirst.value) {
        (_a3 = listRef.value) == null ? void 0 : _a3.focus("next");
      }
      if (!props2.multiple)
        return;
      if (["Backspace", "Delete"].includes(e.key)) {
        if (selectionIndex.value < 0) {
          if (e.key === "Backspace" && !search.value) {
            selectionIndex.value = length - 1;
          }
          return;
        }
        const originalSelectionIndex = selectionIndex.value;
        const selectedItem = model.value[selectionIndex.value];
        if (selectedItem && !selectedItem.props.disabled)
          select(selectedItem);
        selectionIndex.value = originalSelectionIndex >= length - 1 ? length - 2 : originalSelectionIndex;
      }
      if (e.key === "ArrowLeft") {
        if (selectionIndex.value < 0 && selectionStart > 0)
          return;
        const prev = selectionIndex.value > -1 ? selectionIndex.value - 1 : length - 1;
        if (model.value[prev]) {
          selectionIndex.value = prev;
        } else {
          selectionIndex.value = -1;
          vTextFieldRef.value.setSelectionRange(search.value.length, search.value.length);
        }
      }
      if (e.key === "ArrowRight") {
        if (selectionIndex.value < 0)
          return;
        const next = selectionIndex.value + 1;
        if (model.value[next]) {
          selectionIndex.value = next;
        } else {
          selectionIndex.value = -1;
          vTextFieldRef.value.setSelectionRange(0, 0);
        }
      }
      if (e.key === "Enter" && search.value) {
        select(transformItem$1(props2, search.value));
        search.value = "";
      }
    }
    function onAfterLeave() {
      var _a3;
      if (isFocused.value) {
        isPristine.value = true;
        (_a3 = vTextFieldRef.value) == null ? void 0 : _a3.focus();
      }
    }
    function select(item) {
      if (props2.multiple) {
        const index2 = model.value.findIndex((selection) => props2.valueComparator(selection.value, item.value));
        if (index2 === -1) {
          model.value = [...model.value, item];
        } else {
          const value = [...model.value];
          value.splice(index2, 1);
          model.value = value;
        }
        search.value = "";
      } else {
        model.value = [item];
        _search.value = item.title;
        nextTick(() => {
          menu.value = false;
          isPristine.value = true;
        });
      }
    }
    function onFocusin(e) {
      isFocused.value = true;
      setTimeout(() => {
        listHasFocus.value = true;
      });
    }
    function onFocusout(e) {
      listHasFocus.value = false;
    }
    function onUpdateModelValue(v2) {
      if (v2 == null || v2 === "" && !props2.multiple)
        model.value = [];
    }
    watch(filteredItems, (val) => {
      if (!val.length && props2.hideNoData)
        menu.value = false;
    });
    watch(isFocused, (val, oldVal) => {
      if (val || val === oldVal)
        return;
      selectionIndex.value = -1;
      menu.value = false;
      if (highlightFirst.value && !listHasFocus.value && !model.value.some((_ref2) => {
        let {
          value
        } = _ref2;
        return value === displayItems.value[0].value;
      })) {
        select(displayItems.value[0]);
      } else if (props2.multiple && search.value) {
        model.value = [...model.value, transformItem$1(props2, search.value)];
        search.value = "";
      }
    });
    watch(menu, () => {
      if (!props2.hideSelected && menu.value && model.value.length) {
        const index2 = displayItems.value.findIndex((item) => model.value.some((s) => props2.valueComparator(s.value, item.value)));
        IN_BROWSER && window.requestAnimationFrame(() => {
          var _a3;
          index2 >= 0 && ((_a3 = vVirtualScrollRef.value) == null ? void 0 : _a3.scrollToIndex(index2));
        });
      }
    });
    useRender(() => {
      const hasChips = !!(props2.chips || slots.chip);
      const hasList = !!(!props2.hideNoData || displayItems.value.length || slots["prepend-item"] || slots["append-item"] || slots["no-data"]);
      const isDirty = model.value.length > 0;
      const [textFieldProps] = VTextField.filterProps(props2);
      return createVNode(VTextField, mergeProps({
        "ref": vTextFieldRef
      }, textFieldProps, {
        "modelValue": search.value,
        "onUpdate:modelValue": [($event) => search.value = $event, onUpdateModelValue],
        "focused": isFocused.value,
        "onUpdate:focused": ($event) => isFocused.value = $event,
        "validationValue": model.externalValue,
        "counterValue": props2.multiple ? model.value.length : search.value.length,
        "dirty": isDirty,
        "class": ["v-combobox", {
          "v-combobox--active-menu": menu.value,
          "v-combobox--chips": !!props2.chips,
          "v-combobox--selection-slot": !!slots.selection,
          "v-combobox--selecting-index": selectionIndex.value > -1,
          [`v-combobox--${props2.multiple ? "multiple" : "single"}`]: true
        }, props2.class],
        "style": props2.style,
        "readonly": props2.readonly,
        "placeholder": isDirty ? void 0 : props2.placeholder,
        "onClick:clear": onClear,
        "onMousedown:control": onMousedownControl,
        "onKeydown": onKeydown
      }), {
        ...slots,
        default: () => createVNode(Fragment, null, [createVNode(VMenu, mergeProps({
          "ref": vMenuRef,
          "modelValue": menu.value,
          "onUpdate:modelValue": ($event) => menu.value = $event,
          "activator": "parent",
          "contentClass": "v-combobox__content",
          "disabled": menuDisabled.value,
          "eager": props2.eager,
          "maxHeight": 310,
          "openOnClick": false,
          "closeOnContentClick": false,
          "transition": props2.transition,
          "onAfterLeave": onAfterLeave
        }, props2.menuProps), {
          default: () => [hasList && createVNode(VList, {
            "ref": listRef,
            "selected": selectedValues.value,
            "selectStrategy": props2.multiple ? "independent" : "single-independent",
            "onMousedown": (e) => e.preventDefault(),
            "onKeydown": onListKeydown,
            "onFocusin": onFocusin,
            "onFocusout": onFocusout,
            "onScrollPassive": onListScroll,
            "tabindex": "-1",
            "color": props2.itemColor ?? props2.color
          }, {
            default: () => {
              var _a3, _b, _c;
              return [(_a3 = slots["prepend-item"]) == null ? void 0 : _a3.call(slots), !displayItems.value.length && !props2.hideNoData && (((_b = slots["no-data"]) == null ? void 0 : _b.call(slots)) ?? createVNode(VListItem, {
                "title": t(props2.noDataText)
              }, null)), createVNode(VVirtualScroll, {
                "ref": vVirtualScrollRef,
                "renderless": true,
                "items": displayItems.value
              }, {
                default: (_ref3) => {
                  var _a4;
                  let {
                    item,
                    index: index2,
                    itemRef
                  } = _ref3;
                  const itemProps = mergeProps(item.props, {
                    ref: itemRef,
                    key: index2,
                    active: highlightFirst.value && index2 === 0 ? true : void 0,
                    onClick: () => select(item)
                  });
                  return ((_a4 = slots.item) == null ? void 0 : _a4.call(slots, {
                    item,
                    index: index2,
                    props: itemProps
                  })) ?? createVNode(VListItem, itemProps, {
                    prepend: (_ref4) => {
                      let {
                        isSelected
                      } = _ref4;
                      return createVNode(Fragment, null, [props2.multiple && !props2.hideSelected ? createVNode(VCheckboxBtn, {
                        "key": item.value,
                        "modelValue": isSelected,
                        "ripple": false,
                        "tabindex": "-1"
                      }, null) : void 0, item.props.prependIcon && createVNode(VIcon, {
                        "icon": item.props.prependIcon
                      }, null)]);
                    },
                    title: () => {
                      var _a5, _b2;
                      return isPristine.value ? item.title : highlightResult(item.title, (_a5 = getMatches(item)) == null ? void 0 : _a5.title, ((_b2 = search.value) == null ? void 0 : _b2.length) ?? 0);
                    }
                  });
                }
              }), (_c = slots["append-item"]) == null ? void 0 : _c.call(slots)];
            }
          })]
        }), model.value.map((item, index2) => {
          var _a3;
          function onChipClose(e) {
            e.stopPropagation();
            e.preventDefault();
            select(item);
          }
          const slotProps = {
            "onClick:close": onChipClose,
            onMousedown(e) {
              e.preventDefault();
              e.stopPropagation();
            },
            modelValue: true,
            "onUpdate:modelValue": void 0
          };
          return createVNode("div", {
            "key": item.value,
            "class": ["v-combobox__selection", index2 === selectionIndex.value && ["v-combobox__selection--selected", textColorClasses.value]],
            "style": index2 === selectionIndex.value ? textColorStyles.value : {}
          }, [hasChips ? !slots.chip ? createVNode(VChip, mergeProps({
            "key": "chip",
            "closable": props2.closableChips,
            "size": "small",
            "text": item.title,
            "disabled": item.props.disabled
          }, slotProps), null) : createVNode(VDefaultsProvider, {
            "key": "chip-defaults",
            "defaults": {
              VChip: {
                closable: props2.closableChips,
                size: "small",
                text: item.title
              }
            }
          }, {
            default: () => {
              var _a4;
              return [(_a4 = slots.chip) == null ? void 0 : _a4.call(slots, {
                item,
                index: index2,
                props: slotProps
              })];
            }
          }) : ((_a3 = slots.selection) == null ? void 0 : _a3.call(slots, {
            item,
            index: index2
          })) ?? createVNode("span", {
            "class": "v-combobox__selection-text"
          }, [item.title, props2.multiple && index2 < model.value.length - 1 && createVNode("span", {
            "class": "v-combobox__selection-comma"
          }, [createTextVNode(",")])])]);
        })]),
        "append-inner": function() {
          var _a3;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return createVNode(Fragment, null, [(_a3 = slots["append-inner"]) == null ? void 0 : _a3.call(slots, ...args), (!props2.hideNoData || props2.items.length) && props2.menuIcon ? createVNode(VIcon, {
            "class": "v-combobox__menu-icon",
            "icon": props2.menuIcon,
            "onMousedown": onMousedownMenuIcon,
            "onClick": noop,
            "aria-label": t(label.value),
            "title": t(label.value)
          }, null) : void 0]);
        }
      });
    });
    return forwardRefs({
      isFocused,
      isPristine,
      menu,
      search,
      selectionIndex,
      filteredItems,
      select
    }, vTextFieldRef);
  }
});
const VDialog$1 = "";
const makeVDialogProps = propsFactory({
  fullscreen: Boolean,
  retainFocus: {
    type: Boolean,
    default: true
  },
  scrollable: Boolean,
  ...makeVOverlayProps({
    origin: "center center",
    scrollStrategy: "block",
    transition: {
      component: VDialogTransition
    },
    zIndex: 2400
  })
}, "VDialog");
const VDialog = genericComponent()({
  name: "VDialog",
  props: makeVDialogProps(),
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const isActive = useProxiedModel(props2, "modelValue");
    const {
      scopeId
    } = useScopeId();
    const overlay = ref();
    function onFocusin(e) {
      var _a2, _b;
      const before = e.relatedTarget;
      const after = e.target;
      if (before !== after && ((_a2 = overlay.value) == null ? void 0 : _a2.contentEl) && // We're the topmost dialog
      ((_b = overlay.value) == null ? void 0 : _b.globalTop) && // It isn't the document or the dialog body
      ![document, overlay.value.contentEl].includes(after) && // It isn't inside the dialog body
      !overlay.value.contentEl.contains(after)) {
        const focusable = focusableChildren(overlay.value.contentEl);
        if (!focusable.length)
          return;
        const firstElement = focusable[0];
        const lastElement = focusable[focusable.length - 1];
        if (before === firstElement) {
          lastElement.focus();
        } else {
          firstElement.focus();
        }
      }
    }
    if (IN_BROWSER) {
      watch(() => isActive.value && props2.retainFocus, (val) => {
        val ? document.addEventListener("focusin", onFocusin) : document.removeEventListener("focusin", onFocusin);
      }, {
        immediate: true
      });
    }
    watch(isActive, async (val) => {
      var _a2, _b;
      await nextTick();
      if (val) {
        (_a2 = overlay.value.contentEl) == null ? void 0 : _a2.focus({
          preventScroll: true
        });
      } else {
        (_b = overlay.value.activatorEl) == null ? void 0 : _b.focus({
          preventScroll: true
        });
      }
    });
    const activatorProps = computed(() => mergeProps({
      "aria-haspopup": "dialog",
      "aria-expanded": String(isActive.value)
    }, props2.activatorProps));
    useRender(() => {
      const [overlayProps] = VOverlay.filterProps(props2);
      return createVNode(VOverlay, mergeProps({
        "ref": overlay,
        "class": ["v-dialog", {
          "v-dialog--fullscreen": props2.fullscreen,
          "v-dialog--scrollable": props2.scrollable
        }, props2.class],
        "style": props2.style
      }, overlayProps, {
        "modelValue": isActive.value,
        "onUpdate:modelValue": ($event) => isActive.value = $event,
        "aria-modal": "true",
        "activatorProps": activatorProps.value,
        "role": "dialog"
      }, scopeId), {
        activator: slots.activator,
        default: function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return createVNode(VDefaultsProvider, {
            "root": "VDialog"
          }, {
            default: () => {
              var _a2;
              return [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, ...args)];
            }
          });
        }
      });
    });
    return forwardRefs({}, overlay);
  }
});
const VExpansionPanel$1 = "";
const VExpansionPanelSymbol = Symbol.for("vuetify:v-expansion-panel");
const allowedVariants = ["default", "accordion", "inset", "popout"];
const makeVExpansionPanelsProps = propsFactory({
  color: String,
  variant: {
    type: String,
    default: "default",
    validator: (v2) => allowedVariants.includes(v2)
  },
  readonly: Boolean,
  ...makeComponentProps(),
  ...makeGroupProps(),
  ...makeTagProps(),
  ...makeThemeProps()
}, "VExpansionPanels");
const VExpansionPanels = genericComponent()({
  name: "VExpansionPanels",
  props: makeVExpansionPanelsProps(),
  emits: {
    "update:modelValue": (val) => true
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    useGroup(props2, VExpansionPanelSymbol);
    const {
      themeClasses
    } = provideTheme(props2);
    const variantClass = computed(() => props2.variant && `v-expansion-panels--variant-${props2.variant}`);
    provideDefaults({
      VExpansionPanel: {
        color: toRef(props2, "color")
      },
      VExpansionPanelTitle: {
        readonly: toRef(props2, "readonly")
      }
    });
    useRender(() => createVNode(props2.tag, {
      "class": ["v-expansion-panels", themeClasses.value, variantClass.value, props2.class],
      "style": props2.style
    }, slots));
    return {};
  }
});
const makeVExpansionPanelTextProps = propsFactory({
  ...makeComponentProps(),
  ...makeLazyProps()
}, "VExpansionPanelText");
const VExpansionPanelText = genericComponent()({
  name: "VExpansionPanelText",
  props: makeVExpansionPanelTextProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const expansionPanel = inject$1(VExpansionPanelSymbol);
    if (!expansionPanel)
      throw new Error("[Vuetify] v-expansion-panel-text needs to be placed inside v-expansion-panel");
    const {
      hasContent,
      onAfterLeave
    } = useLazy(props2, expansionPanel.isSelected);
    useRender(() => createVNode(VExpandTransition, {
      "onAfterLeave": onAfterLeave
    }, {
      default: () => {
        var _a2;
        return [withDirectives(createVNode("div", {
          "class": ["v-expansion-panel-text", props2.class],
          "style": props2.style
        }, [slots.default && hasContent.value && createVNode("div", {
          "class": "v-expansion-panel-text__wrapper"
        }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)])]), [[vShow, expansionPanel.isSelected.value]])];
      }
    }));
    return {};
  }
});
const makeVExpansionPanelTitleProps = propsFactory({
  color: String,
  expandIcon: {
    type: IconValue,
    default: "$expand"
  },
  collapseIcon: {
    type: IconValue,
    default: "$collapse"
  },
  hideActions: Boolean,
  ripple: {
    type: [Boolean, Object],
    default: false
  },
  readonly: Boolean,
  ...makeComponentProps()
}, "VExpansionPanelTitle");
const VExpansionPanelTitle = genericComponent()({
  name: "VExpansionPanelTitle",
  directives: {
    Ripple
  },
  props: makeVExpansionPanelTitleProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const expansionPanel = inject$1(VExpansionPanelSymbol);
    if (!expansionPanel)
      throw new Error("[Vuetify] v-expansion-panel-title needs to be placed inside v-expansion-panel");
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(props2, "color");
    const slotProps = computed(() => ({
      collapseIcon: props2.collapseIcon,
      disabled: expansionPanel.disabled.value,
      expanded: expansionPanel.isSelected.value,
      expandIcon: props2.expandIcon,
      readonly: props2.readonly
    }));
    useRender(() => {
      var _a2;
      return withDirectives(createVNode("button", {
        "class": ["v-expansion-panel-title", {
          "v-expansion-panel-title--active": expansionPanel.isSelected.value
        }, backgroundColorClasses.value, props2.class],
        "style": [backgroundColorStyles.value, props2.style],
        "type": "button",
        "tabindex": expansionPanel.disabled.value ? -1 : void 0,
        "disabled": expansionPanel.disabled.value,
        "aria-expanded": expansionPanel.isSelected.value,
        "onClick": !props2.readonly ? expansionPanel.toggle : void 0
      }, [createVNode("span", {
        "class": "v-expansion-panel-title__overlay"
      }, null), (_a2 = slots.default) == null ? void 0 : _a2.call(slots, slotProps.value), !props2.hideActions && createVNode("span", {
        "class": "v-expansion-panel-title__icon"
      }, [slots.actions ? slots.actions(slotProps.value) : createVNode(VIcon, {
        "icon": expansionPanel.isSelected.value ? props2.collapseIcon : props2.expandIcon
      }, null)])]), [[resolveDirective("ripple"), props2.ripple]]);
    });
    return {};
  }
});
const makeVExpansionPanelProps = propsFactory({
  title: String,
  text: String,
  bgColor: String,
  ...makeComponentProps(),
  ...makeElevationProps(),
  ...makeGroupItemProps(),
  ...makeLazyProps(),
  ...makeRoundedProps(),
  ...makeTagProps(),
  ...makeVExpansionPanelTitleProps()
}, "VExpansionPanel");
const VExpansionPanel = genericComponent()({
  name: "VExpansionPanel",
  props: makeVExpansionPanelProps(),
  emits: {
    "group:selected": (val) => true
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const groupItem = useGroupItem(props2, VExpansionPanelSymbol);
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(props2, "bgColor");
    const {
      elevationClasses
    } = useElevation(props2);
    const {
      roundedClasses
    } = useRounded(props2);
    const isDisabled = computed(() => (groupItem == null ? void 0 : groupItem.disabled.value) || props2.disabled);
    const selectedIndices = computed(() => groupItem.group.items.value.reduce((arr, item, index2) => {
      if (groupItem.group.selected.value.includes(item.id))
        arr.push(index2);
      return arr;
    }, []));
    const isBeforeSelected = computed(() => {
      const index2 = groupItem.group.items.value.findIndex((item) => item.id === groupItem.id);
      return !groupItem.isSelected.value && selectedIndices.value.some((selectedIndex) => selectedIndex - index2 === 1);
    });
    const isAfterSelected = computed(() => {
      const index2 = groupItem.group.items.value.findIndex((item) => item.id === groupItem.id);
      return !groupItem.isSelected.value && selectedIndices.value.some((selectedIndex) => selectedIndex - index2 === -1);
    });
    provide(VExpansionPanelSymbol, groupItem);
    provideDefaults({
      VExpansionPanelText: {
        eager: toRef(props2, "eager")
      }
    });
    useRender(() => {
      const hasText = !!(slots.text || props2.text);
      const hasTitle = !!(slots.title || props2.title);
      return createVNode(props2.tag, {
        "class": ["v-expansion-panel", {
          "v-expansion-panel--active": groupItem.isSelected.value,
          "v-expansion-panel--before-active": isBeforeSelected.value,
          "v-expansion-panel--after-active": isAfterSelected.value,
          "v-expansion-panel--disabled": isDisabled.value
        }, roundedClasses.value, backgroundColorClasses.value, props2.class],
        "style": [backgroundColorStyles.value, props2.style]
      }, {
        default: () => {
          var _a2;
          return [createVNode("div", {
            "class": ["v-expansion-panel__shadow", ...elevationClasses.value]
          }, null), hasTitle && createVNode(VExpansionPanelTitle, {
            "key": "title",
            "collapseIcon": props2.collapseIcon,
            "color": props2.color,
            "expandIcon": props2.expandIcon,
            "hideActions": props2.hideActions,
            "ripple": props2.ripple
          }, {
            default: () => [slots.title ? slots.title() : props2.title]
          }), hasText && createVNode(VExpansionPanelText, {
            "key": "text"
          }, {
            default: () => [slots.text ? slots.text() : props2.text]
          }), (_a2 = slots.default) == null ? void 0 : _a2.call(slots)];
        }
      });
    });
    return {};
  }
});
const VFileInput$1 = "";
const makeVFileInputProps = propsFactory({
  chips: Boolean,
  counter: Boolean,
  counterSizeString: {
    type: String,
    default: "$vuetify.fileInput.counterSize"
  },
  counterString: {
    type: String,
    default: "$vuetify.fileInput.counter"
  },
  multiple: Boolean,
  showSize: {
    type: [Boolean, Number],
    default: false,
    validator: (v2) => {
      return typeof v2 === "boolean" || [1e3, 1024].includes(v2);
    }
  },
  ...makeVInputProps({
    prependIcon: "$file"
  }),
  modelValue: {
    type: Array,
    default: () => [],
    validator: (val) => {
      return wrapInArray(val).every((v2) => v2 != null && typeof v2 === "object");
    }
  },
  ...makeVFieldProps({
    clearable: true
  })
}, "VFileInput");
const VFileInput = genericComponent()({
  name: "VFileInput",
  inheritAttrs: false,
  props: makeVFileInputProps(),
  emits: {
    "click:control": (e) => true,
    "mousedown:control": (e) => true,
    "update:focused": (focused) => true,
    "update:modelValue": (files) => true
  },
  setup(props2, _ref) {
    let {
      attrs,
      emit: emit2,
      slots
    } = _ref;
    const {
      t
    } = useLocale();
    const model = useProxiedModel(props2, "modelValue");
    const {
      isFocused,
      focus,
      blur
    } = useFocus(props2);
    const base = computed(() => typeof props2.showSize !== "boolean" ? props2.showSize : void 0);
    const totalBytes = computed(() => (model.value ?? []).reduce((bytes, _ref2) => {
      let {
        size: size2 = 0
      } = _ref2;
      return bytes + size2;
    }, 0));
    const totalBytesReadable = computed(() => humanReadableFileSize(totalBytes.value, base.value));
    const fileNames = computed(() => (model.value ?? []).map((file) => {
      const {
        name = "",
        size: size2 = 0
      } = file;
      return !props2.showSize ? name : `${name} (${humanReadableFileSize(size2, base.value)})`;
    }));
    const counterValue = computed(() => {
      var _a2;
      const fileCount = ((_a2 = model.value) == null ? void 0 : _a2.length) ?? 0;
      if (props2.showSize)
        return t(props2.counterSizeString, fileCount, totalBytesReadable.value);
      else
        return t(props2.counterString, fileCount);
    });
    const vInputRef = ref();
    const vFieldRef = ref();
    const inputRef = ref();
    const isActive = computed(() => isFocused.value || props2.active);
    const isPlainOrUnderlined = computed(() => ["plain", "underlined"].includes(props2.variant));
    function onFocus() {
      var _a2;
      if (inputRef.value !== document.activeElement) {
        (_a2 = inputRef.value) == null ? void 0 : _a2.focus();
      }
      if (!isFocused.value)
        focus();
    }
    function onClickPrepend(e) {
      onControlClick(e);
    }
    function onControlMousedown(e) {
      emit2("mousedown:control", e);
    }
    function onControlClick(e) {
      var _a2;
      (_a2 = inputRef.value) == null ? void 0 : _a2.click();
      emit2("click:control", e);
    }
    function onClear(e) {
      e.stopPropagation();
      onFocus();
      nextTick(() => {
        model.value = [];
        callEvent(props2["onClick:clear"], e);
      });
    }
    watch(model, (newValue) => {
      const hasModelReset = !Array.isArray(newValue) || !newValue.length;
      if (hasModelReset && inputRef.value) {
        inputRef.value.value = "";
      }
    });
    useRender(() => {
      const hasCounter = !!(slots.counter || props2.counter);
      const hasDetails = !!(hasCounter || slots.details);
      const [rootAttrs, inputAttrs] = filterInputAttrs(attrs);
      const [{
        modelValue: _2,
        ...inputProps
      }] = VInput.filterProps(props2);
      const [fieldProps] = filterFieldProps(props2);
      return createVNode(VInput, mergeProps({
        "ref": vInputRef,
        "modelValue": model.value,
        "onUpdate:modelValue": ($event) => model.value = $event,
        "class": ["v-file-input", {
          "v-text-field--plain-underlined": isPlainOrUnderlined.value
        }, props2.class],
        "style": props2.style,
        "onClick:prepend": onClickPrepend
      }, rootAttrs, inputProps, {
        "centerAffix": !isPlainOrUnderlined.value,
        "focused": isFocused.value
      }), {
        ...slots,
        default: (_ref3) => {
          let {
            id,
            isDisabled,
            isDirty,
            isReadonly: isReadonly2,
            isValid: isValid2
          } = _ref3;
          return createVNode(VField, mergeProps({
            "ref": vFieldRef,
            "prepend-icon": props2.prependIcon,
            "onMousedown": onControlMousedown,
            "onClick": onControlClick,
            "onClick:clear": onClear,
            "onClick:prependInner": props2["onClick:prependInner"],
            "onClick:appendInner": props2["onClick:appendInner"]
          }, fieldProps, {
            "id": id.value,
            "active": isActive.value || isDirty.value,
            "dirty": isDirty.value,
            "disabled": isDisabled.value,
            "focused": isFocused.value,
            "error": isValid2.value === false
          }), {
            ...slots,
            default: (_ref4) => {
              var _a2;
              let {
                props: {
                  class: fieldClass,
                  ...slotProps
                }
              } = _ref4;
              return createVNode(Fragment, null, [createVNode("input", mergeProps({
                "ref": inputRef,
                "type": "file",
                "readonly": isReadonly2.value,
                "disabled": isDisabled.value,
                "multiple": props2.multiple,
                "name": props2.name,
                "onClick": (e) => {
                  e.stopPropagation();
                  if (isReadonly2.value)
                    e.preventDefault();
                  onFocus();
                },
                "onChange": (e) => {
                  if (!e.target)
                    return;
                  const target = e.target;
                  model.value = [...target.files ?? []];
                },
                "onFocus": onFocus,
                "onBlur": blur
              }, slotProps, inputAttrs), null), createVNode("div", {
                "class": fieldClass
              }, [!!((_a2 = model.value) == null ? void 0 : _a2.length) && (slots.selection ? slots.selection({
                fileNames: fileNames.value,
                totalBytes: totalBytes.value,
                totalBytesReadable: totalBytesReadable.value
              }) : props2.chips ? fileNames.value.map((text) => createVNode(VChip, {
                "key": text,
                "size": "small",
                "color": props2.color
              }, {
                default: () => [text]
              })) : fileNames.value.join(", "))])]);
            }
          });
        },
        details: hasDetails ? (slotProps) => {
          var _a2, _b;
          return createVNode(Fragment, null, [(_a2 = slots.details) == null ? void 0 : _a2.call(slots, slotProps), hasCounter && createVNode(Fragment, null, [createVNode("span", null, null), createVNode(VCounter, {
            "active": !!((_b = model.value) == null ? void 0 : _b.length),
            "value": counterValue.value
          }, slots.counter)])]);
        } : void 0
      });
    });
    return forwardRefs({}, vInputRef, vFieldRef, inputRef);
  }
});
const VFooter$1 = "";
const makeVFooterProps = propsFactory({
  app: Boolean,
  color: String,
  height: {
    type: [Number, String],
    default: "auto"
  },
  ...makeBorderProps(),
  ...makeComponentProps(),
  ...makeElevationProps(),
  ...makeLayoutItemProps(),
  ...makeRoundedProps(),
  ...makeTagProps({
    tag: "footer"
  }),
  ...makeThemeProps()
}, "VFooter");
const VFooter = genericComponent()({
  name: "VFooter",
  props: makeVFooterProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props2);
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props2, "color"));
    const {
      borderClasses
    } = useBorder(props2);
    const {
      elevationClasses
    } = useElevation(props2);
    const {
      roundedClasses
    } = useRounded(props2);
    const autoHeight = shallowRef(32);
    const {
      resizeRef
    } = useResizeObserver((entries) => {
      if (!entries.length)
        return;
      autoHeight.value = entries[0].target.clientHeight;
    });
    const height = computed(() => props2.height === "auto" ? autoHeight.value : parseInt(props2.height, 10));
    const {
      layoutItemStyles
    } = useLayoutItem({
      id: props2.name,
      order: computed(() => parseInt(props2.order, 10)),
      position: computed(() => "bottom"),
      layoutSize: height,
      elementSize: computed(() => props2.height === "auto" ? void 0 : height.value),
      active: computed(() => props2.app),
      absolute: toRef(props2, "absolute")
    });
    useRender(() => createVNode(props2.tag, {
      "ref": resizeRef,
      "class": ["v-footer", themeClasses.value, backgroundColorClasses.value, borderClasses.value, elevationClasses.value, roundedClasses.value, props2.class],
      "style": [backgroundColorStyles.value, props2.app ? layoutItemStyles.value : {
        height: convertToUnit(props2.height)
      }, props2.style]
    }, slots));
    return {};
  }
});
const makeVFormProps = propsFactory({
  ...makeComponentProps(),
  ...makeFormProps()
}, "VForm");
const VForm = genericComponent()({
  name: "VForm",
  props: makeVFormProps(),
  emits: {
    "update:modelValue": (val) => true,
    submit: (e) => true
  },
  setup(props2, _ref) {
    let {
      slots,
      emit: emit2
    } = _ref;
    const form = createForm(props2);
    const formRef = ref();
    function onReset(e) {
      e.preventDefault();
      form.reset();
    }
    function onSubmit(_e) {
      const e = _e;
      const ready = form.validate();
      e.then = ready.then.bind(ready);
      e.catch = ready.catch.bind(ready);
      e.finally = ready.finally.bind(ready);
      emit2("submit", e);
      if (!e.defaultPrevented) {
        ready.then((_ref2) => {
          var _a2;
          let {
            valid
          } = _ref2;
          if (valid) {
            (_a2 = formRef.value) == null ? void 0 : _a2.submit();
          }
        });
      }
      e.preventDefault();
    }
    useRender(() => {
      var _a2;
      return createVNode("form", {
        "ref": formRef,
        "class": ["v-form", props2.class],
        "style": props2.style,
        "novalidate": true,
        "onReset": onReset,
        "onSubmit": onSubmit
      }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, form)]);
    });
    return forwardRefs(form, formRef);
  }
});
const VGrid = "";
const makeVContainerProps = propsFactory({
  fluid: {
    type: Boolean,
    default: false
  },
  ...makeComponentProps(),
  ...makeTagProps()
}, "VContainer");
const VContainer = genericComponent()({
  name: "VContainer",
  props: makeVContainerProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      rtlClasses
    } = useRtl();
    useRender(() => createVNode(props2.tag, {
      "class": ["v-container", {
        "v-container--fluid": props2.fluid
      }, rtlClasses.value, props2.class],
      "style": props2.style
    }, slots));
    return {};
  }
});
const breakpointProps = (() => {
  return breakpoints.reduce((props2, val) => {
    props2[val] = {
      type: [Boolean, String, Number],
      default: false
    };
    return props2;
  }, {});
})();
const offsetProps = (() => {
  return breakpoints.reduce((props2, val) => {
    const offsetKey = "offset" + capitalize(val);
    props2[offsetKey] = {
      type: [String, Number],
      default: null
    };
    return props2;
  }, {});
})();
const orderProps = (() => {
  return breakpoints.reduce((props2, val) => {
    const orderKey = "order" + capitalize(val);
    props2[orderKey] = {
      type: [String, Number],
      default: null
    };
    return props2;
  }, {});
})();
const propMap$1 = {
  col: Object.keys(breakpointProps),
  offset: Object.keys(offsetProps),
  order: Object.keys(orderProps)
};
function breakpointClass$1(type2, prop, val) {
  let className = type2;
  if (val == null || val === false) {
    return void 0;
  }
  if (prop) {
    const breakpoint = prop.replace(type2, "");
    className += `-${breakpoint}`;
  }
  if (type2 === "col") {
    className = "v-" + className;
  }
  if (type2 === "col" && (val === "" || val === true)) {
    return className.toLowerCase();
  }
  className += `-${val}`;
  return className.toLowerCase();
}
const ALIGN_SELF_VALUES = ["auto", "start", "end", "center", "baseline", "stretch"];
const makeVColProps = propsFactory({
  cols: {
    type: [Boolean, String, Number],
    default: false
  },
  ...breakpointProps,
  offset: {
    type: [String, Number],
    default: null
  },
  ...offsetProps,
  order: {
    type: [String, Number],
    default: null
  },
  ...orderProps,
  alignSelf: {
    type: String,
    default: null,
    validator: (str) => ALIGN_SELF_VALUES.includes(str)
  },
  ...makeComponentProps(),
  ...makeTagProps()
}, "VCol");
const VCol = genericComponent()({
  name: "VCol",
  props: makeVColProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const classes = computed(() => {
      const classList = [];
      let type2;
      for (type2 in propMap$1) {
        propMap$1[type2].forEach((prop) => {
          const value = props2[prop];
          const className = breakpointClass$1(type2, prop, value);
          if (className)
            classList.push(className);
        });
      }
      const hasColClasses = classList.some((className) => className.startsWith("v-col-"));
      classList.push({
        // Default to .v-col if no other col-{bp}-* classes generated nor `cols` specified.
        "v-col": !hasColClasses || !props2.cols,
        [`v-col-${props2.cols}`]: props2.cols,
        [`offset-${props2.offset}`]: props2.offset,
        [`order-${props2.order}`]: props2.order,
        [`align-self-${props2.alignSelf}`]: props2.alignSelf
      });
      return classList;
    });
    return () => {
      var _a2;
      return h(props2.tag, {
        class: [classes.value, props2.class],
        style: props2.style
      }, (_a2 = slots.default) == null ? void 0 : _a2.call(slots));
    };
  }
});
const ALIGNMENT = ["start", "end", "center"];
const SPACE = ["space-between", "space-around", "space-evenly"];
function makeRowProps(prefix, def2) {
  return breakpoints.reduce((props2, val) => {
    const prefixKey = prefix + capitalize(val);
    props2[prefixKey] = def2();
    return props2;
  }, {});
}
const ALIGN_VALUES = [...ALIGNMENT, "baseline", "stretch"];
const alignValidator = (str) => ALIGN_VALUES.includes(str);
const alignProps = makeRowProps("align", () => ({
  type: String,
  default: null,
  validator: alignValidator
}));
const JUSTIFY_VALUES = [...ALIGNMENT, ...SPACE];
const justifyValidator = (str) => JUSTIFY_VALUES.includes(str);
const justifyProps = makeRowProps("justify", () => ({
  type: String,
  default: null,
  validator: justifyValidator
}));
const ALIGN_CONTENT_VALUES = [...ALIGNMENT, ...SPACE, "stretch"];
const alignContentValidator = (str) => ALIGN_CONTENT_VALUES.includes(str);
const alignContentProps = makeRowProps("alignContent", () => ({
  type: String,
  default: null,
  validator: alignContentValidator
}));
const propMap = {
  align: Object.keys(alignProps),
  justify: Object.keys(justifyProps),
  alignContent: Object.keys(alignContentProps)
};
const classMap = {
  align: "align",
  justify: "justify",
  alignContent: "align-content"
};
function breakpointClass(type2, prop, val) {
  let className = classMap[type2];
  if (val == null) {
    return void 0;
  }
  if (prop) {
    const breakpoint = prop.replace(type2, "");
    className += `-${breakpoint}`;
  }
  className += `-${val}`;
  return className.toLowerCase();
}
const makeVRowProps = propsFactory({
  dense: Boolean,
  noGutters: Boolean,
  align: {
    type: String,
    default: null,
    validator: alignValidator
  },
  ...alignProps,
  justify: {
    type: String,
    default: null,
    validator: justifyValidator
  },
  ...justifyProps,
  alignContent: {
    type: String,
    default: null,
    validator: alignContentValidator
  },
  ...alignContentProps,
  ...makeComponentProps(),
  ...makeTagProps()
}, "VRow");
const VRow = genericComponent()({
  name: "VRow",
  props: makeVRowProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const classes = computed(() => {
      const classList = [];
      let type2;
      for (type2 in propMap) {
        propMap[type2].forEach((prop) => {
          const value = props2[prop];
          const className = breakpointClass(type2, prop, value);
          if (className)
            classList.push(className);
        });
      }
      classList.push({
        "v-row--no-gutters": props2.noGutters,
        "v-row--dense": props2.dense,
        [`align-${props2.align}`]: props2.align,
        [`justify-${props2.justify}`]: props2.justify,
        [`align-content-${props2.alignContent}`]: props2.alignContent
      });
      return classList;
    });
    return () => {
      var _a2;
      return h(props2.tag, {
        class: ["v-row", classes.value, props2.class],
        style: props2.style
      }, (_a2 = slots.default) == null ? void 0 : _a2.call(slots));
    };
  }
});
const VSpacer = createSimpleFunctional("v-spacer", "div", "VSpacer");
const makeVHoverProps = propsFactory({
  disabled: Boolean,
  modelValue: {
    type: Boolean,
    default: void 0
  },
  ...makeDelayProps()
}, "VHover");
const VHover = genericComponent()({
  name: "VHover",
  props: makeVHoverProps(),
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const isHovering = useProxiedModel(props2, "modelValue");
    const {
      runOpenDelay,
      runCloseDelay
    } = useDelay(props2, (value) => !props2.disabled && (isHovering.value = value));
    return () => {
      var _a2;
      return (_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
        isHovering: isHovering.value,
        props: {
          onMouseenter: runOpenDelay,
          onMouseleave: runCloseDelay
        }
      });
    };
  }
});
const VItemGroup$1 = "";
const VItemGroupSymbol = Symbol.for("vuetify:v-item-group");
const makeVItemGroupProps = propsFactory({
  ...makeComponentProps(),
  ...makeGroupProps({
    selectedClass: "v-item--selected"
  }),
  ...makeTagProps(),
  ...makeThemeProps()
}, "VItemGroup");
const VItemGroup = genericComponent()({
  name: "VItemGroup",
  props: makeVItemGroupProps(),
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props2);
    const {
      isSelected,
      select,
      next,
      prev,
      selected
    } = useGroup(props2, VItemGroupSymbol);
    return () => createVNode(props2.tag, {
      "class": ["v-item-group", themeClasses.value, props2.class],
      "style": props2.style
    }, {
      default: () => {
        var _a2;
        return [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
          isSelected,
          select,
          next,
          prev,
          selected: selected.value
        })];
      }
    });
  }
});
const VItem = genericComponent()({
  name: "VItem",
  props: makeGroupItemProps(),
  emits: {
    "group:selected": (val) => true
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      isSelected,
      select,
      toggle,
      selectedClass,
      value,
      disabled
    } = useGroupItem(props2, VItemGroupSymbol);
    return () => {
      var _a2;
      return (_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
        isSelected: isSelected.value,
        selectedClass: selectedClass.value,
        select,
        toggle,
        value: value.value,
        disabled: disabled.value
      });
    };
  }
});
const VKbd$1 = "";
const VKbd = createSimpleFunctional("v-kbd");
const VLayout$1 = "";
const makeVLayoutProps = propsFactory({
  ...makeComponentProps(),
  ...makeLayoutProps()
}, "VLayout");
const VLayout = genericComponent()({
  name: "VLayout",
  props: makeVLayoutProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      layoutClasses,
      layoutStyles,
      getLayoutItem,
      items,
      layoutRef
    } = createLayout(props2);
    useRender(() => {
      var _a2;
      return createVNode("div", {
        "ref": layoutRef,
        "class": [layoutClasses.value, props2.class],
        "style": [layoutStyles.value, props2.style]
      }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
    });
    return {
      getLayoutItem,
      items
    };
  }
});
const VLayoutItem$1 = "";
const makeVLayoutItemProps = propsFactory({
  position: {
    type: String,
    required: true
  },
  size: {
    type: [Number, String],
    default: 300
  },
  modelValue: Boolean,
  ...makeComponentProps(),
  ...makeLayoutItemProps()
}, "VLayoutItem");
const VLayoutItem = genericComponent()({
  name: "VLayoutItem",
  props: makeVLayoutItemProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      layoutItemStyles
    } = useLayoutItem({
      id: props2.name,
      order: computed(() => parseInt(props2.order, 10)),
      position: toRef(props2, "position"),
      elementSize: toRef(props2, "size"),
      layoutSize: toRef(props2, "size"),
      active: toRef(props2, "modelValue"),
      absolute: toRef(props2, "absolute")
    });
    return () => {
      var _a2;
      return createVNode("div", {
        "class": ["v-layout-item", props2.class],
        "style": [layoutItemStyles.value, props2.style]
      }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
    };
  }
});
const makeVLazyProps = propsFactory({
  modelValue: Boolean,
  options: {
    type: Object,
    // For more information on types, navigate to:
    // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
    default: () => ({
      root: void 0,
      rootMargin: void 0,
      threshold: void 0
    })
  },
  ...makeComponentProps(),
  ...makeDimensionProps(),
  ...makeTagProps(),
  ...makeTransitionProps({
    transition: "fade-transition"
  })
}, "VLazy");
const VLazy = genericComponent()({
  name: "VLazy",
  directives: {
    intersect: Intersect$1
  },
  props: makeVLazyProps(),
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      dimensionStyles
    } = useDimension(props2);
    const isActive = useProxiedModel(props2, "modelValue");
    function onIntersect(isIntersecting) {
      if (isActive.value)
        return;
      isActive.value = isIntersecting;
    }
    useRender(() => withDirectives(createVNode(props2.tag, {
      "class": ["v-lazy", props2.class],
      "style": [dimensionStyles.value, props2.style]
    }, {
      default: () => [isActive.value && createVNode(MaybeTransition, {
        "transition": props2.transition,
        "appear": true
      }, {
        default: () => {
          var _a2;
          return [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)];
        }
      })]
    }), [[resolveDirective("intersect"), {
      handler: onIntersect,
      options: props2.options
    }, null]]));
    return {};
  }
});
const VLocaleProvider$1 = "";
const makeVLocaleProviderProps = propsFactory({
  locale: String,
  fallbackLocale: String,
  messages: Object,
  rtl: {
    type: Boolean,
    default: void 0
  },
  ...makeComponentProps()
}, "VLocaleProvider");
const VLocaleProvider = genericComponent()({
  name: "VLocaleProvider",
  props: makeVLocaleProviderProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      rtlClasses
    } = provideLocale(props2);
    useRender(() => {
      var _a2;
      return createVNode("div", {
        "class": ["v-locale-provider", rtlClasses.value, props2.class],
        "style": props2.style
      }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
    });
    return {};
  }
});
const VMain$1 = "";
const makeVMainProps = propsFactory({
  scrollable: Boolean,
  ...makeComponentProps(),
  ...makeTagProps({
    tag: "main"
  })
}, "VMain");
const VMain = genericComponent()({
  name: "VMain",
  props: makeVMainProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      mainStyles
    } = useLayout();
    const {
      ssrBootStyles
    } = useSsrBoot();
    useRender(() => createVNode(props2.tag, {
      "class": ["v-main", {
        "v-main--scrollable": props2.scrollable
      }, props2.class],
      "style": [mainStyles.value, ssrBootStyles.value, props2.style]
    }, {
      default: () => {
        var _a2, _b;
        return [props2.scrollable ? createVNode("div", {
          "class": "v-main__scroller"
        }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]) : (_b = slots.default) == null ? void 0 : _b.call(slots)];
      }
    }));
    return {};
  }
});
const VNavigationDrawer$1 = "";
function useSticky(_ref) {
  let {
    rootEl: rootEl2,
    isSticky,
    layoutItemStyles
  } = _ref;
  const isStuck = shallowRef(false);
  const stuckPosition = shallowRef(0);
  const stickyStyles = computed(() => {
    const side = typeof isStuck.value === "boolean" ? "top" : isStuck.value;
    return [isSticky.value ? {
      top: "auto",
      bottom: "auto",
      height: void 0
    } : void 0, isStuck.value ? {
      [side]: convertToUnit(stuckPosition.value)
    } : {
      top: layoutItemStyles.value.top
    }];
  });
  onMounted(() => {
    watch(isSticky, (val) => {
      if (val) {
        window.addEventListener("scroll", onScroll, {
          passive: true
        });
      } else {
        window.removeEventListener("scroll", onScroll);
      }
    }, {
      immediate: true
    });
  });
  onBeforeUnmount(() => {
    window.removeEventListener("scroll", onScroll);
  });
  let lastScrollTop = 0;
  function onScroll() {
    const direction = lastScrollTop > window.scrollY ? "up" : "down";
    const rect = rootEl2.value.getBoundingClientRect();
    const layoutTop = parseFloat(layoutItemStyles.value.top ?? 0);
    const top = window.scrollY - Math.max(0, stuckPosition.value - layoutTop);
    const bottom = rect.height + Math.max(stuckPosition.value, layoutTop) - window.scrollY - window.innerHeight;
    const bodyScroll = parseFloat(getComputedStyle(rootEl2.value).getPropertyValue("--v-body-scroll-y")) || 0;
    if (rect.height < window.innerHeight - layoutTop) {
      isStuck.value = "top";
      stuckPosition.value = layoutTop;
    } else if (direction === "up" && isStuck.value === "bottom" || direction === "down" && isStuck.value === "top") {
      stuckPosition.value = window.scrollY + rect.top - bodyScroll;
      isStuck.value = true;
    } else if (direction === "down" && bottom <= 0) {
      stuckPosition.value = 0;
      isStuck.value = "bottom";
    } else if (direction === "up" && top <= 0) {
      if (!bodyScroll) {
        stuckPosition.value = rect.top + top;
        isStuck.value = "top";
      } else if (isStuck.value !== "top") {
        stuckPosition.value = -top + bodyScroll + layoutTop;
        isStuck.value = "top";
      }
    }
    lastScrollTop = window.scrollY;
  }
  return {
    isStuck,
    stickyStyles
  };
}
const HORIZON = 100;
const HISTORY = 20;
function kineticEnergyToVelocity(work) {
  const sqrt2 = 1.41421356237;
  return (work < 0 ? -1 : 1) * Math.sqrt(Math.abs(work)) * sqrt2;
}
function calculateImpulseVelocity(samples) {
  if (samples.length < 2) {
    return 0;
  }
  if (samples.length === 2) {
    if (samples[1].t === samples[0].t) {
      return 0;
    }
    return (samples[1].d - samples[0].d) / (samples[1].t - samples[0].t);
  }
  let work = 0;
  for (let i = samples.length - 1; i > 0; i--) {
    if (samples[i].t === samples[i - 1].t) {
      continue;
    }
    const vprev = kineticEnergyToVelocity(work);
    const vcurr = (samples[i].d - samples[i - 1].d) / (samples[i].t - samples[i - 1].t);
    work += (vcurr - vprev) * Math.abs(vcurr);
    if (i === samples.length - 1) {
      work *= 0.5;
    }
  }
  return kineticEnergyToVelocity(work) * 1e3;
}
function useVelocity() {
  const touches = {};
  function addMovement(e) {
    Array.from(e.changedTouches).forEach((touch) => {
      const samples = touches[touch.identifier] ?? (touches[touch.identifier] = new CircularBuffer(HISTORY));
      samples.push([e.timeStamp, touch]);
    });
  }
  function endTouch(e) {
    Array.from(e.changedTouches).forEach((touch) => {
      delete touches[touch.identifier];
    });
  }
  function getVelocity(id) {
    var _a2;
    const samples = (_a2 = touches[id]) == null ? void 0 : _a2.values().reverse();
    if (!samples) {
      throw new Error(`No samples for touch id ${id}`);
    }
    const newest = samples[0];
    const x2 = [];
    const y2 = [];
    for (const val of samples) {
      if (newest[0] - val[0] > HORIZON)
        break;
      x2.push({
        t: val[0],
        d: val[1].clientX
      });
      y2.push({
        t: val[0],
        d: val[1].clientY
      });
    }
    return {
      x: calculateImpulseVelocity(x2),
      y: calculateImpulseVelocity(y2),
      get direction() {
        const {
          x: x3,
          y: y3
        } = this;
        const [absX, absY] = [Math.abs(x3), Math.abs(y3)];
        return absX > absY && x3 >= 0 ? "right" : absX > absY && x3 <= 0 ? "left" : absY > absX && y3 >= 0 ? "down" : absY > absX && y3 <= 0 ? "up" : oops$1();
      }
    };
  }
  return {
    addMovement,
    endTouch,
    getVelocity
  };
}
function oops$1() {
  throw new Error();
}
function useTouch(_ref) {
  let {
    isActive,
    isTemporary,
    width,
    touchless,
    position
  } = _ref;
  onMounted(() => {
    window.addEventListener("touchstart", onTouchstart, {
      passive: true
    });
    window.addEventListener("touchmove", onTouchmove, {
      passive: false
    });
    window.addEventListener("touchend", onTouchend, {
      passive: true
    });
  });
  onBeforeUnmount(() => {
    window.removeEventListener("touchstart", onTouchstart);
    window.removeEventListener("touchmove", onTouchmove);
    window.removeEventListener("touchend", onTouchend);
  });
  const isHorizontal = computed(() => ["left", "right"].includes(position.value));
  const {
    addMovement,
    endTouch,
    getVelocity
  } = useVelocity();
  let maybeDragging = false;
  const isDragging = shallowRef(false);
  const dragProgress = shallowRef(0);
  const offset = shallowRef(0);
  let start;
  function getOffset2(pos2, active) {
    return (position.value === "left" ? pos2 : position.value === "right" ? document.documentElement.clientWidth - pos2 : position.value === "top" ? pos2 : position.value === "bottom" ? document.documentElement.clientHeight - pos2 : oops()) - (active ? width.value : 0);
  }
  function getProgress(pos2) {
    let limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    const progress = position.value === "left" ? (pos2 - offset.value) / width.value : position.value === "right" ? (document.documentElement.clientWidth - pos2 - offset.value) / width.value : position.value === "top" ? (pos2 - offset.value) / width.value : position.value === "bottom" ? (document.documentElement.clientHeight - pos2 - offset.value) / width.value : oops();
    return limit ? Math.max(0, Math.min(1, progress)) : progress;
  }
  function onTouchstart(e) {
    if (touchless.value)
      return;
    const touchX = e.changedTouches[0].clientX;
    const touchY = e.changedTouches[0].clientY;
    const touchZone = 25;
    const inTouchZone = position.value === "left" ? touchX < touchZone : position.value === "right" ? touchX > document.documentElement.clientWidth - touchZone : position.value === "top" ? touchY < touchZone : position.value === "bottom" ? touchY > document.documentElement.clientHeight - touchZone : oops();
    const inElement = isActive.value && (position.value === "left" ? touchX < width.value : position.value === "right" ? touchX > document.documentElement.clientWidth - width.value : position.value === "top" ? touchY < width.value : position.value === "bottom" ? touchY > document.documentElement.clientHeight - width.value : oops());
    if (inTouchZone || inElement || isActive.value && isTemporary.value) {
      maybeDragging = true;
      start = [touchX, touchY];
      offset.value = getOffset2(isHorizontal.value ? touchX : touchY, isActive.value);
      dragProgress.value = getProgress(isHorizontal.value ? touchX : touchY);
      endTouch(e);
      addMovement(e);
    }
  }
  function onTouchmove(e) {
    const touchX = e.changedTouches[0].clientX;
    const touchY = e.changedTouches[0].clientY;
    if (maybeDragging) {
      if (!e.cancelable) {
        maybeDragging = false;
        return;
      }
      const dx = Math.abs(touchX - start[0]);
      const dy = Math.abs(touchY - start[1]);
      const thresholdMet = isHorizontal.value ? dx > dy && dx > 3 : dy > dx && dy > 3;
      if (thresholdMet) {
        isDragging.value = true;
        maybeDragging = false;
      } else if ((isHorizontal.value ? dy : dx) > 3) {
        maybeDragging = false;
      }
    }
    if (!isDragging.value)
      return;
    e.preventDefault();
    addMovement(e);
    const progress = getProgress(isHorizontal.value ? touchX : touchY, false);
    dragProgress.value = Math.max(0, Math.min(1, progress));
    if (progress > 1) {
      offset.value = getOffset2(isHorizontal.value ? touchX : touchY, true);
    } else if (progress < 0) {
      offset.value = getOffset2(isHorizontal.value ? touchX : touchY, false);
    }
  }
  function onTouchend(e) {
    maybeDragging = false;
    if (!isDragging.value)
      return;
    addMovement(e);
    isDragging.value = false;
    const velocity = getVelocity(e.changedTouches[0].identifier);
    const vx = Math.abs(velocity.x);
    const vy = Math.abs(velocity.y);
    const thresholdMet = isHorizontal.value ? vx > vy && vx > 400 : vy > vx && vy > 3;
    if (thresholdMet) {
      isActive.value = velocity.direction === ({
        left: "right",
        right: "left",
        top: "down",
        bottom: "up"
      }[position.value] || oops());
    } else {
      isActive.value = dragProgress.value > 0.5;
    }
  }
  const dragStyles = computed(() => {
    return isDragging.value ? {
      transform: position.value === "left" ? `translateX(calc(-100% + ${dragProgress.value * width.value}px))` : position.value === "right" ? `translateX(calc(100% - ${dragProgress.value * width.value}px))` : position.value === "top" ? `translateY(calc(-100% + ${dragProgress.value * width.value}px))` : position.value === "bottom" ? `translateY(calc(100% - ${dragProgress.value * width.value}px))` : oops(),
      transition: "none"
    } : void 0;
  });
  return {
    isDragging,
    dragProgress,
    dragStyles
  };
}
function oops() {
  throw new Error();
}
const locations = ["start", "end", "left", "right", "top", "bottom"];
const makeVNavigationDrawerProps = propsFactory({
  color: String,
  disableResizeWatcher: Boolean,
  disableRouteWatcher: Boolean,
  expandOnHover: Boolean,
  floating: Boolean,
  modelValue: {
    type: Boolean,
    default: null
  },
  permanent: Boolean,
  rail: {
    type: Boolean,
    default: null
  },
  railWidth: {
    type: [Number, String],
    default: 56
  },
  scrim: {
    type: [Boolean, String],
    default: true
  },
  image: String,
  temporary: Boolean,
  touchless: Boolean,
  width: {
    type: [Number, String],
    default: 256
  },
  location: {
    type: String,
    default: "start",
    validator: (value) => locations.includes(value)
  },
  sticky: Boolean,
  ...makeBorderProps(),
  ...makeComponentProps(),
  ...makeElevationProps(),
  ...makeLayoutItemProps(),
  ...makeRoundedProps(),
  ...makeTagProps({
    tag: "nav"
  }),
  ...makeThemeProps()
}, "VNavigationDrawer");
const VNavigationDrawer = genericComponent()({
  name: "VNavigationDrawer",
  props: makeVNavigationDrawerProps(),
  emits: {
    "update:modelValue": (val) => true,
    "update:rail": (val) => true
  },
  setup(props2, _ref) {
    let {
      attrs,
      emit: emit2,
      slots
    } = _ref;
    const {
      isRtl
    } = useRtl();
    const {
      themeClasses
    } = provideTheme(props2);
    const {
      borderClasses
    } = useBorder(props2);
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props2, "color"));
    const {
      elevationClasses
    } = useElevation(props2);
    const {
      mobile
    } = useDisplay();
    const {
      roundedClasses
    } = useRounded(props2);
    const router = useRouter();
    const isActive = useProxiedModel(props2, "modelValue", null, (v2) => !!v2);
    const {
      ssrBootStyles
    } = useSsrBoot();
    const {
      scopeId
    } = useScopeId();
    const rootEl2 = ref();
    const isHovering = shallowRef(false);
    const width = computed(() => {
      return props2.rail && props2.expandOnHover && isHovering.value ? Number(props2.width) : Number(props2.rail ? props2.railWidth : props2.width);
    });
    const location2 = computed(() => {
      return toPhysical(props2.location, isRtl.value);
    });
    const isTemporary = computed(() => !props2.permanent && (mobile.value || props2.temporary));
    const isSticky = computed(() => props2.sticky && !isTemporary.value && location2.value !== "bottom");
    useToggleScope(() => props2.expandOnHover && props2.rail != null, () => {
      watch(isHovering, (val) => emit2("update:rail", !val));
    });
    useToggleScope(() => !props2.disableResizeWatcher, () => {
      watch(isTemporary, (val) => !props2.permanent && nextTick(() => isActive.value = !val));
    });
    useToggleScope(() => !props2.disableRouteWatcher && !!router, () => {
      watch(router.currentRoute, () => isTemporary.value && (isActive.value = false));
    });
    watch(() => props2.permanent, (val) => {
      if (val)
        isActive.value = true;
    });
    onBeforeMount(() => {
      if (props2.modelValue != null || isTemporary.value)
        return;
      isActive.value = props2.permanent || !mobile.value;
    });
    const {
      isDragging,
      dragProgress,
      dragStyles
    } = useTouch({
      isActive,
      isTemporary,
      width,
      touchless: toRef(props2, "touchless"),
      position: location2
    });
    const layoutSize = computed(() => {
      const size2 = isTemporary.value ? 0 : props2.rail && props2.expandOnHover ? Number(props2.railWidth) : width.value;
      return isDragging.value ? size2 * dragProgress.value : size2;
    });
    const {
      layoutItemStyles,
      layoutItemScrimStyles
    } = useLayoutItem({
      id: props2.name,
      order: computed(() => parseInt(props2.order, 10)),
      position: location2,
      layoutSize,
      elementSize: width,
      active: computed(() => isActive.value || isDragging.value),
      disableTransitions: computed(() => isDragging.value),
      absolute: computed(() => (
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        props2.absolute || isSticky.value && typeof isStuck.value !== "string"
      ))
    });
    const {
      isStuck,
      stickyStyles
    } = useSticky({
      rootEl: rootEl2,
      isSticky,
      layoutItemStyles
    });
    const scrimColor = useBackgroundColor(computed(() => {
      return typeof props2.scrim === "string" ? props2.scrim : null;
    }));
    const scrimStyles = computed(() => ({
      ...isDragging.value ? {
        opacity: dragProgress.value * 0.2,
        transition: "none"
      } : void 0,
      ...layoutItemScrimStyles.value
    }));
    provideDefaults({
      VList: {
        bgColor: "transparent"
      }
    });
    function onMouseenter() {
      isHovering.value = true;
    }
    function onMouseleave() {
      isHovering.value = false;
    }
    useRender(() => {
      const hasImage = slots.image || props2.image;
      return createVNode(Fragment, null, [createVNode(props2.tag, mergeProps({
        "ref": rootEl2,
        "onMouseenter": onMouseenter,
        "onMouseleave": onMouseleave,
        "class": ["v-navigation-drawer", `v-navigation-drawer--${location2.value}`, {
          "v-navigation-drawer--expand-on-hover": props2.expandOnHover,
          "v-navigation-drawer--floating": props2.floating,
          "v-navigation-drawer--is-hovering": isHovering.value,
          "v-navigation-drawer--rail": props2.rail,
          "v-navigation-drawer--temporary": isTemporary.value,
          "v-navigation-drawer--active": isActive.value,
          "v-navigation-drawer--sticky": isSticky.value
        }, themeClasses.value, backgroundColorClasses.value, borderClasses.value, elevationClasses.value, roundedClasses.value, props2.class],
        "style": [backgroundColorStyles.value, layoutItemStyles.value, dragStyles.value, ssrBootStyles.value, stickyStyles.value, props2.style]
      }, scopeId, attrs), {
        default: () => {
          var _a2, _b, _c, _d;
          return [hasImage && createVNode("div", {
            "key": "image",
            "class": "v-navigation-drawer__img"
          }, [slots.image ? (_a2 = slots.image) == null ? void 0 : _a2.call(slots, {
            image: props2.image
          }) : createVNode("img", {
            "src": props2.image,
            "alt": ""
          }, null)]), slots.prepend && createVNode("div", {
            "class": "v-navigation-drawer__prepend"
          }, [(_b = slots.prepend) == null ? void 0 : _b.call(slots)]), createVNode("div", {
            "class": "v-navigation-drawer__content"
          }, [(_c = slots.default) == null ? void 0 : _c.call(slots)]), slots.append && createVNode("div", {
            "class": "v-navigation-drawer__append"
          }, [(_d = slots.append) == null ? void 0 : _d.call(slots)])];
        }
      }), createVNode(Transition, {
        "name": "fade-transition"
      }, {
        default: () => [isTemporary.value && (isDragging.value || isActive.value) && !!props2.scrim && createVNode("div", mergeProps({
          "class": ["v-navigation-drawer__scrim", scrimColor.backgroundColorClasses.value],
          "style": [scrimStyles.value, scrimColor.backgroundColorStyles.value],
          "onClick": () => isActive.value = false
        }, scopeId), null)]
      })]);
    });
    return {
      isStuck
    };
  }
});
const VNoSsr = defineComponent({
  name: "VNoSsr",
  setup(_2, _ref) {
    let {
      slots
    } = _ref;
    const show = useHydration();
    return () => {
      var _a2;
      return show.value && ((_a2 = slots.default) == null ? void 0 : _a2.call(slots));
    };
  }
});
const VPagination$1 = "";
function useRefs() {
  const refs = ref([]);
  onBeforeUpdate(() => refs.value = []);
  function updateRef(e, i) {
    refs.value[i] = e;
  }
  return {
    refs,
    updateRef
  };
}
const makeVPaginationProps = propsFactory({
  activeColor: String,
  start: {
    type: [Number, String],
    default: 1
  },
  modelValue: {
    type: Number,
    default: (props2) => props2.start
  },
  disabled: Boolean,
  length: {
    type: [Number, String],
    default: 1,
    validator: (val) => val % 1 === 0
  },
  totalVisible: [Number, String],
  firstIcon: {
    type: IconValue,
    default: "$first"
  },
  prevIcon: {
    type: IconValue,
    default: "$prev"
  },
  nextIcon: {
    type: IconValue,
    default: "$next"
  },
  lastIcon: {
    type: IconValue,
    default: "$last"
  },
  ariaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.root"
  },
  pageAriaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.page"
  },
  currentPageAriaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.currentPage"
  },
  firstAriaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.first"
  },
  previousAriaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.previous"
  },
  nextAriaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.next"
  },
  lastAriaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.last"
  },
  ellipsis: {
    type: String,
    default: "..."
  },
  showFirstLastPage: Boolean,
  ...makeBorderProps(),
  ...makeComponentProps(),
  ...makeDensityProps(),
  ...makeElevationProps(),
  ...makeRoundedProps(),
  ...makeSizeProps(),
  ...makeTagProps({
    tag: "nav"
  }),
  ...makeThemeProps(),
  ...makeVariantProps({
    variant: "text"
  })
}, "VPagination");
const VPagination = genericComponent()({
  name: "VPagination",
  props: makeVPaginationProps(),
  emits: {
    "update:modelValue": (value) => true,
    first: (value) => true,
    prev: (value) => true,
    next: (value) => true,
    last: (value) => true
  },
  setup(props2, _ref) {
    let {
      slots,
      emit: emit2
    } = _ref;
    const page = useProxiedModel(props2, "modelValue");
    const {
      t,
      n
    } = useLocale();
    const {
      isRtl
    } = useRtl();
    const {
      themeClasses
    } = provideTheme(props2);
    const {
      width
    } = useDisplay();
    const maxButtons = shallowRef(-1);
    provideDefaults(void 0, {
      scoped: true
    });
    const {
      resizeRef
    } = useResizeObserver((entries) => {
      if (!entries.length)
        return;
      const {
        target,
        contentRect
      } = entries[0];
      const firstItem = target.querySelector(".v-pagination__list > *");
      if (!firstItem)
        return;
      const totalWidth = contentRect.width;
      const itemWidth = firstItem.offsetWidth + parseFloat(getComputedStyle(firstItem).marginRight) * 2;
      maxButtons.value = getMax(totalWidth, itemWidth);
    });
    const length = computed(() => parseInt(props2.length, 10));
    const start = computed(() => parseInt(props2.start, 10));
    const totalVisible = computed(() => {
      if (props2.totalVisible)
        return parseInt(props2.totalVisible, 10);
      else if (maxButtons.value >= 0)
        return maxButtons.value;
      return getMax(width.value, 58);
    });
    function getMax(totalWidth, itemWidth) {
      const minButtons = props2.showFirstLastPage ? 5 : 3;
      return Math.max(0, Math.floor(
        // Round to two decimal places to avoid floating point errors
        +((totalWidth - itemWidth * minButtons) / itemWidth).toFixed(2)
      ));
    }
    const range = computed(() => {
      if (length.value <= 0 || isNaN(length.value) || length.value > Number.MAX_SAFE_INTEGER)
        return [];
      if (totalVisible.value <= 1)
        return [page.value];
      if (length.value <= totalVisible.value) {
        return createRange(length.value, start.value);
      }
      const even = totalVisible.value % 2 === 0;
      const middle = even ? totalVisible.value / 2 : Math.floor(totalVisible.value / 2);
      const left = even ? middle : middle + 1;
      const right = length.value - middle;
      if (left - page.value >= 0) {
        return [...createRange(Math.max(1, totalVisible.value - 1), start.value), props2.ellipsis, length.value];
      } else if (page.value - right >= (even ? 1 : 0)) {
        const rangeLength = totalVisible.value - 1;
        const rangeStart = length.value - rangeLength + start.value;
        return [start.value, props2.ellipsis, ...createRange(rangeLength, rangeStart)];
      } else {
        const rangeLength = Math.max(1, totalVisible.value - 3);
        const rangeStart = rangeLength === 1 ? page.value : page.value - Math.ceil(rangeLength / 2) + start.value;
        return [start.value, props2.ellipsis, ...createRange(rangeLength, rangeStart), props2.ellipsis, length.value];
      }
    });
    function setValue(e, value, event) {
      e.preventDefault();
      page.value = value;
      event && emit2(event, value);
    }
    const {
      refs,
      updateRef
    } = useRefs();
    provideDefaults({
      VPaginationBtn: {
        color: toRef(props2, "color"),
        border: toRef(props2, "border"),
        density: toRef(props2, "density"),
        size: toRef(props2, "size"),
        variant: toRef(props2, "variant"),
        rounded: toRef(props2, "rounded"),
        elevation: toRef(props2, "elevation")
      }
    });
    const items = computed(() => {
      return range.value.map((item, index2) => {
        const ref2 = (e) => updateRef(e, index2);
        if (typeof item === "string") {
          return {
            isActive: false,
            key: `ellipsis-${index2}`,
            page: item,
            props: {
              ref: ref2,
              ellipsis: true,
              icon: true,
              disabled: true
            }
          };
        } else {
          const isActive = item === page.value;
          return {
            isActive,
            key: item,
            page: n(item),
            props: {
              ref: ref2,
              ellipsis: false,
              icon: true,
              disabled: !!props2.disabled || +props2.length < 2,
              color: isActive ? props2.activeColor : props2.color,
              ariaCurrent: isActive,
              ariaLabel: t(isActive ? props2.currentPageAriaLabel : props2.pageAriaLabel, item),
              onClick: (e) => setValue(e, item)
            }
          };
        }
      });
    });
    const controls = computed(() => {
      const prevDisabled = !!props2.disabled || page.value <= start.value;
      const nextDisabled = !!props2.disabled || page.value >= start.value + length.value - 1;
      return {
        first: props2.showFirstLastPage ? {
          icon: isRtl.value ? props2.lastIcon : props2.firstIcon,
          onClick: (e) => setValue(e, start.value, "first"),
          disabled: prevDisabled,
          ariaLabel: t(props2.firstAriaLabel),
          ariaDisabled: prevDisabled
        } : void 0,
        prev: {
          icon: isRtl.value ? props2.nextIcon : props2.prevIcon,
          onClick: (e) => setValue(e, page.value - 1, "prev"),
          disabled: prevDisabled,
          ariaLabel: t(props2.previousAriaLabel),
          ariaDisabled: prevDisabled
        },
        next: {
          icon: isRtl.value ? props2.prevIcon : props2.nextIcon,
          onClick: (e) => setValue(e, page.value + 1, "next"),
          disabled: nextDisabled,
          ariaLabel: t(props2.nextAriaLabel),
          ariaDisabled: nextDisabled
        },
        last: props2.showFirstLastPage ? {
          icon: isRtl.value ? props2.firstIcon : props2.lastIcon,
          onClick: (e) => setValue(e, start.value + length.value - 1, "last"),
          disabled: nextDisabled,
          ariaLabel: t(props2.lastAriaLabel),
          ariaDisabled: nextDisabled
        } : void 0
      };
    });
    function updateFocus() {
      var _a2;
      const currentIndex = page.value - start.value;
      (_a2 = refs.value[currentIndex]) == null ? void 0 : _a2.$el.focus();
    }
    function onKeydown(e) {
      if (e.key === keyValues.left && !props2.disabled && page.value > +props2.start) {
        page.value = page.value - 1;
        nextTick(updateFocus);
      } else if (e.key === keyValues.right && !props2.disabled && page.value < start.value + length.value - 1) {
        page.value = page.value + 1;
        nextTick(updateFocus);
      }
    }
    useRender(() => createVNode(props2.tag, {
      "ref": resizeRef,
      "class": ["v-pagination", themeClasses.value, props2.class],
      "style": props2.style,
      "role": "navigation",
      "aria-label": t(props2.ariaLabel),
      "onKeydown": onKeydown,
      "data-test": "v-pagination-root"
    }, {
      default: () => [createVNode("ul", {
        "class": "v-pagination__list"
      }, [props2.showFirstLastPage && createVNode("li", {
        "key": "first",
        "class": "v-pagination__first",
        "data-test": "v-pagination-first"
      }, [slots.first ? slots.first(controls.value.first) : createVNode(VBtn, mergeProps({
        "_as": "VPaginationBtn"
      }, controls.value.first), null)]), createVNode("li", {
        "key": "prev",
        "class": "v-pagination__prev",
        "data-test": "v-pagination-prev"
      }, [slots.prev ? slots.prev(controls.value.prev) : createVNode(VBtn, mergeProps({
        "_as": "VPaginationBtn"
      }, controls.value.prev), null)]), items.value.map((item, index2) => createVNode("li", {
        "key": item.key,
        "class": ["v-pagination__item", {
          "v-pagination__item--is-active": item.isActive
        }],
        "data-test": "v-pagination-item"
      }, [slots.item ? slots.item(item) : createVNode(VBtn, mergeProps({
        "_as": "VPaginationBtn"
      }, item.props), {
        default: () => [item.page]
      })])), createVNode("li", {
        "key": "next",
        "class": "v-pagination__next",
        "data-test": "v-pagination-next"
      }, [slots.next ? slots.next(controls.value.next) : createVNode(VBtn, mergeProps({
        "_as": "VPaginationBtn"
      }, controls.value.next), null)]), props2.showFirstLastPage && createVNode("li", {
        "key": "last",
        "class": "v-pagination__last",
        "data-test": "v-pagination-last"
      }, [slots.last ? slots.last(controls.value.last) : createVNode(VBtn, mergeProps({
        "_as": "VPaginationBtn"
      }, controls.value.last), null)])])]
    }));
    return {};
  }
});
const VParallax$1 = "";
function floor(val) {
  return Math.floor(Math.abs(val)) * Math.sign(val);
}
const makeVParallaxProps = propsFactory({
  scale: {
    type: [Number, String],
    default: 0.5
  },
  ...makeComponentProps()
}, "VParallax");
const VParallax = genericComponent()({
  name: "VParallax",
  props: makeVParallaxProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      intersectionRef,
      isIntersecting
    } = useIntersectionObserver();
    const {
      resizeRef,
      contentRect
    } = useResizeObserver();
    const {
      height: displayHeight
    } = useDisplay();
    const root2 = ref();
    watchEffect(() => {
      var _a2;
      intersectionRef.value = resizeRef.value = (_a2 = root2.value) == null ? void 0 : _a2.$el;
    });
    let scrollParent;
    watch(isIntersecting, (val) => {
      if (val) {
        scrollParent = getScrollParent(intersectionRef.value);
        scrollParent = scrollParent === document.scrollingElement ? document : scrollParent;
        scrollParent.addEventListener("scroll", onScroll, {
          passive: true
        });
        onScroll();
      } else {
        scrollParent.removeEventListener("scroll", onScroll);
      }
    });
    onBeforeUnmount(() => {
      scrollParent == null ? void 0 : scrollParent.removeEventListener("scroll", onScroll);
    });
    watch(displayHeight, onScroll);
    watch(() => {
      var _a2;
      return (_a2 = contentRect.value) == null ? void 0 : _a2.height;
    }, onScroll);
    const scale = computed(() => {
      return 1 - clamp(+props2.scale);
    });
    let frame = -1;
    function onScroll() {
      if (!isIntersecting.value)
        return;
      cancelAnimationFrame(frame);
      frame = requestAnimationFrame(() => {
        var _a2;
        const el = ((_a2 = root2.value) == null ? void 0 : _a2.$el).querySelector(".v-img__img");
        if (!el)
          return;
        const scrollHeight = scrollParent instanceof Document ? document.documentElement.clientHeight : scrollParent.clientHeight;
        const scrollPos = scrollParent instanceof Document ? window.scrollY : scrollParent.scrollTop;
        const top = intersectionRef.value.getBoundingClientRect().top + scrollPos;
        const height = contentRect.value.height;
        const center = top + (height - scrollHeight) / 2;
        const translate = floor((scrollPos - center) * scale.value);
        const sizeScale = Math.max(1, (scale.value * (scrollHeight - height) + height) / height);
        el.style.setProperty("transform", `translateY(${translate}px) scale(${sizeScale})`);
      });
    }
    useRender(() => createVNode(VImg, {
      "class": ["v-parallax", {
        "v-parallax--active": isIntersecting.value
      }, props2.class],
      "style": props2.style,
      "ref": root2,
      "cover": true,
      "onLoadstart": onScroll,
      "onLoad": onScroll
    }, slots));
    return {};
  }
});
const makeVRadioProps = propsFactory({
  ...makeVSelectionControlProps({
    falseIcon: "$radioOff",
    trueIcon: "$radioOn"
  })
}, "VRadio");
const VRadio = genericComponent()({
  name: "VRadio",
  props: makeVRadioProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    useRender(() => createVNode(VSelectionControl, mergeProps(props2, {
      "class": ["v-radio", props2.class],
      "style": props2.style,
      "type": "radio"
    }), slots));
    return {};
  }
});
const VRadioGroup$1 = "";
const makeVRadioGroupProps = propsFactory({
  height: {
    type: [Number, String],
    default: "auto"
  },
  ...makeVInputProps(),
  ...omit(makeSelectionControlGroupProps(), ["multiple"]),
  trueIcon: {
    type: IconValue,
    default: "$radioOn"
  },
  falseIcon: {
    type: IconValue,
    default: "$radioOff"
  },
  type: {
    type: String,
    default: "radio"
  }
}, "VRadioGroup");
const VRadioGroup = genericComponent()({
  name: "VRadioGroup",
  inheritAttrs: false,
  props: makeVRadioGroupProps(),
  emits: {
    "update:modelValue": (val) => true
  },
  setup(props2, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const uid2 = getUid();
    const id = computed(() => props2.id || `radio-group-${uid2}`);
    const model = useProxiedModel(props2, "modelValue");
    useRender(() => {
      const [rootAttrs, controlAttrs] = filterInputAttrs(attrs);
      const [inputProps, _1] = VInput.filterProps(props2);
      const [controlProps, _2] = VSelectionControl.filterProps(props2);
      const label = slots.label ? slots.label({
        label: props2.label,
        props: {
          for: id.value
        }
      }) : props2.label;
      return createVNode(VInput, mergeProps({
        "class": ["v-radio-group", props2.class],
        "style": props2.style
      }, rootAttrs, inputProps, {
        "modelValue": model.value,
        "onUpdate:modelValue": ($event) => model.value = $event,
        "id": id.value
      }), {
        ...slots,
        default: (_ref2) => {
          let {
            id: id2,
            messagesId,
            isDisabled,
            isReadonly: isReadonly2
          } = _ref2;
          return createVNode(Fragment, null, [label && createVNode(VLabel, {
            "id": id2.value
          }, {
            default: () => [label]
          }), createVNode(VSelectionControlGroup, mergeProps(controlProps, {
            "id": id2.value,
            "aria-describedby": messagesId.value,
            "defaultsTarget": "VRadio",
            "trueIcon": props2.trueIcon,
            "falseIcon": props2.falseIcon,
            "type": props2.type,
            "disabled": isDisabled.value,
            "readonly": isReadonly2.value,
            "aria-labelledby": label ? id2.value : void 0,
            "multiple": false
          }, controlAttrs, {
            "modelValue": model.value,
            "onUpdate:modelValue": ($event) => model.value = $event
          }), slots)]);
        }
      });
    });
    return {};
  }
});
const makeVRangeSliderProps = propsFactory({
  ...makeFocusProps(),
  ...makeVInputProps(),
  ...makeSliderProps(),
  strict: Boolean,
  modelValue: {
    type: Array,
    default: () => [0, 0]
  }
}, "VRangeSlider");
const VRangeSlider = genericComponent()({
  name: "VRangeSlider",
  props: makeVRangeSliderProps(),
  emits: {
    "update:focused": (value) => true,
    "update:modelValue": (value) => true,
    end: (value) => true,
    start: (value) => true
  },
  setup(props2, _ref) {
    let {
      slots,
      emit: emit2
    } = _ref;
    const startThumbRef = ref();
    const stopThumbRef = ref();
    const inputRef = ref();
    const {
      rtlClasses
    } = useRtl();
    function getActiveThumb(e) {
      if (!startThumbRef.value || !stopThumbRef.value)
        return;
      const startOffset = getOffset(e, startThumbRef.value.$el, props2.direction);
      const stopOffset = getOffset(e, stopThumbRef.value.$el, props2.direction);
      const a = Math.abs(startOffset);
      const b2 = Math.abs(stopOffset);
      return a < b2 || a === b2 && startOffset < 0 ? startThumbRef.value.$el : stopThumbRef.value.$el;
    }
    const steps = useSteps(props2);
    const model = useProxiedModel(props2, "modelValue", void 0, (arr) => {
      if (!(arr == null ? void 0 : arr.length))
        return [0, 0];
      return arr.map((value) => steps.roundValue(value));
    });
    const {
      activeThumbRef,
      hasLabels,
      max: max2,
      min,
      mousePressed,
      onSliderMousedown,
      onSliderTouchstart,
      position,
      trackContainerRef
    } = useSlider({
      props: props2,
      steps,
      onSliderStart: () => {
        emit2("start", model.value);
      },
      onSliderEnd: (_ref2) => {
        var _a2;
        let {
          value
        } = _ref2;
        const newValue = activeThumbRef.value === ((_a2 = startThumbRef.value) == null ? void 0 : _a2.$el) ? [value, model.value[1]] : [model.value[0], value];
        if (!props2.strict && newValue[0] < newValue[1]) {
          model.value = newValue;
        }
        emit2("end", model.value);
      },
      onSliderMove: (_ref3) => {
        var _a2, _b, _c, _d;
        let {
          value
        } = _ref3;
        const [start, stop2] = model.value;
        if (!props2.strict && start === stop2 && start !== min.value) {
          activeThumbRef.value = value > start ? (_a2 = stopThumbRef.value) == null ? void 0 : _a2.$el : (_b = startThumbRef.value) == null ? void 0 : _b.$el;
          (_c = activeThumbRef.value) == null ? void 0 : _c.focus();
        }
        if (activeThumbRef.value === ((_d = startThumbRef.value) == null ? void 0 : _d.$el)) {
          model.value = [Math.min(value, stop2), stop2];
        } else {
          model.value = [start, Math.max(start, value)];
        }
      },
      getActiveThumb
    });
    const {
      isFocused,
      focus,
      blur
    } = useFocus(props2);
    const trackStart = computed(() => position(model.value[0]));
    const trackStop = computed(() => position(model.value[1]));
    useRender(() => {
      const [inputProps, _2] = VInput.filterProps(props2);
      const hasPrepend = !!(props2.label || slots.label || slots.prepend);
      return createVNode(VInput, mergeProps({
        "class": ["v-slider", "v-range-slider", {
          "v-slider--has-labels": !!slots["tick-label"] || hasLabels.value,
          "v-slider--focused": isFocused.value,
          "v-slider--pressed": mousePressed.value,
          "v-slider--disabled": props2.disabled
        }, rtlClasses.value, props2.class],
        "style": props2.style,
        "ref": inputRef
      }, inputProps, {
        "focused": isFocused.value
      }), {
        ...slots,
        prepend: hasPrepend ? (slotProps) => {
          var _a2, _b;
          return createVNode(Fragment, null, [((_a2 = slots.label) == null ? void 0 : _a2.call(slots, slotProps)) ?? (props2.label ? createVNode(VLabel, {
            "class": "v-slider__label",
            "text": props2.label
          }, null) : void 0), (_b = slots.prepend) == null ? void 0 : _b.call(slots, slotProps)]);
        } : void 0,
        default: (_ref4) => {
          var _a2, _b;
          let {
            id,
            messagesId
          } = _ref4;
          return createVNode("div", {
            "class": "v-slider__container",
            "onMousedown": onSliderMousedown,
            "onTouchstartPassive": onSliderTouchstart
          }, [createVNode("input", {
            "id": `${id.value}_start`,
            "name": props2.name || id.value,
            "disabled": !!props2.disabled,
            "readonly": !!props2.readonly,
            "tabindex": "-1",
            "value": model.value[0]
          }, null), createVNode("input", {
            "id": `${id.value}_stop`,
            "name": props2.name || id.value,
            "disabled": !!props2.disabled,
            "readonly": !!props2.readonly,
            "tabindex": "-1",
            "value": model.value[1]
          }, null), createVNode(VSliderTrack, {
            "ref": trackContainerRef,
            "start": trackStart.value,
            "stop": trackStop.value
          }, {
            "tick-label": slots["tick-label"]
          }), createVNode(VSliderThumb, {
            "ref": startThumbRef,
            "aria-describedby": messagesId.value,
            "focused": isFocused && activeThumbRef.value === ((_a2 = startThumbRef.value) == null ? void 0 : _a2.$el),
            "modelValue": model.value[0],
            "onUpdate:modelValue": (v2) => model.value = [v2, model.value[1]],
            "onFocus": (e) => {
              var _a3, _b2, _c, _d;
              focus();
              activeThumbRef.value = (_a3 = startThumbRef.value) == null ? void 0 : _a3.$el;
              if (model.value[0] === model.value[1] && model.value[1] === min.value && e.relatedTarget !== ((_b2 = stopThumbRef.value) == null ? void 0 : _b2.$el)) {
                (_c = startThumbRef.value) == null ? void 0 : _c.$el.blur();
                (_d = stopThumbRef.value) == null ? void 0 : _d.$el.focus();
              }
            },
            "onBlur": () => {
              blur();
              activeThumbRef.value = void 0;
            },
            "min": min.value,
            "max": model.value[1],
            "position": trackStart.value
          }, {
            "thumb-label": slots["thumb-label"]
          }), createVNode(VSliderThumb, {
            "ref": stopThumbRef,
            "aria-describedby": messagesId.value,
            "focused": isFocused && activeThumbRef.value === ((_b = stopThumbRef.value) == null ? void 0 : _b.$el),
            "modelValue": model.value[1],
            "onUpdate:modelValue": (v2) => model.value = [model.value[0], v2],
            "onFocus": (e) => {
              var _a3, _b2, _c, _d;
              focus();
              activeThumbRef.value = (_a3 = stopThumbRef.value) == null ? void 0 : _a3.$el;
              if (model.value[0] === model.value[1] && model.value[0] === max2.value && e.relatedTarget !== ((_b2 = startThumbRef.value) == null ? void 0 : _b2.$el)) {
                (_c = stopThumbRef.value) == null ? void 0 : _c.$el.blur();
                (_d = startThumbRef.value) == null ? void 0 : _d.$el.focus();
              }
            },
            "onBlur": () => {
              blur();
              activeThumbRef.value = void 0;
            },
            "min": model.value[0],
            "max": max2.value,
            "position": trackStop.value
          }, {
            "thumb-label": slots["thumb-label"]
          })]);
        }
      });
    });
    return {};
  }
});
const VRating$1 = "";
const makeVRatingProps = propsFactory({
  name: String,
  itemAriaLabel: {
    type: String,
    default: "$vuetify.rating.ariaLabel.item"
  },
  activeColor: String,
  color: String,
  clearable: Boolean,
  disabled: Boolean,
  emptyIcon: {
    type: IconValue,
    default: "$ratingEmpty"
  },
  fullIcon: {
    type: IconValue,
    default: "$ratingFull"
  },
  halfIncrements: Boolean,
  hover: Boolean,
  length: {
    type: [Number, String],
    default: 5
  },
  readonly: Boolean,
  modelValue: {
    type: [Number, String],
    default: 0
  },
  itemLabels: Array,
  itemLabelPosition: {
    type: String,
    default: "top",
    validator: (v2) => ["top", "bottom"].includes(v2)
  },
  ripple: Boolean,
  ...makeComponentProps(),
  ...makeDensityProps(),
  ...makeSizeProps(),
  ...makeTagProps(),
  ...makeThemeProps()
}, "VRating");
const VRating = genericComponent()({
  name: "VRating",
  props: makeVRatingProps(),
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      t
    } = useLocale();
    const {
      themeClasses
    } = provideTheme(props2);
    const rating = useProxiedModel(props2, "modelValue");
    const normalizedValue = computed(() => clamp(parseFloat(rating.value), 0, +props2.length));
    const range = computed(() => createRange(Number(props2.length), 1));
    const increments = computed(() => range.value.flatMap((v2) => props2.halfIncrements ? [v2 - 0.5, v2] : [v2]));
    const hoverIndex = shallowRef(-1);
    const itemState = computed(() => increments.value.map((value) => {
      const isHovering = props2.hover && hoverIndex.value > -1;
      const isFilled = normalizedValue.value >= value;
      const isHovered = hoverIndex.value >= value;
      const isFullIcon = isHovering ? isHovered : isFilled;
      const icon = isFullIcon ? props2.fullIcon : props2.emptyIcon;
      const activeColor = props2.activeColor ?? props2.color;
      const color = isFilled || isHovered ? activeColor : props2.color;
      return {
        isFilled,
        isHovered,
        icon,
        color
      };
    }));
    const eventState = computed(() => [0, ...increments.value].map((value) => {
      function onMouseenter() {
        hoverIndex.value = value;
      }
      function onMouseleave() {
        hoverIndex.value = -1;
      }
      function onClick() {
        if (props2.disabled || props2.readonly)
          return;
        rating.value = normalizedValue.value === value && props2.clearable ? 0 : value;
      }
      return {
        onMouseenter: props2.hover ? onMouseenter : void 0,
        onMouseleave: props2.hover ? onMouseleave : void 0,
        onClick
      };
    }));
    const name = computed(() => props2.name ?? `v-rating-${getUid()}`);
    function VRatingItem(_ref2) {
      var _a2, _b;
      let {
        value,
        index: index2,
        showStar = true
      } = _ref2;
      const {
        onMouseenter,
        onMouseleave,
        onClick
      } = eventState.value[index2 + 1];
      const id = `${name.value}-${String(value).replace(".", "-")}`;
      const btnProps = {
        color: (_a2 = itemState.value[index2]) == null ? void 0 : _a2.color,
        density: props2.density,
        disabled: props2.disabled,
        icon: (_b = itemState.value[index2]) == null ? void 0 : _b.icon,
        ripple: props2.ripple,
        size: props2.size,
        variant: "plain"
      };
      return createVNode(Fragment, null, [createVNode("label", {
        "for": id,
        "class": {
          "v-rating__item--half": props2.halfIncrements && value % 1 > 0,
          "v-rating__item--full": props2.halfIncrements && value % 1 === 0
        },
        "onMouseenter": onMouseenter,
        "onMouseleave": onMouseleave,
        "onClick": onClick
      }, [createVNode("span", {
        "class": "v-rating__hidden"
      }, [t(props2.itemAriaLabel, value, props2.length)]), !showStar ? void 0 : slots.item ? slots.item({
        ...itemState.value[index2],
        props: btnProps,
        value,
        index: index2,
        rating: normalizedValue.value
      }) : createVNode(VBtn, mergeProps({
        "aria-label": t(props2.itemAriaLabel, value, props2.length)
      }, btnProps), null)]), createVNode("input", {
        "class": "v-rating__hidden",
        "name": name.value,
        "id": id,
        "type": "radio",
        "value": value,
        "checked": normalizedValue.value === value,
        "tabindex": -1,
        "readonly": props2.readonly,
        "disabled": props2.disabled
      }, null)]);
    }
    function createLabel(labelProps) {
      if (slots["item-label"])
        return slots["item-label"](labelProps);
      if (labelProps.label)
        return createVNode("span", null, [labelProps.label]);
      return createVNode("span", null, [createTextVNode(" ")]);
    }
    useRender(() => {
      var _a2;
      const hasLabels = !!((_a2 = props2.itemLabels) == null ? void 0 : _a2.length) || slots["item-label"];
      return createVNode(props2.tag, {
        "class": ["v-rating", {
          "v-rating--hover": props2.hover,
          "v-rating--readonly": props2.readonly
        }, themeClasses.value, props2.class],
        "style": props2.style
      }, {
        default: () => [createVNode(VRatingItem, {
          "value": 0,
          "index": -1,
          "showStar": false
        }, null), range.value.map((value, i) => {
          var _a3, _b;
          return createVNode("div", {
            "class": "v-rating__wrapper"
          }, [hasLabels && props2.itemLabelPosition === "top" ? createLabel({
            value,
            index: i,
            label: (_a3 = props2.itemLabels) == null ? void 0 : _a3[i]
          }) : void 0, createVNode("div", {
            "class": "v-rating__item"
          }, [props2.halfIncrements ? createVNode(Fragment, null, [createVNode(VRatingItem, {
            "value": value - 0.5,
            "index": i * 2
          }, null), createVNode(VRatingItem, {
            "value": value,
            "index": i * 2 + 1
          }, null)]) : createVNode(VRatingItem, {
            "value": value,
            "index": i
          }, null)]), hasLabels && props2.itemLabelPosition === "bottom" ? createLabel({
            value,
            index: i,
            label: (_b = props2.itemLabels) == null ? void 0 : _b[i]
          }) : void 0]);
        })]
      });
    });
    return {};
  }
});
const VSlideGroup$1 = "";
function bias(val) {
  const c2 = 0.501;
  const x2 = Math.abs(val);
  return Math.sign(val) * (x2 / ((1 / c2 - 2) * (1 - x2) + 1));
}
function calculateUpdatedOffset(_ref) {
  let {
    selectedElement,
    containerSize,
    contentSize,
    isRtl,
    currentScrollOffset,
    isHorizontal
  } = _ref;
  const clientSize = isHorizontal ? selectedElement.clientWidth : selectedElement.clientHeight;
  const offsetStart = isHorizontal ? selectedElement.offsetLeft : selectedElement.offsetTop;
  const adjustedOffsetStart = isRtl && isHorizontal ? contentSize - offsetStart - clientSize : offsetStart;
  const totalSize = containerSize + currentScrollOffset;
  const itemOffset = clientSize + adjustedOffsetStart;
  const additionalOffset = clientSize * 0.4;
  if (adjustedOffsetStart <= currentScrollOffset) {
    currentScrollOffset = Math.max(adjustedOffsetStart - additionalOffset, 0);
  } else if (totalSize <= itemOffset) {
    currentScrollOffset = Math.min(currentScrollOffset - (totalSize - itemOffset - additionalOffset), contentSize - containerSize);
  }
  return currentScrollOffset;
}
function calculateCenteredOffset(_ref2) {
  let {
    selectedElement,
    containerSize,
    contentSize,
    isRtl,
    isHorizontal
  } = _ref2;
  const clientSize = isHorizontal ? selectedElement.clientWidth : selectedElement.clientHeight;
  const offsetStart = isHorizontal ? selectedElement.offsetLeft : selectedElement.offsetTop;
  const offsetCentered = isRtl && isHorizontal ? contentSize - offsetStart - clientSize / 2 - containerSize / 2 : offsetStart + clientSize / 2 - containerSize / 2;
  return Math.min(contentSize - containerSize, Math.max(0, offsetCentered));
}
const VSlideGroupSymbol = Symbol.for("vuetify:v-slide-group");
const makeVSlideGroupProps = propsFactory({
  centerActive: Boolean,
  direction: {
    type: String,
    default: "horizontal"
  },
  symbol: {
    type: null,
    default: VSlideGroupSymbol
  },
  nextIcon: {
    type: IconValue,
    default: "$next"
  },
  prevIcon: {
    type: IconValue,
    default: "$prev"
  },
  showArrows: {
    type: [Boolean, String],
    validator: (v2) => typeof v2 === "boolean" || ["always", "desktop", "mobile"].includes(v2)
  },
  ...makeComponentProps(),
  ...makeTagProps(),
  ...makeGroupProps({
    selectedClass: "v-slide-group-item--active"
  })
}, "VSlideGroup");
const VSlideGroup = genericComponent()({
  name: "VSlideGroup",
  props: makeVSlideGroupProps(),
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      isRtl
    } = useRtl();
    const {
      mobile
    } = useDisplay();
    const group = useGroup(props2, props2.symbol);
    const isOverflowing = shallowRef(false);
    const scrollOffset = shallowRef(0);
    const containerSize = shallowRef(0);
    const contentSize = shallowRef(0);
    const isHorizontal = computed(() => props2.direction === "horizontal");
    const {
      resizeRef: containerRef,
      contentRect: containerRect
    } = useResizeObserver();
    const {
      resizeRef: contentRef,
      contentRect
    } = useResizeObserver();
    const firstSelectedIndex = computed(() => {
      if (!group.selected.value.length)
        return -1;
      return group.items.value.findIndex((item) => item.id === group.selected.value[0]);
    });
    const lastSelectedIndex = computed(() => {
      if (!group.selected.value.length)
        return -1;
      return group.items.value.findIndex((item) => item.id === group.selected.value[group.selected.value.length - 1]);
    });
    if (IN_BROWSER) {
      let frame = -1;
      watch(() => [group.selected.value, containerRect.value, contentRect.value, isHorizontal.value], () => {
        cancelAnimationFrame(frame);
        frame = requestAnimationFrame(() => {
          if (containerRect.value && contentRect.value) {
            const sizeProperty = isHorizontal.value ? "width" : "height";
            containerSize.value = containerRect.value[sizeProperty];
            contentSize.value = contentRect.value[sizeProperty];
            isOverflowing.value = containerSize.value + 1 < contentSize.value;
          }
          if (firstSelectedIndex.value >= 0 && contentRef.value) {
            const selectedElement = contentRef.value.children[lastSelectedIndex.value];
            if (firstSelectedIndex.value === 0 || !isOverflowing.value) {
              scrollOffset.value = 0;
            } else if (props2.centerActive) {
              scrollOffset.value = calculateCenteredOffset({
                selectedElement,
                containerSize: containerSize.value,
                contentSize: contentSize.value,
                isRtl: isRtl.value,
                isHorizontal: isHorizontal.value
              });
            } else if (isOverflowing.value) {
              scrollOffset.value = calculateUpdatedOffset({
                selectedElement,
                containerSize: containerSize.value,
                contentSize: contentSize.value,
                isRtl: isRtl.value,
                currentScrollOffset: scrollOffset.value,
                isHorizontal: isHorizontal.value
              });
            }
          }
        });
      });
    }
    const disableTransition = shallowRef(false);
    let startTouch = 0;
    let startOffset = 0;
    function onTouchstart(e) {
      const sizeProperty = isHorizontal.value ? "clientX" : "clientY";
      const sign2 = isRtl.value && isHorizontal.value ? -1 : 1;
      startOffset = sign2 * scrollOffset.value;
      startTouch = e.touches[0][sizeProperty];
      disableTransition.value = true;
    }
    function onTouchmove(e) {
      if (!isOverflowing.value)
        return;
      const sizeProperty = isHorizontal.value ? "clientX" : "clientY";
      const sign2 = isRtl.value && isHorizontal.value ? -1 : 1;
      scrollOffset.value = sign2 * (startOffset + startTouch - e.touches[0][sizeProperty]);
    }
    function onTouchend(e) {
      const maxScrollOffset = contentSize.value - containerSize.value;
      if (scrollOffset.value < 0 || !isOverflowing.value) {
        scrollOffset.value = 0;
      } else if (scrollOffset.value >= maxScrollOffset) {
        scrollOffset.value = maxScrollOffset;
      }
      disableTransition.value = false;
    }
    function onScroll() {
      if (!containerRef.value)
        return;
      containerRef.value[isHorizontal.value ? "scrollLeft" : "scrollTop"] = 0;
    }
    const isFocused = shallowRef(false);
    function onFocusin(e) {
      isFocused.value = true;
      if (!isOverflowing.value || !contentRef.value)
        return;
      for (const el of e.composedPath()) {
        for (const item of contentRef.value.children) {
          if (item === el) {
            scrollOffset.value = calculateUpdatedOffset({
              selectedElement: item,
              containerSize: containerSize.value,
              contentSize: contentSize.value,
              isRtl: isRtl.value,
              currentScrollOffset: scrollOffset.value,
              isHorizontal: isHorizontal.value
            });
            return;
          }
        }
      }
    }
    function onFocusout(e) {
      isFocused.value = false;
    }
    function onFocus(e) {
      var _a2;
      if (!isFocused.value && !(e.relatedTarget && ((_a2 = contentRef.value) == null ? void 0 : _a2.contains(e.relatedTarget))))
        focus();
    }
    function onKeydown(e) {
      if (!contentRef.value)
        return;
      if (isHorizontal.value) {
        if (e.key === "ArrowRight") {
          focus(isRtl.value ? "prev" : "next");
        } else if (e.key === "ArrowLeft") {
          focus(isRtl.value ? "next" : "prev");
        }
      } else {
        if (e.key === "ArrowDown") {
          focus("next");
        } else if (e.key === "ArrowUp") {
          focus("prev");
        }
      }
      if (e.key === "Home") {
        focus("first");
      } else if (e.key === "End") {
        focus("last");
      }
    }
    function focus(location2) {
      var _a2, _b, _c, _d, _e;
      if (!contentRef.value)
        return;
      if (!location2) {
        const focusable = focusableChildren(contentRef.value);
        (_a2 = focusable[0]) == null ? void 0 : _a2.focus();
      } else if (location2 === "next") {
        const el = (_b = contentRef.value.querySelector(":focus")) == null ? void 0 : _b.nextElementSibling;
        if (el)
          el.focus();
        else
          focus("first");
      } else if (location2 === "prev") {
        const el = (_c = contentRef.value.querySelector(":focus")) == null ? void 0 : _c.previousElementSibling;
        if (el)
          el.focus();
        else
          focus("last");
      } else if (location2 === "first") {
        (_d = contentRef.value.firstElementChild) == null ? void 0 : _d.focus();
      } else if (location2 === "last") {
        (_e = contentRef.value.lastElementChild) == null ? void 0 : _e.focus();
      }
    }
    function scrollTo(location2) {
      const newAbsoluteOffset = scrollOffset.value + (location2 === "prev" ? -1 : 1) * containerSize.value;
      scrollOffset.value = clamp(newAbsoluteOffset, 0, contentSize.value - containerSize.value);
    }
    const contentStyles = computed(() => {
      let scrollAmount = scrollOffset.value > contentSize.value - containerSize.value ? -(contentSize.value - containerSize.value) + bias(contentSize.value - containerSize.value - scrollOffset.value) : -scrollOffset.value;
      if (scrollOffset.value <= 0) {
        scrollAmount = bias(-scrollOffset.value);
      }
      const sign2 = isRtl.value && isHorizontal.value ? -1 : 1;
      return {
        transform: `translate${isHorizontal.value ? "X" : "Y"}(${sign2 * scrollAmount}px)`,
        transition: disableTransition.value ? "none" : "",
        willChange: disableTransition.value ? "transform" : ""
      };
    });
    const slotProps = computed(() => ({
      next: group.next,
      prev: group.prev,
      select: group.select,
      isSelected: group.isSelected
    }));
    const hasAffixes = computed(() => {
      switch (props2.showArrows) {
        case "always":
          return true;
        case "desktop":
          return !mobile.value;
        case true:
          return isOverflowing.value || Math.abs(scrollOffset.value) > 0;
        case "mobile":
          return mobile.value || isOverflowing.value || Math.abs(scrollOffset.value) > 0;
        default:
          return !mobile.value && (isOverflowing.value || Math.abs(scrollOffset.value) > 0);
      }
    });
    const hasPrev = computed(() => {
      return Math.abs(scrollOffset.value) > 0;
    });
    const hasNext = computed(() => {
      return contentSize.value > Math.abs(scrollOffset.value) + containerSize.value;
    });
    useRender(() => createVNode(props2.tag, {
      "class": ["v-slide-group", {
        "v-slide-group--vertical": !isHorizontal.value,
        "v-slide-group--has-affixes": hasAffixes.value,
        "v-slide-group--is-overflowing": isOverflowing.value
      }, props2.class],
      "style": props2.style,
      "tabindex": isFocused.value || group.selected.value.length ? -1 : 0,
      "onFocus": onFocus
    }, {
      default: () => {
        var _a2, _b, _c;
        return [hasAffixes.value && createVNode("div", {
          "key": "prev",
          "class": ["v-slide-group__prev", {
            "v-slide-group__prev--disabled": !hasPrev.value
          }],
          "onClick": () => scrollTo("prev")
        }, [((_a2 = slots.prev) == null ? void 0 : _a2.call(slots, slotProps.value)) ?? createVNode(VFadeTransition, null, {
          default: () => [createVNode(VIcon, {
            "icon": isRtl.value ? props2.nextIcon : props2.prevIcon
          }, null)]
        })]), createVNode("div", {
          "key": "container",
          "ref": containerRef,
          "class": "v-slide-group__container",
          "onScroll": onScroll
        }, [createVNode("div", {
          "ref": contentRef,
          "class": "v-slide-group__content",
          "style": contentStyles.value,
          "onTouchstartPassive": onTouchstart,
          "onTouchmovePassive": onTouchmove,
          "onTouchendPassive": onTouchend,
          "onFocusin": onFocusin,
          "onFocusout": onFocusout,
          "onKeydown": onKeydown
        }, [(_b = slots.default) == null ? void 0 : _b.call(slots, slotProps.value)])]), hasAffixes.value && createVNode("div", {
          "key": "next",
          "class": ["v-slide-group__next", {
            "v-slide-group__next--disabled": !hasNext.value
          }],
          "onClick": () => scrollTo("next")
        }, [((_c = slots.next) == null ? void 0 : _c.call(slots, slotProps.value)) ?? createVNode(VFadeTransition, null, {
          default: () => [createVNode(VIcon, {
            "icon": isRtl.value ? props2.prevIcon : props2.nextIcon
          }, null)]
        })])];
      }
    }));
    return {
      selected: group.selected,
      scrollTo,
      scrollOffset,
      focus
    };
  }
});
const VSlideGroupItem = genericComponent()({
  name: "VSlideGroupItem",
  props: makeGroupItemProps(),
  emits: {
    "group:selected": (val) => true
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const slideGroupItem = useGroupItem(props2, VSlideGroupSymbol);
    return () => {
      var _a2;
      return (_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
        isSelected: slideGroupItem.isSelected.value,
        select: slideGroupItem.select,
        toggle: slideGroupItem.toggle,
        selectedClass: slideGroupItem.selectedClass.value
      });
    };
  }
});
const VSnackbar$1 = "";
const makeVSnackbarProps = propsFactory({
  multiLine: Boolean,
  timeout: {
    type: [Number, String],
    default: 5e3
  },
  vertical: Boolean,
  ...makeLocationProps({
    location: "bottom"
  }),
  ...makePositionProps(),
  ...makeRoundedProps(),
  ...makeVariantProps(),
  ...makeThemeProps(),
  ...omit(makeVOverlayProps({
    transition: "v-snackbar-transition"
  }), ["persistent", "noClickAnimation", "scrim", "scrollStrategy"])
}, "VSnackbar");
const VSnackbar = genericComponent()({
  name: "VSnackbar",
  props: makeVSnackbarProps(),
  emits: {
    "update:modelValue": (v2) => true
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const isActive = useProxiedModel(props2, "modelValue");
    const {
      locationStyles
    } = useLocation(props2);
    const {
      positionClasses
    } = usePosition(props2);
    const {
      scopeId
    } = useScopeId();
    const {
      themeClasses
    } = provideTheme(props2);
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(props2);
    const {
      roundedClasses
    } = useRounded(props2);
    const overlay = ref();
    watch(isActive, startTimeout);
    watch(() => props2.timeout, startTimeout);
    onMounted(() => {
      if (isActive.value)
        startTimeout();
    });
    let activeTimeout = -1;
    function startTimeout() {
      window.clearTimeout(activeTimeout);
      const timeout = Number(props2.timeout);
      if (!isActive.value || timeout === -1)
        return;
      activeTimeout = window.setTimeout(() => {
        isActive.value = false;
      }, timeout);
    }
    function onPointerenter() {
      window.clearTimeout(activeTimeout);
    }
    useRender(() => {
      const [overlayProps] = VOverlay.filterProps(props2);
      return createVNode(VOverlay, mergeProps({
        "ref": overlay,
        "class": ["v-snackbar", {
          "v-snackbar--active": isActive.value,
          "v-snackbar--multi-line": props2.multiLine && !props2.vertical,
          "v-snackbar--vertical": props2.vertical
        }, positionClasses.value, props2.class],
        "style": props2.style
      }, overlayProps, {
        "modelValue": isActive.value,
        "onUpdate:modelValue": ($event) => isActive.value = $event,
        "contentProps": mergeProps({
          class: ["v-snackbar__wrapper", themeClasses.value, colorClasses.value, roundedClasses.value, variantClasses.value],
          style: [locationStyles.value, colorStyles.value],
          onPointerenter,
          onPointerleave: startTimeout
        }, overlayProps.contentProps),
        "persistent": true,
        "noClickAnimation": true,
        "scrim": false,
        "scrollStrategy": "none",
        "_disableGlobalStack": true
      }, scopeId), {
        default: () => [genOverlays(false, "v-snackbar"), slots.default && createVNode("div", {
          "class": "v-snackbar__content",
          "role": "status",
          "aria-live": "polite"
        }, [slots.default()]), slots.actions && createVNode(VDefaultsProvider, {
          "defaults": {
            VBtn: {
              variant: "text",
              ripple: false
            }
          }
        }, {
          default: () => [createVNode("div", {
            "class": "v-snackbar__actions"
          }, [slots.actions()])]
        })],
        activator: slots.activator
      });
    });
    return forwardRefs({}, overlay);
  }
});
const VSwitch$1 = "";
const makeVSwitchProps = propsFactory({
  indeterminate: Boolean,
  inset: Boolean,
  flat: Boolean,
  loading: {
    type: [Boolean, String],
    default: false
  },
  ...makeVInputProps(),
  ...makeVSelectionControlProps()
}, "VSwitch");
const VSwitch = genericComponent()({
  name: "VSwitch",
  inheritAttrs: false,
  props: makeVSwitchProps(),
  emits: {
    "update:focused": (focused) => true,
    "update:modelValue": () => true,
    "update:indeterminate": (val) => true
  },
  setup(props2, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const indeterminate = useProxiedModel(props2, "indeterminate");
    const model = useProxiedModel(props2, "modelValue");
    const {
      loaderClasses
    } = useLoader(props2);
    const {
      isFocused,
      focus,
      blur
    } = useFocus(props2);
    const control = ref();
    const loaderColor = computed(() => {
      return typeof props2.loading === "string" && props2.loading !== "" ? props2.loading : props2.color;
    });
    const uid2 = getUid();
    const id = computed(() => props2.id || `switch-${uid2}`);
    function onChange() {
      if (indeterminate.value) {
        indeterminate.value = false;
      }
    }
    function onTrackClick(e) {
      var _a2, _b;
      e.stopPropagation();
      e.preventDefault();
      (_b = (_a2 = control.value) == null ? void 0 : _a2.input) == null ? void 0 : _b.click();
    }
    useRender(() => {
      const [rootAttrs, controlAttrs] = filterInputAttrs(attrs);
      const [inputProps, _1] = VInput.filterProps(props2);
      const [controlProps, _2] = VSelectionControl.filterProps(props2);
      return createVNode(VInput, mergeProps({
        "class": ["v-switch", {
          "v-switch--inset": props2.inset
        }, {
          "v-switch--indeterminate": indeterminate.value
        }, loaderClasses.value, props2.class],
        "style": props2.style
      }, rootAttrs, inputProps, {
        "id": id.value,
        "focused": isFocused.value
      }), {
        ...slots,
        default: (_ref2) => {
          let {
            id: id2,
            messagesId,
            isDisabled,
            isReadonly: isReadonly2,
            isValid: isValid2
          } = _ref2;
          return createVNode(VSelectionControl, mergeProps({
            "ref": control
          }, controlProps, {
            "modelValue": model.value,
            "onUpdate:modelValue": [($event) => model.value = $event, onChange],
            "id": id2.value,
            "aria-describedby": messagesId.value,
            "type": "checkbox",
            "aria-checked": indeterminate.value ? "mixed" : void 0,
            "disabled": isDisabled.value,
            "readonly": isReadonly2.value,
            "onFocus": focus,
            "onBlur": blur
          }, controlAttrs), {
            ...slots,
            default: (_ref3) => {
              let {
                backgroundColorClasses,
                backgroundColorStyles
              } = _ref3;
              return createVNode("div", {
                "class": ["v-switch__track", ...backgroundColorClasses.value],
                "style": backgroundColorStyles.value,
                "onClick": onTrackClick
              }, null);
            },
            input: (_ref4) => {
              let {
                inputNode,
                icon,
                backgroundColorClasses,
                backgroundColorStyles
              } = _ref4;
              return createVNode(Fragment, null, [inputNode, createVNode("div", {
                "class": ["v-switch__thumb", {
                  "v-switch__thumb--filled": icon || props2.loading
                }, props2.inset ? void 0 : backgroundColorClasses.value],
                "style": props2.inset ? void 0 : backgroundColorStyles.value
              }, [createVNode(VScaleTransition, null, {
                default: () => [!props2.loading ? icon && createVNode(VIcon, {
                  "key": icon,
                  "icon": icon,
                  "size": "x-small"
                }, null) : createVNode(LoaderSlot, {
                  "name": "v-switch",
                  "active": true,
                  "color": isValid2.value === false ? void 0 : loaderColor.value
                }, {
                  default: (slotProps) => slots.loader ? slots.loader(slotProps) : createVNode(VProgressCircular, {
                    "active": slotProps.isActive,
                    "color": slotProps.color,
                    "indeterminate": true,
                    "size": "16",
                    "width": "2"
                  }, null)
                })]
              })])]);
            }
          });
        }
      });
    });
    return {};
  }
});
const VSystemBar$1 = "";
const makeVSystemBarProps = propsFactory({
  color: String,
  height: [Number, String],
  window: Boolean,
  ...makeComponentProps(),
  ...makeElevationProps(),
  ...makeLayoutItemProps(),
  ...makeRoundedProps(),
  ...makeTagProps(),
  ...makeThemeProps()
}, "VSystemBar");
const VSystemBar = genericComponent()({
  name: "VSystemBar",
  props: makeVSystemBarProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props2);
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props2, "color"));
    const {
      elevationClasses
    } = useElevation(props2);
    const {
      roundedClasses
    } = useRounded(props2);
    const {
      ssrBootStyles
    } = useSsrBoot();
    const height = computed(() => props2.height ?? (props2.window ? 32 : 24));
    const {
      layoutItemStyles
    } = useLayoutItem({
      id: props2.name,
      order: computed(() => parseInt(props2.order, 10)),
      position: shallowRef("top"),
      layoutSize: height,
      elementSize: height,
      active: computed(() => true),
      absolute: toRef(props2, "absolute")
    });
    useRender(() => createVNode(props2.tag, {
      "class": ["v-system-bar", {
        "v-system-bar--window": props2.window
      }, themeClasses.value, backgroundColorClasses.value, elevationClasses.value, roundedClasses.value, props2.class],
      "style": [backgroundColorStyles.value, layoutItemStyles.value, ssrBootStyles.value, props2.style]
    }, slots));
    return {};
  }
});
const VTabs$1 = "";
const VTab$1 = "";
const VTabsSymbol = Symbol.for("vuetify:v-tabs");
const makeVTabProps = propsFactory({
  fixed: Boolean,
  sliderColor: String,
  hideSlider: Boolean,
  direction: {
    type: String,
    default: "horizontal"
  },
  ...omit(makeVBtnProps({
    selectedClass: "v-tab--selected",
    variant: "text"
  }), ["active", "block", "flat", "location", "position", "symbol"])
}, "VTab");
const VTab = genericComponent()({
  name: "VTab",
  props: makeVTabProps(),
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const {
      textColorClasses: sliderColorClasses,
      textColorStyles: sliderColorStyles
    } = useTextColor(props2, "sliderColor");
    const isHorizontal = computed(() => props2.direction === "horizontal");
    const isSelected = shallowRef(false);
    const rootEl2 = ref();
    const sliderEl = ref();
    function updateSlider(_ref2) {
      var _a2, _b;
      let {
        value
      } = _ref2;
      isSelected.value = value;
      if (value) {
        const prevEl = (_b = (_a2 = rootEl2.value) == null ? void 0 : _a2.$el.parentElement) == null ? void 0 : _b.querySelector(".v-tab--selected .v-tab__slider");
        const nextEl2 = sliderEl.value;
        if (!prevEl || !nextEl2)
          return;
        const color = getComputedStyle(prevEl).color;
        const prevBox = prevEl.getBoundingClientRect();
        const nextBox = nextEl2.getBoundingClientRect();
        const xy = isHorizontal.value ? "x" : "y";
        const XY = isHorizontal.value ? "X" : "Y";
        const rightBottom = isHorizontal.value ? "right" : "bottom";
        const widthHeight = isHorizontal.value ? "width" : "height";
        const prevPos = prevBox[xy];
        const nextPos = nextBox[xy];
        const delta2 = prevPos > nextPos ? prevBox[rightBottom] - nextBox[rightBottom] : prevBox[xy] - nextBox[xy];
        const origin = Math.sign(delta2) > 0 ? isHorizontal.value ? "right" : "bottom" : Math.sign(delta2) < 0 ? isHorizontal.value ? "left" : "top" : "center";
        const size2 = Math.abs(delta2) + (Math.sign(delta2) < 0 ? prevBox[widthHeight] : nextBox[widthHeight]);
        const scale = size2 / Math.max(prevBox[widthHeight], nextBox[widthHeight]) || 0;
        const initialScale = prevBox[widthHeight] / nextBox[widthHeight] || 0;
        const sigma = 1.5;
        animate(nextEl2, {
          backgroundColor: [color, "currentcolor"],
          transform: [`translate${XY}(${delta2}px) scale${XY}(${initialScale})`, `translate${XY}(${delta2 / sigma}px) scale${XY}(${(scale - 1) / sigma + 1})`, "none"],
          transformOrigin: Array(3).fill(origin)
        }, {
          duration: 225,
          easing: standardEasing
        });
      }
    }
    useRender(() => {
      const [btnProps] = VBtn.filterProps(props2);
      return createVNode(VBtn, mergeProps({
        "symbol": VTabsSymbol,
        "ref": rootEl2,
        "class": ["v-tab", props2.class],
        "style": props2.style,
        "tabindex": isSelected.value ? 0 : -1,
        "role": "tab",
        "aria-selected": String(isSelected.value),
        "active": false
      }, btnProps, attrs, {
        "block": props2.fixed,
        "maxWidth": props2.fixed ? 300 : void 0,
        "onGroup:selected": updateSlider
      }), {
        default: () => {
          var _a2;
          return [((_a2 = slots.default) == null ? void 0 : _a2.call(slots)) ?? props2.text, !props2.hideSlider && createVNode("div", {
            "ref": sliderEl,
            "class": ["v-tab__slider", sliderColorClasses.value],
            "style": sliderColorStyles.value
          }, null)];
        }
      });
    });
    return {};
  }
});
function parseItems(items) {
  if (!items)
    return [];
  return items.map((item) => {
    if (!isObject(item))
      return {
        text: item,
        value: item
      };
    return item;
  });
}
const makeVTabsProps = propsFactory({
  alignTabs: {
    type: String,
    default: "start"
  },
  color: String,
  fixedTabs: Boolean,
  items: {
    type: Array,
    default: () => []
  },
  stacked: Boolean,
  bgColor: String,
  grow: Boolean,
  height: {
    type: [Number, String],
    default: void 0
  },
  hideSlider: Boolean,
  sliderColor: String,
  ...makeVSlideGroupProps({
    mandatory: "force"
  }),
  ...makeDensityProps(),
  ...makeTagProps()
}, "VTabs");
const VTabs = genericComponent()({
  name: "VTabs",
  props: makeVTabsProps(),
  emits: {
    "update:modelValue": (v2) => true
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const model = useProxiedModel(props2, "modelValue");
    const parsedItems = computed(() => parseItems(props2.items));
    const {
      densityClasses
    } = useDensity(props2);
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props2, "bgColor"));
    provideDefaults({
      VTab: {
        color: toRef(props2, "color"),
        direction: toRef(props2, "direction"),
        stacked: toRef(props2, "stacked"),
        fixed: toRef(props2, "fixedTabs"),
        sliderColor: toRef(props2, "sliderColor"),
        hideSlider: toRef(props2, "hideSlider")
      }
    });
    useRender(() => {
      const [slideGroupProps] = VSlideGroup.filterProps(props2);
      return createVNode(VSlideGroup, mergeProps(slideGroupProps, {
        "modelValue": model.value,
        "onUpdate:modelValue": ($event) => model.value = $event,
        "class": ["v-tabs", `v-tabs--${props2.direction}`, `v-tabs--align-tabs-${props2.alignTabs}`, {
          "v-tabs--fixed-tabs": props2.fixedTabs,
          "v-tabs--grow": props2.grow,
          "v-tabs--stacked": props2.stacked
        }, densityClasses.value, backgroundColorClasses.value, props2.class],
        "style": [{
          "--v-tabs-height": convertToUnit(props2.height)
        }, backgroundColorStyles.value, props2.style],
        "role": "tablist",
        "symbol": VTabsSymbol
      }), {
        default: () => [slots.default ? slots.default() : parsedItems.value.map((item) => createVNode(VTab, mergeProps(item, {
          "key": item.text
        }), null))]
      });
    });
    return {};
  }
});
const VTable$1 = "";
const makeVTableProps = propsFactory({
  fixedHeader: Boolean,
  fixedFooter: Boolean,
  height: [Number, String],
  hover: Boolean,
  ...makeComponentProps(),
  ...makeDensityProps(),
  ...makeTagProps(),
  ...makeThemeProps()
}, "VTable");
const VTable = genericComponent()({
  name: "VTable",
  props: makeVTableProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props2);
    const {
      densityClasses
    } = useDensity(props2);
    useRender(() => createVNode(props2.tag, {
      "class": ["v-table", {
        "v-table--fixed-height": !!props2.height,
        "v-table--fixed-header": props2.fixedHeader,
        "v-table--fixed-footer": props2.fixedFooter,
        "v-table--has-top": !!slots.top,
        "v-table--has-bottom": !!slots.bottom,
        "v-table--hover": props2.hover
      }, themeClasses.value, densityClasses.value, props2.class],
      "style": props2.style
    }, {
      default: () => {
        var _a2, _b, _c;
        return [(_a2 = slots.top) == null ? void 0 : _a2.call(slots), slots.default ? createVNode("div", {
          "class": "v-table__wrapper",
          "style": {
            height: convertToUnit(props2.height)
          }
        }, [createVNode("table", null, [slots.default()])]) : (_b = slots.wrapper) == null ? void 0 : _b.call(slots), (_c = slots.bottom) == null ? void 0 : _c.call(slots)];
      }
    }));
    return {};
  }
});
const VTextarea$1 = "";
const makeVTextareaProps = propsFactory({
  autoGrow: Boolean,
  autofocus: Boolean,
  counter: [Boolean, Number, String],
  counterValue: Function,
  prefix: String,
  placeholder: String,
  persistentPlaceholder: Boolean,
  persistentCounter: Boolean,
  noResize: Boolean,
  rows: {
    type: [Number, String],
    default: 5,
    validator: (v2) => !isNaN(parseFloat(v2))
  },
  maxRows: {
    type: [Number, String],
    validator: (v2) => !isNaN(parseFloat(v2))
  },
  suffix: String,
  modelModifiers: Object,
  ...makeVInputProps(),
  ...makeVFieldProps()
}, "VTextarea");
const VTextarea = genericComponent()({
  name: "VTextarea",
  directives: {
    Intersect: Intersect$1
  },
  inheritAttrs: false,
  props: makeVTextareaProps(),
  emits: {
    "click:control": (e) => true,
    "mousedown:control": (e) => true,
    "update:focused": (focused) => true,
    "update:modelValue": (val) => true
  },
  setup(props2, _ref) {
    let {
      attrs,
      emit: emit2,
      slots
    } = _ref;
    const model = useProxiedModel(props2, "modelValue");
    const {
      isFocused,
      focus,
      blur
    } = useFocus(props2);
    const counterValue = computed(() => {
      return typeof props2.counterValue === "function" ? props2.counterValue(model.value) : (model.value || "").toString().length;
    });
    const max2 = computed(() => {
      if (attrs.maxlength)
        return attrs.maxlength;
      if (!props2.counter || typeof props2.counter !== "number" && typeof props2.counter !== "string")
        return void 0;
      return props2.counter;
    });
    function onIntersect(isIntersecting, entries) {
      var _a2, _b;
      if (!props2.autofocus || !isIntersecting)
        return;
      (_b = (_a2 = entries[0].target) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
    }
    const vInputRef = ref();
    const vFieldRef = ref();
    const controlHeight = shallowRef("");
    const textareaRef = ref();
    const isActive = computed(() => props2.persistentPlaceholder || isFocused.value || props2.active);
    function onFocus() {
      var _a2;
      if (textareaRef.value !== document.activeElement) {
        (_a2 = textareaRef.value) == null ? void 0 : _a2.focus();
      }
      if (!isFocused.value)
        focus();
    }
    function onControlClick(e) {
      onFocus();
      emit2("click:control", e);
    }
    function onControlMousedown(e) {
      emit2("mousedown:control", e);
    }
    function onClear(e) {
      e.stopPropagation();
      onFocus();
      nextTick(() => {
        model.value = "";
        callEvent(props2["onClick:clear"], e);
      });
    }
    function onInput(e) {
      var _a2;
      const el = e.target;
      model.value = el.value;
      if ((_a2 = props2.modelModifiers) == null ? void 0 : _a2.trim) {
        const caretPosition = [el.selectionStart, el.selectionEnd];
        nextTick(() => {
          el.selectionStart = caretPosition[0];
          el.selectionEnd = caretPosition[1];
        });
      }
    }
    const sizerRef = ref();
    const rows = ref(+props2.rows);
    const isPlainOrUnderlined = computed(() => ["plain", "underlined"].includes(props2.variant));
    watchEffect(() => {
      if (!props2.autoGrow)
        rows.value = +props2.rows;
    });
    function calculateInputHeight() {
      if (!props2.autoGrow)
        return;
      nextTick(() => {
        if (!sizerRef.value || !vFieldRef.value)
          return;
        const style3 = getComputedStyle(sizerRef.value);
        const fieldStyle = getComputedStyle(vFieldRef.value.$el);
        const padding = parseFloat(style3.getPropertyValue("--v-field-padding-top")) + parseFloat(style3.getPropertyValue("--v-input-padding-top")) + parseFloat(style3.getPropertyValue("--v-field-padding-bottom"));
        const height = sizerRef.value.scrollHeight;
        const lineHeight = parseFloat(style3.lineHeight);
        const minHeight = Math.max(parseFloat(props2.rows) * lineHeight + padding, parseFloat(fieldStyle.getPropertyValue("--v-input-control-height")));
        const maxHeight = parseFloat(props2.maxRows) * lineHeight + padding || Infinity;
        const newHeight = clamp(height ?? 0, minHeight, maxHeight);
        rows.value = Math.floor((newHeight - padding) / lineHeight);
        controlHeight.value = convertToUnit(newHeight);
      });
    }
    onMounted(calculateInputHeight);
    watch(model, calculateInputHeight);
    watch(() => props2.rows, calculateInputHeight);
    watch(() => props2.maxRows, calculateInputHeight);
    watch(() => props2.density, calculateInputHeight);
    let observer;
    watch(sizerRef, (val) => {
      if (val) {
        observer = new ResizeObserver(calculateInputHeight);
        observer.observe(sizerRef.value);
      } else {
        observer == null ? void 0 : observer.disconnect();
      }
    });
    onBeforeUnmount(() => {
      observer == null ? void 0 : observer.disconnect();
    });
    useRender(() => {
      const hasCounter = !!(slots.counter || props2.counter || props2.counterValue);
      const hasDetails = !!(hasCounter || slots.details);
      const [rootAttrs, inputAttrs] = filterInputAttrs(attrs);
      const [{
        modelValue: _2,
        ...inputProps
      }] = VInput.filterProps(props2);
      const [fieldProps] = filterFieldProps(props2);
      return createVNode(VInput, mergeProps({
        "ref": vInputRef,
        "modelValue": model.value,
        "onUpdate:modelValue": ($event) => model.value = $event,
        "class": ["v-textarea v-text-field", {
          "v-textarea--prefixed": props2.prefix,
          "v-textarea--suffixed": props2.suffix,
          "v-text-field--prefixed": props2.prefix,
          "v-text-field--suffixed": props2.suffix,
          "v-textarea--auto-grow": props2.autoGrow,
          "v-textarea--no-resize": props2.noResize || props2.autoGrow,
          "v-text-field--plain-underlined": isPlainOrUnderlined.value
        }, props2.class],
        "style": props2.style
      }, rootAttrs, inputProps, {
        "centerAffix": rows.value === 1 && !isPlainOrUnderlined.value,
        "focused": isFocused.value
      }), {
        ...slots,
        default: (_ref2) => {
          let {
            isDisabled,
            isDirty,
            isReadonly: isReadonly2,
            isValid: isValid2
          } = _ref2;
          return createVNode(VField, mergeProps({
            "ref": vFieldRef,
            "style": {
              "--v-textarea-control-height": controlHeight.value
            },
            "onClick": onControlClick,
            "onMousedown": onControlMousedown,
            "onClick:clear": onClear,
            "onClick:prependInner": props2["onClick:prependInner"],
            "onClick:appendInner": props2["onClick:appendInner"]
          }, fieldProps, {
            "active": isActive.value || isDirty.value,
            "centerAffix": rows.value === 1 && !isPlainOrUnderlined.value,
            "dirty": isDirty.value || props2.dirty,
            "disabled": isDisabled.value,
            "focused": isFocused.value,
            "error": isValid2.value === false
          }), {
            ...slots,
            default: (_ref3) => {
              let {
                props: {
                  class: fieldClass,
                  ...slotProps
                }
              } = _ref3;
              return createVNode(Fragment, null, [props2.prefix && createVNode("span", {
                "class": "v-text-field__prefix"
              }, [props2.prefix]), withDirectives(createVNode("textarea", mergeProps({
                "ref": textareaRef,
                "class": fieldClass,
                "value": model.value,
                "onInput": onInput,
                "autofocus": props2.autofocus,
                "readonly": isReadonly2.value,
                "disabled": isDisabled.value,
                "placeholder": props2.placeholder,
                "rows": props2.rows,
                "name": props2.name,
                "onFocus": onFocus,
                "onBlur": blur
              }, slotProps, inputAttrs), null), [[resolveDirective("intersect"), {
                handler: onIntersect
              }, null, {
                once: true
              }]]), props2.autoGrow && withDirectives(createVNode("textarea", {
                "class": [fieldClass, "v-textarea__sizer"],
                "id": `${slotProps.id}-sizer`,
                "onUpdate:modelValue": ($event) => model.value = $event,
                "ref": sizerRef,
                "readonly": true,
                "aria-hidden": "true"
              }, null), [[vModelText, model.value]]), props2.suffix && createVNode("span", {
                "class": "v-text-field__suffix"
              }, [props2.suffix])]);
            }
          });
        },
        details: hasDetails ? (slotProps) => {
          var _a2;
          return createVNode(Fragment, null, [(_a2 = slots.details) == null ? void 0 : _a2.call(slots, slotProps), hasCounter && createVNode(Fragment, null, [createVNode("span", null, null), createVNode(VCounter, {
            "active": props2.persistentCounter || isFocused.value,
            "value": counterValue.value,
            "max": max2.value
          }, slots.counter)])]);
        } : void 0
      });
    });
    return forwardRefs({}, vInputRef, vFieldRef, textareaRef);
  }
});
const VThemeProvider$1 = "";
const makeVThemeProviderProps = propsFactory({
  withBackground: Boolean,
  ...makeComponentProps(),
  ...makeThemeProps(),
  ...makeTagProps()
}, "VThemeProvider");
const VThemeProvider = genericComponent()({
  name: "VThemeProvider",
  props: makeVThemeProviderProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props2);
    return () => {
      var _a2;
      if (!props2.withBackground)
        return (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
      return createVNode(props2.tag, {
        "class": ["v-theme-provider", themeClasses.value, props2.class],
        "style": props2.style
      }, {
        default: () => {
          var _a3;
          return [(_a3 = slots.default) == null ? void 0 : _a3.call(slots)];
        }
      });
    };
  }
});
const VTimeline$1 = "";
const makeVTimelineProps = propsFactory({
  align: {
    type: String,
    default: "center",
    validator: (v2) => ["center", "start"].includes(v2)
  },
  direction: {
    type: String,
    default: "vertical",
    validator: (v2) => ["vertical", "horizontal"].includes(v2)
  },
  justify: {
    type: String,
    default: "auto",
    validator: (v2) => ["auto", "center"].includes(v2)
  },
  side: {
    type: String,
    validator: (v2) => v2 == null || ["start", "end"].includes(v2)
  },
  lineInset: {
    type: [String, Number],
    default: 0
  },
  lineThickness: {
    type: [String, Number],
    default: 2
  },
  lineColor: String,
  truncateLine: {
    type: String,
    validator: (v2) => ["start", "end", "both"].includes(v2)
  },
  ...makeComponentProps(),
  ...makeDensityProps(),
  ...makeTagProps(),
  ...makeThemeProps()
}, "VTimeline");
const VTimeline = genericComponent()({
  name: "VTimeline",
  props: makeVTimelineProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props2);
    const {
      densityClasses
    } = useDensity(props2);
    const {
      rtlClasses
    } = useRtl();
    provideDefaults({
      VTimelineDivider: {
        lineColor: toRef(props2, "lineColor")
      },
      VTimelineItem: {
        density: toRef(props2, "density"),
        lineInset: toRef(props2, "lineInset")
      }
    });
    const sideClasses = computed(() => {
      const side = props2.side ? props2.side : props2.density !== "default" ? "end" : null;
      return side && `v-timeline--side-${side}`;
    });
    const truncateClasses = computed(() => {
      const classes = ["v-timeline--truncate-line-start", "v-timeline--truncate-line-end"];
      switch (props2.truncateLine) {
        case "both":
          return classes;
        case "start":
          return classes[0];
        case "end":
          return classes[1];
        default:
          return null;
      }
    });
    useRender(() => createVNode(props2.tag, {
      "class": ["v-timeline", `v-timeline--${props2.direction}`, `v-timeline--align-${props2.align}`, `v-timeline--justify-${props2.justify}`, truncateClasses.value, {
        "v-timeline--inset-line": !!props2.lineInset
      }, themeClasses.value, densityClasses.value, sideClasses.value, rtlClasses.value, props2.class],
      "style": [{
        "--v-timeline-line-thickness": convertToUnit(props2.lineThickness)
      }, props2.style]
    }, slots));
    return {};
  }
});
const makeVTimelineDividerProps = propsFactory({
  dotColor: String,
  fillDot: Boolean,
  hideDot: Boolean,
  icon: IconValue,
  iconColor: String,
  lineColor: String,
  ...makeComponentProps(),
  ...makeRoundedProps(),
  ...makeSizeProps(),
  ...makeElevationProps()
}, "VTimelineDivider");
const VTimelineDivider = genericComponent()({
  name: "VTimelineDivider",
  props: makeVTimelineDividerProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      sizeClasses,
      sizeStyles
    } = useSize(props2, "v-timeline-divider__dot");
    const {
      backgroundColorStyles,
      backgroundColorClasses
    } = useBackgroundColor(toRef(props2, "dotColor"));
    const {
      roundedClasses
    } = useRounded(props2, "v-timeline-divider__dot");
    const {
      elevationClasses
    } = useElevation(props2);
    const {
      backgroundColorClasses: lineColorClasses,
      backgroundColorStyles: lineColorStyles
    } = useBackgroundColor(toRef(props2, "lineColor"));
    useRender(() => createVNode("div", {
      "class": ["v-timeline-divider", {
        "v-timeline-divider--fill-dot": props2.fillDot
      }, props2.class],
      "style": props2.style
    }, [createVNode("div", {
      "class": ["v-timeline-divider__before", lineColorClasses.value],
      "style": lineColorStyles.value
    }, null), !props2.hideDot && createVNode("div", {
      "key": "dot",
      "class": ["v-timeline-divider__dot", elevationClasses.value, roundedClasses.value, sizeClasses.value],
      "style": sizeStyles.value
    }, [createVNode("div", {
      "class": ["v-timeline-divider__inner-dot", backgroundColorClasses.value, roundedClasses.value],
      "style": backgroundColorStyles.value
    }, [!slots.default ? createVNode(VIcon, {
      "key": "icon",
      "color": props2.iconColor,
      "icon": props2.icon,
      "size": props2.size
    }, null) : createVNode(VDefaultsProvider, {
      "key": "icon-defaults",
      "disabled": !props2.icon,
      "defaults": {
        VIcon: {
          color: props2.iconColor,
          icon: props2.icon,
          size: props2.size
        }
      }
    }, slots.default)])]), createVNode("div", {
      "class": ["v-timeline-divider__after", lineColorClasses.value],
      "style": lineColorStyles.value
    }, null)]));
    return {};
  }
});
const makeVTimelineItemProps = propsFactory({
  density: String,
  dotColor: String,
  fillDot: Boolean,
  hideDot: Boolean,
  hideOpposite: {
    type: Boolean,
    default: void 0
  },
  icon: IconValue,
  iconColor: String,
  lineInset: [Number, String],
  ...makeComponentProps(),
  ...makeDimensionProps(),
  ...makeElevationProps(),
  ...makeRoundedProps(),
  ...makeSizeProps(),
  ...makeTagProps()
}, "VTimelineItem");
const VTimelineItem = genericComponent()({
  name: "VTimelineItem",
  props: makeVTimelineItemProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      dimensionStyles
    } = useDimension(props2);
    const dotSize = shallowRef(0);
    const dotRef = ref();
    watch(dotRef, (newValue) => {
      var _a2;
      if (!newValue)
        return;
      dotSize.value = ((_a2 = newValue.$el.querySelector(".v-timeline-divider__dot")) == null ? void 0 : _a2.getBoundingClientRect().width) ?? 0;
    }, {
      flush: "post"
    });
    useRender(() => {
      var _a2, _b;
      return createVNode("div", {
        "class": ["v-timeline-item", {
          "v-timeline-item--fill-dot": props2.fillDot
        }, props2.class],
        "style": [{
          "--v-timeline-dot-size": convertToUnit(dotSize.value),
          "--v-timeline-line-inset": props2.lineInset ? `calc(var(--v-timeline-dot-size) / 2 + ${convertToUnit(props2.lineInset)})` : convertToUnit(0)
        }, props2.style]
      }, [createVNode("div", {
        "class": "v-timeline-item__body",
        "style": dimensionStyles.value
      }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]), createVNode(VTimelineDivider, {
        "ref": dotRef,
        "hideDot": props2.hideDot,
        "icon": props2.icon,
        "iconColor": props2.iconColor,
        "size": props2.size,
        "elevation": props2.elevation,
        "dotColor": props2.dotColor,
        "fillDot": props2.fillDot,
        "rounded": props2.rounded
      }, {
        default: slots.icon
      }), props2.density !== "compact" && createVNode("div", {
        "class": "v-timeline-item__opposite"
      }, [!props2.hideOpposite && ((_b = slots.opposite) == null ? void 0 : _b.call(slots))])]);
    });
    return {};
  }
});
const makeVToolbarItemsProps = propsFactory({
  ...makeComponentProps(),
  ...makeVariantProps({
    variant: "text"
  })
}, "VToolbarItems");
const VToolbarItems = genericComponent()({
  name: "VToolbarItems",
  props: makeVToolbarItemsProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    provideDefaults({
      VBtn: {
        color: toRef(props2, "color"),
        height: "inherit",
        variant: toRef(props2, "variant")
      }
    });
    useRender(() => {
      var _a2;
      return createVNode("div", {
        "class": ["v-toolbar-items", props2.class],
        "style": props2.style
      }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
    });
    return {};
  }
});
const VTooltip$1 = "";
const makeVTooltipProps = propsFactory({
  id: String,
  text: String,
  ...omit(makeVOverlayProps({
    closeOnBack: false,
    location: "end",
    locationStrategy: "connected",
    eager: true,
    minWidth: 0,
    offset: 10,
    openOnClick: false,
    openOnHover: true,
    origin: "auto",
    scrim: false,
    scrollStrategy: "reposition",
    transition: false
  }), ["absolute", "persistent"])
}, "VTooltip");
const VTooltip = genericComponent()({
  name: "VTooltip",
  props: makeVTooltipProps(),
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const isActive = useProxiedModel(props2, "modelValue");
    const {
      scopeId
    } = useScopeId();
    const uid2 = getUid();
    const id = computed(() => props2.id || `v-tooltip-${uid2}`);
    const overlay = ref();
    const location2 = computed(() => {
      return props2.location.split(" ").length > 1 ? props2.location : props2.location + " center";
    });
    const origin = computed(() => {
      return props2.origin === "auto" || props2.origin === "overlap" || props2.origin.split(" ").length > 1 || props2.location.split(" ").length > 1 ? props2.origin : props2.origin + " center";
    });
    const transition = computed(() => {
      if (props2.transition)
        return props2.transition;
      return isActive.value ? "scale-transition" : "fade-transition";
    });
    const activatorProps = computed(() => mergeProps({
      "aria-describedby": id.value
    }, props2.activatorProps));
    useRender(() => {
      const [overlayProps] = VOverlay.filterProps(props2);
      return createVNode(VOverlay, mergeProps({
        "ref": overlay,
        "class": ["v-tooltip", props2.class],
        "style": props2.style,
        "id": id.value
      }, overlayProps, {
        "modelValue": isActive.value,
        "onUpdate:modelValue": ($event) => isActive.value = $event,
        "transition": transition.value,
        "absolute": true,
        "location": location2.value,
        "origin": origin.value,
        "persistent": true,
        "role": "tooltip",
        "activatorProps": activatorProps.value,
        "_disableGlobalStack": true
      }, scopeId), {
        activator: slots.activator,
        default: function() {
          var _a2;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return ((_a2 = slots.default) == null ? void 0 : _a2.call(slots, ...args)) ?? props2.text;
        }
      });
    });
    return forwardRefs({}, overlay);
  }
});
const VValidation = genericComponent()({
  name: "VValidation",
  props: makeValidationProps(),
  emits: {
    "update:modelValue": (val) => true
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const validation = useValidation(props2, "validation");
    return () => {
      var _a2;
      return (_a2 = slots.default) == null ? void 0 : _a2.call(slots, validation);
    };
  }
});
const components = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  VAlert,
  VAlertTitle,
  VApp,
  VAppBar,
  VAppBarNavIcon,
  VAppBarTitle,
  VAutocomplete,
  VAvatar,
  VBadge,
  VBanner,
  VBannerActions,
  VBannerText,
  VBottomNavigation,
  VBreadcrumbs,
  VBreadcrumbsDivider,
  VBreadcrumbsItem,
  VBtn,
  VBtnGroup,
  VBtnToggle,
  VCard,
  VCardActions,
  VCardItem,
  VCardSubtitle,
  VCardText,
  VCardTitle,
  VCarousel,
  VCarouselItem,
  VCheckbox,
  VCheckboxBtn,
  VChip,
  VChipGroup,
  VClassIcon,
  VCode,
  VCol,
  VColorPicker,
  VCombobox,
  VComponentIcon,
  VContainer,
  VCounter,
  VDefaultsProvider,
  VDialog,
  VDialogBottomTransition,
  VDialogTopTransition,
  VDialogTransition,
  VDivider,
  VExpandTransition,
  VExpandXTransition,
  VExpansionPanel,
  VExpansionPanelText,
  VExpansionPanelTitle,
  VExpansionPanels,
  VFabTransition,
  VFadeTransition,
  VField,
  VFieldLabel,
  VFileInput,
  VFooter,
  VForm,
  VHover,
  VIcon,
  VImg,
  VInput,
  VItem,
  VItemGroup,
  VKbd,
  VLabel,
  VLayout,
  VLayoutItem,
  VLazy,
  VLigatureIcon,
  VList,
  VListGroup,
  VListImg,
  VListItem,
  VListItemAction,
  VListItemMedia,
  VListItemSubtitle,
  VListItemTitle,
  VListSubheader,
  VLocaleProvider,
  VMain,
  VMenu,
  VMessages,
  VNavigationDrawer,
  VNoSsr,
  VOverlay,
  VPagination,
  VParallax,
  VProgressCircular,
  VProgressLinear,
  VRadio,
  VRadioGroup,
  VRangeSlider,
  VRating,
  VResponsive,
  VRow,
  VScaleTransition,
  VScrollXReverseTransition,
  VScrollXTransition,
  VScrollYReverseTransition,
  VScrollYTransition,
  VSelect,
  VSelectionControl,
  VSelectionControlGroup,
  VSheet,
  VSlideGroup,
  VSlideGroupItem,
  VSlideXReverseTransition,
  VSlideXTransition,
  VSlideYReverseTransition,
  VSlideYTransition,
  VSlider,
  VSnackbar,
  VSpacer,
  VSvgIcon,
  VSwitch,
  VSystemBar,
  VTab,
  VTable,
  VTabs,
  VTextField,
  VTextarea,
  VThemeProvider,
  VTimeline,
  VTimelineItem,
  VToolbar,
  VToolbarItems,
  VToolbarTitle,
  VTooltip,
  VValidation,
  VVirtualScroll,
  VWindow,
  VWindowItem
}, Symbol.toStringTag, { value: "Module" }));
function mounted$2(el, binding) {
  const modifiers = binding.modifiers || {};
  const value = binding.value;
  const {
    once,
    immediate,
    ...modifierKeys
  } = modifiers;
  const defaultValue = !Object.keys(modifierKeys).length;
  const {
    handler,
    options
  } = typeof value === "object" ? value : {
    handler: value,
    options: {
      attributes: (modifierKeys == null ? void 0 : modifierKeys.attr) ?? defaultValue,
      characterData: (modifierKeys == null ? void 0 : modifierKeys.char) ?? defaultValue,
      childList: (modifierKeys == null ? void 0 : modifierKeys.child) ?? defaultValue,
      subtree: (modifierKeys == null ? void 0 : modifierKeys.sub) ?? defaultValue
    }
  };
  const observer = new MutationObserver(function() {
    let mutations = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    let observer2 = arguments.length > 1 ? arguments[1] : void 0;
    handler == null ? void 0 : handler(mutations, observer2);
    if (once)
      unmounted$2(el, binding);
  });
  if (immediate)
    handler == null ? void 0 : handler([], observer);
  el._mutate = Object(el._mutate);
  el._mutate[binding.instance.$.uid] = {
    observer
  };
  observer.observe(el, options);
}
function unmounted$2(el, binding) {
  var _a2;
  if (!((_a2 = el._mutate) == null ? void 0 : _a2[binding.instance.$.uid]))
    return;
  el._mutate[binding.instance.$.uid].observer.disconnect();
  delete el._mutate[binding.instance.$.uid];
}
const Mutate = {
  mounted: mounted$2,
  unmounted: unmounted$2
};
function mounted$1(el, binding) {
  var _a2, _b;
  const handler = binding.value;
  const options = {
    passive: !((_a2 = binding.modifiers) == null ? void 0 : _a2.active)
  };
  window.addEventListener("resize", handler, options);
  el._onResize = Object(el._onResize);
  el._onResize[binding.instance.$.uid] = {
    handler,
    options
  };
  if (!((_b = binding.modifiers) == null ? void 0 : _b.quiet)) {
    handler();
  }
}
function unmounted$1(el, binding) {
  var _a2;
  if (!((_a2 = el._onResize) == null ? void 0 : _a2[binding.instance.$.uid]))
    return;
  const {
    handler,
    options
  } = el._onResize[binding.instance.$.uid];
  window.removeEventListener("resize", handler, options);
  delete el._onResize[binding.instance.$.uid];
}
const Resize = {
  mounted: mounted$1,
  unmounted: unmounted$1
};
function mounted(el, binding) {
  const {
    self: self2 = false
  } = binding.modifiers ?? {};
  const value = binding.value;
  const options = typeof value === "object" && value.options || {
    passive: true
  };
  const handler = typeof value === "function" || "handleEvent" in value ? value : value.handler;
  const target = self2 ? el : binding.arg ? document.querySelector(binding.arg) : window;
  if (!target)
    return;
  target.addEventListener("scroll", handler, options);
  el._onScroll = Object(el._onScroll);
  el._onScroll[binding.instance.$.uid] = {
    handler,
    options,
    // Don't reference self
    target: self2 ? void 0 : target
  };
}
function unmounted(el, binding) {
  var _a2;
  if (!((_a2 = el._onScroll) == null ? void 0 : _a2[binding.instance.$.uid]))
    return;
  const {
    handler,
    options,
    target = el
  } = el._onScroll[binding.instance.$.uid];
  target.removeEventListener("scroll", handler, options);
  delete el._onScroll[binding.instance.$.uid];
}
function updated(el, binding) {
  if (binding.value === binding.oldValue)
    return;
  unmounted(el, binding);
  mounted(el, binding);
}
const Scroll = {
  mounted,
  unmounted,
  updated
};
const directives = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ClickOutside,
  Intersect,
  Mutate,
  Resize,
  Ripple,
  Scroll,
  Touch
}, Symbol.toStringTag, { value: "Module" }));
const materialdesignicons = "";
const vuetify_min = "";
var axios_min = { exports: {} };
(function(module, exports) {
  !function(e, t) {
    module.exports = t();
  }(commonjsGlobal, function() {
    return function(e) {
      function t(r) {
        if (n[r])
          return n[r].exports;
        var o = n[r] = { exports: {}, id: r, loaded: false };
        return e[r].call(o.exports, o, o.exports, t), o.loaded = true, o.exports;
      }
      var n = {};
      return t.m = e, t.c = n, t.p = "", t(0);
    }([function(e, t, n) {
      e.exports = n(1);
    }, function(e, t, n) {
      function r(e2) {
        var t2 = new s(e2), n2 = i(s.prototype.request, t2);
        return o.extend(n2, s.prototype, t2), o.extend(n2, t2), n2;
      }
      var o = n(2), i = n(3), s = n(4), a = n(22), u = n(10), c2 = r(u);
      c2.Axios = s, c2.create = function(e2) {
        return r(a(c2.defaults, e2));
      }, c2.Cancel = n(23), c2.CancelToken = n(24), c2.isCancel = n(9), c2.all = function(e2) {
        return Promise.all(e2);
      }, c2.spread = n(25), e.exports = c2, e.exports.default = c2;
    }, function(e, t, n) {
      function r(e2) {
        return "[object Array]" === j2.call(e2);
      }
      function o(e2) {
        return "undefined" == typeof e2;
      }
      function i(e2) {
        return null !== e2 && !o(e2) && null !== e2.constructor && !o(e2.constructor) && "function" == typeof e2.constructor.isBuffer && e2.constructor.isBuffer(e2);
      }
      function s(e2) {
        return "[object ArrayBuffer]" === j2.call(e2);
      }
      function a(e2) {
        return "undefined" != typeof FormData && e2 instanceof FormData;
      }
      function u(e2) {
        return "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e2) : e2 && e2.buffer && e2.buffer instanceof ArrayBuffer;
      }
      function c2(e2) {
        return "string" == typeof e2;
      }
      function f2(e2) {
        return "number" == typeof e2;
      }
      function p2(e2) {
        return null !== e2 && "object" == typeof e2;
      }
      function d(e2) {
        return "[object Date]" === j2.call(e2);
      }
      function l(e2) {
        return "[object File]" === j2.call(e2);
      }
      function h2(e2) {
        return "[object Blob]" === j2.call(e2);
      }
      function m(e2) {
        return "[object Function]" === j2.call(e2);
      }
      function y2(e2) {
        return p2(e2) && m(e2.pipe);
      }
      function g2(e2) {
        return "undefined" != typeof URLSearchParams && e2 instanceof URLSearchParams;
      }
      function v2(e2) {
        return e2.replace(/^\s*/, "").replace(/\s*$/, "");
      }
      function x2() {
        return ("undefined" == typeof navigator || "ReactNative" !== navigator.product && "NativeScript" !== navigator.product && "NS" !== navigator.product) && ("undefined" != typeof window && "undefined" != typeof document);
      }
      function w2(e2, t2) {
        if (null !== e2 && "undefined" != typeof e2)
          if ("object" != typeof e2 && (e2 = [e2]), r(e2))
            for (var n2 = 0, o2 = e2.length; n2 < o2; n2++)
              t2.call(null, e2[n2], n2, e2);
          else
            for (var i2 in e2)
              Object.prototype.hasOwnProperty.call(e2, i2) && t2.call(null, e2[i2], i2, e2);
      }
      function b2() {
        function e2(e3, n3) {
          "object" == typeof t2[n3] && "object" == typeof e3 ? t2[n3] = b2(t2[n3], e3) : t2[n3] = e3;
        }
        for (var t2 = {}, n2 = 0, r2 = arguments.length; n2 < r2; n2++)
          w2(arguments[n2], e2);
        return t2;
      }
      function E2() {
        function e2(e3, n3) {
          "object" == typeof t2[n3] && "object" == typeof e3 ? t2[n3] = E2(t2[n3], e3) : "object" == typeof e3 ? t2[n3] = E2({}, e3) : t2[n3] = e3;
        }
        for (var t2 = {}, n2 = 0, r2 = arguments.length; n2 < r2; n2++)
          w2(arguments[n2], e2);
        return t2;
      }
      function S2(e2, t2, n2) {
        return w2(t2, function(t3, r2) {
          n2 && "function" == typeof t3 ? e2[r2] = C2(t3, n2) : e2[r2] = t3;
        }), e2;
      }
      var C2 = n(3), j2 = Object.prototype.toString;
      e.exports = { isArray: r, isArrayBuffer: s, isBuffer: i, isFormData: a, isArrayBufferView: u, isString: c2, isNumber: f2, isObject: p2, isUndefined: o, isDate: d, isFile: l, isBlob: h2, isFunction: m, isStream: y2, isURLSearchParams: g2, isStandardBrowserEnv: x2, forEach: w2, merge: b2, deepMerge: E2, extend: S2, trim: v2 };
    }, function(e, t) {
      e.exports = function(e2, t2) {
        return function() {
          for (var n = new Array(arguments.length), r = 0; r < n.length; r++)
            n[r] = arguments[r];
          return e2.apply(t2, n);
        };
      };
    }, function(e, t, n) {
      function r(e2) {
        this.defaults = e2, this.interceptors = { request: new s(), response: new s() };
      }
      var o = n(2), i = n(5), s = n(6), a = n(7), u = n(22);
      r.prototype.request = function(e2) {
        "string" == typeof e2 ? (e2 = arguments[1] || {}, e2.url = arguments[0]) : e2 = e2 || {}, e2 = u(this.defaults, e2), e2.method ? e2.method = e2.method.toLowerCase() : this.defaults.method ? e2.method = this.defaults.method.toLowerCase() : e2.method = "get";
        var t2 = [a, void 0], n2 = Promise.resolve(e2);
        for (this.interceptors.request.forEach(function(e3) {
          t2.unshift(e3.fulfilled, e3.rejected);
        }), this.interceptors.response.forEach(function(e3) {
          t2.push(e3.fulfilled, e3.rejected);
        }); t2.length; )
          n2 = n2.then(t2.shift(), t2.shift());
        return n2;
      }, r.prototype.getUri = function(e2) {
        return e2 = u(this.defaults, e2), i(e2.url, e2.params, e2.paramsSerializer).replace(/^\?/, "");
      }, o.forEach(["delete", "get", "head", "options"], function(e2) {
        r.prototype[e2] = function(t2, n2) {
          return this.request(o.merge(n2 || {}, { method: e2, url: t2 }));
        };
      }), o.forEach(["post", "put", "patch"], function(e2) {
        r.prototype[e2] = function(t2, n2, r2) {
          return this.request(o.merge(r2 || {}, { method: e2, url: t2, data: n2 }));
        };
      }), e.exports = r;
    }, function(e, t, n) {
      function r(e2) {
        return encodeURIComponent(e2).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
      }
      var o = n(2);
      e.exports = function(e2, t2, n2) {
        if (!t2)
          return e2;
        var i;
        if (n2)
          i = n2(t2);
        else if (o.isURLSearchParams(t2))
          i = t2.toString();
        else {
          var s = [];
          o.forEach(t2, function(e3, t3) {
            null !== e3 && "undefined" != typeof e3 && (o.isArray(e3) ? t3 += "[]" : e3 = [e3], o.forEach(e3, function(e4) {
              o.isDate(e4) ? e4 = e4.toISOString() : o.isObject(e4) && (e4 = JSON.stringify(e4)), s.push(r(t3) + "=" + r(e4));
            }));
          }), i = s.join("&");
        }
        if (i) {
          var a = e2.indexOf("#");
          a !== -1 && (e2 = e2.slice(0, a)), e2 += (e2.indexOf("?") === -1 ? "?" : "&") + i;
        }
        return e2;
      };
    }, function(e, t, n) {
      function r() {
        this.handlers = [];
      }
      var o = n(2);
      r.prototype.use = function(e2, t2) {
        return this.handlers.push({ fulfilled: e2, rejected: t2 }), this.handlers.length - 1;
      }, r.prototype.eject = function(e2) {
        this.handlers[e2] && (this.handlers[e2] = null);
      }, r.prototype.forEach = function(e2) {
        o.forEach(this.handlers, function(t2) {
          null !== t2 && e2(t2);
        });
      }, e.exports = r;
    }, function(e, t, n) {
      function r(e2) {
        e2.cancelToken && e2.cancelToken.throwIfRequested();
      }
      var o = n(2), i = n(8), s = n(9), a = n(10);
      e.exports = function(e2) {
        r(e2), e2.headers = e2.headers || {}, e2.data = i(e2.data, e2.headers, e2.transformRequest), e2.headers = o.merge(e2.headers.common || {}, e2.headers[e2.method] || {}, e2.headers), o.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function(t3) {
          delete e2.headers[t3];
        });
        var t2 = e2.adapter || a.adapter;
        return t2(e2).then(function(t3) {
          return r(e2), t3.data = i(t3.data, t3.headers, e2.transformResponse), t3;
        }, function(t3) {
          return s(t3) || (r(e2), t3 && t3.response && (t3.response.data = i(t3.response.data, t3.response.headers, e2.transformResponse))), Promise.reject(t3);
        });
      };
    }, function(e, t, n) {
      var r = n(2);
      e.exports = function(e2, t2, n2) {
        return r.forEach(n2, function(n3) {
          e2 = n3(e2, t2);
        }), e2;
      };
    }, function(e, t) {
      e.exports = function(e2) {
        return !(!e2 || !e2.__CANCEL__);
      };
    }, function(e, t, n) {
      function r(e2, t2) {
        !i.isUndefined(e2) && i.isUndefined(e2["Content-Type"]) && (e2["Content-Type"] = t2);
      }
      function o() {
        var e2;
        return "undefined" != typeof XMLHttpRequest ? e2 = n(12) : "undefined" != typeof process && "[object process]" === Object.prototype.toString.call(process) && (e2 = n(12)), e2;
      }
      var i = n(2), s = n(11), a = { "Content-Type": "application/x-www-form-urlencoded" }, u = { adapter: o(), transformRequest: [function(e2, t2) {
        return s(t2, "Accept"), s(t2, "Content-Type"), i.isFormData(e2) || i.isArrayBuffer(e2) || i.isBuffer(e2) || i.isStream(e2) || i.isFile(e2) || i.isBlob(e2) ? e2 : i.isArrayBufferView(e2) ? e2.buffer : i.isURLSearchParams(e2) ? (r(t2, "application/x-www-form-urlencoded;charset=utf-8"), e2.toString()) : i.isObject(e2) ? (r(t2, "application/json;charset=utf-8"), JSON.stringify(e2)) : e2;
      }], transformResponse: [function(e2) {
        if ("string" == typeof e2)
          try {
            e2 = JSON.parse(e2);
          } catch (e3) {
          }
        return e2;
      }], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, validateStatus: function(e2) {
        return e2 >= 200 && e2 < 300;
      } };
      u.headers = { common: { Accept: "application/json, text/plain, */*" } }, i.forEach(["delete", "get", "head"], function(e2) {
        u.headers[e2] = {};
      }), i.forEach(["post", "put", "patch"], function(e2) {
        u.headers[e2] = i.merge(a);
      }), e.exports = u;
    }, function(e, t, n) {
      var r = n(2);
      e.exports = function(e2, t2) {
        r.forEach(e2, function(n2, r2) {
          r2 !== t2 && r2.toUpperCase() === t2.toUpperCase() && (e2[t2] = n2, delete e2[r2]);
        });
      };
    }, function(e, t, n) {
      var r = n(2), o = n(13), i = n(5), s = n(16), a = n(19), u = n(20), c2 = n(14);
      e.exports = function(e2) {
        return new Promise(function(t2, f2) {
          var p2 = e2.data, d = e2.headers;
          r.isFormData(p2) && delete d["Content-Type"];
          var l = new XMLHttpRequest();
          if (e2.auth) {
            var h2 = e2.auth.username || "", m = e2.auth.password || "";
            d.Authorization = "Basic " + btoa(h2 + ":" + m);
          }
          var y2 = s(e2.baseURL, e2.url);
          if (l.open(e2.method.toUpperCase(), i(y2, e2.params, e2.paramsSerializer), true), l.timeout = e2.timeout, l.onreadystatechange = function() {
            if (l && 4 === l.readyState && (0 !== l.status || l.responseURL && 0 === l.responseURL.indexOf("file:"))) {
              var n2 = "getAllResponseHeaders" in l ? a(l.getAllResponseHeaders()) : null, r2 = e2.responseType && "text" !== e2.responseType ? l.response : l.responseText, i2 = { data: r2, status: l.status, statusText: l.statusText, headers: n2, config: e2, request: l };
              o(t2, f2, i2), l = null;
            }
          }, l.onabort = function() {
            l && (f2(c2("Request aborted", e2, "ECONNABORTED", l)), l = null);
          }, l.onerror = function() {
            f2(c2("Network Error", e2, null, l)), l = null;
          }, l.ontimeout = function() {
            var t3 = "timeout of " + e2.timeout + "ms exceeded";
            e2.timeoutErrorMessage && (t3 = e2.timeoutErrorMessage), f2(c2(t3, e2, "ECONNABORTED", l)), l = null;
          }, r.isStandardBrowserEnv()) {
            var g2 = n(21), v2 = (e2.withCredentials || u(y2)) && e2.xsrfCookieName ? g2.read(e2.xsrfCookieName) : void 0;
            v2 && (d[e2.xsrfHeaderName] = v2);
          }
          if ("setRequestHeader" in l && r.forEach(d, function(e3, t3) {
            "undefined" == typeof p2 && "content-type" === t3.toLowerCase() ? delete d[t3] : l.setRequestHeader(t3, e3);
          }), r.isUndefined(e2.withCredentials) || (l.withCredentials = !!e2.withCredentials), e2.responseType)
            try {
              l.responseType = e2.responseType;
            } catch (t3) {
              if ("json" !== e2.responseType)
                throw t3;
            }
          "function" == typeof e2.onDownloadProgress && l.addEventListener("progress", e2.onDownloadProgress), "function" == typeof e2.onUploadProgress && l.upload && l.upload.addEventListener("progress", e2.onUploadProgress), e2.cancelToken && e2.cancelToken.promise.then(function(e3) {
            l && (l.abort(), f2(e3), l = null);
          }), void 0 === p2 && (p2 = null), l.send(p2);
        });
      };
    }, function(e, t, n) {
      var r = n(14);
      e.exports = function(e2, t2, n2) {
        var o = n2.config.validateStatus;
        !o || o(n2.status) ? e2(n2) : t2(r("Request failed with status code " + n2.status, n2.config, null, n2.request, n2));
      };
    }, function(e, t, n) {
      var r = n(15);
      e.exports = function(e2, t2, n2, o, i) {
        var s = new Error(e2);
        return r(s, t2, n2, o, i);
      };
    }, function(e, t) {
      e.exports = function(e2, t2, n, r, o) {
        return e2.config = t2, n && (e2.code = n), e2.request = r, e2.response = o, e2.isAxiosError = true, e2.toJSON = function() {
          return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: this.config, code: this.code };
        }, e2;
      };
    }, function(e, t, n) {
      var r = n(17), o = n(18);
      e.exports = function(e2, t2) {
        return e2 && !r(t2) ? o(e2, t2) : t2;
      };
    }, function(e, t) {
      e.exports = function(e2) {
        return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(e2);
      };
    }, function(e, t) {
      e.exports = function(e2, t2) {
        return t2 ? e2.replace(/\/+$/, "") + "/" + t2.replace(/^\/+/, "") : e2;
      };
    }, function(e, t, n) {
      var r = n(2), o = ["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"];
      e.exports = function(e2) {
        var t2, n2, i, s = {};
        return e2 ? (r.forEach(e2.split("\n"), function(e3) {
          if (i = e3.indexOf(":"), t2 = r.trim(e3.substr(0, i)).toLowerCase(), n2 = r.trim(e3.substr(i + 1)), t2) {
            if (s[t2] && o.indexOf(t2) >= 0)
              return;
            "set-cookie" === t2 ? s[t2] = (s[t2] ? s[t2] : []).concat([n2]) : s[t2] = s[t2] ? s[t2] + ", " + n2 : n2;
          }
        }), s) : s;
      };
    }, function(e, t, n) {
      var r = n(2);
      e.exports = r.isStandardBrowserEnv() ? function() {
        function e2(e3) {
          var t3 = e3;
          return n2 && (o.setAttribute("href", t3), t3 = o.href), o.setAttribute("href", t3), { href: o.href, protocol: o.protocol ? o.protocol.replace(/:$/, "") : "", host: o.host, search: o.search ? o.search.replace(/^\?/, "") : "", hash: o.hash ? o.hash.replace(/^#/, "") : "", hostname: o.hostname, port: o.port, pathname: "/" === o.pathname.charAt(0) ? o.pathname : "/" + o.pathname };
        }
        var t2, n2 = /(msie|trident)/i.test(navigator.userAgent), o = document.createElement("a");
        return t2 = e2(window.location.href), function(n3) {
          var o2 = r.isString(n3) ? e2(n3) : n3;
          return o2.protocol === t2.protocol && o2.host === t2.host;
        };
      }() : function() {
        return function() {
          return true;
        };
      }();
    }, function(e, t, n) {
      var r = n(2);
      e.exports = r.isStandardBrowserEnv() ? function() {
        return { write: function(e2, t2, n2, o, i, s) {
          var a = [];
          a.push(e2 + "=" + encodeURIComponent(t2)), r.isNumber(n2) && a.push("expires=" + new Date(n2).toGMTString()), r.isString(o) && a.push("path=" + o), r.isString(i) && a.push("domain=" + i), s === true && a.push("secure"), document.cookie = a.join("; ");
        }, read: function(e2) {
          var t2 = document.cookie.match(new RegExp("(^|;\\s*)(" + e2 + ")=([^;]*)"));
          return t2 ? decodeURIComponent(t2[3]) : null;
        }, remove: function(e2) {
          this.write(e2, "", Date.now() - 864e5);
        } };
      }() : function() {
        return { write: function() {
        }, read: function() {
          return null;
        }, remove: function() {
        } };
      }();
    }, function(e, t, n) {
      var r = n(2);
      e.exports = function(e2, t2) {
        t2 = t2 || {};
        var n2 = {}, o = ["url", "method", "params", "data"], i = ["headers", "auth", "proxy"], s = ["baseURL", "url", "transformRequest", "transformResponse", "paramsSerializer", "timeout", "withCredentials", "adapter", "responseType", "xsrfCookieName", "xsrfHeaderName", "onUploadProgress", "onDownloadProgress", "maxContentLength", "validateStatus", "maxRedirects", "httpAgent", "httpsAgent", "cancelToken", "socketPath"];
        r.forEach(o, function(e3) {
          "undefined" != typeof t2[e3] && (n2[e3] = t2[e3]);
        }), r.forEach(i, function(o2) {
          r.isObject(t2[o2]) ? n2[o2] = r.deepMerge(e2[o2], t2[o2]) : "undefined" != typeof t2[o2] ? n2[o2] = t2[o2] : r.isObject(e2[o2]) ? n2[o2] = r.deepMerge(e2[o2]) : "undefined" != typeof e2[o2] && (n2[o2] = e2[o2]);
        }), r.forEach(s, function(r2) {
          "undefined" != typeof t2[r2] ? n2[r2] = t2[r2] : "undefined" != typeof e2[r2] && (n2[r2] = e2[r2]);
        });
        var a = o.concat(i).concat(s), u = Object.keys(t2).filter(function(e3) {
          return a.indexOf(e3) === -1;
        });
        return r.forEach(u, function(r2) {
          "undefined" != typeof t2[r2] ? n2[r2] = t2[r2] : "undefined" != typeof e2[r2] && (n2[r2] = e2[r2]);
        }), n2;
      };
    }, function(e, t) {
      function n(e2) {
        this.message = e2;
      }
      n.prototype.toString = function() {
        return "Cancel" + (this.message ? ": " + this.message : "");
      }, n.prototype.__CANCEL__ = true, e.exports = n;
    }, function(e, t, n) {
      function r(e2) {
        if ("function" != typeof e2)
          throw new TypeError("executor must be a function.");
        var t2;
        this.promise = new Promise(function(e3) {
          t2 = e3;
        });
        var n2 = this;
        e2(function(e3) {
          n2.reason || (n2.reason = new o(e3), t2(n2.reason));
        });
      }
      var o = n(23);
      r.prototype.throwIfRequested = function() {
        if (this.reason)
          throw this.reason;
      }, r.source = function() {
        var e2, t2 = new r(function(t3) {
          e2 = t3;
        });
        return { token: t2, cancel: e2 };
      }, e.exports = r;
    }, function(e, t) {
      e.exports = function(e2) {
        return function(t2) {
          return e2.apply(null, t2);
        };
      };
    }]);
  });
})(axios_min);
var axios_minExports = axios_min.exports;
const axios = /* @__PURE__ */ getDefaultExportFromCjs(axios_minExports);
var indentString$1 = (string, count = 1, options) => {
  options = {
    indent: " ",
    includeEmptyLines: false,
    ...options
  };
  if (typeof string !== "string") {
    throw new TypeError(
      `Expected \`input\` to be a \`string\`, got \`${typeof string}\``
    );
  }
  if (typeof count !== "number") {
    throw new TypeError(
      `Expected \`count\` to be a \`number\`, got \`${typeof count}\``
    );
  }
  if (typeof options.indent !== "string") {
    throw new TypeError(
      `Expected \`options.indent\` to be a \`string\`, got \`${typeof options.indent}\``
    );
  }
  if (count === 0) {
    return string;
  }
  const regex2 = options.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
  return string.replace(regex2, options.indent.repeat(count));
};
var _endianness;
function endianness() {
  if (typeof _endianness === "undefined") {
    var a = new ArrayBuffer(2);
    var b2 = new Uint8Array(a);
    var c2 = new Uint16Array(a);
    b2[0] = 1;
    b2[1] = 2;
    if (c2[0] === 258) {
      _endianness = "BE";
    } else if (c2[0] === 513) {
      _endianness = "LE";
    } else {
      throw new Error("unable to figure out endianess");
    }
  }
  return _endianness;
}
function hostname() {
  if (typeof global.location !== "undefined") {
    return global.location.hostname;
  } else
    return "";
}
function loadavg() {
  return [];
}
function uptime() {
  return 0;
}
function freemem() {
  return Number.MAX_VALUE;
}
function totalmem() {
  return Number.MAX_VALUE;
}
function cpus() {
  return [];
}
function type() {
  return "Browser";
}
function release() {
  if (typeof global.navigator !== "undefined") {
    return global.navigator.appVersion;
  }
  return "";
}
function networkInterfaces() {
}
function getNetworkInterfaces() {
}
function arch() {
  return "javascript";
}
function platform() {
  return "browser";
}
function tmpDir() {
  return "/tmp";
}
var tmpdir = tmpDir;
var EOL = "\n";
const os$1 = {
  EOL,
  tmpdir,
  tmpDir,
  networkInterfaces,
  getNetworkInterfaces,
  release,
  type,
  cpus,
  totalmem,
  freemem,
  uptime,
  loadavg,
  hostname,
  endianness
};
const os$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  EOL,
  arch,
  cpus,
  default: os$1,
  endianness,
  freemem,
  getNetworkInterfaces,
  hostname,
  loadavg,
  networkInterfaces,
  platform,
  release,
  tmpDir,
  tmpdir,
  totalmem,
  type,
  uptime
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(os$2);
const os = require$$0$1;
const extractPathRegex = /\s+at.*(?:\(|\s)(.*)\)?/;
const pathRegex = /^(?:(?:(?:node|(?:internal\/[\w/]*|.*node_modules\/(?:babel-polyfill|pirates)\/.*)?\w+)\.js:\d+:\d+)|native)/;
const homeDir = typeof os.homedir === "undefined" ? "" : os.homedir();
var cleanStack$1 = (stack2, options) => {
  options = Object.assign({ pretty: false }, options);
  return stack2.replace(/\\/g, "/").split("\n").filter((line2) => {
    const pathMatches = line2.match(extractPathRegex);
    if (pathMatches === null || !pathMatches[1]) {
      return true;
    }
    const match2 = pathMatches[1];
    if (match2.includes(".app/Contents/Resources/electron.asar") || match2.includes(".app/Contents/Resources/default_app.asar")) {
      return false;
    }
    return !pathRegex.test(match2);
  }).filter((line2) => line2.trim() !== "").map((line2) => {
    if (options.pretty) {
      return line2.replace(extractPathRegex, (m, p1) => m.replace(p1, p1.replace(homeDir, "~")));
    }
    return line2;
  }).join("\n");
};
const indentString = indentString$1;
const cleanStack = cleanStack$1;
const cleanInternalStack = (stack2) => stack2.replace(/\s+at .*aggregate-error\/index.js:\d+:\d+\)?/g, "");
let AggregateError$2 = class AggregateError2 extends Error {
  constructor(errors) {
    if (!Array.isArray(errors)) {
      throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
    }
    errors = [...errors].map((error) => {
      if (error instanceof Error) {
        return error;
      }
      if (error !== null && typeof error === "object") {
        return Object.assign(new Error(error.message), error);
      }
      return new Error(error);
    });
    let message = errors.map((error) => {
      return typeof error.stack === "string" ? cleanInternalStack(cleanStack(error.stack)) : String(error);
    }).join("\n");
    message = "\n" + indentString(message, 4);
    super(message);
    this.name = "AggregateError";
    Object.defineProperty(this, "_errors", { value: errors });
  }
  *[Symbol.iterator]() {
    for (const error of this._errors) {
      yield error;
    }
  }
};
var aggregateError = AggregateError$2;
const AggregateError$1 = aggregateError;
var pMap$1 = async (iterable, mapper, {
  concurrency = Infinity,
  stopOnError = true
} = {}) => {
  return new Promise((resolve2, reject) => {
    if (typeof mapper !== "function") {
      throw new TypeError("Mapper function is required");
    }
    if (!((Number.isSafeInteger(concurrency) || concurrency === Infinity) && concurrency >= 1)) {
      throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${concurrency}\` (${typeof concurrency})`);
    }
    const result = [];
    const errors = [];
    const iterator = iterable[Symbol.iterator]();
    let isRejected = false;
    let isIterableDone = false;
    let resolvingCount = 0;
    let currentIndex = 0;
    const next = () => {
      if (isRejected) {
        return;
      }
      const nextItem = iterator.next();
      const index2 = currentIndex;
      currentIndex++;
      if (nextItem.done) {
        isIterableDone = true;
        if (resolvingCount === 0) {
          if (!stopOnError && errors.length !== 0) {
            reject(new AggregateError$1(errors));
          } else {
            resolve2(result);
          }
        }
        return;
      }
      resolvingCount++;
      (async () => {
        try {
          const element = await nextItem.value;
          result[index2] = await mapper(element, index2);
          resolvingCount--;
          next();
        } catch (error) {
          if (stopOnError) {
            isRejected = true;
            reject(error);
          } else {
            errors.push(error);
            resolvingCount--;
            next();
          }
        }
      })();
    };
    for (let i = 0; i < concurrency; i++) {
      next();
      if (isIterableDone) {
        break;
      }
    }
  });
};
const pMap = pMap$1;
var pAll = (iterable, options) => pMap(iterable, (element) => element(), options);
const pAll$1 = /* @__PURE__ */ getDefaultExportFromCjs(pAll);
var tinyEmitter = { exports: {} };
function E$1() {
}
E$1.prototype = {
  on: function(name, callback, ctx) {
    var e = this.e || (this.e = {});
    (e[name] || (e[name] = [])).push({
      fn: callback,
      ctx
    });
    return this;
  },
  once: function(name, callback, ctx) {
    var self2 = this;
    function listener() {
      self2.off(name, listener);
      callback.apply(ctx, arguments);
    }
    listener._ = callback;
    return this.on(name, listener, ctx);
  },
  emit: function(name) {
    var data = [].slice.call(arguments, 1);
    var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
    var i = 0;
    var len = evtArr.length;
    for (i; i < len; i++) {
      evtArr[i].fn.apply(evtArr[i].ctx, data);
    }
    return this;
  },
  off: function(name, callback) {
    var e = this.e || (this.e = {});
    var evts = e[name];
    var liveEvents = [];
    if (evts && callback) {
      for (var i = 0, len = evts.length; i < len; i++) {
        if (evts[i].fn !== callback && evts[i].fn._ !== callback)
          liveEvents.push(evts[i]);
      }
    }
    liveEvents.length ? e[name] = liveEvents : delete e[name];
    return this;
  }
};
tinyEmitter.exports = E$1;
tinyEmitter.exports.TinyEmitter = E$1;
var tinyEmitterExports = tinyEmitter.exports;
const Emitter = /* @__PURE__ */ getDefaultExportFromCjs(tinyEmitterExports);
var dayjs_min = { exports: {} };
(function(module, exports) {
  !function(t, e) {
    module.exports = e();
  }(commonjsGlobal, function() {
    var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", c2 = "month", f2 = "quarter", h2 = "year", d = "date", l = "Invalid Date", $2 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y2 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t2) {
      var e2 = ["th", "st", "nd", "rd"], n2 = t2 % 100;
      return "[" + t2 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
    } }, m = function(t2, e2, n2) {
      var r2 = String(t2);
      return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
    }, v2 = { s: m, z: function(t2) {
      var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
      return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
    }, m: function t2(e2, n2) {
      if (e2.date() < n2.date())
        return -t2(n2, e2);
      var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, c2), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), c2);
      return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
    }, a: function(t2) {
      return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
    }, p: function(t2) {
      return { M: c2, y: h2, w: o, d: a, D: d, h: u, m: s, s: i, ms: r, Q: f2 }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
    }, u: function(t2) {
      return void 0 === t2;
    } }, g2 = "en", D2 = {};
    D2[g2] = M2;
    var p2 = "$isDayjsObject", S2 = function(t2) {
      return t2 instanceof _2 || !(!t2 || !t2[p2]);
    }, w2 = function t2(e2, n2, r2) {
      var i2;
      if (!e2)
        return g2;
      if ("string" == typeof e2) {
        var s2 = e2.toLowerCase();
        D2[s2] && (i2 = s2), n2 && (D2[s2] = n2, i2 = s2);
        var u2 = e2.split("-");
        if (!i2 && u2.length > 1)
          return t2(u2[0]);
      } else {
        var a2 = e2.name;
        D2[a2] = e2, i2 = a2;
      }
      return !r2 && i2 && (g2 = i2), i2 || !r2 && g2;
    }, O2 = function(t2, e2) {
      if (S2(t2))
        return t2.clone();
      var n2 = "object" == typeof e2 ? e2 : {};
      return n2.date = t2, n2.args = arguments, new _2(n2);
    }, b2 = v2;
    b2.l = w2, b2.i = S2, b2.w = function(t2, e2) {
      return O2(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
    };
    var _2 = function() {
      function M3(t2) {
        this.$L = w2(t2.locale, null, true), this.parse(t2), this.$x = this.$x || t2.x || {}, this[p2] = true;
      }
      var m2 = M3.prototype;
      return m2.parse = function(t2) {
        this.$d = function(t3) {
          var e2 = t3.date, n2 = t3.utc;
          if (null === e2)
            return /* @__PURE__ */ new Date(NaN);
          if (b2.u(e2))
            return /* @__PURE__ */ new Date();
          if (e2 instanceof Date)
            return new Date(e2);
          if ("string" == typeof e2 && !/Z$/i.test(e2)) {
            var r2 = e2.match($2);
            if (r2) {
              var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
              return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
            }
          }
          return new Date(e2);
        }(t2), this.init();
      }, m2.init = function() {
        var t2 = this.$d;
        this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
      }, m2.$utils = function() {
        return b2;
      }, m2.isValid = function() {
        return !(this.$d.toString() === l);
      }, m2.isSame = function(t2, e2) {
        var n2 = O2(t2);
        return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
      }, m2.isAfter = function(t2, e2) {
        return O2(t2) < this.startOf(e2);
      }, m2.isBefore = function(t2, e2) {
        return this.endOf(e2) < O2(t2);
      }, m2.$g = function(t2, e2, n2) {
        return b2.u(t2) ? this[e2] : this.set(n2, t2);
      }, m2.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, m2.valueOf = function() {
        return this.$d.getTime();
      }, m2.startOf = function(t2, e2) {
        var n2 = this, r2 = !!b2.u(e2) || e2, f3 = b2.p(t2), l2 = function(t3, e3) {
          var i2 = b2.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
          return r2 ? i2 : i2.endOf(a);
        }, $3 = function(t3, e3) {
          return b2.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
        }, y3 = this.$W, M4 = this.$M, m3 = this.$D, v3 = "set" + (this.$u ? "UTC" : "");
        switch (f3) {
          case h2:
            return r2 ? l2(1, 0) : l2(31, 11);
          case c2:
            return r2 ? l2(1, M4) : l2(0, M4 + 1);
          case o:
            var g3 = this.$locale().weekStart || 0, D3 = (y3 < g3 ? y3 + 7 : y3) - g3;
            return l2(r2 ? m3 - D3 : m3 + (6 - D3), M4);
          case a:
          case d:
            return $3(v3 + "Hours", 0);
          case u:
            return $3(v3 + "Minutes", 1);
          case s:
            return $3(v3 + "Seconds", 2);
          case i:
            return $3(v3 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m2.endOf = function(t2) {
        return this.startOf(t2, false);
      }, m2.$set = function(t2, e2) {
        var n2, o2 = b2.p(t2), f3 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a] = f3 + "Date", n2[d] = f3 + "Date", n2[c2] = f3 + "Month", n2[h2] = f3 + "FullYear", n2[u] = f3 + "Hours", n2[s] = f3 + "Minutes", n2[i] = f3 + "Seconds", n2[r] = f3 + "Milliseconds", n2)[o2], $3 = o2 === a ? this.$D + (e2 - this.$W) : e2;
        if (o2 === c2 || o2 === h2) {
          var y3 = this.clone().set(d, 1);
          y3.$d[l2]($3), y3.init(), this.$d = y3.set(d, Math.min(this.$D, y3.daysInMonth())).$d;
        } else
          l2 && this.$d[l2]($3);
        return this.init(), this;
      }, m2.set = function(t2, e2) {
        return this.clone().$set(t2, e2);
      }, m2.get = function(t2) {
        return this[b2.p(t2)]();
      }, m2.add = function(r2, f3) {
        var d2, l2 = this;
        r2 = Number(r2);
        var $3 = b2.p(f3), y3 = function(t2) {
          var e2 = O2(l2);
          return b2.w(e2.date(e2.date() + Math.round(t2 * r2)), l2);
        };
        if ($3 === c2)
          return this.set(c2, this.$M + r2);
        if ($3 === h2)
          return this.set(h2, this.$y + r2);
        if ($3 === a)
          return y3(1);
        if ($3 === o)
          return y3(7);
        var M4 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t, d2)[$3] || 1, m3 = this.$d.getTime() + r2 * M4;
        return b2.w(m3, this);
      }, m2.subtract = function(t2, e2) {
        return this.add(-1 * t2, e2);
      }, m2.format = function(t2) {
        var e2 = this, n2 = this.$locale();
        if (!this.isValid())
          return n2.invalidDate || l;
        var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b2.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, c3 = n2.months, f3 = n2.meridiem, h3 = function(t3, n3, i3, s3) {
          return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].slice(0, s3);
        }, d2 = function(t3) {
          return b2.s(s2 % 12 || 12, t3, "0");
        }, $3 = f3 || function(t3, e3, n3) {
          var r3 = t3 < 12 ? "AM" : "PM";
          return n3 ? r3.toLowerCase() : r3;
        };
        return r2.replace(y2, function(t3, r3) {
          return r3 || function(t4) {
            switch (t4) {
              case "YY":
                return String(e2.$y).slice(-2);
              case "YYYY":
                return b2.s(e2.$y, 4, "0");
              case "M":
                return a2 + 1;
              case "MM":
                return b2.s(a2 + 1, 2, "0");
              case "MMM":
                return h3(n2.monthsShort, a2, c3, 3);
              case "MMMM":
                return h3(c3, a2);
              case "D":
                return e2.$D;
              case "DD":
                return b2.s(e2.$D, 2, "0");
              case "d":
                return String(e2.$W);
              case "dd":
                return h3(n2.weekdaysMin, e2.$W, o2, 2);
              case "ddd":
                return h3(n2.weekdaysShort, e2.$W, o2, 3);
              case "dddd":
                return o2[e2.$W];
              case "H":
                return String(s2);
              case "HH":
                return b2.s(s2, 2, "0");
              case "h":
                return d2(1);
              case "hh":
                return d2(2);
              case "a":
                return $3(s2, u2, true);
              case "A":
                return $3(s2, u2, false);
              case "m":
                return String(u2);
              case "mm":
                return b2.s(u2, 2, "0");
              case "s":
                return String(e2.$s);
              case "ss":
                return b2.s(e2.$s, 2, "0");
              case "SSS":
                return b2.s(e2.$ms, 3, "0");
              case "Z":
                return i2;
            }
            return null;
          }(t3) || i2.replace(":", "");
        });
      }, m2.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m2.diff = function(r2, d2, l2) {
        var $3, y3 = this, M4 = b2.p(d2), m3 = O2(r2), v3 = (m3.utcOffset() - this.utcOffset()) * e, g3 = this - m3, D3 = function() {
          return b2.m(y3, m3);
        };
        switch (M4) {
          case h2:
            $3 = D3() / 12;
            break;
          case c2:
            $3 = D3();
            break;
          case f2:
            $3 = D3() / 3;
            break;
          case o:
            $3 = (g3 - v3) / 6048e5;
            break;
          case a:
            $3 = (g3 - v3) / 864e5;
            break;
          case u:
            $3 = g3 / n;
            break;
          case s:
            $3 = g3 / e;
            break;
          case i:
            $3 = g3 / t;
            break;
          default:
            $3 = g3;
        }
        return l2 ? $3 : b2.a($3);
      }, m2.daysInMonth = function() {
        return this.endOf(c2).$D;
      }, m2.$locale = function() {
        return D2[this.$L];
      }, m2.locale = function(t2, e2) {
        if (!t2)
          return this.$L;
        var n2 = this.clone(), r2 = w2(t2, e2, true);
        return r2 && (n2.$L = r2), n2;
      }, m2.clone = function() {
        return b2.w(this.$d, this);
      }, m2.toDate = function() {
        return new Date(this.valueOf());
      }, m2.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m2.toISOString = function() {
        return this.$d.toISOString();
      }, m2.toString = function() {
        return this.$d.toUTCString();
      }, M3;
    }(), k2 = _2.prototype;
    return O2.prototype = k2, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", c2], ["$y", h2], ["$D", d]].forEach(function(t2) {
      k2[t2[1]] = function(e2) {
        return this.$g(e2, t2[0], t2[1]);
      };
    }), O2.extend = function(t2, e2) {
      return t2.$i || (t2(e2, _2, O2), t2.$i = true), O2;
    }, O2.locale = w2, O2.isDayjs = S2, O2.unix = function(t2) {
      return O2(1e3 * t2);
    }, O2.en = D2[g2], O2.Ls = D2, O2.p = {}, O2;
  });
})(dayjs_min);
var dayjs_minExports = dayjs_min.exports;
const dayjs = /* @__PURE__ */ getDefaultExportFromCjs(dayjs_minExports);
var relativeTime$1 = { exports: {} };
(function(module, exports) {
  !function(r, e) {
    module.exports = e();
  }(commonjsGlobal, function() {
    return function(r, e, t) {
      r = r || {};
      var n = e.prototype, o = { future: "in %s", past: "%s ago", s: "a few seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" };
      function i(r2, e2, t2, o2) {
        return n.fromToBase(r2, e2, t2, o2);
      }
      t.en.relativeTime = o, n.fromToBase = function(e2, n2, i2, d2, u) {
        for (var f2, a, s, l = i2.$locale().relativeTime || o, h2 = r.thresholds || [{ l: "s", r: 44, d: "second" }, { l: "m", r: 89 }, { l: "mm", r: 44, d: "minute" }, { l: "h", r: 89 }, { l: "hh", r: 21, d: "hour" }, { l: "d", r: 35 }, { l: "dd", r: 25, d: "day" }, { l: "M", r: 45 }, { l: "MM", r: 10, d: "month" }, { l: "y", r: 17 }, { l: "yy", d: "year" }], m = h2.length, c2 = 0; c2 < m; c2 += 1) {
          var y2 = h2[c2];
          y2.d && (f2 = d2 ? t(e2).diff(i2, y2.d, true) : i2.diff(e2, y2.d, true));
          var p2 = (r.rounding || Math.round)(Math.abs(f2));
          if (s = f2 > 0, p2 <= y2.r || !y2.r) {
            p2 <= 1 && c2 > 0 && (y2 = h2[c2 - 1]);
            var v2 = l[y2.l];
            u && (p2 = u("" + p2)), a = "string" == typeof v2 ? v2.replace("%d", p2) : v2(p2, n2, y2.l, s);
            break;
          }
        }
        if (n2)
          return a;
        var M2 = s ? l.future : l.past;
        return "function" == typeof M2 ? M2(a) : M2.replace("%s", a);
      }, n.to = function(r2, e2) {
        return i(r2, e2, this, true);
      }, n.from = function(r2, e2) {
        return i(r2, e2, this);
      };
      var d = function(r2) {
        return r2.$u ? t.utc() : t();
      };
      n.toNow = function(r2) {
        return this.to(d(this), r2);
      }, n.fromNow = function(r2) {
        return this.from(d(this), r2);
      };
    };
  });
})(relativeTime$1);
var relativeTimeExports = relativeTime$1.exports;
const relativeTime = /* @__PURE__ */ getDefaultExportFromCjs(relativeTimeExports);
const getAllProperties = (object) => {
  const properties = /* @__PURE__ */ new Set();
  do {
    for (const key2 of Reflect.ownKeys(object)) {
      properties.add([object, key2]);
    }
  } while ((object = Reflect.getPrototypeOf(object)) && object !== Object.prototype);
  return properties;
};
var autoBind = (self2, { include, exclude } = {}) => {
  const filter = (key2) => {
    const match2 = (pattern) => typeof pattern === "string" ? key2 === pattern : pattern.test(key2);
    if (include) {
      return include.some(match2);
    }
    if (exclude) {
      return !exclude.some(match2);
    }
    return true;
  };
  for (const [object, key2] of getAllProperties(self2.constructor.prototype)) {
    if (key2 === "constructor" || !filter(key2)) {
      continue;
    }
    const descriptor = Reflect.getOwnPropertyDescriptor(object, key2);
    if (descriptor && typeof descriptor.value === "function") {
      self2[key2] = self2[key2].bind(self2);
    }
  }
  return self2;
};
const autoBind$1 = /* @__PURE__ */ getDefaultExportFromCjs(autoBind);
var fuzzysort$1 = { exports: {} };
(function(module) {
  ((root2, UMD) => {
    if (module.exports)
      module.exports = UMD();
    else
      root2["fuzzysort"] = UMD();
  })(commonjsGlobal, (_2) => {
    var single = (search, target) => {
      if (search == "farzher")
        return { target: "farzher was here (^-^*)/", score: 0, _indexes: [0] };
      if (!search || !target)
        return NULL;
      var preparedSearch = getPreparedSearch(search);
      if (!isObj(target))
        target = getPrepared(target);
      var searchBitflags = preparedSearch.bitflags;
      if ((searchBitflags & target._bitflags) !== searchBitflags)
        return NULL;
      return algorithm(preparedSearch, target);
    };
    var go = (search, targets, options) => {
      if (search == "farzher")
        return [{ target: "farzher was here (^-^*)/", score: 0, _indexes: [0], obj: targets ? targets[0] : NULL }];
      if (!search)
        return options && options.all ? all2(search, targets, options) : noResults;
      var preparedSearch = getPreparedSearch(search);
      var searchBitflags = preparedSearch.bitflags;
      preparedSearch.containsSpace;
      var threshold = options && options.threshold || INT_MIN;
      var limit = options && options["limit"] || INT_MAX;
      var resultsLen = 0;
      var limitedCount = 0;
      var targetsLen = targets.length;
      if (options && options.key) {
        var key2 = options.key;
        for (var i = 0; i < targetsLen; ++i) {
          var obj = targets[i];
          var target = getValue2(obj, key2);
          if (!target)
            continue;
          if (!isObj(target))
            target = getPrepared(target);
          if ((searchBitflags & target._bitflags) !== searchBitflags)
            continue;
          var result = algorithm(preparedSearch, target);
          if (result === NULL)
            continue;
          if (result.score < threshold)
            continue;
          result = { target: result.target, _targetLower: "", _targetLowerCodes: NULL, _nextBeginningIndexes: NULL, _bitflags: 0, score: result.score, _indexes: result._indexes, obj };
          if (resultsLen < limit) {
            q2.add(result);
            ++resultsLen;
          } else {
            ++limitedCount;
            if (result.score > q2.peek().score)
              q2.replaceTop(result);
          }
        }
      } else if (options && options.keys) {
        var scoreFn = options["scoreFn"] || defaultScoreFn;
        var keys2 = options.keys;
        var keysLen = keys2.length;
        for (var i = 0; i < targetsLen; ++i) {
          var obj = targets[i];
          var objResults = new Array(keysLen);
          for (var keyI = 0; keyI < keysLen; ++keyI) {
            var key2 = keys2[keyI];
            var target = getValue2(obj, key2);
            if (!target) {
              objResults[keyI] = NULL;
              continue;
            }
            if (!isObj(target))
              target = getPrepared(target);
            if ((searchBitflags & target._bitflags) !== searchBitflags)
              objResults[keyI] = NULL;
            else
              objResults[keyI] = algorithm(preparedSearch, target);
          }
          objResults.obj = obj;
          var score = scoreFn(objResults);
          if (score === NULL)
            continue;
          if (score < threshold)
            continue;
          objResults.score = score;
          if (resultsLen < limit) {
            q2.add(objResults);
            ++resultsLen;
          } else {
            ++limitedCount;
            if (score > q2.peek().score)
              q2.replaceTop(objResults);
          }
        }
      } else {
        for (var i = 0; i < targetsLen; ++i) {
          var target = targets[i];
          if (!target)
            continue;
          if (!isObj(target))
            target = getPrepared(target);
          if ((searchBitflags & target._bitflags) !== searchBitflags)
            continue;
          var result = algorithm(preparedSearch, target);
          if (result === NULL)
            continue;
          if (result.score < threshold)
            continue;
          if (resultsLen < limit) {
            q2.add(result);
            ++resultsLen;
          } else {
            ++limitedCount;
            if (result.score > q2.peek().score)
              q2.replaceTop(result);
          }
        }
      }
      if (resultsLen === 0)
        return noResults;
      var results = new Array(resultsLen);
      for (var i = resultsLen - 1; i >= 0; --i)
        results[i] = q2.poll();
      results.total = resultsLen + limitedCount;
      return results;
    };
    var highlight = (result, hOpen, hClose) => {
      if (typeof hOpen === "function")
        return highlightCallback(result, hOpen);
      if (result === NULL)
        return NULL;
      if (hOpen === void 0)
        hOpen = "<b>";
      if (hClose === void 0)
        hClose = "</b>";
      var highlighted = "";
      var matchesIndex = 0;
      var opened = false;
      var target = result.target;
      var targetLen = target.length;
      var indexes2 = result._indexes;
      indexes2 = indexes2.slice(0, indexes2.len).sort((a, b2) => a - b2);
      for (var i = 0; i < targetLen; ++i) {
        var char = target[i];
        if (indexes2[matchesIndex] === i) {
          ++matchesIndex;
          if (!opened) {
            opened = true;
            highlighted += hOpen;
          }
          if (matchesIndex === indexes2.length) {
            highlighted += char + hClose + target.substr(i + 1);
            break;
          }
        } else {
          if (opened) {
            opened = false;
            highlighted += hClose;
          }
        }
        highlighted += char;
      }
      return highlighted;
    };
    var highlightCallback = (result, cb) => {
      if (result === NULL)
        return NULL;
      var target = result.target;
      var targetLen = target.length;
      var indexes2 = result._indexes;
      indexes2 = indexes2.slice(0, indexes2.len).sort((a, b2) => a - b2);
      var highlighted = "";
      var matchI = 0;
      var indexesI = 0;
      var opened = false;
      var result = [];
      for (var i = 0; i < targetLen; ++i) {
        var char = target[i];
        if (indexes2[indexesI] === i) {
          ++indexesI;
          if (!opened) {
            opened = true;
            result.push(highlighted);
            highlighted = "";
          }
          if (indexesI === indexes2.length) {
            highlighted += char;
            result.push(cb(highlighted, matchI++));
            highlighted = "";
            result.push(target.substr(i + 1));
            break;
          }
        } else {
          if (opened) {
            opened = false;
            result.push(cb(highlighted, matchI++));
            highlighted = "";
          }
        }
        highlighted += char;
      }
      return result;
    };
    var indexes = (result) => result._indexes.slice(0, result._indexes.len).sort((a, b2) => a - b2);
    var prepare = (target) => {
      if (typeof target !== "string")
        target = "";
      var info = prepareLowerInfo(target);
      return { "target": target, _targetLower: info._lower, _targetLowerCodes: info.lowerCodes, _nextBeginningIndexes: NULL, _bitflags: info.bitflags, "score": NULL, _indexes: [0], "obj": NULL };
    };
    var prepareSearch = (search) => {
      if (typeof search !== "string")
        search = "";
      search = search.trim();
      var info = prepareLowerInfo(search);
      var spaceSearches = [];
      if (info.containsSpace) {
        var searches = search.split(/\s+/);
        searches = [...new Set(searches)];
        for (var i = 0; i < searches.length; i++) {
          if (searches[i] === "")
            continue;
          var _info = prepareLowerInfo(searches[i]);
          spaceSearches.push({ lowerCodes: _info.lowerCodes, _lower: searches[i].toLowerCase(), containsSpace: false });
        }
      }
      return { lowerCodes: info.lowerCodes, bitflags: info.bitflags, containsSpace: info.containsSpace, _lower: info._lower, spaceSearches };
    };
    var getPrepared = (target) => {
      if (target.length > 999)
        return prepare(target);
      var targetPrepared = preparedCache.get(target);
      if (targetPrepared !== void 0)
        return targetPrepared;
      targetPrepared = prepare(target);
      preparedCache.set(target, targetPrepared);
      return targetPrepared;
    };
    var getPreparedSearch = (search) => {
      if (search.length > 999)
        return prepareSearch(search);
      var searchPrepared = preparedSearchCache.get(search);
      if (searchPrepared !== void 0)
        return searchPrepared;
      searchPrepared = prepareSearch(search);
      preparedSearchCache.set(search, searchPrepared);
      return searchPrepared;
    };
    var all2 = (search, targets, options) => {
      var results = [];
      results.total = targets.length;
      var limit = options && options.limit || INT_MAX;
      if (options && options.key) {
        for (var i = 0; i < targets.length; i++) {
          var obj = targets[i];
          var target = getValue2(obj, options.key);
          if (!target)
            continue;
          if (!isObj(target))
            target = getPrepared(target);
          target.score = INT_MIN;
          target._indexes.len = 0;
          var result = target;
          result = { target: result.target, _targetLower: "", _targetLowerCodes: NULL, _nextBeginningIndexes: NULL, _bitflags: 0, score: target.score, _indexes: NULL, obj };
          results.push(result);
          if (results.length >= limit)
            return results;
        }
      } else if (options && options.keys) {
        for (var i = 0; i < targets.length; i++) {
          var obj = targets[i];
          var objResults = new Array(options.keys.length);
          for (var keyI = options.keys.length - 1; keyI >= 0; --keyI) {
            var target = getValue2(obj, options.keys[keyI]);
            if (!target) {
              objResults[keyI] = NULL;
              continue;
            }
            if (!isObj(target))
              target = getPrepared(target);
            target.score = INT_MIN;
            target._indexes.len = 0;
            objResults[keyI] = target;
          }
          objResults.obj = obj;
          objResults.score = INT_MIN;
          results.push(objResults);
          if (results.length >= limit)
            return results;
        }
      } else {
        for (var i = 0; i < targets.length; i++) {
          var target = targets[i];
          if (!target)
            continue;
          if (!isObj(target))
            target = getPrepared(target);
          target.score = INT_MIN;
          target._indexes.len = 0;
          results.push(target);
          if (results.length >= limit)
            return results;
        }
      }
      return results;
    };
    var algorithm = (preparedSearch, prepared, allowSpaces = false) => {
      if (allowSpaces === false && preparedSearch.containsSpace)
        return algorithmSpaces(preparedSearch, prepared);
      var searchLower = preparedSearch._lower;
      var searchLowerCodes = preparedSearch.lowerCodes;
      var searchLowerCode = searchLowerCodes[0];
      var targetLowerCodes = prepared._targetLowerCodes;
      var searchLen = searchLowerCodes.length;
      var targetLen = targetLowerCodes.length;
      var searchI = 0;
      var targetI = 0;
      var matchesSimpleLen = 0;
      for (; ; ) {
        var isMatch = searchLowerCode === targetLowerCodes[targetI];
        if (isMatch) {
          matchesSimple[matchesSimpleLen++] = targetI;
          ++searchI;
          if (searchI === searchLen)
            break;
          searchLowerCode = searchLowerCodes[searchI];
        }
        ++targetI;
        if (targetI >= targetLen)
          return NULL;
      }
      var searchI = 0;
      var successStrict = false;
      var matchesStrictLen = 0;
      var nextBeginningIndexes = prepared._nextBeginningIndexes;
      if (nextBeginningIndexes === NULL)
        nextBeginningIndexes = prepared._nextBeginningIndexes = prepareNextBeginningIndexes(prepared.target);
      targetI = matchesSimple[0] === 0 ? 0 : nextBeginningIndexes[matchesSimple[0] - 1];
      var backtrackCount = 0;
      if (targetI !== targetLen)
        for (; ; ) {
          if (targetI >= targetLen) {
            if (searchI <= 0)
              break;
            ++backtrackCount;
            if (backtrackCount > 200)
              break;
            --searchI;
            var lastMatch = matchesStrict[--matchesStrictLen];
            targetI = nextBeginningIndexes[lastMatch];
          } else {
            var isMatch = searchLowerCodes[searchI] === targetLowerCodes[targetI];
            if (isMatch) {
              matchesStrict[matchesStrictLen++] = targetI;
              ++searchI;
              if (searchI === searchLen) {
                successStrict = true;
                break;
              }
              ++targetI;
            } else {
              targetI = nextBeginningIndexes[targetI];
            }
          }
        }
      var substringIndex = prepared._targetLower.indexOf(searchLower, matchesSimple[0]);
      var isSubstring = ~substringIndex;
      if (isSubstring && !successStrict) {
        for (var i = 0; i < matchesSimpleLen; ++i)
          matchesSimple[i] = substringIndex + i;
      }
      var isSubstringBeginning = false;
      if (isSubstring) {
        isSubstringBeginning = prepared._nextBeginningIndexes[substringIndex - 1] === substringIndex;
      }
      {
        if (successStrict) {
          var matchesBest = matchesStrict;
          var matchesBestLen = matchesStrictLen;
        } else {
          var matchesBest = matchesSimple;
          var matchesBestLen = matchesSimpleLen;
        }
        var score = 0;
        var extraMatchGroupCount = 0;
        for (var i = 1; i < searchLen; ++i) {
          if (matchesBest[i] - matchesBest[i - 1] !== 1) {
            score -= matchesBest[i];
            ++extraMatchGroupCount;
          }
        }
        var unmatchedDistance = matchesBest[searchLen - 1] - matchesBest[0] - (searchLen - 1);
        score -= (12 + unmatchedDistance) * extraMatchGroupCount;
        if (matchesBest[0] !== 0)
          score -= matchesBest[0] * matchesBest[0] * 0.2;
        if (!successStrict) {
          score *= 1e3;
        } else {
          var uniqueBeginningIndexes = 1;
          for (var i = nextBeginningIndexes[0]; i < targetLen; i = nextBeginningIndexes[i])
            ++uniqueBeginningIndexes;
          if (uniqueBeginningIndexes > 24)
            score *= (uniqueBeginningIndexes - 24) * 10;
        }
        if (isSubstring)
          score /= 1 + searchLen * searchLen * 1;
        if (isSubstringBeginning)
          score /= 1 + searchLen * searchLen * 1;
        score -= targetLen - searchLen;
        prepared.score = score;
        for (var i = 0; i < matchesBestLen; ++i)
          prepared._indexes[i] = matchesBest[i];
        prepared._indexes.len = matchesBestLen;
        return prepared;
      }
    };
    var algorithmSpaces = (preparedSearch, target) => {
      var seen_indexes = /* @__PURE__ */ new Set();
      var score = 0;
      var result = NULL;
      var first_seen_index_last_search = 0;
      var searches = preparedSearch.spaceSearches;
      for (var i = 0; i < searches.length; ++i) {
        var search = searches[i];
        result = algorithm(search, target);
        if (result === NULL)
          return NULL;
        score += result.score;
        if (result._indexes[0] < first_seen_index_last_search) {
          score -= first_seen_index_last_search - result._indexes[0];
        }
        first_seen_index_last_search = result._indexes[0];
        for (var j2 = 0; j2 < result._indexes.len; ++j2)
          seen_indexes.add(result._indexes[j2]);
      }
      var allowSpacesResult = algorithm(
        preparedSearch,
        target,
        /*allowSpaces=*/
        true
      );
      if (allowSpacesResult !== NULL && allowSpacesResult.score > score) {
        return allowSpacesResult;
      }
      result.score = score;
      var i = 0;
      for (let index2 of seen_indexes)
        result._indexes[i++] = index2;
      result._indexes.len = i;
      return result;
    };
    var prepareLowerInfo = (str) => {
      var strLen = str.length;
      var lower = str.toLowerCase();
      var lowerCodes = [];
      var bitflags = 0;
      var containsSpace = false;
      for (var i = 0; i < strLen; ++i) {
        var lowerCode = lowerCodes[i] = lower.charCodeAt(i);
        if (lowerCode === 32) {
          containsSpace = true;
          continue;
        }
        var bit = lowerCode >= 97 && lowerCode <= 122 ? lowerCode - 97 : lowerCode >= 48 && lowerCode <= 57 ? 26 : lowerCode <= 127 ? 30 : 31;
        bitflags |= 1 << bit;
      }
      return { lowerCodes, bitflags, containsSpace, _lower: lower };
    };
    var prepareBeginningIndexes = (target) => {
      var targetLen = target.length;
      var beginningIndexes = [];
      var beginningIndexesLen = 0;
      var wasUpper = false;
      var wasAlphanum = false;
      for (var i = 0; i < targetLen; ++i) {
        var targetCode = target.charCodeAt(i);
        var isUpper = targetCode >= 65 && targetCode <= 90;
        var isAlphanum = isUpper || targetCode >= 97 && targetCode <= 122 || targetCode >= 48 && targetCode <= 57;
        var isBeginning = isUpper && !wasUpper || !wasAlphanum || !isAlphanum;
        wasUpper = isUpper;
        wasAlphanum = isAlphanum;
        if (isBeginning)
          beginningIndexes[beginningIndexesLen++] = i;
      }
      return beginningIndexes;
    };
    var prepareNextBeginningIndexes = (target) => {
      var targetLen = target.length;
      var beginningIndexes = prepareBeginningIndexes(target);
      var nextBeginningIndexes = [];
      var lastIsBeginning = beginningIndexes[0];
      var lastIsBeginningI = 0;
      for (var i = 0; i < targetLen; ++i) {
        if (lastIsBeginning > i) {
          nextBeginningIndexes[i] = lastIsBeginning;
        } else {
          lastIsBeginning = beginningIndexes[++lastIsBeginningI];
          nextBeginningIndexes[i] = lastIsBeginning === void 0 ? targetLen : lastIsBeginning;
        }
      }
      return nextBeginningIndexes;
    };
    var cleanup = () => {
      preparedCache.clear();
      preparedSearchCache.clear();
      matchesSimple = [];
      matchesStrict = [];
    };
    var preparedCache = /* @__PURE__ */ new Map();
    var preparedSearchCache = /* @__PURE__ */ new Map();
    var matchesSimple = [];
    var matchesStrict = [];
    var defaultScoreFn = (a) => {
      var max2 = INT_MIN;
      var len = a.length;
      for (var i = 0; i < len; ++i) {
        var result = a[i];
        if (result === NULL)
          continue;
        var score = result.score;
        if (score > max2)
          max2 = score;
      }
      if (max2 === INT_MIN)
        return NULL;
      return max2;
    };
    var getValue2 = (obj, prop) => {
      var tmp = obj[prop];
      if (tmp !== void 0)
        return tmp;
      var segs = prop;
      if (!Array.isArray(prop))
        segs = prop.split(".");
      var len = segs.length;
      var i = -1;
      while (obj && ++i < len)
        obj = obj[segs[i]];
      return obj;
    };
    var isObj = (x2) => {
      return typeof x2 === "object";
    };
    var INT_MAX = Infinity;
    var INT_MIN = -INT_MAX;
    var noResults = [];
    noResults.total = 0;
    var NULL = null;
    var fastpriorityqueue = (r) => {
      var e = [], o = 0, a = {}, v2 = (r2) => {
        for (var a2 = 0, v3 = e[a2], c2 = 1; c2 < o; ) {
          var s = c2 + 1;
          a2 = c2, s < o && e[s].score < e[c2].score && (a2 = s), e[a2 - 1 >> 1] = e[a2], c2 = 1 + (a2 << 1);
        }
        for (var f2 = a2 - 1 >> 1; a2 > 0 && v3.score < e[f2].score; f2 = (a2 = f2) - 1 >> 1)
          e[a2] = e[f2];
        e[a2] = v3;
      };
      return a.add = (r2) => {
        var a2 = o;
        e[o++] = r2;
        for (var v3 = a2 - 1 >> 1; a2 > 0 && r2.score < e[v3].score; v3 = (a2 = v3) - 1 >> 1)
          e[a2] = e[v3];
        e[a2] = r2;
      }, a.poll = (r2) => {
        if (0 !== o) {
          var a2 = e[0];
          return e[0] = e[--o], v2(), a2;
        }
      }, a.peek = (r2) => {
        if (0 !== o)
          return e[0];
      }, a.replaceTop = (r2) => {
        e[0] = r2, v2();
      }, a;
    };
    var q2 = fastpriorityqueue();
    return { "single": single, "go": go, "highlight": highlight, "prepare": prepare, "indexes": indexes, "cleanup": cleanup };
  });
})(fuzzysort$1);
var fuzzysortExports = fuzzysort$1.exports;
const fuzzysort = /* @__PURE__ */ getDefaultExportFromCjs(fuzzysortExports);
var mustache = {};
/*!
 * mustache.js - Logic-less {{mustache}} templates with JavaScript
 * http://github.com/janl/mustache.js
 */
(function(exports) {
  (function defineMustache(global2, factory) {
    if (exports && typeof exports.nodeName !== "string") {
      factory(exports);
    } else {
      global2.Mustache = {};
      factory(global2.Mustache);
    }
  })(commonjsGlobal, function mustacheFactory(mustache2) {
    var objectToString2 = Object.prototype.toString;
    var isArray2 = Array.isArray || function isArrayPolyfill(object) {
      return objectToString2.call(object) === "[object Array]";
    };
    function isFunction2(object) {
      return typeof object === "function";
    }
    function typeStr(obj) {
      return isArray2(obj) ? "array" : typeof obj;
    }
    function escapeRegExp(string) {
      return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
    }
    function hasProperty(obj, propName) {
      return obj != null && typeof obj === "object" && propName in obj;
    }
    var regExpTest = RegExp.prototype.test;
    function testRegExp(re2, string) {
      return regExpTest.call(re2, string);
    }
    var nonSpaceRe = /\S/;
    function isWhitespace(string) {
      return !testRegExp(nonSpaceRe, string);
    }
    var entityMap = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;",
      "/": "&#x2F;",
      "`": "&#x60;",
      "=": "&#x3D;"
    };
    function escapeHtml(string) {
      return String(string).replace(/[&<>"'`=\/]/g, function fromEntityMap(s) {
        return entityMap[s];
      });
    }
    var whiteRe = /\s*/;
    var spaceRe = /\s+/;
    var equalsRe = /\s*=/;
    var curlyRe = /\s*\}/;
    var tagRe = /#|\^|\/|>|\{|&|=|!/;
    function parseTemplate(template, tags) {
      if (!template)
        return [];
      var sections = [];
      var tokens = [];
      var spaces = [];
      var hasTag = false;
      var nonSpace = false;
      function stripSpace() {
        if (hasTag && !nonSpace) {
          while (spaces.length)
            delete tokens[spaces.pop()];
        } else {
          spaces = [];
        }
        hasTag = false;
        nonSpace = false;
      }
      var openingTagRe, closingTagRe, closingCurlyRe;
      function compileTags(tagsToCompile) {
        if (typeof tagsToCompile === "string")
          tagsToCompile = tagsToCompile.split(spaceRe, 2);
        if (!isArray2(tagsToCompile) || tagsToCompile.length !== 2)
          throw new Error("Invalid tags: " + tagsToCompile);
        openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + "\\s*");
        closingTagRe = new RegExp("\\s*" + escapeRegExp(tagsToCompile[1]));
        closingCurlyRe = new RegExp("\\s*" + escapeRegExp("}" + tagsToCompile[1]));
      }
      compileTags(tags || mustache2.tags);
      var scanner = new Scanner(template);
      var start, type2, value, chr, token2, openSection;
      while (!scanner.eos()) {
        start = scanner.pos;
        value = scanner.scanUntil(openingTagRe);
        if (value) {
          for (var i = 0, valueLength = value.length; i < valueLength; ++i) {
            chr = value.charAt(i);
            if (isWhitespace(chr)) {
              spaces.push(tokens.length);
            } else {
              nonSpace = true;
            }
            tokens.push(["text", chr, start, start + 1]);
            start += 1;
            if (chr === "\n")
              stripSpace();
          }
        }
        if (!scanner.scan(openingTagRe))
          break;
        hasTag = true;
        type2 = scanner.scan(tagRe) || "name";
        scanner.scan(whiteRe);
        if (type2 === "=") {
          value = scanner.scanUntil(equalsRe);
          scanner.scan(equalsRe);
          scanner.scanUntil(closingTagRe);
        } else if (type2 === "{") {
          value = scanner.scanUntil(closingCurlyRe);
          scanner.scan(curlyRe);
          scanner.scanUntil(closingTagRe);
          type2 = "&";
        } else {
          value = scanner.scanUntil(closingTagRe);
        }
        if (!scanner.scan(closingTagRe))
          throw new Error("Unclosed tag at " + scanner.pos);
        token2 = [type2, value, start, scanner.pos];
        tokens.push(token2);
        if (type2 === "#" || type2 === "^") {
          sections.push(token2);
        } else if (type2 === "/") {
          openSection = sections.pop();
          if (!openSection)
            throw new Error('Unopened section "' + value + '" at ' + start);
          if (openSection[1] !== value)
            throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
        } else if (type2 === "name" || type2 === "{" || type2 === "&") {
          nonSpace = true;
        } else if (type2 === "=") {
          compileTags(value);
        }
      }
      openSection = sections.pop();
      if (openSection)
        throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);
      return nestTokens(squashTokens(tokens));
    }
    function squashTokens(tokens) {
      var squashedTokens = [];
      var token2, lastToken;
      for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
        token2 = tokens[i];
        if (token2) {
          if (token2[0] === "text" && lastToken && lastToken[0] === "text") {
            lastToken[1] += token2[1];
            lastToken[3] = token2[3];
          } else {
            squashedTokens.push(token2);
            lastToken = token2;
          }
        }
      }
      return squashedTokens;
    }
    function nestTokens(tokens) {
      var nestedTokens = [];
      var collector = nestedTokens;
      var sections = [];
      var token2, section;
      for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
        token2 = tokens[i];
        switch (token2[0]) {
          case "#":
          case "^":
            collector.push(token2);
            sections.push(token2);
            collector = token2[4] = [];
            break;
          case "/":
            section = sections.pop();
            section[5] = token2[2];
            collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
            break;
          default:
            collector.push(token2);
        }
      }
      return nestedTokens;
    }
    function Scanner(string) {
      this.string = string;
      this.tail = string;
      this.pos = 0;
    }
    Scanner.prototype.eos = function eos() {
      return this.tail === "";
    };
    Scanner.prototype.scan = function scan(re2) {
      var match2 = this.tail.match(re2);
      if (!match2 || match2.index !== 0)
        return "";
      var string = match2[0];
      this.tail = this.tail.substring(string.length);
      this.pos += string.length;
      return string;
    };
    Scanner.prototype.scanUntil = function scanUntil(re2) {
      var index2 = this.tail.search(re2), match2;
      switch (index2) {
        case -1:
          match2 = this.tail;
          this.tail = "";
          break;
        case 0:
          match2 = "";
          break;
        default:
          match2 = this.tail.substring(0, index2);
          this.tail = this.tail.substring(index2);
      }
      this.pos += match2.length;
      return match2;
    };
    function Context(view, parentContext) {
      this.view = view;
      this.cache = { ".": this.view };
      this.parent = parentContext;
    }
    Context.prototype.push = function push2(view) {
      return new Context(view, this);
    };
    Context.prototype.lookup = function lookup(name) {
      var cache = this.cache;
      var value;
      if (cache.hasOwnProperty(name)) {
        value = cache[name];
      } else {
        var context = this, names, index2, lookupHit = false;
        while (context) {
          if (name.indexOf(".") > 0) {
            value = context.view;
            names = name.split(".");
            index2 = 0;
            while (value != null && index2 < names.length) {
              if (index2 === names.length - 1)
                lookupHit = hasProperty(value, names[index2]);
              value = value[names[index2++]];
            }
          } else {
            value = context.view[name];
            lookupHit = hasProperty(context.view, name);
          }
          if (lookupHit)
            break;
          context = context.parent;
        }
        cache[name] = value;
      }
      if (isFunction2(value))
        value = value.call(this.view);
      return value;
    };
    function Writer() {
      this.cache = {};
    }
    Writer.prototype.clearCache = function clearCache() {
      this.cache = {};
    };
    Writer.prototype.parse = function parse3(template, tags) {
      var cache = this.cache;
      var tokens = cache[template];
      if (tokens == null)
        tokens = cache[template] = parseTemplate(template, tags);
      return tokens;
    };
    Writer.prototype.render = function render2(template, view, partials) {
      var tokens = this.parse(template);
      var context = view instanceof Context ? view : new Context(view);
      return this.renderTokens(tokens, context, partials, template);
    };
    Writer.prototype.renderTokens = function renderTokens(tokens, context, partials, originalTemplate) {
      var buffer2 = "";
      var token2, symbol, value;
      for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
        value = void 0;
        token2 = tokens[i];
        symbol = token2[0];
        if (symbol === "#")
          value = this.renderSection(token2, context, partials, originalTemplate);
        else if (symbol === "^")
          value = this.renderInverted(token2, context, partials, originalTemplate);
        else if (symbol === ">")
          value = this.renderPartial(token2, context, partials, originalTemplate);
        else if (symbol === "&")
          value = this.unescapedValue(token2, context);
        else if (symbol === "name")
          value = this.escapedValue(token2, context);
        else if (symbol === "text")
          value = this.rawValue(token2);
        if (value !== void 0)
          buffer2 += value;
      }
      return buffer2;
    };
    Writer.prototype.renderSection = function renderSection(token2, context, partials, originalTemplate) {
      var self2 = this;
      var buffer2 = "";
      var value = context.lookup(token2[1]);
      function subRender(template) {
        return self2.render(template, context, partials);
      }
      if (!value)
        return;
      if (isArray2(value)) {
        for (var j2 = 0, valueLength = value.length; j2 < valueLength; ++j2) {
          buffer2 += this.renderTokens(token2[4], context.push(value[j2]), partials, originalTemplate);
        }
      } else if (typeof value === "object" || typeof value === "string" || typeof value === "number") {
        buffer2 += this.renderTokens(token2[4], context.push(value), partials, originalTemplate);
      } else if (isFunction2(value)) {
        if (typeof originalTemplate !== "string")
          throw new Error("Cannot use higher-order sections without the original template");
        value = value.call(context.view, originalTemplate.slice(token2[3], token2[5]), subRender);
        if (value != null)
          buffer2 += value;
      } else {
        buffer2 += this.renderTokens(token2[4], context, partials, originalTemplate);
      }
      return buffer2;
    };
    Writer.prototype.renderInverted = function renderInverted(token2, context, partials, originalTemplate) {
      var value = context.lookup(token2[1]);
      if (!value || isArray2(value) && value.length === 0)
        return this.renderTokens(token2[4], context, partials, originalTemplate);
    };
    Writer.prototype.renderPartial = function renderPartial(token2, context, partials) {
      if (!partials)
        return;
      var value = isFunction2(partials) ? partials(token2[1]) : partials[token2[1]];
      if (value != null)
        return this.renderTokens(this.parse(value), context, partials, value);
    };
    Writer.prototype.unescapedValue = function unescapedValue(token2, context) {
      var value = context.lookup(token2[1]);
      if (value != null)
        return value;
    };
    Writer.prototype.escapedValue = function escapedValue(token2, context) {
      var value = context.lookup(token2[1]);
      if (value != null)
        return mustache2.escape(value);
    };
    Writer.prototype.rawValue = function rawValue(token2) {
      return token2[1];
    };
    mustache2.name = "mustache.js";
    mustache2.version = "2.3.2";
    mustache2.tags = ["{{", "}}"];
    var defaultWriter = new Writer();
    mustache2.clearCache = function clearCache() {
      return defaultWriter.clearCache();
    };
    mustache2.parse = function parse3(template, tags) {
      return defaultWriter.parse(template, tags);
    };
    mustache2.render = function render2(template, view, partials) {
      if (typeof template !== "string") {
        throw new TypeError('Invalid template! Template should be a "string" but "' + typeStr(template) + '" was given as the first argument for mustache#render(template, view, partials)');
      }
      return defaultWriter.render(template, view, partials);
    };
    mustache2.to_html = function to_html(template, view, partials, send) {
      var result = mustache2.render(template, view, partials);
      if (isFunction2(send)) {
        send(result);
      } else {
        return result;
      }
    };
    mustache2.escape = escapeHtml;
    mustache2.Scanner = Scanner;
    mustache2.Context = Context;
    mustache2.Writer = Writer;
    return mustache2;
  });
})(mustache);
var shams = function hasSymbols() {
  if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
    return false;
  }
  if (typeof Symbol.iterator === "symbol") {
    return true;
  }
  var obj = {};
  var sym = Symbol("test");
  var symObj = Object(sym);
  if (typeof sym === "string") {
    return false;
  }
  if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
    return false;
  }
  if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
    return false;
  }
  var symVal = 42;
  obj[sym] = symVal;
  for (sym in obj) {
    return false;
  }
  if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
    return false;
  }
  if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
    return false;
  }
  var syms = Object.getOwnPropertySymbols(obj);
  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }
  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
    return false;
  }
  if (typeof Object.getOwnPropertyDescriptor === "function") {
    var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
      return false;
    }
  }
  return true;
};
var origSymbol = typeof Symbol !== "undefined" && Symbol;
var hasSymbolSham = shams;
var hasSymbols$1 = function hasNativeSymbols() {
  if (typeof origSymbol !== "function") {
    return false;
  }
  if (typeof Symbol !== "function") {
    return false;
  }
  if (typeof origSymbol("foo") !== "symbol") {
    return false;
  }
  if (typeof Symbol("bar") !== "symbol") {
    return false;
  }
  return hasSymbolSham();
};
var test = {
  foo: {}
};
var $Object = Object;
var hasProto$1 = function hasProto() {
  return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
};
var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
var toStr$1 = Object.prototype.toString;
var max = Math.max;
var funcType = "[object Function]";
var concatty = function concatty2(a, b2) {
  var arr = [];
  for (var i = 0; i < a.length; i += 1) {
    arr[i] = a[i];
  }
  for (var j2 = 0; j2 < b2.length; j2 += 1) {
    arr[j2 + a.length] = b2[j2];
  }
  return arr;
};
var slicy = function slicy2(arrLike, offset) {
  var arr = [];
  for (var i = offset || 0, j2 = 0; i < arrLike.length; i += 1, j2 += 1) {
    arr[j2] = arrLike[i];
  }
  return arr;
};
var joiny = function(arr, joiner) {
  var str = "";
  for (var i = 0; i < arr.length; i += 1) {
    str += arr[i];
    if (i + 1 < arr.length) {
      str += joiner;
    }
  }
  return str;
};
var implementation$1 = function bind2(that) {
  var target = this;
  if (typeof target !== "function" || toStr$1.apply(target) !== funcType) {
    throw new TypeError(ERROR_MESSAGE + target);
  }
  var args = slicy(arguments, 1);
  var bound;
  var binder = function() {
    if (this instanceof bound) {
      var result = target.apply(
        this,
        concatty(args, arguments)
      );
      if (Object(result) === result) {
        return result;
      }
      return this;
    }
    return target.apply(
      that,
      concatty(args, arguments)
    );
  };
  var boundLength = max(0, target.length - args.length);
  var boundArgs = [];
  for (var i = 0; i < boundLength; i++) {
    boundArgs[i] = "$" + i;
  }
  bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
  if (target.prototype) {
    var Empty = function Empty2() {
    };
    Empty.prototype = target.prototype;
    bound.prototype = new Empty();
    Empty.prototype = null;
  }
  return bound;
};
var implementation = implementation$1;
var functionBind = Function.prototype.bind || implementation;
var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind$1 = functionBind;
var hasown = bind$1.call(call, $hasOwn);
var undefined$1;
var $SyntaxError$1 = SyntaxError;
var $Function = Function;
var $TypeError$3 = TypeError;
var getEvalledConstructor = function(expressionSyntax) {
  try {
    return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
  } catch (e) {
  }
};
var $gOPD$1 = Object.getOwnPropertyDescriptor;
if ($gOPD$1) {
  try {
    $gOPD$1({}, "");
  } catch (e) {
    $gOPD$1 = null;
  }
}
var throwTypeError = function() {
  throw new $TypeError$3();
};
var ThrowTypeError = $gOPD$1 ? function() {
  try {
    arguments.callee;
    return throwTypeError;
  } catch (calleeThrows) {
    try {
      return $gOPD$1(arguments, "callee").get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;
var hasSymbols2 = hasSymbols$1();
var hasProto2 = hasProto$1();
var getProto = Object.getPrototypeOf || (hasProto2 ? function(x2) {
  return x2.__proto__;
} : null);
var needsEval = {};
var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined$1 : getProto(Uint8Array);
var INTRINSICS = {
  "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols2 && getProto ? getProto([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
  "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": EvalError,
  "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols2 && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
  "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
  "%RangeError%": RangeError,
  "%ReferenceError%": ReferenceError,
  "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols2 && getProto ? getProto(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols2 ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError$1,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$3,
  "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
  "%URIError%": URIError,
  "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
};
if (getProto) {
  try {
    null.error;
  } catch (e) {
    var errorProto = getProto(getProto(e));
    INTRINSICS["%Error.prototype%"] = errorProto;
  }
}
var doEval = function doEval2(name) {
  var value;
  if (name === "%AsyncFunction%") {
    value = getEvalledConstructor("async function () {}");
  } else if (name === "%GeneratorFunction%") {
    value = getEvalledConstructor("function* () {}");
  } else if (name === "%AsyncGeneratorFunction%") {
    value = getEvalledConstructor("async function* () {}");
  } else if (name === "%AsyncGenerator%") {
    var fn = doEval2("%AsyncGeneratorFunction%");
    if (fn) {
      value = fn.prototype;
    }
  } else if (name === "%AsyncIteratorPrototype%") {
    var gen = doEval2("%AsyncGenerator%");
    if (gen && getProto) {
      value = getProto(gen.prototype);
    }
  }
  INTRINSICS[name] = value;
  return value;
};
var LEGACY_ALIASES = {
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
};
var bind3 = functionBind;
var hasOwn$1 = hasown;
var $concat$1 = bind3.call(Function.call, Array.prototype.concat);
var $spliceApply = bind3.call(Function.apply, Array.prototype.splice);
var $replace$1 = bind3.call(Function.call, String.prototype.replace);
var $strSlice = bind3.call(Function.call, String.prototype.slice);
var $exec = bind3.call(Function.call, RegExp.prototype.exec);
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = function stringToPath2(string) {
  var first = $strSlice(string, 0, 1);
  var last = $strSlice(string, -1);
  if (first === "%" && last !== "%") {
    throw new $SyntaxError$1("invalid intrinsic syntax, expected closing `%`");
  } else if (last === "%" && first !== "%") {
    throw new $SyntaxError$1("invalid intrinsic syntax, expected opening `%`");
  }
  var result = [];
  $replace$1(string, rePropName, function(match2, number, quote2, subString) {
    result[result.length] = quote2 ? $replace$1(subString, reEscapeChar, "$1") : number || match2;
  });
  return result;
};
var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
  var intrinsicName = name;
  var alias;
  if (hasOwn$1(LEGACY_ALIASES, intrinsicName)) {
    alias = LEGACY_ALIASES[intrinsicName];
    intrinsicName = "%" + alias[0] + "%";
  }
  if (hasOwn$1(INTRINSICS, intrinsicName)) {
    var value = INTRINSICS[intrinsicName];
    if (value === needsEval) {
      value = doEval(intrinsicName);
    }
    if (typeof value === "undefined" && !allowMissing) {
      throw new $TypeError$3("intrinsic " + name + " exists, but is not available. Please file an issue!");
    }
    return {
      alias,
      name: intrinsicName,
      value
    };
  }
  throw new $SyntaxError$1("intrinsic " + name + " does not exist!");
};
var getIntrinsic = function GetIntrinsic(name, allowMissing) {
  if (typeof name !== "string" || name.length === 0) {
    throw new $TypeError$3("intrinsic name must be a non-empty string");
  }
  if (arguments.length > 1 && typeof allowMissing !== "boolean") {
    throw new $TypeError$3('"allowMissing" argument must be a boolean');
  }
  if ($exec(/^%?[^%]*%?$/, name) === null) {
    throw new $SyntaxError$1("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  }
  var parts = stringToPath(name);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
  var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;
  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply(parts, $concat$1([0, 1], alias));
  }
  for (var i = 1, isOwn = true; i < parts.length; i += 1) {
    var part = parts[i];
    var first = $strSlice(part, 0, 1);
    var last = $strSlice(part, -1);
    if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
      throw new $SyntaxError$1("property names with quotes must have matching quotes");
    }
    if (part === "constructor" || !isOwn) {
      skipFurtherCaching = true;
    }
    intrinsicBaseName += "." + part;
    intrinsicRealName = "%" + intrinsicBaseName + "%";
    if (hasOwn$1(INTRINSICS, intrinsicRealName)) {
      value = INTRINSICS[intrinsicRealName];
    } else if (value != null) {
      if (!(part in value)) {
        if (!allowMissing) {
          throw new $TypeError$3("base intrinsic for " + name + " exists, but the property is not available.");
        }
        return void 0;
      }
      if ($gOPD$1 && i + 1 >= parts.length) {
        var desc = $gOPD$1(value, part);
        isOwn = !!desc;
        if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
          value = desc.get;
        } else {
          value = value[part];
        }
      } else {
        isOwn = hasOwn$1(value, part);
        value = value[part];
      }
      if (isOwn && !skipFurtherCaching) {
        INTRINSICS[intrinsicRealName] = value;
      }
    }
  }
  return value;
};
var callBind$1 = { exports: {} };
var GetIntrinsic$5 = getIntrinsic;
var $defineProperty$1 = GetIntrinsic$5("%Object.defineProperty%", true);
var hasPropertyDescriptors$1 = function hasPropertyDescriptors() {
  if ($defineProperty$1) {
    try {
      $defineProperty$1({}, "a", { value: 1 });
      return true;
    } catch (e) {
      return false;
    }
  }
  return false;
};
hasPropertyDescriptors$1.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
  if (!hasPropertyDescriptors$1()) {
    return null;
  }
  try {
    return $defineProperty$1([], "length", { value: 1 }).length !== 1;
  } catch (e) {
    return true;
  }
};
var hasPropertyDescriptors_1 = hasPropertyDescriptors$1;
var GetIntrinsic$4 = getIntrinsic;
var $gOPD = GetIntrinsic$4("%Object.getOwnPropertyDescriptor%", true);
if ($gOPD) {
  try {
    $gOPD([], "length");
  } catch (e) {
    $gOPD = null;
  }
}
var gopd$1 = $gOPD;
var hasPropertyDescriptors2 = hasPropertyDescriptors_1();
var GetIntrinsic$3 = getIntrinsic;
var $defineProperty = hasPropertyDescriptors2 && GetIntrinsic$3("%Object.defineProperty%", true);
if ($defineProperty) {
  try {
    $defineProperty({}, "a", { value: 1 });
  } catch (e) {
    $defineProperty = false;
  }
}
var $SyntaxError = GetIntrinsic$3("%SyntaxError%");
var $TypeError$2 = GetIntrinsic$3("%TypeError%");
var gopd = gopd$1;
var defineDataProperty = function defineDataProperty2(obj, property, value) {
  if (!obj || typeof obj !== "object" && typeof obj !== "function") {
    throw new $TypeError$2("`obj` must be an object or a function`");
  }
  if (typeof property !== "string" && typeof property !== "symbol") {
    throw new $TypeError$2("`property` must be a string or a symbol`");
  }
  if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
    throw new $TypeError$2("`nonEnumerable`, if provided, must be a boolean or null");
  }
  if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
    throw new $TypeError$2("`nonWritable`, if provided, must be a boolean or null");
  }
  if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
    throw new $TypeError$2("`nonConfigurable`, if provided, must be a boolean or null");
  }
  if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
    throw new $TypeError$2("`loose`, if provided, must be a boolean");
  }
  var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
  var nonWritable = arguments.length > 4 ? arguments[4] : null;
  var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
  var loose = arguments.length > 6 ? arguments[6] : false;
  var desc = !!gopd && gopd(obj, property);
  if ($defineProperty) {
    $defineProperty(obj, property, {
      configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
      enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
      value,
      writable: nonWritable === null && desc ? desc.writable : !nonWritable
    });
  } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
    obj[property] = value;
  } else {
    throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
  }
};
var GetIntrinsic$2 = getIntrinsic;
var define = defineDataProperty;
var hasDescriptors = hasPropertyDescriptors_1();
var gOPD = gopd$1;
var $TypeError$1 = GetIntrinsic$2("%TypeError%");
var $floor$1 = GetIntrinsic$2("%Math.floor%");
var setFunctionLength = function setFunctionLength2(fn, length) {
  if (typeof fn !== "function") {
    throw new $TypeError$1("`fn` is not a function");
  }
  if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor$1(length) !== length) {
    throw new $TypeError$1("`length` must be a positive 32-bit integer");
  }
  var loose = arguments.length > 2 && !!arguments[2];
  var functionLengthIsConfigurable = true;
  var functionLengthIsWritable = true;
  if ("length" in fn && gOPD) {
    var desc = gOPD(fn, "length");
    if (desc && !desc.configurable) {
      functionLengthIsConfigurable = false;
    }
    if (desc && !desc.writable) {
      functionLengthIsWritable = false;
    }
  }
  if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
    if (hasDescriptors) {
      define(fn, "length", length, true, true);
    } else {
      define(fn, "length", length);
    }
  }
  return fn;
};
(function(module) {
  var bind4 = functionBind;
  var GetIntrinsic3 = getIntrinsic;
  var setFunctionLength$1 = setFunctionLength;
  var $TypeError2 = GetIntrinsic3("%TypeError%");
  var $apply = GetIntrinsic3("%Function.prototype.apply%");
  var $call = GetIntrinsic3("%Function.prototype.call%");
  var $reflectApply = GetIntrinsic3("%Reflect.apply%", true) || bind4.call($call, $apply);
  var $defineProperty2 = GetIntrinsic3("%Object.defineProperty%", true);
  var $max = GetIntrinsic3("%Math.max%");
  if ($defineProperty2) {
    try {
      $defineProperty2({}, "a", { value: 1 });
    } catch (e) {
      $defineProperty2 = null;
    }
  }
  module.exports = function callBind2(originalFunction) {
    if (typeof originalFunction !== "function") {
      throw new $TypeError2("a function is required");
    }
    var func = $reflectApply(bind4, $call, arguments);
    return setFunctionLength$1(
      func,
      1 + $max(0, originalFunction.length - (arguments.length - 1)),
      true
    );
  };
  var applyBind = function applyBind2() {
    return $reflectApply(bind4, $apply, arguments);
  };
  if ($defineProperty2) {
    $defineProperty2(module.exports, "apply", { value: applyBind });
  } else {
    module.exports.apply = applyBind;
  }
})(callBind$1);
var callBindExports = callBind$1.exports;
var GetIntrinsic$1 = getIntrinsic;
var callBind = callBindExports;
var $indexOf = callBind(GetIntrinsic$1("String.prototype.indexOf"));
var callBound$1 = function callBoundIntrinsic(name, allowMissing) {
  var intrinsic = GetIntrinsic$1(name, !!allowMissing);
  if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
    return callBind(intrinsic);
  }
  return intrinsic;
};
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var hasMap = typeof Map === "function" && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === "function" && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice = String.prototype.slice;
var $replace = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;
var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O2) {
  return O2.__proto__;
} : null);
function addNumericSeparator(num, str) {
  if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
    return str;
  }
  var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
  if (typeof num === "number") {
    var int = num < 0 ? -$floor(-num) : $floor(num);
    if (int !== num) {
      var intStr = String(int);
      var dec = $slice.call(str, intStr.length + 1);
      return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
    }
  }
  return $replace.call(str, sepRegex, "$&_");
}
var utilInspect = require$$0;
var inspectCustom = utilInspect.custom;
var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
var objectInspect = function inspect_(obj, options, depth, seen) {
  var opts = options || {};
  if (has$3(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
    throw new TypeError('option "quoteStyle" must be "single" or "double"');
  }
  if (has$3(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
    throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
  }
  var customInspect = has$3(opts, "customInspect") ? opts.customInspect : true;
  if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
    throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
  }
  if (has$3(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
    throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
  }
  if (has$3(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
    throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
  }
  var numericSeparator = opts.numericSeparator;
  if (typeof obj === "undefined") {
    return "undefined";
  }
  if (obj === null) {
    return "null";
  }
  if (typeof obj === "boolean") {
    return obj ? "true" : "false";
  }
  if (typeof obj === "string") {
    return inspectString(obj, opts);
  }
  if (typeof obj === "number") {
    if (obj === 0) {
      return Infinity / obj > 0 ? "0" : "-0";
    }
    var str = String(obj);
    return numericSeparator ? addNumericSeparator(obj, str) : str;
  }
  if (typeof obj === "bigint") {
    var bigIntStr = String(obj) + "n";
    return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
  }
  var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
  if (typeof depth === "undefined") {
    depth = 0;
  }
  if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
    return isArray$3(obj) ? "[Array]" : "[Object]";
  }
  var indent = getIndent(opts, depth);
  if (typeof seen === "undefined") {
    seen = [];
  } else if (indexOf(seen, obj) >= 0) {
    return "[Circular]";
  }
  function inspect2(value, from, noIndent) {
    if (from) {
      seen = $arrSlice.call(seen);
      seen.push(from);
    }
    if (noIndent) {
      var newOpts = {
        depth: opts.depth
      };
      if (has$3(opts, "quoteStyle")) {
        newOpts.quoteStyle = opts.quoteStyle;
      }
      return inspect_(value, newOpts, depth + 1, seen);
    }
    return inspect_(value, opts, depth + 1, seen);
  }
  if (typeof obj === "function" && !isRegExp$1(obj)) {
    var name = nameOf(obj);
    var keys2 = arrObjKeys(obj, inspect2);
    return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys2.length > 0 ? " { " + $join.call(keys2, ", ") + " }" : "");
  }
  if (isSymbol(obj)) {
    var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
    return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
  }
  if (isElement(obj)) {
    var s = "<" + $toLowerCase.call(String(obj.nodeName));
    var attrs = obj.attributes || [];
    for (var i = 0; i < attrs.length; i++) {
      s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
    }
    s += ">";
    if (obj.childNodes && obj.childNodes.length) {
      s += "...";
    }
    s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
    return s;
  }
  if (isArray$3(obj)) {
    if (obj.length === 0) {
      return "[]";
    }
    var xs = arrObjKeys(obj, inspect2);
    if (indent && !singleLineValues(xs)) {
      return "[" + indentedJoin(xs, indent) + "]";
    }
    return "[ " + $join.call(xs, ", ") + " ]";
  }
  if (isError(obj)) {
    var parts = arrObjKeys(obj, inspect2);
    if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
      return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect2(obj.cause), parts), ", ") + " }";
    }
    if (parts.length === 0) {
      return "[" + String(obj) + "]";
    }
    return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
  }
  if (typeof obj === "object" && customInspect) {
    if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
      return utilInspect(obj, { depth: maxDepth - depth });
    } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
      return obj.inspect();
    }
  }
  if (isMap(obj)) {
    var mapParts = [];
    if (mapForEach) {
      mapForEach.call(obj, function(value, key2) {
        mapParts.push(inspect2(key2, obj, true) + " => " + inspect2(value, obj));
      });
    }
    return collectionOf("Map", mapSize.call(obj), mapParts, indent);
  }
  if (isSet(obj)) {
    var setParts = [];
    if (setForEach) {
      setForEach.call(obj, function(value) {
        setParts.push(inspect2(value, obj));
      });
    }
    return collectionOf("Set", setSize.call(obj), setParts, indent);
  }
  if (isWeakMap(obj)) {
    return weakCollectionOf("WeakMap");
  }
  if (isWeakSet(obj)) {
    return weakCollectionOf("WeakSet");
  }
  if (isWeakRef(obj)) {
    return weakCollectionOf("WeakRef");
  }
  if (isNumber(obj)) {
    return markBoxed(inspect2(Number(obj)));
  }
  if (isBigInt(obj)) {
    return markBoxed(inspect2(bigIntValueOf.call(obj)));
  }
  if (isBoolean(obj)) {
    return markBoxed(booleanValueOf.call(obj));
  }
  if (isString(obj)) {
    return markBoxed(inspect2(String(obj)));
  }
  if (typeof window !== "undefined" && obj === window) {
    return "{ [object Window] }";
  }
  if (obj === commonjsGlobal) {
    return "{ [object globalThis] }";
  }
  if (!isDate(obj) && !isRegExp$1(obj)) {
    var ys = arrObjKeys(obj, inspect2);
    var isPlainObject2 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
    var protoTag = obj instanceof Object ? "" : "null prototype";
    var stringTag = !isPlainObject2 && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
    var constructorTag = isPlainObject2 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
    var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
    if (ys.length === 0) {
      return tag + "{}";
    }
    if (indent) {
      return tag + "{" + indentedJoin(ys, indent) + "}";
    }
    return tag + "{ " + $join.call(ys, ", ") + " }";
  }
  return String(obj);
};
function wrapQuotes(s, defaultStyle, opts) {
  var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
  return quoteChar + s + quoteChar;
}
function quote(s) {
  return $replace.call(String(s), /"/g, "&quot;");
}
function isArray$3(obj) {
  return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isDate(obj) {
  return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isRegExp$1(obj) {
  return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isError(obj) {
  return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isString(obj) {
  return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isNumber(obj) {
  return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isBoolean(obj) {
  return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isSymbol(obj) {
  if (hasShammedSymbols) {
    return obj && typeof obj === "object" && obj instanceof Symbol;
  }
  if (typeof obj === "symbol") {
    return true;
  }
  if (!obj || typeof obj !== "object" || !symToString) {
    return false;
  }
  try {
    symToString.call(obj);
    return true;
  } catch (e) {
  }
  return false;
}
function isBigInt(obj) {
  if (!obj || typeof obj !== "object" || !bigIntValueOf) {
    return false;
  }
  try {
    bigIntValueOf.call(obj);
    return true;
  } catch (e) {
  }
  return false;
}
var hasOwn = Object.prototype.hasOwnProperty || function(key2) {
  return key2 in this;
};
function has$3(obj, key2) {
  return hasOwn.call(obj, key2);
}
function toStr(obj) {
  return objectToString.call(obj);
}
function nameOf(f2) {
  if (f2.name) {
    return f2.name;
  }
  var m = $match.call(functionToString.call(f2), /^function\s*([\w$]+)/);
  if (m) {
    return m[1];
  }
  return null;
}
function indexOf(xs, x2) {
  if (xs.indexOf) {
    return xs.indexOf(x2);
  }
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x2) {
      return i;
    }
  }
  return -1;
}
function isMap(x2) {
  if (!mapSize || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    mapSize.call(x2);
    try {
      setSize.call(x2);
    } catch (s) {
      return true;
    }
    return x2 instanceof Map;
  } catch (e) {
  }
  return false;
}
function isWeakMap(x2) {
  if (!weakMapHas || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    weakMapHas.call(x2, weakMapHas);
    try {
      weakSetHas.call(x2, weakSetHas);
    } catch (s) {
      return true;
    }
    return x2 instanceof WeakMap;
  } catch (e) {
  }
  return false;
}
function isWeakRef(x2) {
  if (!weakRefDeref || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    weakRefDeref.call(x2);
    return true;
  } catch (e) {
  }
  return false;
}
function isSet(x2) {
  if (!setSize || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    setSize.call(x2);
    try {
      mapSize.call(x2);
    } catch (m) {
      return true;
    }
    return x2 instanceof Set;
  } catch (e) {
  }
  return false;
}
function isWeakSet(x2) {
  if (!weakSetHas || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    weakSetHas.call(x2, weakSetHas);
    try {
      weakMapHas.call(x2, weakMapHas);
    } catch (s) {
      return true;
    }
    return x2 instanceof WeakSet;
  } catch (e) {
  }
  return false;
}
function isElement(x2) {
  if (!x2 || typeof x2 !== "object") {
    return false;
  }
  if (typeof HTMLElement !== "undefined" && x2 instanceof HTMLElement) {
    return true;
  }
  return typeof x2.nodeName === "string" && typeof x2.getAttribute === "function";
}
function inspectString(str, opts) {
  if (str.length > opts.maxStringLength) {
    var remaining = str.length - opts.maxStringLength;
    var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
    return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
  }
  var s = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
  return wrapQuotes(s, "single", opts);
}
function lowbyte(c2) {
  var n = c2.charCodeAt(0);
  var x2 = {
    8: "b",
    9: "t",
    10: "n",
    12: "f",
    13: "r"
  }[n];
  if (x2) {
    return "\\" + x2;
  }
  return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
}
function markBoxed(str) {
  return "Object(" + str + ")";
}
function weakCollectionOf(type2) {
  return type2 + " { ? }";
}
function collectionOf(type2, size2, entries, indent) {
  var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
  return type2 + " (" + size2 + ") {" + joinedEntries + "}";
}
function singleLineValues(xs) {
  for (var i = 0; i < xs.length; i++) {
    if (indexOf(xs[i], "\n") >= 0) {
      return false;
    }
  }
  return true;
}
function getIndent(opts, depth) {
  var baseIndent;
  if (opts.indent === "	") {
    baseIndent = "	";
  } else if (typeof opts.indent === "number" && opts.indent > 0) {
    baseIndent = $join.call(Array(opts.indent + 1), " ");
  } else {
    return null;
  }
  return {
    base: baseIndent,
    prev: $join.call(Array(depth + 1), baseIndent)
  };
}
function indentedJoin(xs, indent) {
  if (xs.length === 0) {
    return "";
  }
  var lineJoiner = "\n" + indent.prev + indent.base;
  return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
}
function arrObjKeys(obj, inspect2) {
  var isArr = isArray$3(obj);
  var xs = [];
  if (isArr) {
    xs.length = obj.length;
    for (var i = 0; i < obj.length; i++) {
      xs[i] = has$3(obj, i) ? inspect2(obj[i], obj) : "";
    }
  }
  var syms = typeof gOPS === "function" ? gOPS(obj) : [];
  var symMap;
  if (hasShammedSymbols) {
    symMap = {};
    for (var k2 = 0; k2 < syms.length; k2++) {
      symMap["$" + syms[k2]] = syms[k2];
    }
  }
  for (var key2 in obj) {
    if (!has$3(obj, key2)) {
      continue;
    }
    if (isArr && String(Number(key2)) === key2 && key2 < obj.length) {
      continue;
    }
    if (hasShammedSymbols && symMap["$" + key2] instanceof Symbol) {
      continue;
    } else if ($test.call(/[^\w$]/, key2)) {
      xs.push(inspect2(key2, obj) + ": " + inspect2(obj[key2], obj));
    } else {
      xs.push(key2 + ": " + inspect2(obj[key2], obj));
    }
  }
  if (typeof gOPS === "function") {
    for (var j2 = 0; j2 < syms.length; j2++) {
      if (isEnumerable.call(obj, syms[j2])) {
        xs.push("[" + inspect2(syms[j2]) + "]: " + inspect2(obj[syms[j2]], obj));
      }
    }
  }
  return xs;
}
var GetIntrinsic2 = getIntrinsic;
var callBound = callBound$1;
var inspect = objectInspect;
var $TypeError = GetIntrinsic2("%TypeError%");
var $WeakMap = GetIntrinsic2("%WeakMap%", true);
var $Map = GetIntrinsic2("%Map%", true);
var $weakMapGet = callBound("WeakMap.prototype.get", true);
var $weakMapSet = callBound("WeakMap.prototype.set", true);
var $weakMapHas = callBound("WeakMap.prototype.has", true);
var $mapGet = callBound("Map.prototype.get", true);
var $mapSet = callBound("Map.prototype.set", true);
var $mapHas = callBound("Map.prototype.has", true);
var listGetNode = function(list, key2) {
  for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
    if (curr.key === key2) {
      prev.next = curr.next;
      curr.next = list.next;
      list.next = curr;
      return curr;
    }
  }
};
var listGet = function(objects, key2) {
  var node = listGetNode(objects, key2);
  return node && node.value;
};
var listSet = function(objects, key2, value) {
  var node = listGetNode(objects, key2);
  if (node) {
    node.value = value;
  } else {
    objects.next = {
      // eslint-disable-line no-param-reassign
      key: key2,
      next: objects.next,
      value
    };
  }
};
var listHas = function(objects, key2) {
  return !!listGetNode(objects, key2);
};
var sideChannel = function getSideChannel() {
  var $wm;
  var $m;
  var $o;
  var channel = {
    assert: function(key2) {
      if (!channel.has(key2)) {
        throw new $TypeError("Side channel does not contain " + inspect(key2));
      }
    },
    get: function(key2) {
      if ($WeakMap && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
        if ($wm) {
          return $weakMapGet($wm, key2);
        }
      } else if ($Map) {
        if ($m) {
          return $mapGet($m, key2);
        }
      } else {
        if ($o) {
          return listGet($o, key2);
        }
      }
    },
    has: function(key2) {
      if ($WeakMap && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
        if ($wm) {
          return $weakMapHas($wm, key2);
        }
      } else if ($Map) {
        if ($m) {
          return $mapHas($m, key2);
        }
      } else {
        if ($o) {
          return listHas($o, key2);
        }
      }
      return false;
    },
    set: function(key2, value) {
      if ($WeakMap && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
        if (!$wm) {
          $wm = new $WeakMap();
        }
        $weakMapSet($wm, key2, value);
      } else if ($Map) {
        if (!$m) {
          $m = new $Map();
        }
        $mapSet($m, key2, value);
      } else {
        if (!$o) {
          $o = { key: {}, next: null };
        }
        listSet($o, key2, value);
      }
    }
  };
  return channel;
};
var replace = String.prototype.replace;
var percentTwenties = /%20/g;
var Format = {
  RFC1738: "RFC1738",
  RFC3986: "RFC3986"
};
var formats$3 = {
  "default": Format.RFC3986,
  formatters: {
    RFC1738: function(value) {
      return replace.call(value, percentTwenties, "+");
    },
    RFC3986: function(value) {
      return String(value);
    }
  },
  RFC1738: Format.RFC1738,
  RFC3986: Format.RFC3986
};
var formats$2 = formats$3;
var has$2 = Object.prototype.hasOwnProperty;
var isArray$2 = Array.isArray;
var hexTable = function() {
  var array = [];
  for (var i = 0; i < 256; ++i) {
    array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
  }
  return array;
}();
var compactQueue = function compactQueue2(queue2) {
  while (queue2.length > 1) {
    var item = queue2.pop();
    var obj = item.obj[item.prop];
    if (isArray$2(obj)) {
      var compacted = [];
      for (var j2 = 0; j2 < obj.length; ++j2) {
        if (typeof obj[j2] !== "undefined") {
          compacted.push(obj[j2]);
        }
      }
      item.obj[item.prop] = compacted;
    }
  }
};
var arrayToObject = function arrayToObject2(source2, options) {
  var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  for (var i = 0; i < source2.length; ++i) {
    if (typeof source2[i] !== "undefined") {
      obj[i] = source2[i];
    }
  }
  return obj;
};
var merge = function merge2(target, source2, options) {
  if (!source2) {
    return target;
  }
  if (typeof source2 !== "object") {
    if (isArray$2(target)) {
      target.push(source2);
    } else if (target && typeof target === "object") {
      if (options && (options.plainObjects || options.allowPrototypes) || !has$2.call(Object.prototype, source2)) {
        target[source2] = true;
      }
    } else {
      return [target, source2];
    }
    return target;
  }
  if (!target || typeof target !== "object") {
    return [target].concat(source2);
  }
  var mergeTarget = target;
  if (isArray$2(target) && !isArray$2(source2)) {
    mergeTarget = arrayToObject(target, options);
  }
  if (isArray$2(target) && isArray$2(source2)) {
    source2.forEach(function(item, i) {
      if (has$2.call(target, i)) {
        var targetItem = target[i];
        if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
          target[i] = merge2(targetItem, item, options);
        } else {
          target.push(item);
        }
      } else {
        target[i] = item;
      }
    });
    return target;
  }
  return Object.keys(source2).reduce(function(acc, key2) {
    var value = source2[key2];
    if (has$2.call(acc, key2)) {
      acc[key2] = merge2(acc[key2], value, options);
    } else {
      acc[key2] = value;
    }
    return acc;
  }, mergeTarget);
};
var assign = function assignSingleSource(target, source2) {
  return Object.keys(source2).reduce(function(acc, key2) {
    acc[key2] = source2[key2];
    return acc;
  }, target);
};
var decode = function(str, decoder, charset) {
  var strWithoutPlus = str.replace(/\+/g, " ");
  if (charset === "iso-8859-1") {
    return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
  }
  try {
    return decodeURIComponent(strWithoutPlus);
  } catch (e) {
    return strWithoutPlus;
  }
};
var encode = function encode2(str, defaultEncoder, charset, kind, format2) {
  if (str.length === 0) {
    return str;
  }
  var string = str;
  if (typeof str === "symbol") {
    string = Symbol.prototype.toString.call(str);
  } else if (typeof str !== "string") {
    string = String(str);
  }
  if (charset === "iso-8859-1") {
    return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
      return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
    });
  }
  var out = "";
  for (var i = 0; i < string.length; ++i) {
    var c2 = string.charCodeAt(i);
    if (c2 === 45 || c2 === 46 || c2 === 95 || c2 === 126 || c2 >= 48 && c2 <= 57 || c2 >= 65 && c2 <= 90 || c2 >= 97 && c2 <= 122 || format2 === formats$2.RFC1738 && (c2 === 40 || c2 === 41)) {
      out += string.charAt(i);
      continue;
    }
    if (c2 < 128) {
      out = out + hexTable[c2];
      continue;
    }
    if (c2 < 2048) {
      out = out + (hexTable[192 | c2 >> 6] + hexTable[128 | c2 & 63]);
      continue;
    }
    if (c2 < 55296 || c2 >= 57344) {
      out = out + (hexTable[224 | c2 >> 12] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63]);
      continue;
    }
    i += 1;
    c2 = 65536 + ((c2 & 1023) << 10 | string.charCodeAt(i) & 1023);
    out += hexTable[240 | c2 >> 18] + hexTable[128 | c2 >> 12 & 63] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63];
  }
  return out;
};
var compact = function compact2(value) {
  var queue2 = [{ obj: { o: value }, prop: "o" }];
  var refs = [];
  for (var i = 0; i < queue2.length; ++i) {
    var item = queue2[i];
    var obj = item.obj[item.prop];
    var keys2 = Object.keys(obj);
    for (var j2 = 0; j2 < keys2.length; ++j2) {
      var key2 = keys2[j2];
      var val = obj[key2];
      if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
        queue2.push({ obj, prop: key2 });
        refs.push(val);
      }
    }
  }
  compactQueue(queue2);
  return value;
};
var isRegExp = function isRegExp2(obj) {
  return Object.prototype.toString.call(obj) === "[object RegExp]";
};
var isBuffer = function isBuffer2(obj) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};
var combine = function combine2(a, b2) {
  return [].concat(a, b2);
};
var maybeMap = function maybeMap2(val, fn) {
  if (isArray$2(val)) {
    var mapped = [];
    for (var i = 0; i < val.length; i += 1) {
      mapped.push(fn(val[i]));
    }
    return mapped;
  }
  return fn(val);
};
var utils$2 = {
  arrayToObject,
  assign,
  combine,
  compact,
  decode,
  encode,
  isBuffer,
  isRegExp,
  maybeMap,
  merge
};
var getSideChannel2 = sideChannel;
var utils$1 = utils$2;
var formats$1 = formats$3;
var has$1 = Object.prototype.hasOwnProperty;
var arrayPrefixGenerators = {
  brackets: function brackets(prefix) {
    return prefix + "[]";
  },
  comma: "comma",
  indices: function indices(prefix, key2) {
    return prefix + "[" + key2 + "]";
  },
  repeat: function repeat(prefix) {
    return prefix;
  }
};
var isArray$1 = Array.isArray;
var push$1 = Array.prototype.push;
var pushToArray = function(arr, valueOrArray) {
  push$1.apply(arr, isArray$1(valueOrArray) ? valueOrArray : [valueOrArray]);
};
var toISO = Date.prototype.toISOString;
var defaultFormat = formats$1["default"];
var defaults$1 = {
  addQueryPrefix: false,
  allowDots: false,
  charset: "utf-8",
  charsetSentinel: false,
  delimiter: "&",
  encode: true,
  encoder: utils$1.encode,
  encodeValuesOnly: false,
  format: defaultFormat,
  formatter: formats$1.formatters[defaultFormat],
  // deprecated
  indices: false,
  serializeDate: function serializeDate(date2) {
    return toISO.call(date2);
  },
  skipNulls: false,
  strictNullHandling: false
};
var isNonNullishPrimitive = function isNonNullishPrimitive2(v2) {
  return typeof v2 === "string" || typeof v2 === "number" || typeof v2 === "boolean" || typeof v2 === "symbol" || typeof v2 === "bigint";
};
var sentinel = {};
var stringify$2 = function stringify(object, prefix, generateArrayPrefix, commaRoundTrip, strictNullHandling, skipNulls, encoder, filter, sort2, allowDots, serializeDate2, format2, formatter, encodeValuesOnly, charset, sideChannel2) {
  var obj = object;
  var tmpSc = sideChannel2;
  var step = 0;
  var findFlag = false;
  while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
    var pos2 = tmpSc.get(object);
    step += 1;
    if (typeof pos2 !== "undefined") {
      if (pos2 === step) {
        throw new RangeError("Cyclic object value");
      } else {
        findFlag = true;
      }
    }
    if (typeof tmpSc.get(sentinel) === "undefined") {
      step = 0;
    }
  }
  if (typeof filter === "function") {
    obj = filter(prefix, obj);
  } else if (obj instanceof Date) {
    obj = serializeDate2(obj);
  } else if (generateArrayPrefix === "comma" && isArray$1(obj)) {
    obj = utils$1.maybeMap(obj, function(value2) {
      if (value2 instanceof Date) {
        return serializeDate2(value2);
      }
      return value2;
    });
  }
  if (obj === null) {
    if (strictNullHandling) {
      return encoder && !encodeValuesOnly ? encoder(prefix, defaults$1.encoder, charset, "key", format2) : prefix;
    }
    obj = "";
  }
  if (isNonNullishPrimitive(obj) || utils$1.isBuffer(obj)) {
    if (encoder) {
      var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults$1.encoder, charset, "key", format2);
      return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults$1.encoder, charset, "value", format2))];
    }
    return [formatter(prefix) + "=" + formatter(String(obj))];
  }
  var values = [];
  if (typeof obj === "undefined") {
    return values;
  }
  var objKeys;
  if (generateArrayPrefix === "comma" && isArray$1(obj)) {
    if (encodeValuesOnly && encoder) {
      obj = utils$1.maybeMap(obj, encoder);
    }
    objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
  } else if (isArray$1(filter)) {
    objKeys = filter;
  } else {
    var keys2 = Object.keys(obj);
    objKeys = sort2 ? keys2.sort(sort2) : keys2;
  }
  var adjustedPrefix = commaRoundTrip && isArray$1(obj) && obj.length === 1 ? prefix + "[]" : prefix;
  for (var j2 = 0; j2 < objKeys.length; ++j2) {
    var key2 = objKeys[j2];
    var value = typeof key2 === "object" && typeof key2.value !== "undefined" ? key2.value : obj[key2];
    if (skipNulls && value === null) {
      continue;
    }
    var keyPrefix = isArray$1(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, key2) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + key2 : "[" + key2 + "]");
    sideChannel2.set(object, step);
    var valueSideChannel = getSideChannel2();
    valueSideChannel.set(sentinel, sideChannel2);
    pushToArray(values, stringify(
      value,
      keyPrefix,
      generateArrayPrefix,
      commaRoundTrip,
      strictNullHandling,
      skipNulls,
      generateArrayPrefix === "comma" && encodeValuesOnly && isArray$1(obj) ? null : encoder,
      filter,
      sort2,
      allowDots,
      serializeDate2,
      format2,
      formatter,
      encodeValuesOnly,
      charset,
      valueSideChannel
    ));
  }
  return values;
};
var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
  if (!opts) {
    return defaults$1;
  }
  if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
    throw new TypeError("Encoder has to be a function.");
  }
  var charset = opts.charset || defaults$1.charset;
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  var format2 = formats$1["default"];
  if (typeof opts.format !== "undefined") {
    if (!has$1.call(formats$1.formatters, opts.format)) {
      throw new TypeError("Unknown format option provided.");
    }
    format2 = opts.format;
  }
  var formatter = formats$1.formatters[format2];
  var filter = defaults$1.filter;
  if (typeof opts.filter === "function" || isArray$1(opts.filter)) {
    filter = opts.filter;
  }
  return {
    addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults$1.addQueryPrefix,
    allowDots: typeof opts.allowDots === "undefined" ? defaults$1.allowDots : !!opts.allowDots,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults$1.charsetSentinel,
    delimiter: typeof opts.delimiter === "undefined" ? defaults$1.delimiter : opts.delimiter,
    encode: typeof opts.encode === "boolean" ? opts.encode : defaults$1.encode,
    encoder: typeof opts.encoder === "function" ? opts.encoder : defaults$1.encoder,
    encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults$1.encodeValuesOnly,
    filter,
    format: format2,
    formatter,
    serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults$1.serializeDate,
    skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults$1.skipNulls,
    sort: typeof opts.sort === "function" ? opts.sort : null,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults$1.strictNullHandling
  };
};
var stringify_1 = function(object, opts) {
  var obj = object;
  var options = normalizeStringifyOptions(opts);
  var objKeys;
  var filter;
  if (typeof options.filter === "function") {
    filter = options.filter;
    obj = filter("", obj);
  } else if (isArray$1(options.filter)) {
    filter = options.filter;
    objKeys = filter;
  }
  var keys2 = [];
  if (typeof obj !== "object" || obj === null) {
    return "";
  }
  var arrayFormat;
  if (opts && opts.arrayFormat in arrayPrefixGenerators) {
    arrayFormat = opts.arrayFormat;
  } else if (opts && "indices" in opts) {
    arrayFormat = opts.indices ? "indices" : "repeat";
  } else {
    arrayFormat = "indices";
  }
  var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
  if (opts && "commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  }
  var commaRoundTrip = generateArrayPrefix === "comma" && opts && opts.commaRoundTrip;
  if (!objKeys) {
    objKeys = Object.keys(obj);
  }
  if (options.sort) {
    objKeys.sort(options.sort);
  }
  var sideChannel2 = getSideChannel2();
  for (var i = 0; i < objKeys.length; ++i) {
    var key2 = objKeys[i];
    if (options.skipNulls && obj[key2] === null) {
      continue;
    }
    pushToArray(keys2, stringify$2(
      obj[key2],
      key2,
      generateArrayPrefix,
      commaRoundTrip,
      options.strictNullHandling,
      options.skipNulls,
      options.encode ? options.encoder : null,
      options.filter,
      options.sort,
      options.allowDots,
      options.serializeDate,
      options.format,
      options.formatter,
      options.encodeValuesOnly,
      options.charset,
      sideChannel2
    ));
  }
  var joined = keys2.join(options.delimiter);
  var prefix = options.addQueryPrefix === true ? "?" : "";
  if (options.charsetSentinel) {
    if (options.charset === "iso-8859-1") {
      prefix += "utf8=%26%2310003%3B&";
    } else {
      prefix += "utf8=%E2%9C%93&";
    }
  }
  return joined.length > 0 ? prefix + joined : "";
};
var utils = utils$2;
var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;
var defaults = {
  allowDots: false,
  allowPrototypes: false,
  allowSparse: false,
  arrayLimit: 20,
  charset: "utf-8",
  charsetSentinel: false,
  comma: false,
  decoder: utils.decode,
  delimiter: "&",
  depth: 5,
  ignoreQueryPrefix: false,
  interpretNumericEntities: false,
  parameterLimit: 1e3,
  parseArrays: true,
  plainObjects: false,
  strictNullHandling: false
};
var interpretNumericEntities = function(str) {
  return str.replace(/&#(\d+);/g, function($0, numberStr) {
    return String.fromCharCode(parseInt(numberStr, 10));
  });
};
var parseArrayValue = function(val, options) {
  if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
    return val.split(",");
  }
  return val;
};
var isoSentinel = "utf8=%26%2310003%3B";
var charsetSentinel = "utf8=%E2%9C%93";
var parseValues = function parseQueryStringValues(str, options) {
  var obj = { __proto__: null };
  var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
  var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
  var parts = cleanStr.split(options.delimiter, limit);
  var skipIndex = -1;
  var i;
  var charset = options.charset;
  if (options.charsetSentinel) {
    for (i = 0; i < parts.length; ++i) {
      if (parts[i].indexOf("utf8=") === 0) {
        if (parts[i] === charsetSentinel) {
          charset = "utf-8";
        } else if (parts[i] === isoSentinel) {
          charset = "iso-8859-1";
        }
        skipIndex = i;
        i = parts.length;
      }
    }
  }
  for (i = 0; i < parts.length; ++i) {
    if (i === skipIndex) {
      continue;
    }
    var part = parts[i];
    var bracketEqualsPos = part.indexOf("]=");
    var pos2 = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
    var key2, val;
    if (pos2 === -1) {
      key2 = options.decoder(part, defaults.decoder, charset, "key");
      val = options.strictNullHandling ? null : "";
    } else {
      key2 = options.decoder(part.slice(0, pos2), defaults.decoder, charset, "key");
      val = utils.maybeMap(
        parseArrayValue(part.slice(pos2 + 1), options),
        function(encodedVal) {
          return options.decoder(encodedVal, defaults.decoder, charset, "value");
        }
      );
    }
    if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
      val = interpretNumericEntities(val);
    }
    if (part.indexOf("[]=") > -1) {
      val = isArray(val) ? [val] : val;
    }
    if (has.call(obj, key2)) {
      obj[key2] = utils.combine(obj[key2], val);
    } else {
      obj[key2] = val;
    }
  }
  return obj;
};
var parseObject = function(chain, val, options, valuesParsed) {
  var leaf = valuesParsed ? val : parseArrayValue(val, options);
  for (var i = chain.length - 1; i >= 0; --i) {
    var obj;
    var root2 = chain[i];
    if (root2 === "[]" && options.parseArrays) {
      obj = [].concat(leaf);
    } else {
      obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var cleanRoot = root2.charAt(0) === "[" && root2.charAt(root2.length - 1) === "]" ? root2.slice(1, -1) : root2;
      var index2 = parseInt(cleanRoot, 10);
      if (!options.parseArrays && cleanRoot === "") {
        obj = { 0: leaf };
      } else if (!isNaN(index2) && root2 !== cleanRoot && String(index2) === cleanRoot && index2 >= 0 && (options.parseArrays && index2 <= options.arrayLimit)) {
        obj = [];
        obj[index2] = leaf;
      } else if (cleanRoot !== "__proto__") {
        obj[cleanRoot] = leaf;
      }
    }
    leaf = obj;
  }
  return leaf;
};
var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
  if (!givenKey) {
    return;
  }
  var key2 = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
  var brackets2 = /(\[[^[\]]*])/;
  var child = /(\[[^[\]]*])/g;
  var segment = options.depth > 0 && brackets2.exec(key2);
  var parent = segment ? key2.slice(0, segment.index) : key2;
  var keys2 = [];
  if (parent) {
    if (!options.plainObjects && has.call(Object.prototype, parent)) {
      if (!options.allowPrototypes) {
        return;
      }
    }
    keys2.push(parent);
  }
  var i = 0;
  while (options.depth > 0 && (segment = child.exec(key2)) !== null && i < options.depth) {
    i += 1;
    if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
      if (!options.allowPrototypes) {
        return;
      }
    }
    keys2.push(segment[1]);
  }
  if (segment) {
    keys2.push("[" + key2.slice(segment.index) + "]");
  }
  return parseObject(keys2, val, options, valuesParsed);
};
var normalizeParseOptions = function normalizeParseOptions2(opts) {
  if (!opts) {
    return defaults;
  }
  if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
    throw new TypeError("Decoder has to be a function.");
  }
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
  return {
    allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
    allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
    allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
    arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
    comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
    decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
    delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
    // eslint-disable-next-line no-implicit-coercion, no-extra-parens
    depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
    ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
    interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
    parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
    parseArrays: opts.parseArrays !== false,
    plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
  };
};
var parse$2 = function(str, opts) {
  var options = normalizeParseOptions(opts);
  if (str === "" || str === null || typeof str === "undefined") {
    return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  }
  var tempObj = typeof str === "string" ? parseValues(str, options) : str;
  var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  var keys2 = Object.keys(tempObj);
  for (var i = 0; i < keys2.length; ++i) {
    var key2 = keys2[i];
    var newObj = parseKeys(key2, tempObj[key2], options, typeof str === "string");
    obj = utils.merge(obj, newObj, options);
  }
  if (options.allowSparse === true) {
    return obj;
  }
  return utils.compact(obj);
};
var stringify$1 = stringify_1;
var parse$1 = parse$2;
var formats = formats$3;
var lib$1 = {
  formats,
  parse: parse$1,
  stringify: stringify$1
};
const qs = /* @__PURE__ */ getDefaultExportFromCjs(lib$1);
var sift$1 = { exports: {} };
(function(module, exports) {
  (function() {
    function isFunction2(value) {
      return typeof value === "function";
    }
    function isArray2(value) {
      return Object.prototype.toString.call(value) === "[object Array]";
    }
    function comparable(value) {
      if (value instanceof Date) {
        return value.getTime();
      } else if (value instanceof Array) {
        return value.map(comparable);
      } else {
        return value;
      }
    }
    function get2(obj, key2) {
      if (obj.get) {
        return obj.get(key2);
      }
      return obj[key2];
    }
    function or(validator2) {
      return function(a, b2) {
        if (!isArray2(b2) || !b2.length) {
          return validator2(a, b2);
        }
        for (var i = 0, n = b2.length; i < n; i++) {
          if (validator2(a, get2(b2, i)))
            return true;
        }
        return false;
      };
    }
    function and(validator2) {
      return function(a, b2) {
        if (!isArray2(b2) || !b2.length) {
          return validator2(a, b2);
        }
        for (var i = 0, n = b2.length; i < n; i++) {
          if (!validator2(a, get2(b2, i)))
            return false;
        }
        return true;
      };
    }
    function validate(validator2, b2) {
      return validator2.v(validator2.a, b2);
    }
    var operator = {
      /**
       */
      $eq: or(function(a, b2) {
        return a(b2);
      }),
      /**
       */
      $ne: and(function(a, b2) {
        return !a(b2);
      }),
      /**
       */
      $or: function(a, b2) {
        for (var i = 0, n = a.length; i < n; i++)
          if (validate(get2(a, i), b2))
            return true;
        return false;
      },
      /**
       */
      $gt: or(function(a, b2) {
        return sift2.compare(comparable(b2), a) > 0;
      }),
      /**
       */
      $gte: or(function(a, b2) {
        return sift2.compare(comparable(b2), a) >= 0;
      }),
      /**
       */
      $lt: or(function(a, b2) {
        return sift2.compare(comparable(b2), a) < 0;
      }),
      /**
       */
      $lte: or(function(a, b2) {
        return sift2.compare(comparable(b2), a) <= 0;
      }),
      /**
       */
      $mod: or(function(a, b2) {
        return b2 % a[0] == a[1];
      }),
      /**
       */
      $in: function(a, b2) {
        if (b2 instanceof Array) {
          for (var i = b2.length; i--; ) {
            if (~a.indexOf(comparable(get2(b2, i)))) {
              return true;
            }
          }
        } else {
          var comparableB = comparable(b2);
          if (comparableB === b2 && typeof b2 === "object") {
            for (var i = a.length; i--; ) {
              if (String(a[i]) === String(b2) && String(b2) !== "[object Object]") {
                return true;
              }
            }
          }
          if (typeof comparableB == "undefined") {
            for (var i = a.length; i--; ) {
              if (a[i] == null) {
                return true;
              }
            }
          }
          for (var i = a.length; i--; ) {
            var validator2 = createRootValidator(get2(a, i), void 0);
            var result = validate(validator2, b2);
            if (result && String(result) !== "[object Object]" && String(b2) !== "[object Object]") {
              return true;
            }
          }
          return Boolean(!!~a.indexOf(comparable(b2)));
        }
        return false;
      },
      /**
       */
      $nin: function(a, b2) {
        return !operator.$in(a, b2);
      },
      /**
       */
      $not: function(a, b2) {
        return !validate(a, b2);
      },
      /**
       */
      $type: function(a, b2) {
        return b2 != void 0 ? b2 instanceof a || b2.constructor == a : false;
      },
      /**
       */
      $all: function(a, b2) {
        return operator.$and(a, b2);
      },
      /**
       */
      $size: function(a, b2) {
        return b2 ? a === b2.length : false;
      },
      /**
       */
      $nor: function(a, b2) {
        for (var i = 0, n = a.length; i < n; i++) {
          if (validate(get2(a, i), b2)) {
            return false;
          }
        }
        return true;
      },
      /**
       */
      $and: function(a, b2) {
        for (var i = 0, n = a.length; i < n; i++) {
          if (!validate(get2(a, i), b2)) {
            return false;
          }
        }
        return true;
      },
      /**
       */
      $regex: or(function(a, b2) {
        return typeof b2 === "string" && a.test(b2);
      }),
      /**
       */
      $where: function(a, b2) {
        return a.call(b2, b2);
      },
      /**
       */
      $elemMatch: function(a, b2) {
        if (isArray2(b2)) {
          return !!~search(b2, a);
        }
        return validate(a, b2);
      },
      /**
       */
      $exists: function(a, b2) {
        return b2 != void 0 === a;
      }
    };
    var prepare = {
      /**
       */
      $eq: function(a) {
        if (a instanceof RegExp) {
          return function(b2) {
            return typeof b2 === "string" && a.test(b2);
          };
        } else if (a instanceof Function) {
          return a;
        } else if (isArray2(a) && !a.length) {
          return function(b2) {
            return isArray2(b2) && !b2.length;
          };
        } else if (a === null) {
          return function(b2) {
            return b2 == null;
          };
        }
        return function(b2) {
          return sift2.compare(comparable(b2), a) === 0;
        };
      },
      /**
       */
      $ne: function(a) {
        return prepare.$eq(a);
      },
      /**
       */
      $and: function(a) {
        return a.map(parse3);
      },
      /**
       */
      $all: function(a) {
        return prepare.$and(a);
      },
      /**
       */
      $or: function(a) {
        return a.map(parse3);
      },
      /**
       */
      $nor: function(a) {
        return a.map(parse3);
      },
      /**
       */
      $not: function(a) {
        return parse3(a);
      },
      /**
       */
      $regex: function(a, query) {
        return new RegExp(a, query.$options);
      },
      /**
       */
      $where: function(a) {
        return typeof a === "string" ? new Function("obj", "return " + a) : a;
      },
      /**
       */
      $elemMatch: function(a) {
        return parse3(a);
      },
      /**
       */
      $exists: function(a) {
        return !!a;
      }
    };
    function search(array, validator2) {
      for (var i = 0; i < array.length; i++) {
        if (validate(validator2, get2(array, i))) {
          return i;
        }
      }
      return -1;
    }
    function createValidator(a, validate2) {
      return { a, v: validate2 };
    }
    function nestedValidator(a, b2) {
      var values = [];
      findValues(b2, a.k, 0, values);
      if (values.length === 1) {
        return validate(a.nv, values[0]);
      }
      return !!~search(values, a.nv);
    }
    function findValues(current, keypath, index2, values) {
      if (index2 === keypath.length || current == void 0) {
        values.push(current);
        return;
      }
      var k2 = get2(keypath, index2);
      if (isArray2(current) && isNaN(Number(k2))) {
        for (var i = 0, n = current.length; i < n; i++) {
          findValues(get2(current, i), keypath, index2, values);
        }
      } else {
        findValues(get2(current, k2), keypath, index2 + 1, values);
      }
    }
    function createNestedValidator(keypath, a) {
      return { a: { k: keypath, nv: a }, v: nestedValidator };
    }
    function isVanillaObject(value) {
      return String(value.constructor) === "Object" || String(value.constructor).replace(/[\r\n\s\t]/g, "") === "functionObject(){[nativecode]}";
    }
    function parse3(query) {
      query = comparable(query);
      if (!query || !isVanillaObject(query)) {
        query = { $eq: query };
      }
      var validators = [];
      for (var key2 in query) {
        var a = query[key2];
        if (key2 === "$options") {
          continue;
        }
        if (operator[key2]) {
          if (prepare[key2])
            a = prepare[key2](a, query);
          validators.push(createValidator(comparable(a), operator[key2]));
        } else {
          if (key2.charCodeAt(0) === 36) {
            throw new Error("Unknown operation " + key2);
          }
          validators.push(createNestedValidator(key2.split("."), parse3(a)));
        }
      }
      return validators.length === 1 ? validators[0] : createValidator(validators, operator.$and);
    }
    function createRootValidator(query, getter) {
      var validator2 = parse3(query);
      if (getter) {
        validator2 = {
          a: validator2,
          v: function(a, b2) {
            return validate(a, getter(b2));
          }
        };
      }
      return validator2;
    }
    function sift2(query, array, getter) {
      if (isFunction2(array)) {
        getter = array;
        array = void 0;
      }
      var validator2 = createRootValidator(query, getter);
      function filter(b2) {
        return validate(validator2, b2);
      }
      if (array) {
        return array.filter(filter);
      }
      return filter;
    }
    sift2.use = function(plugin2) {
      if (isFunction2(plugin2))
        return plugin2(sift2);
      for (var key2 in plugin2) {
        if (key2.charCodeAt(0) === 36) {
          operator[key2] = plugin2[key2];
        }
      }
    };
    sift2.indexOf = function(query, array, getter) {
      return search(array, createRootValidator(query, getter));
    };
    sift2.compare = function(a, b2) {
      if (a === b2)
        return 0;
      if (typeof a === typeof b2) {
        if (a > b2) {
          return 1;
        }
        if (a < b2) {
          return -1;
        }
      }
    };
    {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      module.exports = sift2;
      exports["default"] = module.exports.default = sift2;
    }
    if (typeof window !== "undefined") {
      window.sift = sift2;
    }
  })();
})(sift$1, sift$1.exports);
var siftExports = sift$1.exports;
const sift = /* @__PURE__ */ getDefaultExportFromCjs(siftExports);
var Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
var ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
var ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;
var unicode = {
  Space_Separator,
  ID_Start,
  ID_Continue
};
var util = {
  isSpaceSeparator(c2) {
    return typeof c2 === "string" && unicode.Space_Separator.test(c2);
  },
  isIdStartChar(c2) {
    return typeof c2 === "string" && (c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 === "$" || c2 === "_" || unicode.ID_Start.test(c2));
  },
  isIdContinueChar(c2) {
    return typeof c2 === "string" && (c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 >= "0" && c2 <= "9" || c2 === "$" || c2 === "_" || c2 === "‌" || c2 === "‍" || unicode.ID_Continue.test(c2));
  },
  isDigit(c2) {
    return typeof c2 === "string" && /[0-9]/.test(c2);
  },
  isHexDigit(c2) {
    return typeof c2 === "string" && /[0-9A-Fa-f]/.test(c2);
  }
};
let source;
let parseState;
let stack;
let pos;
let line;
let column;
let token;
let key;
let root;
var parse = function parse2(text, reviver) {
  source = String(text);
  parseState = "start";
  stack = [];
  pos = 0;
  line = 1;
  column = 0;
  token = void 0;
  key = void 0;
  root = void 0;
  do {
    token = lex();
    parseStates[parseState]();
  } while (token.type !== "eof");
  if (typeof reviver === "function") {
    return internalize({ "": root }, "", reviver);
  }
  return root;
};
function internalize(holder, name, reviver) {
  const value = holder[name];
  if (value != null && typeof value === "object") {
    if (Array.isArray(value)) {
      for (let i = 0; i < value.length; i++) {
        const key2 = String(i);
        const replacement = internalize(value, key2, reviver);
        if (replacement === void 0) {
          delete value[key2];
        } else {
          Object.defineProperty(value, key2, {
            value: replacement,
            writable: true,
            enumerable: true,
            configurable: true
          });
        }
      }
    } else {
      for (const key2 in value) {
        const replacement = internalize(value, key2, reviver);
        if (replacement === void 0) {
          delete value[key2];
        } else {
          Object.defineProperty(value, key2, {
            value: replacement,
            writable: true,
            enumerable: true,
            configurable: true
          });
        }
      }
    }
  }
  return reviver.call(holder, name, value);
}
let lexState;
let buffer;
let doubleQuote;
let sign;
let c;
function lex() {
  lexState = "default";
  buffer = "";
  doubleQuote = false;
  sign = 1;
  for (; ; ) {
    c = peek();
    const token2 = lexStates[lexState]();
    if (token2) {
      return token2;
    }
  }
}
function peek() {
  if (source[pos]) {
    return String.fromCodePoint(source.codePointAt(pos));
  }
}
function read() {
  const c2 = peek();
  if (c2 === "\n") {
    line++;
    column = 0;
  } else if (c2) {
    column += c2.length;
  } else {
    column++;
  }
  if (c2) {
    pos += c2.length;
  }
  return c2;
}
const lexStates = {
  default() {
    switch (c) {
      case "	":
      case "\v":
      case "\f":
      case " ":
      case " ":
      case "\uFEFF":
      case "\n":
      case "\r":
      case "\u2028":
      case "\u2029":
        read();
        return;
      case "/":
        read();
        lexState = "comment";
        return;
      case void 0:
        read();
        return newToken("eof");
    }
    if (util.isSpaceSeparator(c)) {
      read();
      return;
    }
    return lexStates[parseState]();
  },
  comment() {
    switch (c) {
      case "*":
        read();
        lexState = "multiLineComment";
        return;
      case "/":
        read();
        lexState = "singleLineComment";
        return;
    }
    throw invalidChar(read());
  },
  multiLineComment() {
    switch (c) {
      case "*":
        read();
        lexState = "multiLineCommentAsterisk";
        return;
      case void 0:
        throw invalidChar(read());
    }
    read();
  },
  multiLineCommentAsterisk() {
    switch (c) {
      case "*":
        read();
        return;
      case "/":
        read();
        lexState = "default";
        return;
      case void 0:
        throw invalidChar(read());
    }
    read();
    lexState = "multiLineComment";
  },
  singleLineComment() {
    switch (c) {
      case "\n":
      case "\r":
      case "\u2028":
      case "\u2029":
        read();
        lexState = "default";
        return;
      case void 0:
        read();
        return newToken("eof");
    }
    read();
  },
  value() {
    switch (c) {
      case "{":
      case "[":
        return newToken("punctuator", read());
      case "n":
        read();
        literal("ull");
        return newToken("null", null);
      case "t":
        read();
        literal("rue");
        return newToken("boolean", true);
      case "f":
        read();
        literal("alse");
        return newToken("boolean", false);
      case "-":
      case "+":
        if (read() === "-") {
          sign = -1;
        }
        lexState = "sign";
        return;
      case ".":
        buffer = read();
        lexState = "decimalPointLeading";
        return;
      case "0":
        buffer = read();
        lexState = "zero";
        return;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        buffer = read();
        lexState = "decimalInteger";
        return;
      case "I":
        read();
        literal("nfinity");
        return newToken("numeric", Infinity);
      case "N":
        read();
        literal("aN");
        return newToken("numeric", NaN);
      case '"':
      case "'":
        doubleQuote = read() === '"';
        buffer = "";
        lexState = "string";
        return;
    }
    throw invalidChar(read());
  },
  identifierNameStartEscape() {
    if (c !== "u") {
      throw invalidChar(read());
    }
    read();
    const u = unicodeEscape();
    switch (u) {
      case "$":
      case "_":
        break;
      default:
        if (!util.isIdStartChar(u)) {
          throw invalidIdentifier();
        }
        break;
    }
    buffer += u;
    lexState = "identifierName";
  },
  identifierName() {
    switch (c) {
      case "$":
      case "_":
      case "‌":
      case "‍":
        buffer += read();
        return;
      case "\\":
        read();
        lexState = "identifierNameEscape";
        return;
    }
    if (util.isIdContinueChar(c)) {
      buffer += read();
      return;
    }
    return newToken("identifier", buffer);
  },
  identifierNameEscape() {
    if (c !== "u") {
      throw invalidChar(read());
    }
    read();
    const u = unicodeEscape();
    switch (u) {
      case "$":
      case "_":
      case "‌":
      case "‍":
        break;
      default:
        if (!util.isIdContinueChar(u)) {
          throw invalidIdentifier();
        }
        break;
    }
    buffer += u;
    lexState = "identifierName";
  },
  sign() {
    switch (c) {
      case ".":
        buffer = read();
        lexState = "decimalPointLeading";
        return;
      case "0":
        buffer = read();
        lexState = "zero";
        return;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        buffer = read();
        lexState = "decimalInteger";
        return;
      case "I":
        read();
        literal("nfinity");
        return newToken("numeric", sign * Infinity);
      case "N":
        read();
        literal("aN");
        return newToken("numeric", NaN);
    }
    throw invalidChar(read());
  },
  zero() {
    switch (c) {
      case ".":
        buffer += read();
        lexState = "decimalPoint";
        return;
      case "e":
      case "E":
        buffer += read();
        lexState = "decimalExponent";
        return;
      case "x":
      case "X":
        buffer += read();
        lexState = "hexadecimal";
        return;
    }
    return newToken("numeric", sign * 0);
  },
  decimalInteger() {
    switch (c) {
      case ".":
        buffer += read();
        lexState = "decimalPoint";
        return;
      case "e":
      case "E":
        buffer += read();
        lexState = "decimalExponent";
        return;
    }
    if (util.isDigit(c)) {
      buffer += read();
      return;
    }
    return newToken("numeric", sign * Number(buffer));
  },
  decimalPointLeading() {
    if (util.isDigit(c)) {
      buffer += read();
      lexState = "decimalFraction";
      return;
    }
    throw invalidChar(read());
  },
  decimalPoint() {
    switch (c) {
      case "e":
      case "E":
        buffer += read();
        lexState = "decimalExponent";
        return;
    }
    if (util.isDigit(c)) {
      buffer += read();
      lexState = "decimalFraction";
      return;
    }
    return newToken("numeric", sign * Number(buffer));
  },
  decimalFraction() {
    switch (c) {
      case "e":
      case "E":
        buffer += read();
        lexState = "decimalExponent";
        return;
    }
    if (util.isDigit(c)) {
      buffer += read();
      return;
    }
    return newToken("numeric", sign * Number(buffer));
  },
  decimalExponent() {
    switch (c) {
      case "+":
      case "-":
        buffer += read();
        lexState = "decimalExponentSign";
        return;
    }
    if (util.isDigit(c)) {
      buffer += read();
      lexState = "decimalExponentInteger";
      return;
    }
    throw invalidChar(read());
  },
  decimalExponentSign() {
    if (util.isDigit(c)) {
      buffer += read();
      lexState = "decimalExponentInteger";
      return;
    }
    throw invalidChar(read());
  },
  decimalExponentInteger() {
    if (util.isDigit(c)) {
      buffer += read();
      return;
    }
    return newToken("numeric", sign * Number(buffer));
  },
  hexadecimal() {
    if (util.isHexDigit(c)) {
      buffer += read();
      lexState = "hexadecimalInteger";
      return;
    }
    throw invalidChar(read());
  },
  hexadecimalInteger() {
    if (util.isHexDigit(c)) {
      buffer += read();
      return;
    }
    return newToken("numeric", sign * Number(buffer));
  },
  string() {
    switch (c) {
      case "\\":
        read();
        buffer += escape$1();
        return;
      case '"':
        if (doubleQuote) {
          read();
          return newToken("string", buffer);
        }
        buffer += read();
        return;
      case "'":
        if (!doubleQuote) {
          read();
          return newToken("string", buffer);
        }
        buffer += read();
        return;
      case "\n":
      case "\r":
        throw invalidChar(read());
      case "\u2028":
      case "\u2029":
        separatorChar(c);
        break;
      case void 0:
        throw invalidChar(read());
    }
    buffer += read();
  },
  start() {
    switch (c) {
      case "{":
      case "[":
        return newToken("punctuator", read());
    }
    lexState = "value";
  },
  beforePropertyName() {
    switch (c) {
      case "$":
      case "_":
        buffer = read();
        lexState = "identifierName";
        return;
      case "\\":
        read();
        lexState = "identifierNameStartEscape";
        return;
      case "}":
        return newToken("punctuator", read());
      case '"':
      case "'":
        doubleQuote = read() === '"';
        lexState = "string";
        return;
    }
    if (util.isIdStartChar(c)) {
      buffer += read();
      lexState = "identifierName";
      return;
    }
    throw invalidChar(read());
  },
  afterPropertyName() {
    if (c === ":") {
      return newToken("punctuator", read());
    }
    throw invalidChar(read());
  },
  beforePropertyValue() {
    lexState = "value";
  },
  afterPropertyValue() {
    switch (c) {
      case ",":
      case "}":
        return newToken("punctuator", read());
    }
    throw invalidChar(read());
  },
  beforeArrayValue() {
    if (c === "]") {
      return newToken("punctuator", read());
    }
    lexState = "value";
  },
  afterArrayValue() {
    switch (c) {
      case ",":
      case "]":
        return newToken("punctuator", read());
    }
    throw invalidChar(read());
  },
  end() {
    throw invalidChar(read());
  }
};
function newToken(type2, value) {
  return {
    type: type2,
    value,
    line,
    column
  };
}
function literal(s) {
  for (const c2 of s) {
    const p2 = peek();
    if (p2 !== c2) {
      throw invalidChar(read());
    }
    read();
  }
}
function escape$1() {
  const c2 = peek();
  switch (c2) {
    case "b":
      read();
      return "\b";
    case "f":
      read();
      return "\f";
    case "n":
      read();
      return "\n";
    case "r":
      read();
      return "\r";
    case "t":
      read();
      return "	";
    case "v":
      read();
      return "\v";
    case "0":
      read();
      if (util.isDigit(peek())) {
        throw invalidChar(read());
      }
      return "\0";
    case "x":
      read();
      return hexEscape();
    case "u":
      read();
      return unicodeEscape();
    case "\n":
    case "\u2028":
    case "\u2029":
      read();
      return "";
    case "\r":
      read();
      if (peek() === "\n") {
        read();
      }
      return "";
    case "1":
    case "2":
    case "3":
    case "4":
    case "5":
    case "6":
    case "7":
    case "8":
    case "9":
      throw invalidChar(read());
    case void 0:
      throw invalidChar(read());
  }
  return read();
}
function hexEscape() {
  let buffer2 = "";
  let c2 = peek();
  if (!util.isHexDigit(c2)) {
    throw invalidChar(read());
  }
  buffer2 += read();
  c2 = peek();
  if (!util.isHexDigit(c2)) {
    throw invalidChar(read());
  }
  buffer2 += read();
  return String.fromCodePoint(parseInt(buffer2, 16));
}
function unicodeEscape() {
  let buffer2 = "";
  let count = 4;
  while (count-- > 0) {
    const c2 = peek();
    if (!util.isHexDigit(c2)) {
      throw invalidChar(read());
    }
    buffer2 += read();
  }
  return String.fromCodePoint(parseInt(buffer2, 16));
}
const parseStates = {
  start() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    push();
  },
  beforePropertyName() {
    switch (token.type) {
      case "identifier":
      case "string":
        key = token.value;
        parseState = "afterPropertyName";
        return;
      case "punctuator":
        pop();
        return;
      case "eof":
        throw invalidEOF();
    }
  },
  afterPropertyName() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    parseState = "beforePropertyValue";
  },
  beforePropertyValue() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    push();
  },
  beforeArrayValue() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    if (token.type === "punctuator" && token.value === "]") {
      pop();
      return;
    }
    push();
  },
  afterPropertyValue() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    switch (token.value) {
      case ",":
        parseState = "beforePropertyName";
        return;
      case "}":
        pop();
    }
  },
  afterArrayValue() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    switch (token.value) {
      case ",":
        parseState = "beforeArrayValue";
        return;
      case "]":
        pop();
    }
  },
  end() {
  }
};
function push() {
  let value;
  switch (token.type) {
    case "punctuator":
      switch (token.value) {
        case "{":
          value = {};
          break;
        case "[":
          value = [];
          break;
      }
      break;
    case "null":
    case "boolean":
    case "numeric":
    case "string":
      value = token.value;
      break;
  }
  if (root === void 0) {
    root = value;
  } else {
    const parent = stack[stack.length - 1];
    if (Array.isArray(parent)) {
      parent.push(value);
    } else {
      Object.defineProperty(parent, key, {
        value,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
  }
  if (value !== null && typeof value === "object") {
    stack.push(value);
    if (Array.isArray(value)) {
      parseState = "beforeArrayValue";
    } else {
      parseState = "beforePropertyName";
    }
  } else {
    const current = stack[stack.length - 1];
    if (current == null) {
      parseState = "end";
    } else if (Array.isArray(current)) {
      parseState = "afterArrayValue";
    } else {
      parseState = "afterPropertyValue";
    }
  }
}
function pop() {
  stack.pop();
  const current = stack[stack.length - 1];
  if (current == null) {
    parseState = "end";
  } else if (Array.isArray(current)) {
    parseState = "afterArrayValue";
  } else {
    parseState = "afterPropertyValue";
  }
}
function invalidChar(c2) {
  if (c2 === void 0) {
    return syntaxError(`JSON5: invalid end of input at ${line}:${column}`);
  }
  return syntaxError(`JSON5: invalid character '${formatChar(c2)}' at ${line}:${column}`);
}
function invalidEOF() {
  return syntaxError(`JSON5: invalid end of input at ${line}:${column}`);
}
function invalidIdentifier() {
  column -= 5;
  return syntaxError(`JSON5: invalid identifier character at ${line}:${column}`);
}
function separatorChar(c2) {
  console.warn(`JSON5: '${formatChar(c2)}' in strings is not valid ECMAScript; consider escaping`);
}
function formatChar(c2) {
  const replacements = {
    "'": "\\'",
    '"': '\\"',
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t",
    "\v": "\\v",
    "\0": "\\0",
    "\u2028": "\\u2028",
    "\u2029": "\\u2029"
  };
  if (replacements[c2]) {
    return replacements[c2];
  }
  if (c2 < " ") {
    const hexString = c2.charCodeAt(0).toString(16);
    return "\\x" + ("00" + hexString).substring(hexString.length);
  }
  return c2;
}
function syntaxError(message) {
  const err = new SyntaxError(message);
  err.lineNumber = line;
  err.columnNumber = column;
  return err;
}
var stringify2 = function stringify3(value, replacer2, space) {
  const stack2 = [];
  let indent = "";
  let propertyList;
  let replacerFunc;
  let gap = "";
  let quote2;
  if (replacer2 != null && typeof replacer2 === "object" && !Array.isArray(replacer2)) {
    space = replacer2.space;
    quote2 = replacer2.quote;
    replacer2 = replacer2.replacer;
  }
  if (typeof replacer2 === "function") {
    replacerFunc = replacer2;
  } else if (Array.isArray(replacer2)) {
    propertyList = [];
    for (const v2 of replacer2) {
      let item;
      if (typeof v2 === "string") {
        item = v2;
      } else if (typeof v2 === "number" || v2 instanceof String || v2 instanceof Number) {
        item = String(v2);
      }
      if (item !== void 0 && propertyList.indexOf(item) < 0) {
        propertyList.push(item);
      }
    }
  }
  if (space instanceof Number) {
    space = Number(space);
  } else if (space instanceof String) {
    space = String(space);
  }
  if (typeof space === "number") {
    if (space > 0) {
      space = Math.min(10, Math.floor(space));
      gap = "          ".substr(0, space);
    }
  } else if (typeof space === "string") {
    gap = space.substr(0, 10);
  }
  return serializeProperty("", { "": value });
  function serializeProperty(key2, holder) {
    let value2 = holder[key2];
    if (value2 != null) {
      if (typeof value2.toJSON5 === "function") {
        value2 = value2.toJSON5(key2);
      } else if (typeof value2.toJSON === "function") {
        value2 = value2.toJSON(key2);
      }
    }
    if (replacerFunc) {
      value2 = replacerFunc.call(holder, key2, value2);
    }
    if (value2 instanceof Number) {
      value2 = Number(value2);
    } else if (value2 instanceof String) {
      value2 = String(value2);
    } else if (value2 instanceof Boolean) {
      value2 = value2.valueOf();
    }
    switch (value2) {
      case null:
        return "null";
      case true:
        return "true";
      case false:
        return "false";
    }
    if (typeof value2 === "string") {
      return quoteString(value2);
    }
    if (typeof value2 === "number") {
      return String(value2);
    }
    if (typeof value2 === "object") {
      return Array.isArray(value2) ? serializeArray(value2) : serializeObject(value2);
    }
    return void 0;
  }
  function quoteString(value2) {
    const quotes = {
      "'": 0.1,
      '"': 0.2
    };
    const replacements = {
      "'": "\\'",
      '"': '\\"',
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t",
      "\v": "\\v",
      "\0": "\\0",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    let product = "";
    for (let i = 0; i < value2.length; i++) {
      const c2 = value2[i];
      switch (c2) {
        case "'":
        case '"':
          quotes[c2]++;
          product += c2;
          continue;
        case "\0":
          if (util.isDigit(value2[i + 1])) {
            product += "\\x00";
            continue;
          }
      }
      if (replacements[c2]) {
        product += replacements[c2];
        continue;
      }
      if (c2 < " ") {
        let hexString = c2.charCodeAt(0).toString(16);
        product += "\\x" + ("00" + hexString).substring(hexString.length);
        continue;
      }
      product += c2;
    }
    const quoteChar = quote2 || Object.keys(quotes).reduce((a, b2) => quotes[a] < quotes[b2] ? a : b2);
    product = product.replace(new RegExp(quoteChar, "g"), replacements[quoteChar]);
    return quoteChar + product + quoteChar;
  }
  function serializeObject(value2) {
    if (stack2.indexOf(value2) >= 0) {
      throw TypeError("Converting circular structure to JSON5");
    }
    stack2.push(value2);
    let stepback = indent;
    indent = indent + gap;
    let keys2 = propertyList || Object.keys(value2);
    let partial = [];
    for (const key2 of keys2) {
      const propertyString = serializeProperty(key2, value2);
      if (propertyString !== void 0) {
        let member = serializeKey(key2) + ":";
        if (gap !== "") {
          member += " ";
        }
        member += propertyString;
        partial.push(member);
      }
    }
    let final;
    if (partial.length === 0) {
      final = "{}";
    } else {
      let properties;
      if (gap === "") {
        properties = partial.join(",");
        final = "{" + properties + "}";
      } else {
        let separator = ",\n" + indent;
        properties = partial.join(separator);
        final = "{\n" + indent + properties + ",\n" + stepback + "}";
      }
    }
    stack2.pop();
    indent = stepback;
    return final;
  }
  function serializeKey(key2) {
    if (key2.length === 0) {
      return quoteString(key2);
    }
    const firstChar = String.fromCodePoint(key2.codePointAt(0));
    if (!util.isIdStartChar(firstChar)) {
      return quoteString(key2);
    }
    for (let i = firstChar.length; i < key2.length; i++) {
      if (!util.isIdContinueChar(String.fromCodePoint(key2.codePointAt(i)))) {
        return quoteString(key2);
      }
    }
    return key2;
  }
  function serializeArray(value2) {
    if (stack2.indexOf(value2) >= 0) {
      throw TypeError("Converting circular structure to JSON5");
    }
    stack2.push(value2);
    let stepback = indent;
    indent = indent + gap;
    let partial = [];
    for (let i = 0; i < value2.length; i++) {
      const propertyString = serializeProperty(String(i), value2);
      partial.push(propertyString !== void 0 ? propertyString : "null");
    }
    let final;
    if (partial.length === 0) {
      final = "[]";
    } else {
      if (gap === "") {
        let properties = partial.join(",");
        final = "[" + properties + "]";
      } else {
        let separator = ",\n" + indent;
        let properties = partial.join(separator);
        final = "[\n" + indent + properties + ",\n" + stepback + "]";
      }
    }
    stack2.pop();
    indent = stepback;
    return final;
  }
};
const JSON5 = {
  parse,
  stringify: stringify2
};
var lib = JSON5;
var jsoneditor = { exports: {} };
/*! For license information please see jsoneditor.js.LICENSE.txt */
(function(module, exports) {
  !function(t, e) {
    module.exports = e();
  }(self, () => (() => {
    var t = { 9662: (t2, e2, r2) => {
      var n2 = r2(614), i = r2(6330), o = TypeError;
      t2.exports = function(t3) {
        if (n2(t3))
          return t3;
        throw o(i(t3) + " is not a function");
      };
    }, 9483: (t2, e2, r2) => {
      var n2 = r2(4411), i = r2(6330), o = TypeError;
      t2.exports = function(t3) {
        if (n2(t3))
          return t3;
        throw o(i(t3) + " is not a constructor");
      };
    }, 6077: (t2, e2, r2) => {
      var n2 = r2(614), i = String, o = TypeError;
      t2.exports = function(t3) {
        if ("object" == typeof t3 || n2(t3))
          return t3;
        throw o("Can't set " + i(t3) + " as a prototype");
      };
    }, 1223: (t2, e2, r2) => {
      var n2 = r2(5112), i = r2(30), o = r2(3070).f, a = n2("unscopables"), s = Array.prototype;
      null == s[a] && o(s, a, { configurable: true, value: i(null) }), t2.exports = function(t3) {
        s[a][t3] = true;
      };
    }, 1530: (t2, e2, r2) => {
      var n2 = r2(8710).charAt;
      t2.exports = function(t3, e3, r3) {
        return e3 + (r3 ? n2(t3, e3).length : 1);
      };
    }, 5787: (t2, e2, r2) => {
      var n2 = r2(7976), i = TypeError;
      t2.exports = function(t3, e3) {
        if (n2(e3, t3))
          return t3;
        throw i("Incorrect invocation");
      };
    }, 9670: (t2, e2, r2) => {
      var n2 = r2(111), i = String, o = TypeError;
      t2.exports = function(t3) {
        if (n2(t3))
          return t3;
        throw o(i(t3) + " is not an object");
      };
    }, 8533: (t2, e2, r2) => {
      var n2 = r2(2092).forEach, i = r2(9341)("forEach");
      t2.exports = i ? [].forEach : function(t3) {
        return n2(this, t3, arguments.length > 1 ? arguments[1] : void 0);
      };
    }, 8457: (t2, e2, r2) => {
      var n2 = r2(9974), i = r2(6916), o = r2(7908), a = r2(3411), s = r2(7659), l = r2(4411), c2 = r2(6244), u = r2(6135), h2 = r2(4121), p2 = r2(1246), d = Array;
      t2.exports = function(t3) {
        var e3 = o(t3), r3 = l(this), f2 = arguments.length, y2 = f2 > 1 ? arguments[1] : void 0, m = void 0 !== y2;
        m && (y2 = n2(y2, f2 > 2 ? arguments[2] : void 0));
        var v2, b2, g2, w2, _2, k2, j2 = p2(e3), O2 = 0;
        if (!j2 || this === d && s(j2))
          for (v2 = c2(e3), b2 = r3 ? new this(v2) : d(v2); v2 > O2; O2++)
            k2 = m ? y2(e3[O2], O2) : e3[O2], u(b2, O2, k2);
        else
          for (_2 = (w2 = h2(e3, j2)).next, b2 = r3 ? new this() : []; !(g2 = i(_2, w2)).done; O2++)
            k2 = m ? a(w2, y2, [g2.value, O2], true) : g2.value, u(b2, O2, k2);
        return b2.length = O2, b2;
      };
    }, 1318: (t2, e2, r2) => {
      var n2 = r2(5656), i = r2(1400), o = r2(6244), a = function(t3) {
        return function(e3, r3, a2) {
          var s, l = n2(e3), c2 = o(l), u = i(a2, c2);
          if (t3 && r3 != r3) {
            for (; c2 > u; )
              if ((s = l[u++]) != s)
                return true;
          } else
            for (; c2 > u; u++)
              if ((t3 || u in l) && l[u] === r3)
                return t3 || u || 0;
          return !t3 && -1;
        };
      };
      t2.exports = { includes: a(true), indexOf: a(false) };
    }, 2092: (t2, e2, r2) => {
      var n2 = r2(9974), i = r2(1702), o = r2(8361), a = r2(7908), s = r2(6244), l = r2(5417), c2 = i([].push), u = function(t3) {
        var e3 = 1 == t3, r3 = 2 == t3, i2 = 3 == t3, u2 = 4 == t3, h2 = 6 == t3, p2 = 7 == t3, d = 5 == t3 || h2;
        return function(f2, y2, m, v2) {
          for (var b2, g2, w2 = a(f2), _2 = o(w2), k2 = n2(y2, m), j2 = s(_2), O2 = 0, x2 = v2 || l, C2 = e3 ? x2(f2, j2) : r3 || p2 ? x2(f2, 0) : void 0; j2 > O2; O2++)
            if ((d || O2 in _2) && (g2 = k2(b2 = _2[O2], O2, w2), t3))
              if (e3)
                C2[O2] = g2;
              else if (g2)
                switch (t3) {
                  case 3:
                    return true;
                  case 5:
                    return b2;
                  case 6:
                    return O2;
                  case 2:
                    c2(C2, b2);
                }
              else
                switch (t3) {
                  case 4:
                    return false;
                  case 7:
                    c2(C2, b2);
                }
          return h2 ? -1 : i2 || u2 ? u2 : C2;
        };
      };
      t2.exports = { forEach: u(0), map: u(1), filter: u(2), some: u(3), every: u(4), find: u(5), findIndex: u(6), filterReject: u(7) };
    }, 1194: (t2, e2, r2) => {
      var n2 = r2(7293), i = r2(5112), o = r2(7392), a = i("species");
      t2.exports = function(t3) {
        return o >= 51 || !n2(function() {
          var e3 = [];
          return (e3.constructor = {})[a] = function() {
            return { foo: 1 };
          }, 1 !== e3[t3](Boolean).foo;
        });
      };
    }, 9341: (t2, e2, r2) => {
      var n2 = r2(7293);
      t2.exports = function(t3, e3) {
        var r3 = [][t3];
        return !!r3 && n2(function() {
          r3.call(null, e3 || function() {
            return 1;
          }, 1);
        });
      };
    }, 3671: (t2, e2, r2) => {
      var n2 = r2(9662), i = r2(7908), o = r2(8361), a = r2(6244), s = TypeError, l = function(t3) {
        return function(e3, r3, l2, c2) {
          n2(r3);
          var u = i(e3), h2 = o(u), p2 = a(u), d = t3 ? p2 - 1 : 0, f2 = t3 ? -1 : 1;
          if (l2 < 2)
            for (; ; ) {
              if (d in h2) {
                c2 = h2[d], d += f2;
                break;
              }
              if (d += f2, t3 ? d < 0 : p2 <= d)
                throw s("Reduce of empty array with no initial value");
            }
          for (; t3 ? d >= 0 : p2 > d; d += f2)
            d in h2 && (c2 = r3(c2, h2[d], d, u));
          return c2;
        };
      };
      t2.exports = { left: l(false), right: l(true) };
    }, 3658: (t2, e2, r2) => {
      var n2 = r2(9781), i = r2(3157), o = TypeError, a = Object.getOwnPropertyDescriptor, s = n2 && !function() {
        if (void 0 !== this)
          return true;
        try {
          Object.defineProperty([], "length", { writable: false }).length = 1;
        } catch (t3) {
          return t3 instanceof TypeError;
        }
      }();
      t2.exports = s ? function(t3, e3) {
        if (i(t3) && !a(t3, "length").writable)
          throw o("Cannot set read only .length");
        return t3.length = e3;
      } : function(t3, e3) {
        return t3.length = e3;
      };
    }, 1589: (t2, e2, r2) => {
      var n2 = r2(1400), i = r2(6244), o = r2(6135), a = Array, s = Math.max;
      t2.exports = function(t3, e3, r3) {
        for (var l = i(t3), c2 = n2(e3, l), u = n2(void 0 === r3 ? l : r3, l), h2 = a(s(u - c2, 0)), p2 = 0; c2 < u; c2++, p2++)
          o(h2, p2, t3[c2]);
        return h2.length = p2, h2;
      };
    }, 206: (t2, e2, r2) => {
      var n2 = r2(1702);
      t2.exports = n2([].slice);
    }, 4362: (t2, e2, r2) => {
      var n2 = r2(1589), i = Math.floor, o = function(t3, e3) {
        var r3 = t3.length, l = i(r3 / 2);
        return r3 < 8 ? a(t3, e3) : s(t3, o(n2(t3, 0, l), e3), o(n2(t3, l), e3), e3);
      }, a = function(t3, e3) {
        for (var r3, n3, i2 = t3.length, o2 = 1; o2 < i2; ) {
          for (n3 = o2, r3 = t3[o2]; n3 && e3(t3[n3 - 1], r3) > 0; )
            t3[n3] = t3[--n3];
          n3 !== o2++ && (t3[n3] = r3);
        }
        return t3;
      }, s = function(t3, e3, r3, n3) {
        for (var i2 = e3.length, o2 = r3.length, a2 = 0, s2 = 0; a2 < i2 || s2 < o2; )
          t3[a2 + s2] = a2 < i2 && s2 < o2 ? n3(e3[a2], r3[s2]) <= 0 ? e3[a2++] : r3[s2++] : a2 < i2 ? e3[a2++] : r3[s2++];
        return t3;
      };
      t2.exports = o;
    }, 7475: (t2, e2, r2) => {
      var n2 = r2(3157), i = r2(4411), o = r2(111), a = r2(5112)("species"), s = Array;
      t2.exports = function(t3) {
        var e3;
        return n2(t3) && (e3 = t3.constructor, (i(e3) && (e3 === s || n2(e3.prototype)) || o(e3) && null === (e3 = e3[a])) && (e3 = void 0)), void 0 === e3 ? s : e3;
      };
    }, 5417: (t2, e2, r2) => {
      var n2 = r2(7475);
      t2.exports = function(t3, e3) {
        return new (n2(t3))(0 === e3 ? 0 : e3);
      };
    }, 3411: (t2, e2, r2) => {
      var n2 = r2(9670), i = r2(9212);
      t2.exports = function(t3, e3, r3, o) {
        try {
          return o ? e3(n2(r3)[0], r3[1]) : e3(r3);
        } catch (e4) {
          i(t3, "throw", e4);
        }
      };
    }, 7072: (t2, e2, r2) => {
      var n2 = r2(5112)("iterator"), i = false;
      try {
        var o = 0, a = { next: function() {
          return { done: !!o++ };
        }, return: function() {
          i = true;
        } };
        a[n2] = function() {
          return this;
        }, Array.from(a, function() {
          throw 2;
        });
      } catch (t3) {
      }
      t2.exports = function(t3, e3) {
        if (!e3 && !i)
          return false;
        var r3 = false;
        try {
          var o2 = {};
          o2[n2] = function() {
            return { next: function() {
              return { done: r3 = true };
            } };
          }, t3(o2);
        } catch (t4) {
        }
        return r3;
      };
    }, 4326: (t2, e2, r2) => {
      var n2 = r2(1702), i = n2({}.toString), o = n2("".slice);
      t2.exports = function(t3) {
        return o(i(t3), 8, -1);
      };
    }, 648: (t2, e2, r2) => {
      var n2 = r2(1694), i = r2(614), o = r2(4326), a = r2(5112)("toStringTag"), s = Object, l = "Arguments" == o(function() {
        return arguments;
      }());
      t2.exports = n2 ? o : function(t3) {
        var e3, r3, n3;
        return void 0 === t3 ? "Undefined" : null === t3 ? "Null" : "string" == typeof (r3 = function(t4, e4) {
          try {
            return t4[e4];
          } catch (t5) {
          }
        }(e3 = s(t3), a)) ? r3 : l ? o(e3) : "Object" == (n3 = o(e3)) && i(e3.callee) ? "Arguments" : n3;
      };
    }, 9920: (t2, e2, r2) => {
      var n2 = r2(2597), i = r2(3887), o = r2(1236), a = r2(3070);
      t2.exports = function(t3, e3, r3) {
        for (var s = i(e3), l = a.f, c2 = o.f, u = 0; u < s.length; u++) {
          var h2 = s[u];
          n2(t3, h2) || r3 && n2(r3, h2) || l(t3, h2, c2(e3, h2));
        }
      };
    }, 4964: (t2, e2, r2) => {
      var n2 = r2(5112)("match");
      t2.exports = function(t3) {
        var e3 = /./;
        try {
          "/./"[t3](e3);
        } catch (r3) {
          try {
            return e3[n2] = false, "/./"[t3](e3);
          } catch (t4) {
          }
        }
        return false;
      };
    }, 8544: (t2, e2, r2) => {
      var n2 = r2(7293);
      t2.exports = !n2(function() {
        function t3() {
        }
        return t3.prototype.constructor = null, Object.getPrototypeOf(new t3()) !== t3.prototype;
      });
    }, 6178: (t2) => {
      t2.exports = function(t3, e2) {
        return { value: t3, done: e2 };
      };
    }, 8880: (t2, e2, r2) => {
      var n2 = r2(9781), i = r2(3070), o = r2(9114);
      t2.exports = n2 ? function(t3, e3, r3) {
        return i.f(t3, e3, o(1, r3));
      } : function(t3, e3, r3) {
        return t3[e3] = r3, t3;
      };
    }, 9114: (t2) => {
      t2.exports = function(t3, e2) {
        return { enumerable: !(1 & t3), configurable: !(2 & t3), writable: !(4 & t3), value: e2 };
      };
    }, 6135: (t2, e2, r2) => {
      var n2 = r2(4948), i = r2(3070), o = r2(9114);
      t2.exports = function(t3, e3, r3) {
        var a = n2(e3);
        a in t3 ? i.f(t3, a, o(0, r3)) : t3[a] = r3;
      };
    }, 5573: (t2, e2, r2) => {
      var n2 = r2(1702), i = r2(7293), o = r2(6650).start, a = RangeError, s = isFinite, l = Math.abs, c2 = Date.prototype, u = c2.toISOString, h2 = n2(c2.getTime), p2 = n2(c2.getUTCDate), d = n2(c2.getUTCFullYear), f2 = n2(c2.getUTCHours), y2 = n2(c2.getUTCMilliseconds), m = n2(c2.getUTCMinutes), v2 = n2(c2.getUTCMonth), b2 = n2(c2.getUTCSeconds);
      t2.exports = i(function() {
        return "0385-07-25T07:06:39.999Z" != u.call(/* @__PURE__ */ new Date(-50000000000001));
      }) || !i(function() {
        u.call(/* @__PURE__ */ new Date(NaN));
      }) ? function() {
        if (!s(h2(this)))
          throw a("Invalid time value");
        var t3 = this, e3 = d(t3), r3 = y2(t3), n3 = e3 < 0 ? "-" : e3 > 9999 ? "+" : "";
        return n3 + o(l(e3), n3 ? 6 : 4, 0) + "-" + o(v2(t3) + 1, 2, 0) + "-" + o(p2(t3), 2, 0) + "T" + o(f2(t3), 2, 0) + ":" + o(m(t3), 2, 0) + ":" + o(b2(t3), 2, 0) + "." + o(r3, 3, 0) + "Z";
      } : u;
    }, 8709: (t2, e2, r2) => {
      var n2 = r2(9670), i = r2(2140), o = TypeError;
      t2.exports = function(t3) {
        if (n2(this), "string" === t3 || "default" === t3)
          t3 = "string";
        else if ("number" !== t3)
          throw o("Incorrect hint");
        return i(this, t3);
      };
    }, 7045: (t2, e2, r2) => {
      var n2 = r2(6339), i = r2(3070);
      t2.exports = function(t3, e3, r3) {
        return r3.get && n2(r3.get, e3, { getter: true }), r3.set && n2(r3.set, e3, { setter: true }), i.f(t3, e3, r3);
      };
    }, 8052: (t2, e2, r2) => {
      var n2 = r2(614), i = r2(3070), o = r2(6339), a = r2(3072);
      t2.exports = function(t3, e3, r3, s) {
        s || (s = {});
        var l = s.enumerable, c2 = void 0 !== s.name ? s.name : e3;
        if (n2(r3) && o(r3, c2, s), s.global)
          l ? t3[e3] = r3 : a(e3, r3);
        else {
          try {
            s.unsafe ? t3[e3] && (l = true) : delete t3[e3];
          } catch (t4) {
          }
          l ? t3[e3] = r3 : i.f(t3, e3, { value: r3, enumerable: false, configurable: !s.nonConfigurable, writable: !s.nonWritable });
        }
        return t3;
      };
    }, 3072: (t2, e2, r2) => {
      var n2 = r2(7854), i = Object.defineProperty;
      t2.exports = function(t3, e3) {
        try {
          i(n2, t3, { value: e3, configurable: true, writable: true });
        } catch (r3) {
          n2[t3] = e3;
        }
        return e3;
      };
    }, 5117: (t2, e2, r2) => {
      var n2 = r2(6330), i = TypeError;
      t2.exports = function(t3, e3) {
        if (!delete t3[e3])
          throw i("Cannot delete property " + n2(e3) + " of " + n2(t3));
      };
    }, 9781: (t2, e2, r2) => {
      var n2 = r2(7293);
      t2.exports = !n2(function() {
        return 7 != Object.defineProperty({}, 1, { get: function() {
          return 7;
        } })[1];
      });
    }, 4154: (t2) => {
      var e2 = "object" == typeof document && document.all, r2 = void 0 === e2 && void 0 !== e2;
      t2.exports = { all: e2, IS_HTMLDDA: r2 };
    }, 317: (t2, e2, r2) => {
      var n2 = r2(7854), i = r2(111), o = n2.document, a = i(o) && i(o.createElement);
      t2.exports = function(t3) {
        return a ? o.createElement(t3) : {};
      };
    }, 7207: (t2) => {
      var e2 = TypeError;
      t2.exports = function(t3) {
        if (t3 > 9007199254740991)
          throw e2("Maximum allowed index exceeded");
        return t3;
      };
    }, 8324: (t2) => {
      t2.exports = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 };
    }, 8509: (t2, e2, r2) => {
      var n2 = r2(317)("span").classList, i = n2 && n2.constructor && n2.constructor.prototype;
      t2.exports = i === Object.prototype ? void 0 : i;
    }, 8886: (t2, e2, r2) => {
      var n2 = r2(8113).match(/firefox\/(\d+)/i);
      t2.exports = !!n2 && +n2[1];
    }, 7871: (t2, e2, r2) => {
      var n2 = r2(3823), i = r2(5268);
      t2.exports = !n2 && !i && "object" == typeof window && "object" == typeof document;
    }, 9363: (t2) => {
      t2.exports = "function" == typeof Bun && Bun && "string" == typeof Bun.version;
    }, 3823: (t2) => {
      t2.exports = "object" == typeof Deno && Deno && "object" == typeof Deno.version;
    }, 256: (t2, e2, r2) => {
      var n2 = r2(8113);
      t2.exports = /MSIE|Trident/.test(n2);
    }, 1528: (t2, e2, r2) => {
      var n2 = r2(8113);
      t2.exports = /ipad|iphone|ipod/i.test(n2) && "undefined" != typeof Pebble;
    }, 8334: (t2, e2, r2) => {
      var n2 = r2(8113);
      t2.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(n2);
    }, 5268: (t2, e2, r2) => {
      var n2 = r2(4326);
      t2.exports = "undefined" != typeof process && "process" == n2(process);
    }, 1036: (t2, e2, r2) => {
      var n2 = r2(8113);
      t2.exports = /web0s(?!.*chrome)/i.test(n2);
    }, 8113: (t2) => {
      t2.exports = "undefined" != typeof navigator && String(navigator.userAgent) || "";
    }, 7392: (t2, e2, r2) => {
      var n2, i, o = r2(7854), a = r2(8113), s = o.process, l = o.Deno, c2 = s && s.versions || l && l.version, u = c2 && c2.v8;
      u && (i = (n2 = u.split("."))[0] > 0 && n2[0] < 4 ? 1 : +(n2[0] + n2[1])), !i && a && (!(n2 = a.match(/Edge\/(\d+)/)) || n2[1] >= 74) && (n2 = a.match(/Chrome\/(\d+)/)) && (i = +n2[1]), t2.exports = i;
    }, 8008: (t2, e2, r2) => {
      var n2 = r2(8113).match(/AppleWebKit\/(\d+)\./);
      t2.exports = !!n2 && +n2[1];
    }, 748: (t2) => {
      t2.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
    }, 2109: (t2, e2, r2) => {
      var n2 = r2(7854), i = r2(1236).f, o = r2(8880), a = r2(8052), s = r2(3072), l = r2(9920), c2 = r2(4705);
      t2.exports = function(t3, e3) {
        var r3, u, h2, p2, d, f2 = t3.target, y2 = t3.global, m = t3.stat;
        if (r3 = y2 ? n2 : m ? n2[f2] || s(f2, {}) : (n2[f2] || {}).prototype)
          for (u in e3) {
            if (p2 = e3[u], h2 = t3.dontCallGetSet ? (d = i(r3, u)) && d.value : r3[u], !c2(y2 ? u : f2 + (m ? "." : "#") + u, t3.forced) && void 0 !== h2) {
              if (typeof p2 == typeof h2)
                continue;
              l(p2, h2);
            }
            (t3.sham || h2 && h2.sham) && o(p2, "sham", true), a(r3, u, p2, t3);
          }
      };
    }, 7293: (t2) => {
      t2.exports = function(t3) {
        try {
          return !!t3();
        } catch (t4) {
          return true;
        }
      };
    }, 7007: (t2, e2, r2) => {
      r2(4916);
      var n2 = r2(1470), i = r2(8052), o = r2(2261), a = r2(7293), s = r2(5112), l = r2(8880), c2 = s("species"), u = RegExp.prototype;
      t2.exports = function(t3, e3, r3, h2) {
        var p2 = s(t3), d = !a(function() {
          var e4 = {};
          return e4[p2] = function() {
            return 7;
          }, 7 != ""[t3](e4);
        }), f2 = d && !a(function() {
          var e4 = false, r4 = /a/;
          return "split" === t3 && ((r4 = {}).constructor = {}, r4.constructor[c2] = function() {
            return r4;
          }, r4.flags = "", r4[p2] = /./[p2]), r4.exec = function() {
            return e4 = true, null;
          }, r4[p2](""), !e4;
        });
        if (!d || !f2 || r3) {
          var y2 = n2(/./[p2]), m = e3(p2, ""[t3], function(t4, e4, r4, i2, a2) {
            var s2 = n2(t4), l2 = e4.exec;
            return l2 === o || l2 === u.exec ? d && !a2 ? { done: true, value: y2(e4, r4, i2) } : { done: true, value: s2(r4, e4, i2) } : { done: false };
          });
          i(String.prototype, t3, m[0]), i(u, p2, m[1]);
        }
        h2 && l(u[p2], "sham", true);
      };
    }, 2104: (t2, e2, r2) => {
      var n2 = r2(4374), i = Function.prototype, o = i.apply, a = i.call;
      t2.exports = "object" == typeof Reflect && Reflect.apply || (n2 ? a.bind(o) : function() {
        return a.apply(o, arguments);
      });
    }, 9974: (t2, e2, r2) => {
      var n2 = r2(1470), i = r2(9662), o = r2(4374), a = n2(n2.bind);
      t2.exports = function(t3, e3) {
        return i(t3), void 0 === e3 ? t3 : o ? a(t3, e3) : function() {
          return t3.apply(e3, arguments);
        };
      };
    }, 4374: (t2, e2, r2) => {
      var n2 = r2(7293);
      t2.exports = !n2(function() {
        var t3 = (function() {
        }).bind();
        return "function" != typeof t3 || t3.hasOwnProperty("prototype");
      });
    }, 7065: (t2, e2, r2) => {
      var n2 = r2(1702), i = r2(9662), o = r2(111), a = r2(2597), s = r2(206), l = r2(4374), c2 = Function, u = n2([].concat), h2 = n2([].join), p2 = {}, d = function(t3, e3, r3) {
        if (!a(p2, e3)) {
          for (var n3 = [], i2 = 0; i2 < e3; i2++)
            n3[i2] = "a[" + i2 + "]";
          p2[e3] = c2("C,a", "return new C(" + h2(n3, ",") + ")");
        }
        return p2[e3](t3, r3);
      };
      t2.exports = l ? c2.bind : function(t3) {
        var e3 = i(this), r3 = e3.prototype, n3 = s(arguments, 1), a2 = function() {
          var r4 = u(n3, s(arguments));
          return this instanceof a2 ? d(e3, r4.length, r4) : e3.apply(t3, r4);
        };
        return o(r3) && (a2.prototype = r3), a2;
      };
    }, 6916: (t2, e2, r2) => {
      var n2 = r2(4374), i = Function.prototype.call;
      t2.exports = n2 ? i.bind(i) : function() {
        return i.apply(i, arguments);
      };
    }, 6530: (t2, e2, r2) => {
      var n2 = r2(9781), i = r2(2597), o = Function.prototype, a = n2 && Object.getOwnPropertyDescriptor, s = i(o, "name"), l = s && "something" === (function() {
      }).name, c2 = s && (!n2 || n2 && a(o, "name").configurable);
      t2.exports = { EXISTS: s, PROPER: l, CONFIGURABLE: c2 };
    }, 5668: (t2, e2, r2) => {
      var n2 = r2(1702), i = r2(9662);
      t2.exports = function(t3, e3, r3) {
        try {
          return n2(i(Object.getOwnPropertyDescriptor(t3, e3)[r3]));
        } catch (t4) {
        }
      };
    }, 1470: (t2, e2, r2) => {
      var n2 = r2(4326), i = r2(1702);
      t2.exports = function(t3) {
        if ("Function" === n2(t3))
          return i(t3);
      };
    }, 1702: (t2, e2, r2) => {
      var n2 = r2(4374), i = Function.prototype, o = i.call, a = n2 && i.bind.bind(o, o);
      t2.exports = n2 ? a : function(t3) {
        return function() {
          return o.apply(t3, arguments);
        };
      };
    }, 5005: (t2, e2, r2) => {
      var n2 = r2(7854), i = r2(614), o = function(t3) {
        return i(t3) ? t3 : void 0;
      };
      t2.exports = function(t3, e3) {
        return arguments.length < 2 ? o(n2[t3]) : n2[t3] && n2[t3][e3];
      };
    }, 1246: (t2, e2, r2) => {
      var n2 = r2(648), i = r2(8173), o = r2(8554), a = r2(7497), s = r2(5112)("iterator");
      t2.exports = function(t3) {
        if (!o(t3))
          return i(t3, s) || i(t3, "@@iterator") || a[n2(t3)];
      };
    }, 4121: (t2, e2, r2) => {
      var n2 = r2(6916), i = r2(9662), o = r2(9670), a = r2(6330), s = r2(1246), l = TypeError;
      t2.exports = function(t3, e3) {
        var r3 = arguments.length < 2 ? s(t3) : e3;
        if (i(r3))
          return o(n2(r3, t3));
        throw l(a(t3) + " is not iterable");
      };
    }, 8044: (t2, e2, r2) => {
      var n2 = r2(1702), i = r2(3157), o = r2(614), a = r2(4326), s = r2(1340), l = n2([].push);
      t2.exports = function(t3) {
        if (o(t3))
          return t3;
        if (i(t3)) {
          for (var e3 = t3.length, r3 = [], n3 = 0; n3 < e3; n3++) {
            var c2 = t3[n3];
            "string" == typeof c2 ? l(r3, c2) : "number" != typeof c2 && "Number" != a(c2) && "String" != a(c2) || l(r3, s(c2));
          }
          var u = r3.length, h2 = true;
          return function(t4, e4) {
            if (h2)
              return h2 = false, e4;
            if (i(this))
              return e4;
            for (var n4 = 0; n4 < u; n4++)
              if (r3[n4] === t4)
                return e4;
          };
        }
      };
    }, 8173: (t2, e2, r2) => {
      var n2 = r2(9662), i = r2(8554);
      t2.exports = function(t3, e3) {
        var r3 = t3[e3];
        return i(r3) ? void 0 : n2(r3);
      };
    }, 647: (t2, e2, r2) => {
      var n2 = r2(1702), i = r2(7908), o = Math.floor, a = n2("".charAt), s = n2("".replace), l = n2("".slice), c2 = /\$([$&'`]|\d{1,2}|<[^>]*>)/g, u = /\$([$&'`]|\d{1,2})/g;
      t2.exports = function(t3, e3, r3, n3, h2, p2) {
        var d = r3 + t3.length, f2 = n3.length, y2 = u;
        return void 0 !== h2 && (h2 = i(h2), y2 = c2), s(p2, y2, function(i2, s2) {
          var c3;
          switch (a(s2, 0)) {
            case "$":
              return "$";
            case "&":
              return t3;
            case "`":
              return l(e3, 0, r3);
            case "'":
              return l(e3, d);
            case "<":
              c3 = h2[l(s2, 1, -1)];
              break;
            default:
              var u2 = +s2;
              if (0 === u2)
                return i2;
              if (u2 > f2) {
                var p3 = o(u2 / 10);
                return 0 === p3 ? i2 : p3 <= f2 ? void 0 === n3[p3 - 1] ? a(s2, 1) : n3[p3 - 1] + a(s2, 1) : i2;
              }
              c3 = n3[u2 - 1];
          }
          return void 0 === c3 ? "" : c3;
        });
      };
    }, 7854: (t2, e2, r2) => {
      var n2 = function(t3) {
        return t3 && t3.Math == Math && t3;
      };
      t2.exports = n2("object" == typeof globalThis && globalThis) || n2("object" == typeof window && window) || n2("object" == typeof self && self) || n2("object" == typeof r2.g && r2.g) || function() {
        return this;
      }() || Function("return this")();
    }, 2597: (t2, e2, r2) => {
      var n2 = r2(1702), i = r2(7908), o = n2({}.hasOwnProperty);
      t2.exports = Object.hasOwn || function(t3, e3) {
        return o(i(t3), e3);
      };
    }, 3501: (t2) => {
      t2.exports = {};
    }, 842: (t2) => {
      t2.exports = function(t3, e2) {
        try {
          1 == arguments.length ? console.error(t3) : console.error(t3, e2);
        } catch (t4) {
        }
      };
    }, 490: (t2, e2, r2) => {
      var n2 = r2(5005);
      t2.exports = n2("document", "documentElement");
    }, 4664: (t2, e2, r2) => {
      var n2 = r2(9781), i = r2(7293), o = r2(317);
      t2.exports = !n2 && !i(function() {
        return 7 != Object.defineProperty(o("div"), "a", { get: function() {
          return 7;
        } }).a;
      });
    }, 8361: (t2, e2, r2) => {
      var n2 = r2(1702), i = r2(7293), o = r2(4326), a = Object, s = n2("".split);
      t2.exports = i(function() {
        return !a("z").propertyIsEnumerable(0);
      }) ? function(t3) {
        return "String" == o(t3) ? s(t3, "") : a(t3);
      } : a;
    }, 9587: (t2, e2, r2) => {
      var n2 = r2(614), i = r2(111), o = r2(7674);
      t2.exports = function(t3, e3, r3) {
        var a, s;
        return o && n2(a = e3.constructor) && a !== r3 && i(s = a.prototype) && s !== r3.prototype && o(t3, s), t3;
      };
    }, 2788: (t2, e2, r2) => {
      var n2 = r2(1702), i = r2(614), o = r2(5465), a = n2(Function.toString);
      i(o.inspectSource) || (o.inspectSource = function(t3) {
        return a(t3);
      }), t2.exports = o.inspectSource;
    }, 9909: (t2, e2, r2) => {
      var n2, i, o, a = r2(4811), s = r2(7854), l = r2(111), c2 = r2(8880), u = r2(2597), h2 = r2(5465), p2 = r2(6200), d = r2(3501), f2 = "Object already initialized", y2 = s.TypeError, m = s.WeakMap;
      if (a || h2.state) {
        var v2 = h2.state || (h2.state = new m());
        v2.get = v2.get, v2.has = v2.has, v2.set = v2.set, n2 = function(t3, e3) {
          if (v2.has(t3))
            throw y2(f2);
          return e3.facade = t3, v2.set(t3, e3), e3;
        }, i = function(t3) {
          return v2.get(t3) || {};
        }, o = function(t3) {
          return v2.has(t3);
        };
      } else {
        var b2 = p2("state");
        d[b2] = true, n2 = function(t3, e3) {
          if (u(t3, b2))
            throw y2(f2);
          return e3.facade = t3, c2(t3, b2, e3), e3;
        }, i = function(t3) {
          return u(t3, b2) ? t3[b2] : {};
        }, o = function(t3) {
          return u(t3, b2);
        };
      }
      t2.exports = { set: n2, get: i, has: o, enforce: function(t3) {
        return o(t3) ? i(t3) : n2(t3, {});
      }, getterFor: function(t3) {
        return function(e3) {
          var r3;
          if (!l(e3) || (r3 = i(e3)).type !== t3)
            throw y2("Incompatible receiver, " + t3 + " required");
          return r3;
        };
      } };
    }, 7659: (t2, e2, r2) => {
      var n2 = r2(5112), i = r2(7497), o = n2("iterator"), a = Array.prototype;
      t2.exports = function(t3) {
        return void 0 !== t3 && (i.Array === t3 || a[o] === t3);
      };
    }, 3157: (t2, e2, r2) => {
      var n2 = r2(4326);
      t2.exports = Array.isArray || function(t3) {
        return "Array" == n2(t3);
      };
    }, 614: (t2, e2, r2) => {
      var n2 = r2(4154), i = n2.all;
      t2.exports = n2.IS_HTMLDDA ? function(t3) {
        return "function" == typeof t3 || t3 === i;
      } : function(t3) {
        return "function" == typeof t3;
      };
    }, 4411: (t2, e2, r2) => {
      var n2 = r2(1702), i = r2(7293), o = r2(614), a = r2(648), s = r2(5005), l = r2(2788), c2 = function() {
      }, u = [], h2 = s("Reflect", "construct"), p2 = /^\s*(?:class|function)\b/, d = n2(p2.exec), f2 = !p2.exec(c2), y2 = function(t3) {
        if (!o(t3))
          return false;
        try {
          return h2(c2, u, t3), true;
        } catch (t4) {
          return false;
        }
      }, m = function(t3) {
        if (!o(t3))
          return false;
        switch (a(t3)) {
          case "AsyncFunction":
          case "GeneratorFunction":
          case "AsyncGeneratorFunction":
            return false;
        }
        try {
          return f2 || !!d(p2, l(t3));
        } catch (t4) {
          return true;
        }
      };
      m.sham = true, t2.exports = !h2 || i(function() {
        var t3;
        return y2(y2.call) || !y2(Object) || !y2(function() {
          t3 = true;
        }) || t3;
      }) ? m : y2;
    }, 5032: (t2, e2, r2) => {
      var n2 = r2(2597);
      t2.exports = function(t3) {
        return void 0 !== t3 && (n2(t3, "value") || n2(t3, "writable"));
      };
    }, 4705: (t2, e2, r2) => {
      var n2 = r2(7293), i = r2(614), o = /#|\.prototype\./, a = function(t3, e3) {
        var r3 = l[s(t3)];
        return r3 == u || r3 != c2 && (i(e3) ? n2(e3) : !!e3);
      }, s = a.normalize = function(t3) {
        return String(t3).replace(o, ".").toLowerCase();
      }, l = a.data = {}, c2 = a.NATIVE = "N", u = a.POLYFILL = "P";
      t2.exports = a;
    }, 8554: (t2) => {
      t2.exports = function(t3) {
        return null == t3;
      };
    }, 111: (t2, e2, r2) => {
      var n2 = r2(614), i = r2(4154), o = i.all;
      t2.exports = i.IS_HTMLDDA ? function(t3) {
        return "object" == typeof t3 ? null !== t3 : n2(t3) || t3 === o;
      } : function(t3) {
        return "object" == typeof t3 ? null !== t3 : n2(t3);
      };
    }, 1913: (t2) => {
      t2.exports = false;
    }, 7850: (t2, e2, r2) => {
      var n2 = r2(111), i = r2(4326), o = r2(5112)("match");
      t2.exports = function(t3) {
        var e3;
        return n2(t3) && (void 0 !== (e3 = t3[o]) ? !!e3 : "RegExp" == i(t3));
      };
    }, 2190: (t2, e2, r2) => {
      var n2 = r2(5005), i = r2(614), o = r2(7976), a = r2(3307), s = Object;
      t2.exports = a ? function(t3) {
        return "symbol" == typeof t3;
      } : function(t3) {
        var e3 = n2("Symbol");
        return i(e3) && o(e3.prototype, s(t3));
      };
    }, 408: (t2, e2, r2) => {
      var n2 = r2(9974), i = r2(6916), o = r2(9670), a = r2(6330), s = r2(7659), l = r2(6244), c2 = r2(7976), u = r2(4121), h2 = r2(1246), p2 = r2(9212), d = TypeError, f2 = function(t3, e3) {
        this.stopped = t3, this.result = e3;
      }, y2 = f2.prototype;
      t2.exports = function(t3, e3, r3) {
        var m, v2, b2, g2, w2, _2, k2, j2 = r3 && r3.that, O2 = !(!r3 || !r3.AS_ENTRIES), x2 = !(!r3 || !r3.IS_RECORD), C2 = !(!r3 || !r3.IS_ITERATOR), E2 = !(!r3 || !r3.INTERRUPTED), S2 = n2(e3, j2), P2 = function(t4) {
          return m && p2(m, "normal", t4), new f2(true, t4);
        }, T2 = function(t4) {
          return O2 ? (o(t4), E2 ? S2(t4[0], t4[1], P2) : S2(t4[0], t4[1])) : E2 ? S2(t4, P2) : S2(t4);
        };
        if (x2)
          m = t3.iterator;
        else if (C2)
          m = t3;
        else {
          if (!(v2 = h2(t3)))
            throw d(a(t3) + " is not iterable");
          if (s(v2)) {
            for (b2 = 0, g2 = l(t3); g2 > b2; b2++)
              if ((w2 = T2(t3[b2])) && c2(y2, w2))
                return w2;
            return new f2(false);
          }
          m = u(t3, v2);
        }
        for (_2 = x2 ? t3.next : m.next; !(k2 = i(_2, m)).done; ) {
          try {
            w2 = T2(k2.value);
          } catch (t4) {
            p2(m, "throw", t4);
          }
          if ("object" == typeof w2 && w2 && c2(y2, w2))
            return w2;
        }
        return new f2(false);
      };
    }, 9212: (t2, e2, r2) => {
      var n2 = r2(6916), i = r2(9670), o = r2(8173);
      t2.exports = function(t3, e3, r3) {
        var a, s;
        i(t3);
        try {
          if (!(a = o(t3, "return"))) {
            if ("throw" === e3)
              throw r3;
            return r3;
          }
          a = n2(a, t3);
        } catch (t4) {
          s = true, a = t4;
        }
        if ("throw" === e3)
          throw r3;
        if (s)
          throw a;
        return i(a), r3;
      };
    }, 3061: (t2, e2, r2) => {
      var n2 = r2(3383).IteratorPrototype, i = r2(30), o = r2(9114), a = r2(8003), s = r2(7497), l = function() {
        return this;
      };
      t2.exports = function(t3, e3, r3, c2) {
        var u = e3 + " Iterator";
        return t3.prototype = i(n2, { next: o(+!c2, r3) }), a(t3, u, false, true), s[u] = l, t3;
      };
    }, 1656: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(6916), o = r2(1913), a = r2(6530), s = r2(614), l = r2(3061), c2 = r2(9518), u = r2(7674), h2 = r2(8003), p2 = r2(8880), d = r2(8052), f2 = r2(5112), y2 = r2(7497), m = r2(3383), v2 = a.PROPER, b2 = a.CONFIGURABLE, g2 = m.IteratorPrototype, w2 = m.BUGGY_SAFARI_ITERATORS, _2 = f2("iterator"), k2 = "keys", j2 = "values", O2 = "entries", x2 = function() {
        return this;
      };
      t2.exports = function(t3, e3, r3, a2, f3, m2, C2) {
        l(r3, e3, a2);
        var E2, S2, P2, T2 = function(t4) {
          if (t4 === f3 && B2)
            return B2;
          if (!w2 && t4 in A2)
            return A2[t4];
          switch (t4) {
            case k2:
            case j2:
            case O2:
              return function() {
                return new r3(this, t4);
              };
          }
          return function() {
            return new r3(this);
          };
        }, L2 = e3 + " Iterator", R2 = false, A2 = t3.prototype, I2 = A2[_2] || A2["@@iterator"] || f3 && A2[f3], B2 = !w2 && I2 || T2(f3), N2 = "Array" == e3 && A2.entries || I2;
        if (N2 && (E2 = c2(N2.call(new t3()))) !== Object.prototype && E2.next && (o || c2(E2) === g2 || (u ? u(E2, g2) : s(E2[_2]) || d(E2, _2, x2)), h2(E2, L2, true, true), o && (y2[L2] = x2)), v2 && f3 == j2 && I2 && I2.name !== j2 && (!o && b2 ? p2(A2, "name", j2) : (R2 = true, B2 = function() {
          return i(I2, this);
        })), f3)
          if (S2 = { values: T2(j2), keys: m2 ? B2 : T2(k2), entries: T2(O2) }, C2)
            for (P2 in S2)
              (w2 || R2 || !(P2 in A2)) && d(A2, P2, S2[P2]);
          else
            n2({ target: e3, proto: true, forced: w2 || R2 }, S2);
        return o && !C2 || A2[_2] === B2 || d(A2, _2, B2, { name: f3 }), y2[e3] = B2, S2;
      };
    }, 3383: (t2, e2, r2) => {
      var n2, i, o, a = r2(7293), s = r2(614), l = r2(111), c2 = r2(30), u = r2(9518), h2 = r2(8052), p2 = r2(5112), d = r2(1913), f2 = p2("iterator"), y2 = false;
      [].keys && ("next" in (o = [].keys()) ? (i = u(u(o))) !== Object.prototype && (n2 = i) : y2 = true), !l(n2) || a(function() {
        var t3 = {};
        return n2[f2].call(t3) !== t3;
      }) ? n2 = {} : d && (n2 = c2(n2)), s(n2[f2]) || h2(n2, f2, function() {
        return this;
      }), t2.exports = { IteratorPrototype: n2, BUGGY_SAFARI_ITERATORS: y2 };
    }, 7497: (t2) => {
      t2.exports = {};
    }, 6244: (t2, e2, r2) => {
      var n2 = r2(7466);
      t2.exports = function(t3) {
        return n2(t3.length);
      };
    }, 6339: (t2, e2, r2) => {
      var n2 = r2(1702), i = r2(7293), o = r2(614), a = r2(2597), s = r2(9781), l = r2(6530).CONFIGURABLE, c2 = r2(2788), u = r2(9909), h2 = u.enforce, p2 = u.get, d = String, f2 = Object.defineProperty, y2 = n2("".slice), m = n2("".replace), v2 = n2([].join), b2 = s && !i(function() {
        return 8 !== f2(function() {
        }, "length", { value: 8 }).length;
      }), g2 = String(String).split("String"), w2 = t2.exports = function(t3, e3, r3) {
        "Symbol(" === y2(d(e3), 0, 7) && (e3 = "[" + m(d(e3), /^Symbol\(([^)]*)\)/, "$1") + "]"), r3 && r3.getter && (e3 = "get " + e3), r3 && r3.setter && (e3 = "set " + e3), (!a(t3, "name") || l && t3.name !== e3) && (s ? f2(t3, "name", { value: e3, configurable: true }) : t3.name = e3), b2 && r3 && a(r3, "arity") && t3.length !== r3.arity && f2(t3, "length", { value: r3.arity });
        try {
          r3 && a(r3, "constructor") && r3.constructor ? s && f2(t3, "prototype", { writable: false }) : t3.prototype && (t3.prototype = void 0);
        } catch (t4) {
        }
        var n3 = h2(t3);
        return a(n3, "source") || (n3.source = v2(g2, "string" == typeof e3 ? e3 : "")), t3;
      };
      Function.prototype.toString = w2(function() {
        return o(this) && p2(this).source || c2(this);
      }, "toString");
    }, 4758: (t2) => {
      var e2 = Math.ceil, r2 = Math.floor;
      t2.exports = Math.trunc || function(t3) {
        var n2 = +t3;
        return (n2 > 0 ? r2 : e2)(n2);
      };
    }, 5948: (t2, e2, r2) => {
      var n2, i, o, a, s, l = r2(7854), c2 = r2(9974), u = r2(1236).f, h2 = r2(261).set, p2 = r2(8572), d = r2(8334), f2 = r2(1528), y2 = r2(1036), m = r2(5268), v2 = l.MutationObserver || l.WebKitMutationObserver, b2 = l.document, g2 = l.process, w2 = l.Promise, _2 = u(l, "queueMicrotask"), k2 = _2 && _2.value;
      if (!k2) {
        var j2 = new p2(), O2 = function() {
          var t3, e3;
          for (m && (t3 = g2.domain) && t3.exit(); e3 = j2.get(); )
            try {
              e3();
            } catch (t4) {
              throw j2.head && n2(), t4;
            }
          t3 && t3.enter();
        };
        d || m || y2 || !v2 || !b2 ? !f2 && w2 && w2.resolve ? ((a = w2.resolve(void 0)).constructor = w2, s = c2(a.then, a), n2 = function() {
          s(O2);
        }) : m ? n2 = function() {
          g2.nextTick(O2);
        } : (h2 = c2(h2, l), n2 = function() {
          h2(O2);
        }) : (i = true, o = b2.createTextNode(""), new v2(O2).observe(o, { characterData: true }), n2 = function() {
          o.data = i = !i;
        }), k2 = function(t3) {
          j2.head || n2(), j2.add(t3);
        };
      }
      t2.exports = k2;
    }, 8523: (t2, e2, r2) => {
      var n2 = r2(9662), i = TypeError, o = function(t3) {
        var e3, r3;
        this.promise = new t3(function(t4, n3) {
          if (void 0 !== e3 || void 0 !== r3)
            throw i("Bad Promise constructor");
          e3 = t4, r3 = n3;
        }), this.resolve = n2(e3), this.reject = n2(r3);
      };
      t2.exports.f = function(t3) {
        return new o(t3);
      };
    }, 3929: (t2, e2, r2) => {
      var n2 = r2(7850), i = TypeError;
      t2.exports = function(t3) {
        if (n2(t3))
          throw i("The method doesn't accept regular expressions");
        return t3;
      };
    }, 2814: (t2, e2, r2) => {
      var n2 = r2(7854), i = r2(7293), o = r2(1702), a = r2(1340), s = r2(3111).trim, l = r2(1361), c2 = o("".charAt), u = n2.parseFloat, h2 = n2.Symbol, p2 = h2 && h2.iterator, d = 1 / u(l + "-0") != -1 / 0 || p2 && !i(function() {
        u(Object(p2));
      });
      t2.exports = d ? function(t3) {
        var e3 = s(a(t3)), r3 = u(e3);
        return 0 === r3 && "-" == c2(e3, 0) ? -0 : r3;
      } : u;
    }, 3009: (t2, e2, r2) => {
      var n2 = r2(7854), i = r2(7293), o = r2(1702), a = r2(1340), s = r2(3111).trim, l = r2(1361), c2 = n2.parseInt, u = n2.Symbol, h2 = u && u.iterator, p2 = /^[+-]?0x/i, d = o(p2.exec), f2 = 8 !== c2(l + "08") || 22 !== c2(l + "0x16") || h2 && !i(function() {
        c2(Object(h2));
      });
      t2.exports = f2 ? function(t3, e3) {
        var r3 = s(a(t3));
        return c2(r3, e3 >>> 0 || (d(p2, r3) ? 16 : 10));
      } : c2;
    }, 1574: (t2, e2, r2) => {
      var n2 = r2(9781), i = r2(1702), o = r2(6916), a = r2(7293), s = r2(1956), l = r2(5181), c2 = r2(5296), u = r2(7908), h2 = r2(8361), p2 = Object.assign, d = Object.defineProperty, f2 = i([].concat);
      t2.exports = !p2 || a(function() {
        if (n2 && 1 !== p2({ b: 1 }, p2(d({}, "a", { enumerable: true, get: function() {
          d(this, "b", { value: 3, enumerable: false });
        } }), { b: 2 })).b)
          return true;
        var t3 = {}, e3 = {}, r3 = Symbol(), i2 = "abcdefghijklmnopqrst";
        return t3[r3] = 7, i2.split("").forEach(function(t4) {
          e3[t4] = t4;
        }), 7 != p2({}, t3)[r3] || s(p2({}, e3)).join("") != i2;
      }) ? function(t3, e3) {
        for (var r3 = u(t3), i2 = arguments.length, a2 = 1, p3 = l.f, d2 = c2.f; i2 > a2; )
          for (var y2, m = h2(arguments[a2++]), v2 = p3 ? f2(s(m), p3(m)) : s(m), b2 = v2.length, g2 = 0; b2 > g2; )
            y2 = v2[g2++], n2 && !o(d2, m, y2) || (r3[y2] = m[y2]);
        return r3;
      } : p2;
    }, 30: (t2, e2, r2) => {
      var n2, i = r2(9670), o = r2(6048), a = r2(748), s = r2(3501), l = r2(490), c2 = r2(317), u = r2(6200), h2 = "prototype", p2 = "script", d = u("IE_PROTO"), f2 = function() {
      }, y2 = function(t3) {
        return "<" + p2 + ">" + t3 + "</" + p2 + ">";
      }, m = function(t3) {
        t3.write(y2("")), t3.close();
        var e3 = t3.parentWindow.Object;
        return t3 = null, e3;
      }, v2 = function() {
        try {
          n2 = new ActiveXObject("htmlfile");
        } catch (t4) {
        }
        var t3, e3, r3;
        v2 = "undefined" != typeof document ? document.domain && n2 ? m(n2) : (e3 = c2("iframe"), r3 = "java" + p2 + ":", e3.style.display = "none", l.appendChild(e3), e3.src = String(r3), (t3 = e3.contentWindow.document).open(), t3.write(y2("document.F=Object")), t3.close(), t3.F) : m(n2);
        for (var i2 = a.length; i2--; )
          delete v2[h2][a[i2]];
        return v2();
      };
      s[d] = true, t2.exports = Object.create || function(t3, e3) {
        var r3;
        return null !== t3 ? (f2[h2] = i(t3), r3 = new f2(), f2[h2] = null, r3[d] = t3) : r3 = v2(), void 0 === e3 ? r3 : o.f(r3, e3);
      };
    }, 6048: (t2, e2, r2) => {
      var n2 = r2(9781), i = r2(3353), o = r2(3070), a = r2(9670), s = r2(5656), l = r2(1956);
      e2.f = n2 && !i ? Object.defineProperties : function(t3, e3) {
        a(t3);
        for (var r3, n3 = s(e3), i2 = l(e3), c2 = i2.length, u = 0; c2 > u; )
          o.f(t3, r3 = i2[u++], n3[r3]);
        return t3;
      };
    }, 3070: (t2, e2, r2) => {
      var n2 = r2(9781), i = r2(4664), o = r2(3353), a = r2(9670), s = r2(4948), l = TypeError, c2 = Object.defineProperty, u = Object.getOwnPropertyDescriptor, h2 = "enumerable", p2 = "configurable", d = "writable";
      e2.f = n2 ? o ? function(t3, e3, r3) {
        if (a(t3), e3 = s(e3), a(r3), "function" == typeof t3 && "prototype" === e3 && "value" in r3 && d in r3 && !r3[d]) {
          var n3 = u(t3, e3);
          n3 && n3[d] && (t3[e3] = r3.value, r3 = { configurable: p2 in r3 ? r3[p2] : n3[p2], enumerable: h2 in r3 ? r3[h2] : n3[h2], writable: false });
        }
        return c2(t3, e3, r3);
      } : c2 : function(t3, e3, r3) {
        if (a(t3), e3 = s(e3), a(r3), i)
          try {
            return c2(t3, e3, r3);
          } catch (t4) {
          }
        if ("get" in r3 || "set" in r3)
          throw l("Accessors not supported");
        return "value" in r3 && (t3[e3] = r3.value), t3;
      };
    }, 1236: (t2, e2, r2) => {
      var n2 = r2(9781), i = r2(6916), o = r2(5296), a = r2(9114), s = r2(5656), l = r2(4948), c2 = r2(2597), u = r2(4664), h2 = Object.getOwnPropertyDescriptor;
      e2.f = n2 ? h2 : function(t3, e3) {
        if (t3 = s(t3), e3 = l(e3), u)
          try {
            return h2(t3, e3);
          } catch (t4) {
          }
        if (c2(t3, e3))
          return a(!i(o.f, t3, e3), t3[e3]);
      };
    }, 1156: (t2, e2, r2) => {
      var n2 = r2(4326), i = r2(5656), o = r2(8006).f, a = r2(1589), s = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
      t2.exports.f = function(t3) {
        return s && "Window" == n2(t3) ? function(t4) {
          try {
            return o(t4);
          } catch (t5) {
            return a(s);
          }
        }(t3) : o(i(t3));
      };
    }, 8006: (t2, e2, r2) => {
      var n2 = r2(6324), i = r2(748).concat("length", "prototype");
      e2.f = Object.getOwnPropertyNames || function(t3) {
        return n2(t3, i);
      };
    }, 5181: (t2, e2) => {
      e2.f = Object.getOwnPropertySymbols;
    }, 9518: (t2, e2, r2) => {
      var n2 = r2(2597), i = r2(614), o = r2(7908), a = r2(6200), s = r2(8544), l = a("IE_PROTO"), c2 = Object, u = c2.prototype;
      t2.exports = s ? c2.getPrototypeOf : function(t3) {
        var e3 = o(t3);
        if (n2(e3, l))
          return e3[l];
        var r3 = e3.constructor;
        return i(r3) && e3 instanceof r3 ? r3.prototype : e3 instanceof c2 ? u : null;
      };
    }, 7976: (t2, e2, r2) => {
      var n2 = r2(1702);
      t2.exports = n2({}.isPrototypeOf);
    }, 6324: (t2, e2, r2) => {
      var n2 = r2(1702), i = r2(2597), o = r2(5656), a = r2(1318).indexOf, s = r2(3501), l = n2([].push);
      t2.exports = function(t3, e3) {
        var r3, n3 = o(t3), c2 = 0, u = [];
        for (r3 in n3)
          !i(s, r3) && i(n3, r3) && l(u, r3);
        for (; e3.length > c2; )
          i(n3, r3 = e3[c2++]) && (~a(u, r3) || l(u, r3));
        return u;
      };
    }, 1956: (t2, e2, r2) => {
      var n2 = r2(6324), i = r2(748);
      t2.exports = Object.keys || function(t3) {
        return n2(t3, i);
      };
    }, 5296: (t2, e2) => {
      var r2 = {}.propertyIsEnumerable, n2 = Object.getOwnPropertyDescriptor, i = n2 && !r2.call({ 1: 2 }, 1);
      e2.f = i ? function(t3) {
        var e3 = n2(this, t3);
        return !!e3 && e3.enumerable;
      } : r2;
    }, 7674: (t2, e2, r2) => {
      var n2 = r2(5668), i = r2(9670), o = r2(6077);
      t2.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
        var t3, e3 = false, r3 = {};
        try {
          (t3 = n2(Object.prototype, "__proto__", "set"))(r3, []), e3 = r3 instanceof Array;
        } catch (t4) {
        }
        return function(r4, n3) {
          return i(r4), o(n3), e3 ? t3(r4, n3) : r4.__proto__ = n3, r4;
        };
      }() : void 0);
    }, 4699: (t2, e2, r2) => {
      var n2 = r2(9781), i = r2(1702), o = r2(1956), a = r2(5656), s = i(r2(5296).f), l = i([].push), c2 = function(t3) {
        return function(e3) {
          for (var r3, i2 = a(e3), c3 = o(i2), u = c3.length, h2 = 0, p2 = []; u > h2; )
            r3 = c3[h2++], n2 && !s(i2, r3) || l(p2, t3 ? [r3, i2[r3]] : i2[r3]);
          return p2;
        };
      };
      t2.exports = { entries: c2(true), values: c2(false) };
    }, 288: (t2, e2, r2) => {
      var n2 = r2(1694), i = r2(648);
      t2.exports = n2 ? {}.toString : function() {
        return "[object " + i(this) + "]";
      };
    }, 2140: (t2, e2, r2) => {
      var n2 = r2(6916), i = r2(614), o = r2(111), a = TypeError;
      t2.exports = function(t3, e3) {
        var r3, s;
        if ("string" === e3 && i(r3 = t3.toString) && !o(s = n2(r3, t3)))
          return s;
        if (i(r3 = t3.valueOf) && !o(s = n2(r3, t3)))
          return s;
        if ("string" !== e3 && i(r3 = t3.toString) && !o(s = n2(r3, t3)))
          return s;
        throw a("Can't convert object to primitive value");
      };
    }, 3887: (t2, e2, r2) => {
      var n2 = r2(5005), i = r2(1702), o = r2(8006), a = r2(5181), s = r2(9670), l = i([].concat);
      t2.exports = n2("Reflect", "ownKeys") || function(t3) {
        var e3 = o.f(s(t3)), r3 = a.f;
        return r3 ? l(e3, r3(t3)) : e3;
      };
    }, 857: (t2, e2, r2) => {
      var n2 = r2(7854);
      t2.exports = n2;
    }, 2534: (t2) => {
      t2.exports = function(t3) {
        try {
          return { error: false, value: t3() };
        } catch (t4) {
          return { error: true, value: t4 };
        }
      };
    }, 3702: (t2, e2, r2) => {
      var n2 = r2(7854), i = r2(2492), o = r2(614), a = r2(4705), s = r2(2788), l = r2(5112), c2 = r2(7871), u = r2(3823), h2 = r2(1913), p2 = r2(7392), d = i && i.prototype, f2 = l("species"), y2 = false, m = o(n2.PromiseRejectionEvent), v2 = a("Promise", function() {
        var t3 = s(i), e3 = t3 !== String(i);
        if (!e3 && 66 === p2)
          return true;
        if (h2 && (!d.catch || !d.finally))
          return true;
        if (!p2 || p2 < 51 || !/native code/.test(t3)) {
          var r3 = new i(function(t4) {
            t4(1);
          }), n3 = function(t4) {
            t4(function() {
            }, function() {
            });
          };
          if ((r3.constructor = {})[f2] = n3, !(y2 = r3.then(function() {
          }) instanceof n3))
            return true;
        }
        return !e3 && (c2 || u) && !m;
      });
      t2.exports = { CONSTRUCTOR: v2, REJECTION_EVENT: m, SUBCLASSING: y2 };
    }, 2492: (t2, e2, r2) => {
      var n2 = r2(7854);
      t2.exports = n2.Promise;
    }, 9478: (t2, e2, r2) => {
      var n2 = r2(9670), i = r2(111), o = r2(8523);
      t2.exports = function(t3, e3) {
        if (n2(t3), i(e3) && e3.constructor === t3)
          return e3;
        var r3 = o.f(t3);
        return (0, r3.resolve)(e3), r3.promise;
      };
    }, 612: (t2, e2, r2) => {
      var n2 = r2(2492), i = r2(7072), o = r2(3702).CONSTRUCTOR;
      t2.exports = o || !i(function(t3) {
        n2.all(t3).then(void 0, function() {
        });
      });
    }, 2626: (t2, e2, r2) => {
      var n2 = r2(3070).f;
      t2.exports = function(t3, e3, r3) {
        r3 in t3 || n2(t3, r3, { configurable: true, get: function() {
          return e3[r3];
        }, set: function(t4) {
          e3[r3] = t4;
        } });
      };
    }, 8572: (t2) => {
      var e2 = function() {
        this.head = null, this.tail = null;
      };
      e2.prototype = { add: function(t3) {
        var e3 = { item: t3, next: null }, r2 = this.tail;
        r2 ? r2.next = e3 : this.head = e3, this.tail = e3;
      }, get: function() {
        var t3 = this.head;
        if (t3)
          return null === (this.head = t3.next) && (this.tail = null), t3.item;
      } }, t2.exports = e2;
    }, 7651: (t2, e2, r2) => {
      var n2 = r2(6916), i = r2(9670), o = r2(614), a = r2(4326), s = r2(2261), l = TypeError;
      t2.exports = function(t3, e3) {
        var r3 = t3.exec;
        if (o(r3)) {
          var c2 = n2(r3, t3, e3);
          return null !== c2 && i(c2), c2;
        }
        if ("RegExp" === a(t3))
          return n2(s, t3, e3);
        throw l("RegExp#exec called on incompatible receiver");
      };
    }, 2261: (t2, e2, r2) => {
      var n2, i, o = r2(6916), a = r2(1702), s = r2(1340), l = r2(7066), c2 = r2(2999), u = r2(2309), h2 = r2(30), p2 = r2(9909).get, d = r2(9441), f2 = r2(7168), y2 = u("native-string-replace", String.prototype.replace), m = RegExp.prototype.exec, v2 = m, b2 = a("".charAt), g2 = a("".indexOf), w2 = a("".replace), _2 = a("".slice), k2 = (i = /b*/g, o(m, n2 = /a/, "a"), o(m, i, "a"), 0 !== n2.lastIndex || 0 !== i.lastIndex), j2 = c2.BROKEN_CARET, O2 = void 0 !== /()??/.exec("")[1];
      (k2 || O2 || j2 || d || f2) && (v2 = function(t3) {
        var e3, r3, n3, i2, a2, c3, u2, d2 = this, f3 = p2(d2), x2 = s(t3), C2 = f3.raw;
        if (C2)
          return C2.lastIndex = d2.lastIndex, e3 = o(v2, C2, x2), d2.lastIndex = C2.lastIndex, e3;
        var E2 = f3.groups, S2 = j2 && d2.sticky, P2 = o(l, d2), T2 = d2.source, L2 = 0, R2 = x2;
        if (S2 && (P2 = w2(P2, "y", ""), -1 === g2(P2, "g") && (P2 += "g"), R2 = _2(x2, d2.lastIndex), d2.lastIndex > 0 && (!d2.multiline || d2.multiline && "\n" !== b2(x2, d2.lastIndex - 1)) && (T2 = "(?: " + T2 + ")", R2 = " " + R2, L2++), r3 = new RegExp("^(?:" + T2 + ")", P2)), O2 && (r3 = new RegExp("^" + T2 + "$(?!\\s)", P2)), k2 && (n3 = d2.lastIndex), i2 = o(m, S2 ? r3 : d2, R2), S2 ? i2 ? (i2.input = _2(i2.input, L2), i2[0] = _2(i2[0], L2), i2.index = d2.lastIndex, d2.lastIndex += i2[0].length) : d2.lastIndex = 0 : k2 && i2 && (d2.lastIndex = d2.global ? i2.index + i2[0].length : n3), O2 && i2 && i2.length > 1 && o(y2, i2[0], r3, function() {
          for (a2 = 1; a2 < arguments.length - 2; a2++)
            void 0 === arguments[a2] && (i2[a2] = void 0);
        }), i2 && E2)
          for (i2.groups = c3 = h2(null), a2 = 0; a2 < E2.length; a2++)
            c3[(u2 = E2[a2])[0]] = i2[u2[1]];
        return i2;
      }), t2.exports = v2;
    }, 7066: (t2, e2, r2) => {
      var n2 = r2(9670);
      t2.exports = function() {
        var t3 = n2(this), e3 = "";
        return t3.hasIndices && (e3 += "d"), t3.global && (e3 += "g"), t3.ignoreCase && (e3 += "i"), t3.multiline && (e3 += "m"), t3.dotAll && (e3 += "s"), t3.unicode && (e3 += "u"), t3.unicodeSets && (e3 += "v"), t3.sticky && (e3 += "y"), e3;
      };
    }, 4706: (t2, e2, r2) => {
      var n2 = r2(6916), i = r2(2597), o = r2(7976), a = r2(7066), s = RegExp.prototype;
      t2.exports = function(t3) {
        var e3 = t3.flags;
        return void 0 !== e3 || "flags" in s || i(t3, "flags") || !o(s, t3) ? e3 : n2(a, t3);
      };
    }, 2999: (t2, e2, r2) => {
      var n2 = r2(7293), i = r2(7854).RegExp, o = n2(function() {
        var t3 = i("a", "y");
        return t3.lastIndex = 2, null != t3.exec("abcd");
      }), a = o || n2(function() {
        return !i("a", "y").sticky;
      }), s = o || n2(function() {
        var t3 = i("^r", "gy");
        return t3.lastIndex = 2, null != t3.exec("str");
      });
      t2.exports = { BROKEN_CARET: s, MISSED_STICKY: a, UNSUPPORTED_Y: o };
    }, 9441: (t2, e2, r2) => {
      var n2 = r2(7293), i = r2(7854).RegExp;
      t2.exports = n2(function() {
        var t3 = i(".", "s");
        return !(t3.dotAll && t3.exec("\n") && "s" === t3.flags);
      });
    }, 7168: (t2, e2, r2) => {
      var n2 = r2(7293), i = r2(7854).RegExp;
      t2.exports = n2(function() {
        var t3 = i("(?<a>b)", "g");
        return "b" !== t3.exec("b").groups.a || "bc" !== "b".replace(t3, "$<a>c");
      });
    }, 4488: (t2, e2, r2) => {
      var n2 = r2(8554), i = TypeError;
      t2.exports = function(t3) {
        if (n2(t3))
          throw i("Can't call method on " + t3);
        return t3;
      };
    }, 7152: (t2, e2, r2) => {
      var n2, i = r2(7854), o = r2(2104), a = r2(614), s = r2(9363), l = r2(8113), c2 = r2(206), u = r2(8053), h2 = i.Function, p2 = /MSIE .\./.test(l) || s && ((n2 = i.Bun.version.split(".")).length < 3 || 0 == n2[0] && (n2[1] < 3 || 3 == n2[1] && 0 == n2[2]));
      t2.exports = function(t3, e3) {
        var r3 = e3 ? 2 : 1;
        return p2 ? function(n3, i2) {
          var s2 = u(arguments.length, 1) > r3, l2 = a(n3) ? n3 : h2(n3), p3 = s2 ? c2(arguments, r3) : [], d = s2 ? function() {
            o(l2, this, p3);
          } : l2;
          return e3 ? t3(d, i2) : t3(d);
        } : t3;
      };
    }, 6340: (t2, e2, r2) => {
      var n2 = r2(5005), i = r2(7045), o = r2(5112), a = r2(9781), s = o("species");
      t2.exports = function(t3) {
        var e3 = n2(t3);
        a && e3 && !e3[s] && i(e3, s, { configurable: true, get: function() {
          return this;
        } });
      };
    }, 8003: (t2, e2, r2) => {
      var n2 = r2(3070).f, i = r2(2597), o = r2(5112)("toStringTag");
      t2.exports = function(t3, e3, r3) {
        t3 && !r3 && (t3 = t3.prototype), t3 && !i(t3, o) && n2(t3, o, { configurable: true, value: e3 });
      };
    }, 6200: (t2, e2, r2) => {
      var n2 = r2(2309), i = r2(9711), o = n2("keys");
      t2.exports = function(t3) {
        return o[t3] || (o[t3] = i(t3));
      };
    }, 5465: (t2, e2, r2) => {
      var n2 = r2(7854), i = r2(3072), o = "__core-js_shared__", a = n2[o] || i(o, {});
      t2.exports = a;
    }, 2309: (t2, e2, r2) => {
      var n2 = r2(1913), i = r2(5465);
      (t2.exports = function(t3, e3) {
        return i[t3] || (i[t3] = void 0 !== e3 ? e3 : {});
      })("versions", []).push({ version: "3.29.0", mode: n2 ? "pure" : "global", copyright: "© 2014-2023 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.29.0/LICENSE", source: "https://github.com/zloirock/core-js" });
    }, 6707: (t2, e2, r2) => {
      var n2 = r2(9670), i = r2(9483), o = r2(8554), a = r2(5112)("species");
      t2.exports = function(t3, e3) {
        var r3, s = n2(t3).constructor;
        return void 0 === s || o(r3 = n2(s)[a]) ? e3 : i(r3);
      };
    }, 8710: (t2, e2, r2) => {
      var n2 = r2(1702), i = r2(9303), o = r2(1340), a = r2(4488), s = n2("".charAt), l = n2("".charCodeAt), c2 = n2("".slice), u = function(t3) {
        return function(e3, r3) {
          var n3, u2, h2 = o(a(e3)), p2 = i(r3), d = h2.length;
          return p2 < 0 || p2 >= d ? t3 ? "" : void 0 : (n3 = l(h2, p2)) < 55296 || n3 > 56319 || p2 + 1 === d || (u2 = l(h2, p2 + 1)) < 56320 || u2 > 57343 ? t3 ? s(h2, p2) : n3 : t3 ? c2(h2, p2, p2 + 2) : u2 - 56320 + (n3 - 55296 << 10) + 65536;
        };
      };
      t2.exports = { codeAt: u(false), charAt: u(true) };
    }, 6650: (t2, e2, r2) => {
      var n2 = r2(1702), i = r2(7466), o = r2(1340), a = r2(8415), s = r2(4488), l = n2(a), c2 = n2("".slice), u = Math.ceil, h2 = function(t3) {
        return function(e3, r3, n3) {
          var a2, h3, p2 = o(s(e3)), d = i(r3), f2 = p2.length, y2 = void 0 === n3 ? " " : o(n3);
          return d <= f2 || "" == y2 ? p2 : ((h3 = l(y2, u((a2 = d - f2) / y2.length))).length > a2 && (h3 = c2(h3, 0, a2)), t3 ? p2 + h3 : h3 + p2);
        };
      };
      t2.exports = { start: h2(false), end: h2(true) };
    }, 8415: (t2, e2, r2) => {
      var n2 = r2(9303), i = r2(1340), o = r2(4488), a = RangeError;
      t2.exports = function(t3) {
        var e3 = i(o(this)), r3 = "", s = n2(t3);
        if (s < 0 || s == 1 / 0)
          throw a("Wrong number of repetitions");
        for (; s > 0; (s >>>= 1) && (e3 += e3))
          1 & s && (r3 += e3);
        return r3;
      };
    }, 6091: (t2, e2, r2) => {
      var n2 = r2(6530).PROPER, i = r2(7293), o = r2(1361);
      t2.exports = function(t3) {
        return i(function() {
          return !!o[t3]() || "​᠎" !== "​᠎"[t3]() || n2 && o[t3].name !== t3;
        });
      };
    }, 3111: (t2, e2, r2) => {
      var n2 = r2(1702), i = r2(4488), o = r2(1340), a = r2(1361), s = n2("".replace), l = RegExp("^[" + a + "]+"), c2 = RegExp("(^|[^" + a + "])[" + a + "]+$"), u = function(t3) {
        return function(e3) {
          var r3 = o(i(e3));
          return 1 & t3 && (r3 = s(r3, l, "")), 2 & t3 && (r3 = s(r3, c2, "$1")), r3;
        };
      };
      t2.exports = { start: u(1), end: u(2), trim: u(3) };
    }, 6293: (t2, e2, r2) => {
      var n2 = r2(7392), i = r2(7293);
      t2.exports = !!Object.getOwnPropertySymbols && !i(function() {
        var t3 = Symbol();
        return !String(t3) || !(Object(t3) instanceof Symbol) || !Symbol.sham && n2 && n2 < 41;
      });
    }, 6532: (t2, e2, r2) => {
      var n2 = r2(6916), i = r2(5005), o = r2(5112), a = r2(8052);
      t2.exports = function() {
        var t3 = i("Symbol"), e3 = t3 && t3.prototype, r3 = e3 && e3.valueOf, s = o("toPrimitive");
        e3 && !e3[s] && a(e3, s, function(t4) {
          return n2(r3, this);
        }, { arity: 1 });
      };
    }, 2015: (t2, e2, r2) => {
      var n2 = r2(6293);
      t2.exports = n2 && !!Symbol.for && !!Symbol.keyFor;
    }, 261: (t2, e2, r2) => {
      var n2, i, o, a, s = r2(7854), l = r2(2104), c2 = r2(9974), u = r2(614), h2 = r2(2597), p2 = r2(7293), d = r2(490), f2 = r2(206), y2 = r2(317), m = r2(8053), v2 = r2(8334), b2 = r2(5268), g2 = s.setImmediate, w2 = s.clearImmediate, _2 = s.process, k2 = s.Dispatch, j2 = s.Function, O2 = s.MessageChannel, x2 = s.String, C2 = 0, E2 = {}, S2 = "onreadystatechange";
      p2(function() {
        n2 = s.location;
      });
      var P2 = function(t3) {
        if (h2(E2, t3)) {
          var e3 = E2[t3];
          delete E2[t3], e3();
        }
      }, T2 = function(t3) {
        return function() {
          P2(t3);
        };
      }, L2 = function(t3) {
        P2(t3.data);
      }, R2 = function(t3) {
        s.postMessage(x2(t3), n2.protocol + "//" + n2.host);
      };
      g2 && w2 || (g2 = function(t3) {
        m(arguments.length, 1);
        var e3 = u(t3) ? t3 : j2(t3), r3 = f2(arguments, 1);
        return E2[++C2] = function() {
          l(e3, void 0, r3);
        }, i(C2), C2;
      }, w2 = function(t3) {
        delete E2[t3];
      }, b2 ? i = function(t3) {
        _2.nextTick(T2(t3));
      } : k2 && k2.now ? i = function(t3) {
        k2.now(T2(t3));
      } : O2 && !v2 ? (a = (o = new O2()).port2, o.port1.onmessage = L2, i = c2(a.postMessage, a)) : s.addEventListener && u(s.postMessage) && !s.importScripts && n2 && "file:" !== n2.protocol && !p2(R2) ? (i = R2, s.addEventListener("message", L2, false)) : i = S2 in y2("script") ? function(t3) {
        d.appendChild(y2("script"))[S2] = function() {
          d.removeChild(this), P2(t3);
        };
      } : function(t3) {
        setTimeout(T2(t3), 0);
      }), t2.exports = { set: g2, clear: w2 };
    }, 863: (t2, e2, r2) => {
      var n2 = r2(1702);
      t2.exports = n2(1 .valueOf);
    }, 1400: (t2, e2, r2) => {
      var n2 = r2(9303), i = Math.max, o = Math.min;
      t2.exports = function(t3, e3) {
        var r3 = n2(t3);
        return r3 < 0 ? i(r3 + e3, 0) : o(r3, e3);
      };
    }, 5656: (t2, e2, r2) => {
      var n2 = r2(8361), i = r2(4488);
      t2.exports = function(t3) {
        return n2(i(t3));
      };
    }, 9303: (t2, e2, r2) => {
      var n2 = r2(4758);
      t2.exports = function(t3) {
        var e3 = +t3;
        return e3 != e3 || 0 === e3 ? 0 : n2(e3);
      };
    }, 7466: (t2, e2, r2) => {
      var n2 = r2(9303), i = Math.min;
      t2.exports = function(t3) {
        return t3 > 0 ? i(n2(t3), 9007199254740991) : 0;
      };
    }, 7908: (t2, e2, r2) => {
      var n2 = r2(4488), i = Object;
      t2.exports = function(t3) {
        return i(n2(t3));
      };
    }, 7593: (t2, e2, r2) => {
      var n2 = r2(6916), i = r2(111), o = r2(2190), a = r2(8173), s = r2(2140), l = r2(5112), c2 = TypeError, u = l("toPrimitive");
      t2.exports = function(t3, e3) {
        if (!i(t3) || o(t3))
          return t3;
        var r3, l2 = a(t3, u);
        if (l2) {
          if (void 0 === e3 && (e3 = "default"), r3 = n2(l2, t3, e3), !i(r3) || o(r3))
            return r3;
          throw c2("Can't convert object to primitive value");
        }
        return void 0 === e3 && (e3 = "number"), s(t3, e3);
      };
    }, 4948: (t2, e2, r2) => {
      var n2 = r2(7593), i = r2(2190);
      t2.exports = function(t3) {
        var e3 = n2(t3, "string");
        return i(e3) ? e3 : e3 + "";
      };
    }, 1694: (t2, e2, r2) => {
      var n2 = {};
      n2[r2(5112)("toStringTag")] = "z", t2.exports = "[object z]" === String(n2);
    }, 1340: (t2, e2, r2) => {
      var n2 = r2(648), i = String;
      t2.exports = function(t3) {
        if ("Symbol" === n2(t3))
          throw TypeError("Cannot convert a Symbol value to a string");
        return i(t3);
      };
    }, 6330: (t2) => {
      var e2 = String;
      t2.exports = function(t3) {
        try {
          return e2(t3);
        } catch (t4) {
          return "Object";
        }
      };
    }, 9711: (t2, e2, r2) => {
      var n2 = r2(1702), i = 0, o = Math.random(), a = n2(1 .toString);
      t2.exports = function(t3) {
        return "Symbol(" + (void 0 === t3 ? "" : t3) + ")_" + a(++i + o, 36);
      };
    }, 3307: (t2, e2, r2) => {
      var n2 = r2(6293);
      t2.exports = n2 && !Symbol.sham && "symbol" == typeof Symbol.iterator;
    }, 3353: (t2, e2, r2) => {
      var n2 = r2(9781), i = r2(7293);
      t2.exports = n2 && i(function() {
        return 42 != Object.defineProperty(function() {
        }, "prototype", { value: 42, writable: false }).prototype;
      });
    }, 8053: (t2) => {
      var e2 = TypeError;
      t2.exports = function(t3, r2) {
        if (t3 < r2)
          throw e2("Not enough arguments");
        return t3;
      };
    }, 4811: (t2, e2, r2) => {
      var n2 = r2(7854), i = r2(614), o = n2.WeakMap;
      t2.exports = i(o) && /native code/.test(String(o));
    }, 6800: (t2, e2, r2) => {
      var n2 = r2(857), i = r2(2597), o = r2(6061), a = r2(3070).f;
      t2.exports = function(t3) {
        var e3 = n2.Symbol || (n2.Symbol = {});
        i(e3, t3) || a(e3, t3, { value: o.f(t3) });
      };
    }, 6061: (t2, e2, r2) => {
      var n2 = r2(5112);
      e2.f = n2;
    }, 5112: (t2, e2, r2) => {
      var n2 = r2(7854), i = r2(2309), o = r2(2597), a = r2(9711), s = r2(6293), l = r2(3307), c2 = n2.Symbol, u = i("wks"), h2 = l ? c2.for || c2 : c2 && c2.withoutSetter || a;
      t2.exports = function(t3) {
        return o(u, t3) || (u[t3] = s && o(c2, t3) ? c2[t3] : h2("Symbol." + t3)), u[t3];
      };
    }, 1361: (t2) => {
      t2.exports = "	\n\v\f\r                　\u2028\u2029\uFEFF";
    }, 2222: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(7293), o = r2(3157), a = r2(111), s = r2(7908), l = r2(6244), c2 = r2(7207), u = r2(6135), h2 = r2(5417), p2 = r2(1194), d = r2(5112), f2 = r2(7392), y2 = d("isConcatSpreadable"), m = f2 >= 51 || !i(function() {
        var t3 = [];
        return t3[y2] = false, t3.concat()[0] !== t3;
      }), v2 = function(t3) {
        if (!a(t3))
          return false;
        var e3 = t3[y2];
        return void 0 !== e3 ? !!e3 : o(t3);
      };
      n2({ target: "Array", proto: true, arity: 1, forced: !m || !p2("concat") }, { concat: function(t3) {
        var e3, r3, n3, i2, o2, a2 = s(this), p3 = h2(a2, 0), d2 = 0;
        for (e3 = -1, n3 = arguments.length; e3 < n3; e3++)
          if (v2(o2 = -1 === e3 ? a2 : arguments[e3]))
            for (i2 = l(o2), c2(d2 + i2), r3 = 0; r3 < i2; r3++, d2++)
              r3 in o2 && u(p3, d2, o2[r3]);
          else
            c2(d2 + 1), u(p3, d2++, o2);
        return p3.length = d2, p3;
      } });
    }, 6541: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(2092).every;
      n2({ target: "Array", proto: true, forced: !r2(9341)("every") }, { every: function(t3) {
        return i(this, t3, arguments.length > 1 ? arguments[1] : void 0);
      } });
    }, 7327: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(2092).filter;
      n2({ target: "Array", proto: true, forced: !r2(1194)("filter") }, { filter: function(t3) {
        return i(this, t3, arguments.length > 1 ? arguments[1] : void 0);
      } });
    }, 9826: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(2092).find, o = r2(1223), a = "find", s = true;
      a in [] && Array(1)[a](function() {
        s = false;
      }), n2({ target: "Array", proto: true, forced: s }, { find: function(t3) {
        return i(this, t3, arguments.length > 1 ? arguments[1] : void 0);
      } }), o(a);
    }, 9554: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(8533);
      n2({ target: "Array", proto: true, forced: [].forEach != i }, { forEach: i });
    }, 1038: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(8457);
      n2({ target: "Array", stat: true, forced: !r2(7072)(function(t3) {
        Array.from(t3);
      }) }, { from: i });
    }, 6699: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(1318).includes, o = r2(7293), a = r2(1223);
      n2({ target: "Array", proto: true, forced: o(function() {
        return !Array(1).includes();
      }) }, { includes: function(t3) {
        return i(this, t3, arguments.length > 1 ? arguments[1] : void 0);
      } }), a("includes");
    }, 2772: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(1470), o = r2(1318).indexOf, a = r2(9341), s = i([].indexOf), l = !!s && 1 / s([1], 1, -0) < 0;
      n2({ target: "Array", proto: true, forced: l || !a("indexOf") }, { indexOf: function(t3) {
        var e3 = arguments.length > 1 ? arguments[1] : void 0;
        return l ? s(this, t3, e3) || 0 : o(this, t3, e3);
      } });
    }, 9753: (t2, e2, r2) => {
      r2(2109)({ target: "Array", stat: true }, { isArray: r2(3157) });
    }, 6992: (t2, e2, r2) => {
      var n2 = r2(5656), i = r2(1223), o = r2(7497), a = r2(9909), s = r2(3070).f, l = r2(1656), c2 = r2(6178), u = r2(1913), h2 = r2(9781), p2 = "Array Iterator", d = a.set, f2 = a.getterFor(p2);
      t2.exports = l(Array, "Array", function(t3, e3) {
        d(this, { type: p2, target: n2(t3), index: 0, kind: e3 });
      }, function() {
        var t3 = f2(this), e3 = t3.target, r3 = t3.kind, n3 = t3.index++;
        return !e3 || n3 >= e3.length ? (t3.target = void 0, c2(void 0, true)) : c2("keys" == r3 ? n3 : "values" == r3 ? e3[n3] : [n3, e3[n3]], false);
      }, "values");
      var y2 = o.Arguments = o.Array;
      if (i("keys"), i("values"), i("entries"), !u && h2 && "values" !== y2.name)
        try {
          s(y2, "name", { value: "values" });
        } catch (t3) {
        }
    }, 9600: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(1702), o = r2(8361), a = r2(5656), s = r2(9341), l = i([].join);
      n2({ target: "Array", proto: true, forced: o != Object || !s("join", ",") }, { join: function(t3) {
        return l(a(this), void 0 === t3 ? "," : t3);
      } });
    }, 1249: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(2092).map;
      n2({ target: "Array", proto: true, forced: !r2(1194)("map") }, { map: function(t3) {
        return i(this, t3, arguments.length > 1 ? arguments[1] : void 0);
      } });
    }, 5827: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(3671).left, o = r2(9341), a = r2(7392);
      n2({ target: "Array", proto: true, forced: !r2(5268) && a > 79 && a < 83 || !o("reduce") }, { reduce: function(t3) {
        var e3 = arguments.length;
        return i(this, t3, e3, e3 > 1 ? arguments[1] : void 0);
      } });
    }, 5069: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(1702), o = r2(3157), a = i([].reverse), s = [1, 2];
      n2({ target: "Array", proto: true, forced: String(s) === String(s.reverse()) }, { reverse: function() {
        return o(this) && (this.length = this.length), a(this);
      } });
    }, 7042: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(3157), o = r2(4411), a = r2(111), s = r2(1400), l = r2(6244), c2 = r2(5656), u = r2(6135), h2 = r2(5112), p2 = r2(1194), d = r2(206), f2 = p2("slice"), y2 = h2("species"), m = Array, v2 = Math.max;
      n2({ target: "Array", proto: true, forced: !f2 }, { slice: function(t3, e3) {
        var r3, n3, h3, p3 = c2(this), f3 = l(p3), b2 = s(t3, f3), g2 = s(void 0 === e3 ? f3 : e3, f3);
        if (i(p3) && (r3 = p3.constructor, (o(r3) && (r3 === m || i(r3.prototype)) || a(r3) && null === (r3 = r3[y2])) && (r3 = void 0), r3 === m || void 0 === r3))
          return d(p3, b2, g2);
        for (n3 = new (void 0 === r3 ? m : r3)(v2(g2 - b2, 0)), h3 = 0; b2 < g2; b2++, h3++)
          b2 in p3 && u(n3, h3, p3[b2]);
        return n3.length = h3, n3;
      } });
    }, 5212: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(2092).some;
      n2({ target: "Array", proto: true, forced: !r2(9341)("some") }, { some: function(t3) {
        return i(this, t3, arguments.length > 1 ? arguments[1] : void 0);
      } });
    }, 2707: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(1702), o = r2(9662), a = r2(7908), s = r2(6244), l = r2(5117), c2 = r2(1340), u = r2(7293), h2 = r2(4362), p2 = r2(9341), d = r2(8886), f2 = r2(256), y2 = r2(7392), m = r2(8008), v2 = [], b2 = i(v2.sort), g2 = i(v2.push), w2 = u(function() {
        v2.sort(void 0);
      }), _2 = u(function() {
        v2.sort(null);
      }), k2 = p2("sort"), j2 = !u(function() {
        if (y2)
          return y2 < 70;
        if (!(d && d > 3)) {
          if (f2)
            return true;
          if (m)
            return m < 603;
          var t3, e3, r3, n3, i2 = "";
          for (t3 = 65; t3 < 76; t3++) {
            switch (e3 = String.fromCharCode(t3), t3) {
              case 66:
              case 69:
              case 70:
              case 72:
                r3 = 3;
                break;
              case 68:
              case 71:
                r3 = 4;
                break;
              default:
                r3 = 2;
            }
            for (n3 = 0; n3 < 47; n3++)
              v2.push({ k: e3 + n3, v: r3 });
          }
          for (v2.sort(function(t4, e4) {
            return e4.v - t4.v;
          }), n3 = 0; n3 < v2.length; n3++)
            e3 = v2[n3].k.charAt(0), i2.charAt(i2.length - 1) !== e3 && (i2 += e3);
          return "DGBEFHACIJK" !== i2;
        }
      });
      n2({ target: "Array", proto: true, forced: w2 || !_2 || !k2 || !j2 }, { sort: function(t3) {
        void 0 !== t3 && o(t3);
        var e3 = a(this);
        if (j2)
          return void 0 === t3 ? b2(e3) : b2(e3, t3);
        var r3, n3, i2 = [], u2 = s(e3);
        for (n3 = 0; n3 < u2; n3++)
          n3 in e3 && g2(i2, e3[n3]);
        for (h2(i2, function(t4) {
          return function(e4, r4) {
            return void 0 === r4 ? -1 : void 0 === e4 ? 1 : void 0 !== t4 ? +t4(e4, r4) || 0 : c2(e4) > c2(r4) ? 1 : -1;
          };
        }(t3)), r3 = s(i2), n3 = 0; n3 < r3; )
          e3[n3] = i2[n3++];
        for (; n3 < u2; )
          l(e3, n3++);
        return e3;
      } });
    }, 561: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(7908), o = r2(1400), a = r2(9303), s = r2(6244), l = r2(3658), c2 = r2(7207), u = r2(5417), h2 = r2(6135), p2 = r2(5117), d = r2(1194)("splice"), f2 = Math.max, y2 = Math.min;
      n2({ target: "Array", proto: true, forced: !d }, { splice: function(t3, e3) {
        var r3, n3, d2, m, v2, b2, g2 = i(this), w2 = s(g2), _2 = o(t3, w2), k2 = arguments.length;
        for (0 === k2 ? r3 = n3 = 0 : 1 === k2 ? (r3 = 0, n3 = w2 - _2) : (r3 = k2 - 2, n3 = y2(f2(a(e3), 0), w2 - _2)), c2(w2 + r3 - n3), d2 = u(g2, n3), m = 0; m < n3; m++)
          (v2 = _2 + m) in g2 && h2(d2, m, g2[v2]);
        if (d2.length = n3, r3 < n3) {
          for (m = _2; m < w2 - n3; m++)
            b2 = m + r3, (v2 = m + n3) in g2 ? g2[b2] = g2[v2] : p2(g2, b2);
          for (m = w2; m > w2 - n3 + r3; m--)
            p2(g2, m - 1);
        } else if (r3 > n3)
          for (m = w2 - n3; m > _2; m--)
            b2 = m + r3 - 1, (v2 = m + n3 - 1) in g2 ? g2[b2] = g2[v2] : p2(g2, b2);
        for (m = 0; m < r3; m++)
          g2[m + _2] = arguments[m + 2];
        return l(g2, w2 - n3 + r3), d2;
      } });
    }, 3843: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(1702), o = Date, a = i(o.prototype.getTime);
      n2({ target: "Date", stat: true }, { now: function() {
        return a(new o());
      } });
    }, 8733: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(5573);
      n2({ target: "Date", proto: true, forced: Date.prototype.toISOString !== i }, { toISOString: i });
    }, 6078: (t2, e2, r2) => {
      var n2 = r2(2597), i = r2(8052), o = r2(8709), a = r2(5112)("toPrimitive"), s = Date.prototype;
      n2(s, a) || i(s, a, o);
    }, 3710: (t2, e2, r2) => {
      var n2 = r2(1702), i = r2(8052), o = Date.prototype, a = "Invalid Date", s = "toString", l = n2(o[s]), c2 = n2(o.getTime);
      String(/* @__PURE__ */ new Date(NaN)) != a && i(o, s, function() {
        var t3 = c2(this);
        return t3 == t3 ? l(this) : a;
      });
    }, 4812: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(7065);
      n2({ target: "Function", proto: true, forced: Function.bind !== i }, { bind: i });
    }, 8309: (t2, e2, r2) => {
      var n2 = r2(9781), i = r2(6530).EXISTS, o = r2(1702), a = r2(7045), s = Function.prototype, l = o(s.toString), c2 = /function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/, u = o(c2.exec);
      n2 && !i && a(s, "name", { configurable: true, get: function() {
        try {
          return u(c2, l(this))[1];
        } catch (t3) {
          return "";
        }
      } });
    }, 8862: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(5005), o = r2(2104), a = r2(6916), s = r2(1702), l = r2(7293), c2 = r2(614), u = r2(2190), h2 = r2(206), p2 = r2(8044), d = r2(6293), f2 = String, y2 = i("JSON", "stringify"), m = s(/./.exec), v2 = s("".charAt), b2 = s("".charCodeAt), g2 = s("".replace), w2 = s(1 .toString), _2 = /[\uD800-\uDFFF]/g, k2 = /^[\uD800-\uDBFF]$/, j2 = /^[\uDC00-\uDFFF]$/, O2 = !d || l(function() {
        var t3 = i("Symbol")();
        return "[null]" != y2([t3]) || "{}" != y2({ a: t3 }) || "{}" != y2(Object(t3));
      }), x2 = l(function() {
        return '"\\udf06\\ud834"' !== y2("\uDF06\uD834") || '"\\udead"' !== y2("\uDEAD");
      }), C2 = function(t3, e3) {
        var r3 = h2(arguments), n3 = p2(e3);
        if (c2(n3) || void 0 !== t3 && !u(t3))
          return r3[1] = function(t4, e4) {
            if (c2(n3) && (e4 = a(n3, this, f2(t4), e4)), !u(e4))
              return e4;
          }, o(y2, null, r3);
      }, E2 = function(t3, e3, r3) {
        var n3 = v2(r3, e3 - 1), i2 = v2(r3, e3 + 1);
        return m(k2, t3) && !m(j2, i2) || m(j2, t3) && !m(k2, n3) ? "\\u" + w2(b2(t3, 0), 16) : t3;
      };
      y2 && n2({ target: "JSON", stat: true, arity: 3, forced: O2 || x2 }, { stringify: function(t3, e3, r3) {
        var n3 = h2(arguments), i2 = o(O2 ? C2 : y2, null, n3);
        return x2 && "string" == typeof i2 ? g2(i2, _2, E2) : i2;
      } });
    }, 3706: (t2, e2, r2) => {
      var n2 = r2(7854);
      r2(8003)(n2.JSON, "JSON", true);
    }, 2703: (t2, e2, r2) => {
      r2(8003)(Math, "Math", true);
    }, 9653: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(1913), o = r2(9781), a = r2(7854), s = r2(857), l = r2(1702), c2 = r2(4705), u = r2(2597), h2 = r2(9587), p2 = r2(7976), d = r2(2190), f2 = r2(7593), y2 = r2(7293), m = r2(8006).f, v2 = r2(1236).f, b2 = r2(3070).f, g2 = r2(863), w2 = r2(3111).trim, _2 = "Number", k2 = a[_2], j2 = s[_2], O2 = k2.prototype, x2 = a.TypeError, C2 = l("".slice), E2 = l("".charCodeAt), S2 = function(t3) {
        var e3 = f2(t3, "number");
        return "bigint" == typeof e3 ? e3 : P2(e3);
      }, P2 = function(t3) {
        var e3, r3, n3, i2, o2, a2, s2, l2, c3 = f2(t3, "number");
        if (d(c3))
          throw x2("Cannot convert a Symbol value to a number");
        if ("string" == typeof c3 && c3.length > 2) {
          if (c3 = w2(c3), 43 === (e3 = E2(c3, 0)) || 45 === e3) {
            if (88 === (r3 = E2(c3, 2)) || 120 === r3)
              return NaN;
          } else if (48 === e3) {
            switch (E2(c3, 1)) {
              case 66:
              case 98:
                n3 = 2, i2 = 49;
                break;
              case 79:
              case 111:
                n3 = 8, i2 = 55;
                break;
              default:
                return +c3;
            }
            for (a2 = (o2 = C2(c3, 2)).length, s2 = 0; s2 < a2; s2++)
              if ((l2 = E2(o2, s2)) < 48 || l2 > i2)
                return NaN;
            return parseInt(o2, n3);
          }
        }
        return +c3;
      }, T2 = c2(_2, !k2(" 0o1") || !k2("0b1") || k2("+0x1")), L2 = function(t3) {
        return p2(O2, t3) && y2(function() {
          g2(t3);
        });
      }, R2 = function(t3) {
        var e3 = arguments.length < 1 ? 0 : k2(S2(t3));
        return L2(this) ? h2(Object(e3), this, R2) : e3;
      };
      R2.prototype = O2, T2 && !i && (O2.constructor = R2), n2({ global: true, constructor: true, wrap: true, forced: T2 }, { Number: R2 });
      var A2 = function(t3, e3) {
        for (var r3, n3 = o ? m(e3) : "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,fromString,range".split(","), i2 = 0; n3.length > i2; i2++)
          u(e3, r3 = n3[i2]) && !u(t3, r3) && b2(t3, r3, v2(e3, r3));
      };
      i && j2 && A2(s[_2], j2), (T2 || i) && A2(s[_2], k2);
    }, 6977: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(1702), o = r2(9303), a = r2(863), s = r2(8415), l = r2(7293), c2 = RangeError, u = String, h2 = Math.floor, p2 = i(s), d = i("".slice), f2 = i(1 .toFixed), y2 = function(t3, e3, r3) {
        return 0 === e3 ? r3 : e3 % 2 == 1 ? y2(t3, e3 - 1, r3 * t3) : y2(t3 * t3, e3 / 2, r3);
      }, m = function(t3, e3, r3) {
        for (var n3 = -1, i2 = r3; ++n3 < 6; )
          i2 += e3 * t3[n3], t3[n3] = i2 % 1e7, i2 = h2(i2 / 1e7);
      }, v2 = function(t3, e3) {
        for (var r3 = 6, n3 = 0; --r3 >= 0; )
          n3 += t3[r3], t3[r3] = h2(n3 / e3), n3 = n3 % e3 * 1e7;
      }, b2 = function(t3) {
        for (var e3 = 6, r3 = ""; --e3 >= 0; )
          if ("" !== r3 || 0 === e3 || 0 !== t3[e3]) {
            var n3 = u(t3[e3]);
            r3 = "" === r3 ? n3 : r3 + p2("0", 7 - n3.length) + n3;
          }
        return r3;
      };
      n2({ target: "Number", proto: true, forced: l(function() {
        return "0.000" !== f2(8e-5, 3) || "1" !== f2(0.9, 0) || "1.25" !== f2(1.255, 2) || "1000000000000000128" !== f2(1000000000000000100, 0);
      }) || !l(function() {
        f2({});
      }) }, { toFixed: function(t3) {
        var e3, r3, n3, i2, s2 = a(this), l2 = o(t3), h3 = [0, 0, 0, 0, 0, 0], f3 = "", g2 = "0";
        if (l2 < 0 || l2 > 20)
          throw c2("Incorrect fraction digits");
        if (s2 != s2)
          return "NaN";
        if (s2 <= -1e21 || s2 >= 1e21)
          return u(s2);
        if (s2 < 0 && (f3 = "-", s2 = -s2), s2 > 1e-21)
          if (r3 = (e3 = function(t4) {
            for (var e4 = 0, r4 = t4; r4 >= 4096; )
              e4 += 12, r4 /= 4096;
            for (; r4 >= 2; )
              e4 += 1, r4 /= 2;
            return e4;
          }(s2 * y2(2, 69, 1)) - 69) < 0 ? s2 * y2(2, -e3, 1) : s2 / y2(2, e3, 1), r3 *= 4503599627370496, (e3 = 52 - e3) > 0) {
            for (m(h3, 0, r3), n3 = l2; n3 >= 7; )
              m(h3, 1e7, 0), n3 -= 7;
            for (m(h3, y2(10, n3, 1), 0), n3 = e3 - 1; n3 >= 23; )
              v2(h3, 1 << 23), n3 -= 23;
            v2(h3, 1 << n3), m(h3, 1, 1), v2(h3, 2), g2 = b2(h3);
          } else
            m(h3, 0, r3), m(h3, 1 << -e3, 0), g2 = b2(h3) + p2("0", l2);
        return l2 > 0 ? f3 + ((i2 = g2.length) <= l2 ? "0." + p2("0", l2 - i2) + g2 : d(g2, 0, i2 - l2) + "." + d(g2, i2 - l2)) : f3 + g2;
      } });
    }, 9601: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(1574);
      n2({ target: "Object", stat: true, arity: 2, forced: Object.assign !== i }, { assign: i });
    }, 8011: (t2, e2, r2) => {
      r2(2109)({ target: "Object", stat: true, sham: !r2(9781) }, { create: r2(30) });
    }, 3321: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(9781), o = r2(6048).f;
      n2({ target: "Object", stat: true, forced: Object.defineProperties !== o, sham: !i }, { defineProperties: o });
    }, 9070: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(9781), o = r2(3070).f;
      n2({ target: "Object", stat: true, forced: Object.defineProperty !== o, sham: !i }, { defineProperty: o });
    }, 9720: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(4699).entries;
      n2({ target: "Object", stat: true }, { entries: function(t3) {
        return i(t3);
      } });
    }, 5003: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(7293), o = r2(5656), a = r2(1236).f, s = r2(9781);
      n2({ target: "Object", stat: true, forced: !s || i(function() {
        a(1);
      }), sham: !s }, { getOwnPropertyDescriptor: function(t3, e3) {
        return a(o(t3), e3);
      } });
    }, 9337: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(9781), o = r2(3887), a = r2(5656), s = r2(1236), l = r2(6135);
      n2({ target: "Object", stat: true, sham: !i }, { getOwnPropertyDescriptors: function(t3) {
        for (var e3, r3, n3 = a(t3), i2 = s.f, c2 = o(n3), u = {}, h2 = 0; c2.length > h2; )
          void 0 !== (r3 = i2(n3, e3 = c2[h2++])) && l(u, e3, r3);
        return u;
      } });
    }, 9660: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(6293), o = r2(7293), a = r2(5181), s = r2(7908);
      n2({ target: "Object", stat: true, forced: !i || o(function() {
        a.f(1);
      }) }, { getOwnPropertySymbols: function(t3) {
        var e3 = a.f;
        return e3 ? e3(s(t3)) : [];
      } });
    }, 489: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(7293), o = r2(7908), a = r2(9518), s = r2(8544);
      n2({ target: "Object", stat: true, forced: i(function() {
        a(1);
      }), sham: !s }, { getPrototypeOf: function(t3) {
        return a(o(t3));
      } });
    }, 7941: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(7908), o = r2(1956);
      n2({ target: "Object", stat: true, forced: r2(7293)(function() {
        o(1);
      }) }, { keys: function(t3) {
        return o(i(t3));
      } });
    }, 8304: (t2, e2, r2) => {
      r2(2109)({ target: "Object", stat: true }, { setPrototypeOf: r2(7674) });
    }, 1539: (t2, e2, r2) => {
      var n2 = r2(1694), i = r2(8052), o = r2(288);
      n2 || i(Object.prototype, "toString", o, { unsafe: true });
    }, 6833: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(4699).values;
      n2({ target: "Object", stat: true }, { values: function(t3) {
        return i(t3);
      } });
    }, 4678: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(2814);
      n2({ global: true, forced: parseFloat != i }, { parseFloat: i });
    }, 1058: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(3009);
      n2({ global: true, forced: parseInt != i }, { parseInt: i });
    }, 821: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(6916), o = r2(9662), a = r2(8523), s = r2(2534), l = r2(408);
      n2({ target: "Promise", stat: true, forced: r2(612) }, { all: function(t3) {
        var e3 = this, r3 = a.f(e3), n3 = r3.resolve, c2 = r3.reject, u = s(function() {
          var r4 = o(e3.resolve), a2 = [], s2 = 0, u2 = 1;
          l(t3, function(t4) {
            var o2 = s2++, l2 = false;
            u2++, i(r4, e3, t4).then(function(t5) {
              l2 || (l2 = true, a2[o2] = t5, --u2 || n3(a2));
            }, c2);
          }), --u2 || n3(a2);
        });
        return u.error && c2(u.value), r3.promise;
      } });
    }, 4164: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(1913), o = r2(3702).CONSTRUCTOR, a = r2(2492), s = r2(5005), l = r2(614), c2 = r2(8052), u = a && a.prototype;
      if (n2({ target: "Promise", proto: true, forced: o, real: true }, { catch: function(t3) {
        return this.then(void 0, t3);
      } }), !i && l(a)) {
        var h2 = s("Promise").prototype.catch;
        u.catch !== h2 && c2(u, "catch", h2, { unsafe: true });
      }
    }, 3401: (t2, e2, r2) => {
      var n2, i, o, a = r2(2109), s = r2(1913), l = r2(5268), c2 = r2(7854), u = r2(6916), h2 = r2(8052), p2 = r2(7674), d = r2(8003), f2 = r2(6340), y2 = r2(9662), m = r2(614), v2 = r2(111), b2 = r2(5787), g2 = r2(6707), w2 = r2(261).set, _2 = r2(5948), k2 = r2(842), j2 = r2(2534), O2 = r2(8572), x2 = r2(9909), C2 = r2(2492), E2 = r2(3702), S2 = r2(8523), P2 = "Promise", T2 = E2.CONSTRUCTOR, L2 = E2.REJECTION_EVENT, R2 = E2.SUBCLASSING, A2 = x2.getterFor(P2), I2 = x2.set, B2 = C2 && C2.prototype, N2 = C2, D2 = B2, F2 = c2.TypeError, V2 = c2.document, z2 = c2.process, H2 = S2.f, M2 = H2, q2 = !!(V2 && V2.createEvent && c2.dispatchEvent), G2 = "unhandledrejection", U2 = function(t3) {
        var e3;
        return !(!v2(t3) || !m(e3 = t3.then)) && e3;
      }, $2 = function(t3, e3) {
        var r3, n3, i2, o2 = e3.value, a2 = 1 == e3.state, s2 = a2 ? t3.ok : t3.fail, l2 = t3.resolve, c3 = t3.reject, h3 = t3.domain;
        try {
          s2 ? (a2 || (2 === e3.rejection && Q2(e3), e3.rejection = 1), true === s2 ? r3 = o2 : (h3 && h3.enter(), r3 = s2(o2), h3 && (h3.exit(), i2 = true)), r3 === t3.promise ? c3(F2("Promise-chain cycle")) : (n3 = U2(r3)) ? u(n3, r3, l2, c3) : l2(r3)) : c3(o2);
        } catch (t4) {
          h3 && !i2 && h3.exit(), c3(t4);
        }
      }, J2 = function(t3, e3) {
        t3.notified || (t3.notified = true, _2(function() {
          for (var r3, n3 = t3.reactions; r3 = n3.get(); )
            $2(r3, t3);
          t3.notified = false, e3 && !t3.rejection && Z2(t3);
        }));
      }, W2 = function(t3, e3, r3) {
        var n3, i2;
        q2 ? ((n3 = V2.createEvent("Event")).promise = e3, n3.reason = r3, n3.initEvent(t3, false, true), c2.dispatchEvent(n3)) : n3 = { promise: e3, reason: r3 }, !L2 && (i2 = c2["on" + t3]) ? i2(n3) : t3 === G2 && k2("Unhandled promise rejection", r3);
      }, Z2 = function(t3) {
        u(w2, c2, function() {
          var e3, r3 = t3.facade, n3 = t3.value;
          if (Y2(t3) && (e3 = j2(function() {
            l ? z2.emit("unhandledRejection", n3, r3) : W2(G2, r3, n3);
          }), t3.rejection = l || Y2(t3) ? 2 : 1, e3.error))
            throw e3.value;
        });
      }, Y2 = function(t3) {
        return 1 !== t3.rejection && !t3.parent;
      }, Q2 = function(t3) {
        u(w2, c2, function() {
          var e3 = t3.facade;
          l ? z2.emit("rejectionHandled", e3) : W2("rejectionhandled", e3, t3.value);
        });
      }, K2 = function(t3, e3, r3) {
        return function(n3) {
          t3(e3, n3, r3);
        };
      }, X2 = function(t3, e3, r3) {
        t3.done || (t3.done = true, r3 && (t3 = r3), t3.value = e3, t3.state = 2, J2(t3, true));
      }, tt2 = function(t3, e3, r3) {
        if (!t3.done) {
          t3.done = true, r3 && (t3 = r3);
          try {
            if (t3.facade === e3)
              throw F2("Promise can't be resolved itself");
            var n3 = U2(e3);
            n3 ? _2(function() {
              var r4 = { done: false };
              try {
                u(n3, e3, K2(tt2, r4, t3), K2(X2, r4, t3));
              } catch (e4) {
                X2(r4, e4, t3);
              }
            }) : (t3.value = e3, t3.state = 1, J2(t3, false));
          } catch (e4) {
            X2({ done: false }, e4, t3);
          }
        }
      };
      if (T2 && (D2 = (N2 = function(t3) {
        b2(this, D2), y2(t3), u(n2, this);
        var e3 = A2(this);
        try {
          t3(K2(tt2, e3), K2(X2, e3));
        } catch (t4) {
          X2(e3, t4);
        }
      }).prototype, (n2 = function(t3) {
        I2(this, { type: P2, done: false, notified: false, parent: false, reactions: new O2(), rejection: false, state: 0, value: void 0 });
      }).prototype = h2(D2, "then", function(t3, e3) {
        var r3 = A2(this), n3 = H2(g2(this, N2));
        return r3.parent = true, n3.ok = !m(t3) || t3, n3.fail = m(e3) && e3, n3.domain = l ? z2.domain : void 0, 0 == r3.state ? r3.reactions.add(n3) : _2(function() {
          $2(n3, r3);
        }), n3.promise;
      }), i = function() {
        var t3 = new n2(), e3 = A2(t3);
        this.promise = t3, this.resolve = K2(tt2, e3), this.reject = K2(X2, e3);
      }, S2.f = H2 = function(t3) {
        return t3 === N2 || void 0 === t3 ? new i(t3) : M2(t3);
      }, !s && m(C2) && B2 !== Object.prototype)) {
        o = B2.then, R2 || h2(B2, "then", function(t3, e3) {
          var r3 = this;
          return new N2(function(t4, e4) {
            u(o, r3, t4, e4);
          }).then(t3, e3);
        }, { unsafe: true });
        try {
          delete B2.constructor;
        } catch (t3) {
        }
        p2 && p2(B2, D2);
      }
      a({ global: true, constructor: true, wrap: true, forced: T2 }, { Promise: N2 }), d(N2, P2, false, true), f2(P2);
    }, 8674: (t2, e2, r2) => {
      r2(3401), r2(821), r2(4164), r2(6027), r2(683), r2(6294);
    }, 6027: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(6916), o = r2(9662), a = r2(8523), s = r2(2534), l = r2(408);
      n2({ target: "Promise", stat: true, forced: r2(612) }, { race: function(t3) {
        var e3 = this, r3 = a.f(e3), n3 = r3.reject, c2 = s(function() {
          var a2 = o(e3.resolve);
          l(t3, function(t4) {
            i(a2, e3, t4).then(r3.resolve, n3);
          });
        });
        return c2.error && n3(c2.value), r3.promise;
      } });
    }, 683: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(6916), o = r2(8523);
      n2({ target: "Promise", stat: true, forced: r2(3702).CONSTRUCTOR }, { reject: function(t3) {
        var e3 = o.f(this);
        return i(e3.reject, void 0, t3), e3.promise;
      } });
    }, 6294: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(5005), o = r2(1913), a = r2(2492), s = r2(3702).CONSTRUCTOR, l = r2(9478), c2 = i("Promise"), u = o && !s;
      n2({ target: "Promise", stat: true, forced: o || s }, { resolve: function(t3) {
        return l(u && this === c2 ? a : this, t3);
      } });
    }, 2419: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(5005), o = r2(2104), a = r2(7065), s = r2(9483), l = r2(9670), c2 = r2(111), u = r2(30), h2 = r2(7293), p2 = i("Reflect", "construct"), d = Object.prototype, f2 = [].push, y2 = h2(function() {
        function t3() {
        }
        return !(p2(function() {
        }, [], t3) instanceof t3);
      }), m = !h2(function() {
        p2(function() {
        });
      }), v2 = y2 || m;
      n2({ target: "Reflect", stat: true, forced: v2, sham: v2 }, { construct: function(t3, e3) {
        s(t3), l(e3);
        var r3 = arguments.length < 3 ? t3 : s(arguments[2]);
        if (m && !y2)
          return p2(t3, e3, r3);
        if (t3 == r3) {
          switch (e3.length) {
            case 0:
              return new t3();
            case 1:
              return new t3(e3[0]);
            case 2:
              return new t3(e3[0], e3[1]);
            case 3:
              return new t3(e3[0], e3[1], e3[2]);
            case 4:
              return new t3(e3[0], e3[1], e3[2], e3[3]);
          }
          var n3 = [null];
          return o(f2, n3, e3), new (o(a, t3, n3))();
        }
        var i2 = r3.prototype, h3 = u(c2(i2) ? i2 : d), v3 = o(t3, h3, e3);
        return c2(v3) ? v3 : h3;
      } });
    }, 4819: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(6916), o = r2(111), a = r2(9670), s = r2(5032), l = r2(1236), c2 = r2(9518);
      n2({ target: "Reflect", stat: true }, { get: function t3(e3, r3) {
        var n3, u, h2 = arguments.length < 3 ? e3 : arguments[2];
        return a(e3) === h2 ? e3[r3] : (n3 = l.f(e3, r3)) ? s(n3) ? n3.value : void 0 === n3.get ? void 0 : i(n3.get, h2) : o(u = c2(e3)) ? t3(u, r3, h2) : void 0;
      } });
    }, 4603: (t2, e2, r2) => {
      var n2 = r2(9781), i = r2(7854), o = r2(1702), a = r2(4705), s = r2(9587), l = r2(8880), c2 = r2(8006).f, u = r2(7976), h2 = r2(7850), p2 = r2(1340), d = r2(4706), f2 = r2(2999), y2 = r2(2626), m = r2(8052), v2 = r2(7293), b2 = r2(2597), g2 = r2(9909).enforce, w2 = r2(6340), _2 = r2(5112), k2 = r2(9441), j2 = r2(7168), O2 = _2("match"), x2 = i.RegExp, C2 = x2.prototype, E2 = i.SyntaxError, S2 = o(C2.exec), P2 = o("".charAt), T2 = o("".replace), L2 = o("".indexOf), R2 = o("".slice), A2 = /^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/, I2 = /a/g, B2 = /a/g, N2 = new x2(I2) !== I2, D2 = f2.MISSED_STICKY, F2 = f2.UNSUPPORTED_Y;
      if (a("RegExp", n2 && (!N2 || D2 || k2 || j2 || v2(function() {
        return B2[O2] = false, x2(I2) != I2 || x2(B2) == B2 || "/a/i" != x2(I2, "i");
      })))) {
        for (var V2 = function(t3, e3) {
          var r3, n3, i2, o2, a2, c3, f3 = u(C2, this), y3 = h2(t3), m2 = void 0 === e3, v3 = [], w3 = t3;
          if (!f3 && y3 && m2 && t3.constructor === V2)
            return t3;
          if ((y3 || u(C2, t3)) && (t3 = t3.source, m2 && (e3 = d(w3))), t3 = void 0 === t3 ? "" : p2(t3), e3 = void 0 === e3 ? "" : p2(e3), w3 = t3, k2 && "dotAll" in I2 && (n3 = !!e3 && L2(e3, "s") > -1) && (e3 = T2(e3, /s/g, "")), r3 = e3, D2 && "sticky" in I2 && (i2 = !!e3 && L2(e3, "y") > -1) && F2 && (e3 = T2(e3, /y/g, "")), j2 && (o2 = function(t4) {
            for (var e4, r4 = t4.length, n4 = 0, i3 = "", o3 = [], a3 = {}, s2 = false, l2 = false, c4 = 0, u2 = ""; n4 <= r4; n4++) {
              if ("\\" === (e4 = P2(t4, n4)))
                e4 += P2(t4, ++n4);
              else if ("]" === e4)
                s2 = false;
              else if (!s2)
                switch (true) {
                  case "[" === e4:
                    s2 = true;
                    break;
                  case "(" === e4:
                    S2(A2, R2(t4, n4 + 1)) && (n4 += 2, l2 = true), i3 += e4, c4++;
                    continue;
                  case (">" === e4 && l2):
                    if ("" === u2 || b2(a3, u2))
                      throw new E2("Invalid capture group name");
                    a3[u2] = true, o3[o3.length] = [u2, c4], l2 = false, u2 = "";
                    continue;
                }
              l2 ? u2 += e4 : i3 += e4;
            }
            return [i3, o3];
          }(t3), t3 = o2[0], v3 = o2[1]), a2 = s(x2(t3, e3), f3 ? this : C2, V2), (n3 || i2 || v3.length) && (c3 = g2(a2), n3 && (c3.dotAll = true, c3.raw = V2(function(t4) {
            for (var e4, r4 = t4.length, n4 = 0, i3 = "", o3 = false; n4 <= r4; n4++)
              "\\" !== (e4 = P2(t4, n4)) ? o3 || "." !== e4 ? ("[" === e4 ? o3 = true : "]" === e4 && (o3 = false), i3 += e4) : i3 += "[\\s\\S]" : i3 += e4 + P2(t4, ++n4);
            return i3;
          }(t3), r3)), i2 && (c3.sticky = true), v3.length && (c3.groups = v3)), t3 !== w3)
            try {
              l(a2, "source", "" === w3 ? "(?:)" : w3);
            } catch (t4) {
            }
          return a2;
        }, z2 = c2(x2), H2 = 0; z2.length > H2; )
          y2(V2, x2, z2[H2++]);
        C2.constructor = V2, V2.prototype = C2, m(i, "RegExp", V2, { constructor: true });
      }
      w2("RegExp");
    }, 4916: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(2261);
      n2({ target: "RegExp", proto: true, forced: /./.exec !== i }, { exec: i });
    }, 9714: (t2, e2, r2) => {
      var n2 = r2(6530).PROPER, i = r2(8052), o = r2(9670), a = r2(1340), s = r2(7293), l = r2(4706), c2 = "toString", u = RegExp.prototype[c2], h2 = s(function() {
        return "/a/b" != u.call({ source: "a", flags: "b" });
      }), p2 = n2 && u.name != c2;
      (h2 || p2) && i(RegExp.prototype, c2, function() {
        var t3 = o(this);
        return "/" + a(t3.source) + "/" + a(l(t3));
      }, { unsafe: true });
    }, 2023: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(1702), o = r2(3929), a = r2(4488), s = r2(1340), l = r2(4964), c2 = i("".indexOf);
      n2({ target: "String", proto: true, forced: !l("includes") }, { includes: function(t3) {
        return !!~c2(s(a(this)), s(o(t3)), arguments.length > 1 ? arguments[1] : void 0);
      } });
    }, 8783: (t2, e2, r2) => {
      var n2 = r2(8710).charAt, i = r2(1340), o = r2(9909), a = r2(1656), s = r2(6178), l = "String Iterator", c2 = o.set, u = o.getterFor(l);
      a(String, "String", function(t3) {
        c2(this, { type: l, string: i(t3), index: 0 });
      }, function() {
        var t3, e3 = u(this), r3 = e3.string, i2 = e3.index;
        return i2 >= r3.length ? s(void 0, true) : (t3 = n2(r3, i2), e3.index += t3.length, s(t3, false));
      });
    }, 4723: (t2, e2, r2) => {
      var n2 = r2(6916), i = r2(7007), o = r2(9670), a = r2(8554), s = r2(7466), l = r2(1340), c2 = r2(4488), u = r2(8173), h2 = r2(1530), p2 = r2(7651);
      i("match", function(t3, e3, r3) {
        return [function(e4) {
          var r4 = c2(this), i2 = a(e4) ? void 0 : u(e4, t3);
          return i2 ? n2(i2, e4, r4) : new RegExp(e4)[t3](l(r4));
        }, function(t4) {
          var n3 = o(this), i2 = l(t4), a2 = r3(e3, n3, i2);
          if (a2.done)
            return a2.value;
          if (!n3.global)
            return p2(n3, i2);
          var c3 = n3.unicode;
          n3.lastIndex = 0;
          for (var u2, d = [], f2 = 0; null !== (u2 = p2(n3, i2)); ) {
            var y2 = l(u2[0]);
            d[f2] = y2, "" === y2 && (n3.lastIndex = h2(i2, s(n3.lastIndex), c3)), f2++;
          }
          return 0 === f2 ? null : d;
        }];
      });
    }, 5306: (t2, e2, r2) => {
      var n2 = r2(2104), i = r2(6916), o = r2(1702), a = r2(7007), s = r2(7293), l = r2(9670), c2 = r2(614), u = r2(8554), h2 = r2(9303), p2 = r2(7466), d = r2(1340), f2 = r2(4488), y2 = r2(1530), m = r2(8173), v2 = r2(647), b2 = r2(7651), g2 = r2(5112)("replace"), w2 = Math.max, _2 = Math.min, k2 = o([].concat), j2 = o([].push), O2 = o("".indexOf), x2 = o("".slice), C2 = "$0" === "a".replace(/./, "$0"), E2 = !!/./[g2] && "" === /./[g2]("a", "$0");
      a("replace", function(t3, e3, r3) {
        var o2 = E2 ? "$" : "$0";
        return [function(t4, r4) {
          var n3 = f2(this), o3 = u(t4) ? void 0 : m(t4, g2);
          return o3 ? i(o3, t4, n3, r4) : i(e3, d(n3), t4, r4);
        }, function(t4, i2) {
          var a2 = l(this), s2 = d(t4);
          if ("string" == typeof i2 && -1 === O2(i2, o2) && -1 === O2(i2, "$<")) {
            var u2 = r3(e3, a2, s2, i2);
            if (u2.done)
              return u2.value;
          }
          var f3 = c2(i2);
          f3 || (i2 = d(i2));
          var m2 = a2.global;
          if (m2) {
            var g3 = a2.unicode;
            a2.lastIndex = 0;
          }
          for (var C3 = []; ; ) {
            var E3 = b2(a2, s2);
            if (null === E3)
              break;
            if (j2(C3, E3), !m2)
              break;
            "" === d(E3[0]) && (a2.lastIndex = y2(s2, p2(a2.lastIndex), g3));
          }
          for (var S2, P2 = "", T2 = 0, L2 = 0; L2 < C3.length; L2++) {
            for (var R2 = d((E3 = C3[L2])[0]), A2 = w2(_2(h2(E3.index), s2.length), 0), I2 = [], B2 = 1; B2 < E3.length; B2++)
              j2(I2, void 0 === (S2 = E3[B2]) ? S2 : String(S2));
            var N2 = E3.groups;
            if (f3) {
              var D2 = k2([R2], I2, A2, s2);
              void 0 !== N2 && j2(D2, N2);
              var F2 = d(n2(i2, void 0, D2));
            } else
              F2 = v2(R2, s2, A2, I2, N2, i2);
            A2 >= T2 && (P2 += x2(s2, T2, A2) + F2, T2 = A2 + R2.length);
          }
          return P2 + x2(s2, T2);
        }];
      }, !!s(function() {
        var t3 = /./;
        return t3.exec = function() {
          var t4 = [];
          return t4.groups = { a: "7" }, t4;
        }, "7" !== "".replace(t3, "$<a>");
      }) || !C2 || E2);
    }, 6755: (t2, e2, r2) => {
      var n2, i = r2(2109), o = r2(1470), a = r2(1236).f, s = r2(7466), l = r2(1340), c2 = r2(3929), u = r2(4488), h2 = r2(4964), p2 = r2(1913), d = o("".startsWith), f2 = o("".slice), y2 = Math.min, m = h2("startsWith");
      i({ target: "String", proto: true, forced: !(!p2 && !m && (n2 = a(String.prototype, "startsWith"), n2 && !n2.writable) || m) }, { startsWith: function(t3) {
        var e3 = l(u(this));
        c2(t3);
        var r3 = s(y2(arguments.length > 1 ? arguments[1] : void 0, e3.length)), n3 = l(t3);
        return d ? d(e3, n3, r3) : f2(e3, r3, r3 + n3.length) === n3;
      } });
    }, 3210: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(3111).trim;
      n2({ target: "String", proto: true, forced: r2(6091)("trim") }, { trim: function() {
        return i(this);
      } });
    }, 2443: (t2, e2, r2) => {
      r2(6800)("asyncIterator");
    }, 4032: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(7854), o = r2(6916), a = r2(1702), s = r2(1913), l = r2(9781), c2 = r2(6293), u = r2(7293), h2 = r2(2597), p2 = r2(7976), d = r2(9670), f2 = r2(5656), y2 = r2(4948), m = r2(1340), v2 = r2(9114), b2 = r2(30), g2 = r2(1956), w2 = r2(8006), _2 = r2(1156), k2 = r2(5181), j2 = r2(1236), O2 = r2(3070), x2 = r2(6048), C2 = r2(5296), E2 = r2(8052), S2 = r2(7045), P2 = r2(2309), T2 = r2(6200), L2 = r2(3501), R2 = r2(9711), A2 = r2(5112), I2 = r2(6061), B2 = r2(6800), N2 = r2(6532), D2 = r2(8003), F2 = r2(9909), V2 = r2(2092).forEach, z2 = T2("hidden"), H2 = "Symbol", M2 = "prototype", q2 = F2.set, G2 = F2.getterFor(H2), U2 = Object[M2], $2 = i.Symbol, J2 = $2 && $2[M2], W2 = i.TypeError, Z2 = i.QObject, Y2 = j2.f, Q2 = O2.f, K2 = _2.f, X2 = C2.f, tt2 = a([].push), et2 = P2("symbols"), rt2 = P2("op-symbols"), nt2 = P2("wks"), it2 = !Z2 || !Z2[M2] || !Z2[M2].findChild, ot2 = l && u(function() {
        return 7 != b2(Q2({}, "a", { get: function() {
          return Q2(this, "a", { value: 7 }).a;
        } })).a;
      }) ? function(t3, e3, r3) {
        var n3 = Y2(U2, e3);
        n3 && delete U2[e3], Q2(t3, e3, r3), n3 && t3 !== U2 && Q2(U2, e3, n3);
      } : Q2, at2 = function(t3, e3) {
        var r3 = et2[t3] = b2(J2);
        return q2(r3, { type: H2, tag: t3, description: e3 }), l || (r3.description = e3), r3;
      }, st2 = function(t3, e3, r3) {
        t3 === U2 && st2(rt2, e3, r3), d(t3);
        var n3 = y2(e3);
        return d(r3), h2(et2, n3) ? (r3.enumerable ? (h2(t3, z2) && t3[z2][n3] && (t3[z2][n3] = false), r3 = b2(r3, { enumerable: v2(0, false) })) : (h2(t3, z2) || Q2(t3, z2, v2(1, {})), t3[z2][n3] = true), ot2(t3, n3, r3)) : Q2(t3, n3, r3);
      }, lt2 = function(t3, e3) {
        d(t3);
        var r3 = f2(e3), n3 = g2(r3).concat(pt2(r3));
        return V2(n3, function(e4) {
          l && !o(ct2, r3, e4) || st2(t3, e4, r3[e4]);
        }), t3;
      }, ct2 = function(t3) {
        var e3 = y2(t3), r3 = o(X2, this, e3);
        return !(this === U2 && h2(et2, e3) && !h2(rt2, e3)) && (!(r3 || !h2(this, e3) || !h2(et2, e3) || h2(this, z2) && this[z2][e3]) || r3);
      }, ut2 = function(t3, e3) {
        var r3 = f2(t3), n3 = y2(e3);
        if (r3 !== U2 || !h2(et2, n3) || h2(rt2, n3)) {
          var i2 = Y2(r3, n3);
          return !i2 || !h2(et2, n3) || h2(r3, z2) && r3[z2][n3] || (i2.enumerable = true), i2;
        }
      }, ht2 = function(t3) {
        var e3 = K2(f2(t3)), r3 = [];
        return V2(e3, function(t4) {
          h2(et2, t4) || h2(L2, t4) || tt2(r3, t4);
        }), r3;
      }, pt2 = function(t3) {
        var e3 = t3 === U2, r3 = K2(e3 ? rt2 : f2(t3)), n3 = [];
        return V2(r3, function(t4) {
          !h2(et2, t4) || e3 && !h2(U2, t4) || tt2(n3, et2[t4]);
        }), n3;
      };
      c2 || (E2(J2 = ($2 = function() {
        if (p2(J2, this))
          throw W2("Symbol is not a constructor");
        var t3 = arguments.length && void 0 !== arguments[0] ? m(arguments[0]) : void 0, e3 = R2(t3), r3 = function(t4) {
          this === U2 && o(r3, rt2, t4), h2(this, z2) && h2(this[z2], e3) && (this[z2][e3] = false), ot2(this, e3, v2(1, t4));
        };
        return l && it2 && ot2(U2, e3, { configurable: true, set: r3 }), at2(e3, t3);
      })[M2], "toString", function() {
        return G2(this).tag;
      }), E2($2, "withoutSetter", function(t3) {
        return at2(R2(t3), t3);
      }), C2.f = ct2, O2.f = st2, x2.f = lt2, j2.f = ut2, w2.f = _2.f = ht2, k2.f = pt2, I2.f = function(t3) {
        return at2(A2(t3), t3);
      }, l && (S2(J2, "description", { configurable: true, get: function() {
        return G2(this).description;
      } }), s || E2(U2, "propertyIsEnumerable", ct2, { unsafe: true }))), n2({ global: true, constructor: true, wrap: true, forced: !c2, sham: !c2 }, { Symbol: $2 }), V2(g2(nt2), function(t3) {
        B2(t3);
      }), n2({ target: H2, stat: true, forced: !c2 }, { useSetter: function() {
        it2 = true;
      }, useSimple: function() {
        it2 = false;
      } }), n2({ target: "Object", stat: true, forced: !c2, sham: !l }, { create: function(t3, e3) {
        return void 0 === e3 ? b2(t3) : lt2(b2(t3), e3);
      }, defineProperty: st2, defineProperties: lt2, getOwnPropertyDescriptor: ut2 }), n2({ target: "Object", stat: true, forced: !c2 }, { getOwnPropertyNames: ht2 }), N2(), D2($2, H2), L2[z2] = true;
    }, 1817: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(9781), o = r2(7854), a = r2(1702), s = r2(2597), l = r2(614), c2 = r2(7976), u = r2(1340), h2 = r2(7045), p2 = r2(9920), d = o.Symbol, f2 = d && d.prototype;
      if (i && l(d) && (!("description" in f2) || void 0 !== d().description)) {
        var y2 = {}, m = function() {
          var t3 = arguments.length < 1 || void 0 === arguments[0] ? void 0 : u(arguments[0]), e3 = c2(f2, this) ? new d(t3) : void 0 === t3 ? d() : d(t3);
          return "" === t3 && (y2[e3] = true), e3;
        };
        p2(m, d), m.prototype = f2, f2.constructor = m;
        var v2 = "Symbol(test)" == String(d("test")), b2 = a(f2.valueOf), g2 = a(f2.toString), w2 = /^Symbol\((.*)\)[^)]+$/, _2 = a("".replace), k2 = a("".slice);
        h2(f2, "description", { configurable: true, get: function() {
          var t3 = b2(this);
          if (s(y2, t3))
            return "";
          var e3 = g2(t3), r3 = v2 ? k2(e3, 7, -1) : _2(e3, w2, "$1");
          return "" === r3 ? void 0 : r3;
        } }), n2({ global: true, constructor: true, forced: true }, { Symbol: m });
      }
    }, 763: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(5005), o = r2(2597), a = r2(1340), s = r2(2309), l = r2(2015), c2 = s("string-to-symbol-registry"), u = s("symbol-to-string-registry");
      n2({ target: "Symbol", stat: true, forced: !l }, { for: function(t3) {
        var e3 = a(t3);
        if (o(c2, e3))
          return c2[e3];
        var r3 = i("Symbol")(e3);
        return c2[e3] = r3, u[r3] = e3, r3;
      } });
    }, 2165: (t2, e2, r2) => {
      r2(6800)("iterator");
    }, 2526: (t2, e2, r2) => {
      r2(4032), r2(763), r2(6620), r2(8862), r2(9660);
    }, 6620: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(2597), o = r2(2190), a = r2(6330), s = r2(2309), l = r2(2015), c2 = s("symbol-to-string-registry");
      n2({ target: "Symbol", stat: true, forced: !l }, { keyFor: function(t3) {
        if (!o(t3))
          throw TypeError(a(t3) + " is not a symbol");
        if (i(c2, t3))
          return c2[t3];
      } });
    }, 6649: (t2, e2, r2) => {
      var n2 = r2(6800), i = r2(6532);
      n2("toPrimitive"), i();
    }, 3680: (t2, e2, r2) => {
      var n2 = r2(5005), i = r2(6800), o = r2(8003);
      i("toStringTag"), o(n2("Symbol"), "Symbol");
    }, 4747: (t2, e2, r2) => {
      var n2 = r2(7854), i = r2(8324), o = r2(8509), a = r2(8533), s = r2(8880), l = function(t3) {
        if (t3 && t3.forEach !== a)
          try {
            s(t3, "forEach", a);
          } catch (e3) {
            t3.forEach = a;
          }
      };
      for (var c2 in i)
        i[c2] && l(n2[c2] && n2[c2].prototype);
      l(o);
    }, 3948: (t2, e2, r2) => {
      var n2 = r2(7854), i = r2(8324), o = r2(8509), a = r2(6992), s = r2(8880), l = r2(5112), c2 = l("iterator"), u = l("toStringTag"), h2 = a.values, p2 = function(t3, e3) {
        if (t3) {
          if (t3[c2] !== h2)
            try {
              s(t3, c2, h2);
            } catch (e4) {
              t3[c2] = h2;
            }
          if (t3[u] || s(t3, u, e3), i[e3]) {
            for (var r3 in a)
              if (t3[r3] !== a[r3])
                try {
                  s(t3, r3, a[r3]);
                } catch (e4) {
                  t3[r3] = a[r3];
                }
          }
        }
      };
      for (var d in i)
        p2(n2[d] && n2[d].prototype, d);
      p2(o, "DOMTokenList");
    }, 6815: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(7854), o = r2(7152)(i.setInterval, true);
      n2({ global: true, bind: true, forced: i.setInterval !== o }, { setInterval: o });
    }, 8417: (t2, e2, r2) => {
      var n2 = r2(2109), i = r2(7854), o = r2(7152)(i.setTimeout, true);
      n2({ global: true, bind: true, forced: i.setTimeout !== o }, { setTimeout: o });
    }, 2564: (t2, e2, r2) => {
      r2(6815), r2(8417);
    } }, e = {};
    function r(n2) {
      var i = e[n2];
      if (void 0 !== i)
        return i.exports;
      var o = e[n2] = { exports: {} };
      return t[n2](o, o.exports, r), o.exports;
    }
    r.d = (t2, e2) => {
      for (var n2 in e2)
        r.o(e2, n2) && !r.o(t2, n2) && Object.defineProperty(t2, n2, { enumerable: true, get: e2[n2] });
    }, r.g = function() {
      if ("object" == typeof globalThis)
        return globalThis;
      try {
        return this || new Function("return this")();
      } catch (t2) {
        if ("object" == typeof window)
          return window;
      }
    }(), r.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), r.r = (t2) => {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
    };
    var n = {};
    return (() => {
      r.r(n), r.d(n, { JSONEditor: () => ha }), r(3710), r(1539), r(9714), r(5827), r(6833), r(9826), r(9554), r(4747), r(7941), r(2222), r(9601), r(6649), r(6078), r(2526), r(1817), r(9653), r(9070), r(8674), r(2165), r(6992), r(8783), r(3948), r(2443), r(3680), r(3706), r(2703), r(8011), r(489), r(8309), r(8304), r(5069), r(7042), r(9753), r(1038), r(4916), r(9720), r(5306), r(4603), r(6699);
      var t2 = ["actionscript", "batchfile", "c", "c++", "cpp", "coffee", "csharp", "css", "dart", "django", "ejs", "erlang", "golang", "groovy", "handlebars", "haskell", "haxe", "html", "ini", "jade", "java", "javascript", "json", "less", "lisp", "lua", "makefile", "matlab", "mysql", "objectivec", "pascal", "perl", "pgsql", "php", "python", "r", "ruby", "sass", "scala", "scss", "sh", "smarty", "sql", "sqlserver", "stylus", "svg", "twig", "vbscript", "xml", "yaml"], e2 = [function(t3) {
        return "string" === t3.type && "color" === t3.format && "colorpicker";
      }, function(t3) {
        return "string" === t3.type && ["ip", "ipv4", "ipv6", "hostname"].includes(t3.format) && "ip";
      }, function(e3) {
        return "string" === e3.type && t2.includes(e3.format) && "ace";
      }, function(t3) {
        return "string" === t3.type && ["xhtml", "bbcode"].includes(t3.format) && "sceditor";
      }, function(t3) {
        return "string" === t3.type && "markdown" === t3.format && "simplemde";
      }, function(t3) {
        return "string" === t3.type && "jodit" === t3.format && "jodit";
      }, function(t3) {
        return "string" === t3.type && "autocomplete" === t3.format && "autocomplete";
      }, function(t3) {
        return "string" === t3.type && "uuid" === t3.format && "uuid";
      }, function(t3) {
        return "info" === t3.format && "info";
      }, function(t3) {
        return "button" === t3.format && "button";
      }, function(t3) {
        if (("integer" === t3.type || "number" === t3.type) && "stepper" === t3.format)
          return "stepper";
      }, function(t3) {
        if (t3.links) {
          for (var e3 = 0; e3 < t3.links.length; e3++)
            if (t3.links[e3].rel && "describedby" === t3.links[e3].rel.toLowerCase())
              return "describedBy";
        }
      }, function(t3) {
        return ["string", "integer"].includes(t3.type) && ["starrating", "rating"].includes(t3.format) && "starrating";
      }, function(t3) {
        return ["string", "integer"].includes(t3.type) && ["date", "time", "datetime-local"].includes(t3.format) && "datetime";
      }, function(t3) {
        return (t3.oneOf || t3.anyOf) && "multiple";
      }, function(t3) {
        return t3.if && "multiple";
      }, function(t3) {
        if ("array" === t3.type && t3.items && !Array.isArray(t3.items) && ["string", "number", "integer"].includes(t3.items.type)) {
          if ("choices" === t3.format)
            return "arrayChoices";
          if (t3.uniqueItems) {
            if ("selectize" === t3.format)
              return "arraySelectize";
            if ("select2" === t3.format)
              return "arraySelect2";
            if (t3.items.enum)
              return "multiselect";
          }
        }
      }, function(t3) {
        if (t3.enum) {
          if ("array" === t3.type || "object" === t3.type)
            return "enum";
          if ("number" === t3.type || "integer" === t3.type || "string" === t3.type)
            return "radio" === t3.format ? "radio" : "select2" === t3.format ? "select2" : "selectize" === t3.format ? "selectize" : "choices" === t3.format ? "choices" : "select";
        }
      }, function(t3) {
        if (t3.enumSource)
          return "radio" === t3.format ? "radio" : "select2" === t3.format ? "select2" : "selectize" === t3.format ? "selectize" : "choices" === t3.format ? "choices" : "select";
      }, function(t3) {
        return "array" === t3.type && "table" === t3.format && "table";
      }, function(t3) {
        return "string" === t3.type && "url" === t3.format && window.FileReader && t3.options && t3.options.upload === Object(t3.options.upload) && "upload";
      }, function(t3) {
        return "string" === t3.type && t3.media && "base64" === t3.media.binaryEncoding && "base64";
      }, function(t3) {
        return "any" === t3.type && "multiple";
      }, function(t3) {
        if ("boolean" === t3.type)
          return "checkbox" === t3.format || t3.options && t3.options.checkbox ? "checkbox" : "select2" === t3.format ? "select2" : "selectize" === t3.format ? "selectize" : "choices" === t3.format ? "choices" : "select";
      }, function(t3) {
        return "string" === t3.type && "signature" === t3.format && "signature";
      }, function(t3) {
        return "string" == typeof t3.type && t3.type;
      }, function(t3) {
        return !t3.type && t3.properties && "object";
      }, function(t3) {
        return "string" != typeof t3.type && "multiple";
      }];
      function i(t3, e3, r2) {
        return (e3 = function(t4) {
          var e4 = function(t5, e5) {
            if ("object" !== o(t5) || null === t5)
              return t5;
            var r3 = t5[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(t5, "string");
              if ("object" !== o(n2))
                return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t5);
          }(t4);
          return "symbol" === o(e4) ? e4 : String(e4);
        }(e3)) in t3 ? Object.defineProperty(t3, e3, { value: r2, enumerable: true, configurable: true, writable: true }) : t3[e3] = r2, t3;
      }
      function o(t3) {
        return o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, o(t3);
      }
      function a(t3) {
        return !(null === t3 || "object" !== o(t3) || t3.nodeType || t3 === t3.window || t3.constructor && !h2(t3.constructor.prototype, "isPrototypeOf"));
      }
      function s(t3) {
        return a(t3) ? l({}, t3) : Array.isArray(t3) ? t3.map(s) : t3;
      }
      function l(t3) {
        for (var e3 = arguments.length, r2 = new Array(e3 > 1 ? e3 - 1 : 0), n2 = 1; n2 < e3; n2++)
          r2[n2 - 1] = arguments[n2];
        return r2.forEach(function(e4) {
          e4 && Object.keys(e4).forEach(function(r3) {
            e4[r3] && a(e4[r3]) ? (h2(t3, r3) || (t3[r3] = {}), l(t3[r3], e4[r3])) : Array.isArray(e4[r3]) ? t3[r3] = s(e4[r3]) : t3[r3] = e4[r3];
          });
        }), t3;
      }
      function c2(t3, e3) {
        var r2 = document.createEvent("HTMLEvents");
        r2.initEvent(e3, true, true), t3.dispatchEvent(r2);
      }
      function u(t3) {
        return t3 && ("[object ShadowRoot]" === t3.toString() ? t3 : u(t3.parentNode));
      }
      function h2(t3, e3) {
        return t3 && Object.prototype.hasOwnProperty.call(t3, e3);
      }
      r(4812), r(2419), r(4819), r(5003), r(4723), r(2023), r(9600), r(6755), r(5212), r(1249), r(4678), r(1058);
      var p2 = /^\s*(-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/, d = /^\s*(-|\+)?(\d+)\s*$/;
      function f2() {
        var t3 = (/* @__PURE__ */ new Date()).getTime();
        return "undefined" != typeof performance && "function" == typeof performance.now && (t3 += performance.now()), "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(e3) {
          var r2 = (t3 + 16 * Math.random()) % 16 | 0;
          return t3 = Math.floor(t3 / 16), ("x" === e3 ? r2 : 3 & r2 | 8).toString(16);
        });
      }
      function y2(t3) {
        return t3 && "object" === o(t3) && !Array.isArray(t3);
      }
      function m(t3) {
        for (var e3 = arguments.length, r2 = new Array(e3 > 1 ? e3 - 1 : 0), n2 = 1; n2 < e3; n2++)
          r2[n2 - 1] = arguments[n2];
        if (!r2.length)
          return t3;
        var o2 = r2.shift();
        if (y2(t3) && y2(o2))
          for (var a2 in o2)
            y2(o2[a2]) ? (t3[a2] || Object.assign(t3, i({}, a2, {})), m(t3[a2], o2[a2])) : Object.assign(t3, i({}, a2, o2[a2]));
        return m.apply(void 0, [t3].concat(r2));
      }
      function v2(t3, e3) {
        (null == e3 || e3 > t3.length) && (e3 = t3.length);
        for (var r2 = 0, n2 = new Array(e3); r2 < e3; r2++)
          n2[r2] = t3[r2];
        return n2;
      }
      function b2(t3) {
        return b2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, b2(t3);
      }
      function g2(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== b2(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== b2(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === b2(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      var w2 = function() {
        function t3(e4, r3) {
          !function(t4, e5) {
            if (!(t4 instanceof e5))
              throw new TypeError("Cannot call a class as a function");
          }(this, t3), this.defaults = r3, this.jsoneditor = e4.jsoneditor, this.theme = this.jsoneditor.theme, this.template_engine = this.jsoneditor.template, this.iconlib = this.jsoneditor.iconlib, this.translate = this.jsoneditor.translate || this.defaults.translate, this.translateProperty = this.jsoneditor.translateProperty || this.defaults.translateProperty, this.original_schema = e4.schema, this.schema = this.jsoneditor.expandSchema(this.original_schema), this.active = true, this.options = l({}, this.options || {}, this.schema.options || {}, e4.schema.options || {}, e4), this.formname = this.jsoneditor.options.form_name_root || "root", e4.path || this.schema.id || (this.schema.id = this.formname), this.path = e4.path || this.formname, this.formname = e4.formname || this.path.replace(/\.([^.]+)/g, "[$1]"), this.parent = e4.parent, this.key = void 0 !== this.parent ? this.path.split(".").slice(this.parent.path.split(".").length).join(".") : this.path, this.link_watchers = [], this.watchLoop = false, e4.container && this.setContainer(e4.container), this.registerDependencies();
        }
        var e3, r2;
        return e3 = t3, r2 = [{ key: "onChildEditorChange", value: function(t4) {
          this.onChange(true);
        } }, { key: "notify", value: function() {
          this.path && this.jsoneditor.notifyWatchers(this.path);
        } }, { key: "change", value: function() {
          this.parent ? this.parent.onChildEditorChange(this) : this.jsoneditor && this.jsoneditor.onChange();
        } }, { key: "onChange", value: function(t4) {
          this.notify(), this.watch_listener && this.watch_listener(), t4 && this.change();
        } }, { key: "register", value: function() {
          this.jsoneditor.registerEditor(this), this.onChange();
        } }, { key: "unregister", value: function() {
          this.jsoneditor && this.jsoneditor.unregisterEditor(this);
        } }, { key: "getNumColumns", value: function() {
          return 12;
        } }, { key: "isActive", value: function() {
          return this.active;
        } }, { key: "activate", value: function() {
          this.active = true, this.optInCheckbox.checked = true, this.enable(), this.change();
        } }, { key: "deactivate", value: function() {
          this.isRequired() || (this.active = false, this.optInCheckbox.checked = false, this.disable(), this.change());
        } }, { key: "registerDependencies", value: function() {
          var t4 = this;
          this.dependenciesFulfilled = true;
          var e4 = this.options.dependencies;
          e4 && Object.keys(e4).forEach(function(e5) {
            var r3;
            e5.startsWith(t4.jsoneditor.root.path) ? r3 = e5 : ((r3 = t4.path.split("."))[r3.length - 1] = e5, r3 = r3.join(".")), t4.jsoneditor.watch(r3, function() {
              t4.evaluateDependencies();
            });
          });
        } }, { key: "evaluateDependencies", value: function() {
          var t4 = this, e4 = this.container || this.control;
          if (e4 && null !== this.jsoneditor) {
            var r3 = this.options.dependencies;
            if (r3) {
              var n2 = this.dependenciesFulfilled;
              this.dependenciesFulfilled = true, Object.keys(r3).forEach(function(e5) {
                var n3;
                e5.startsWith(t4.jsoneditor.root.path) ? n3 = e5 : ((n3 = t4.path.split("."))[n3.length - 1] = e5, n3 = n3.join("."));
                var i3 = r3[e5];
                t4.checkDependency(n3, i3);
              }), this.dependenciesFulfilled !== n2 && this.notify();
              var i2 = this.dependenciesFulfilled ? "block" : "none";
              this.options.hidden && (i2 = "none"), "TD" === e4.tagName ? Object.keys(e4.childNodes).forEach(function(t5) {
                return e4.childNodes[t5].style.display = i2;
              }) : e4.style.display = i2;
            }
          }
        } }, { key: "checkDependency", value: function(t4, e4) {
          var r3 = this;
          if (this.path !== t4 && null !== this.jsoneditor) {
            var n2 = this.jsoneditor.getEditor(t4), i2 = n2 ? n2.getValue() : void 0;
            n2 && n2.dependenciesFulfilled ? Array.isArray(e4) ? this.dependenciesFulfilled = e4.some(function(t5) {
              if (JSON.stringify(i2) === JSON.stringify(t5))
                return true;
            }) : "object" === b2(e4) ? "object" !== b2(i2) ? this.dependenciesFulfilled = e4 === i2 : Object.keys(e4).some(function(t5) {
              return !!h2(e4, t5) && (h2(i2, t5) && e4[t5] === i2[t5] ? void 0 : (r3.dependenciesFulfilled = false, true));
            }) : "string" == typeof e4 || "number" == typeof e4 ? this.dependenciesFulfilled = this.dependenciesFulfilled && i2 === e4 : "boolean" == typeof e4 && (this.dependenciesFulfilled = e4 ? this.dependenciesFulfilled && (i2 || i2.length > 0) : this.dependenciesFulfilled && (!i2 || 0 === i2.length)) : this.dependenciesFulfilled = false;
          }
        } }, { key: "setContainer", value: function(t4) {
          this.container = t4, this.setContainerAttributes(), this.schema.id && this.container.setAttribute("data-schemaid", this.schema.id), this.schema.type && "string" == typeof this.schema.type && this.container.setAttribute("data-schematype", this.schema.type), this.container.setAttribute("data-schemapath", this.path);
        } }, { key: "setOptInCheckbox", value: function(t4) {
          var e4 = this;
          this.optInCheckbox = document.createElement("input"), this.optInCheckbox.setAttribute("type", "checkbox"), this.optInCheckbox.setAttribute("style", "margin: 0 10px 0 0;"), this.optInCheckbox.classList.add("json-editor-opt-in"), this.optInCheckbox.addEventListener("click", function() {
            e4.isActive() ? e4.deactivate() : e4.activate();
          });
          var r3 = this.jsoneditor.options.show_opt_in, n2 = void 0 !== this.parent.options.show_opt_in, i2 = n2 && true === this.parent.options.show_opt_in, o2 = n2 && false === this.parent.options.show_opt_in;
          (i2 || !o2 && r3 || !n2 && r3) && this.parent && "object" === this.parent.schema.type && !this.isRequired() && this.header && (this.header.appendChild(this.optInCheckbox), this.header.insertBefore(this.optInCheckbox, this.header.firstChild));
        } }, { key: "preBuild", value: function() {
        } }, { key: "build", value: function() {
        } }, { key: "postBuild", value: function() {
          this.setupWatchListeners(), this.addLinks(), this.setValue(this.getDefault(), true), this.updateHeaderText(), this.register(), this.onWatchedFieldChange();
        } }, { key: "setupWatchListeners", value: function() {
          var t4 = this;
          if (this.watched = {}, this.schema.vars && (this.schema.watch = this.schema.vars), this.watched_values = {}, this.watch_listener = function() {
            t4.refreshWatchedFieldValues() && t4.onWatchedFieldChange();
          }, h2(this.schema, "watch")) {
            var e4, r3, n2, i2, o2, a2 = this.container.getAttribute("data-schemapath");
            Object.keys(this.schema.watch).forEach(function(s2) {
              if (e4 = t4.schema.watch[s2], Array.isArray(e4)) {
                if (e4.length < 2)
                  return;
                r3 = [e4[0]].concat(e4[1].split("."));
              } else
                r3 = e4.split("."), t4.theme.closest(t4.container, '[data-schemaid="'.concat(r3[0], '"]')) || r3.unshift("#");
              if ("#" === (n2 = r3.shift()) && (n2 = t4.jsoneditor.schema.id || t4.jsoneditor.root.formname), !(i2 = t4.theme.closest(t4.container, '[data-schemaid="'.concat(n2, '"]'))))
                throw new Error("Could not find ancestor node with id ".concat(n2));
              o2 = "".concat(i2.getAttribute("data-schemapath"), ".").concat(r3.join(".")), a2.startsWith(o2) && (t4.watchLoop = true), t4.jsoneditor.watch(o2, t4.watch_listener), t4.watched[s2] = o2;
            });
          }
          this.schema.headerTemplate && (this.header_template = this.jsoneditor.compileTemplate(this.schema.headerTemplate, this.template_engine));
        } }, { key: "addLinks", value: function() {
          if (!this.no_link_holder && (this.link_holder = this.theme.getLinksHolder(), void 0 !== this.description ? this.description.parentNode.insertBefore(this.link_holder, this.description) : this.container.appendChild(this.link_holder), this.schema.links))
            for (var t4 = 0; t4 < this.schema.links.length; t4++)
              this.addLink(this.getLink(this.schema.links[t4]));
        } }, { key: "onMove", value: function() {
        } }, { key: "getButton", value: function(t4, e4, r3) {
          var n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : [], i2 = "json-editor-btn-".concat(e4);
          e4 = this.iconlib ? this.iconlib.getIcon(e4) : null, t4 = this.translate(t4, n2), r3 = this.translate(r3, n2), !e4 && r3 && (t4 = r3, r3 = null);
          var o2 = this.theme.getButton(t4, e4, r3);
          return o2.classList.add(i2), o2;
        } }, { key: "setButtonText", value: function(t4, e4, r3, n2) {
          var i2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : [];
          return r3 = this.iconlib ? this.iconlib.getIcon(r3) : null, e4 = this.translate(e4, i2), n2 = this.translate(n2, i2), !r3 && n2 && (e4 = n2, n2 = null), this.theme.setButtonText(t4, e4, r3, n2);
        } }, { key: "addLink", value: function(t4) {
          this.link_holder && this.link_holder.appendChild(t4);
        } }, { key: "getLink", value: function(t4) {
          var e4, r3, n2 = (t4.mediaType || "application/javascript").split("/")[0], i2 = this.jsoneditor.compileTemplate(t4.href, this.template_engine), o2 = this.jsoneditor.compileTemplate(t4.rel ? t4.rel : t4.href, this.template_engine), a2 = null;
          if (t4.download && (a2 = t4.download), a2 && true !== a2 && (a2 = this.jsoneditor.compileTemplate(a2, this.template_engine)), "image" === n2) {
            e4 = this.theme.getBlockLinkHolder(), (r3 = document.createElement("a")).setAttribute("target", "_blank");
            var s2 = document.createElement("img");
            this.theme.createImageLink(e4, r3, s2), this.link_watchers.push(function(t5) {
              var e5 = i2(t5), n3 = o2(t5);
              r3.setAttribute("href", e5), r3.setAttribute("title", n3 || e5), s2.setAttribute("src", e5);
            });
          } else if (["audio", "video"].includes(n2)) {
            e4 = this.theme.getBlockLinkHolder(), (r3 = this.theme.getBlockLink()).setAttribute("target", "_blank");
            var l2 = document.createElement(n2);
            l2.setAttribute("controls", "controls"), this.theme.createMediaLink(e4, r3, l2), this.link_watchers.push(function(t5) {
              var e5 = i2(t5), n3 = o2(t5);
              r3.setAttribute("href", e5), r3.textContent = n3 || e5, l2.setAttribute("src", e5);
            });
          } else
            r3 = e4 = this.theme.getBlockLink(), e4.setAttribute("target", "_blank"), e4.textContent = t4.rel, e4.style.display = "none", this.link_watchers.push(function(t5) {
              var r4 = i2(t5), n3 = o2(t5);
              r4 && (e4.style.display = ""), e4.setAttribute("href", r4), e4.textContent = n3 || r4;
            });
          return a2 && r3 && (true === a2 ? r3.setAttribute("download", "") : this.link_watchers.push(function(t5) {
            r3.setAttribute("download", a2(t5));
          })), t4.class && r3.classList.add(t4.class), e4;
        } }, { key: "refreshWatchedFieldValues", value: function() {
          var t4 = this;
          if (this.watched_values) {
            var e4 = {}, r3 = false;
            return this.watched && Object.keys(this.watched).forEach(function(n2) {
              var i2 = t4.jsoneditor.getEditor(t4.watched[n2]), o2 = i2 ? i2.getValue() : null;
              t4.watched_values[n2] !== o2 && (r3 = true), e4[n2] = o2;
            }), e4.self = this.getValue(), this.watched_values.self !== e4.self && (r3 = true), this.watched_values = e4, r3;
          }
        } }, { key: "getWatchedFieldValues", value: function() {
          return this.watched_values;
        } }, { key: "updateHeaderText", value: function() {
          if (this.header) {
            var t4 = this.getHeaderText();
            if (this.header.children.length) {
              for (var e4 = 0; e4 < this.header.childNodes.length; e4++)
                if (3 === this.header.childNodes[e4].nodeType) {
                  this.header.childNodes[e4].nodeValue = this.cleanText(t4);
                  break;
                }
            } else
              window.DOMPurify ? this.header.innerHTML = window.DOMPurify.sanitize(t4) : this.header.textContent = this.cleanText(t4);
          }
        } }, { key: "getHeaderText", value: function(t4) {
          return this.header_text ? this.header_text : t4 ? this.translateProperty(this.schema.title) : this.getTitle();
        } }, { key: "getPathDepth", value: function() {
          return this.path.split(".").length;
        } }, { key: "cleanText", value: function(t4) {
          var e4 = document.createElement("div");
          return e4.innerHTML = t4, e4.textContent || e4.innerText;
        } }, { key: "onWatchedFieldChange", value: function() {
          var t4;
          if (this.header_template) {
            t4 = l(this.getWatchedFieldValues(), { key: this.key, i: this.key, i0: 1 * this.key, i1: 1 * this.key + 1, title: this.getTitle() });
            var e4 = this.header_template(t4);
            e4 !== this.header_text && (this.header_text = e4, this.updateHeaderText(), this.notify());
          }
          if (this.link_watchers.length) {
            t4 = this.getWatchedFieldValues();
            for (var r3 = 0; r3 < this.link_watchers.length; r3++)
              this.link_watchers[r3](t4);
          }
        } }, { key: "setValue", value: function(t4) {
          this.value = t4;
        } }, { key: "getValue", value: function() {
          if (this.dependenciesFulfilled)
            return this.value;
        } }, { key: "refreshValue", value: function() {
        } }, { key: "getChildEditors", value: function() {
          return false;
        } }, { key: "destroy", value: function() {
          var t4 = this;
          this.unregister(this), this.watched && Object.values(this.watched).forEach(function(e4) {
            return t4.jsoneditor.unwatch(e4, t4.watch_listener);
          }), this.watched = null, this.watched_values = null, this.watch_listener = null, this.header_text = null, this.header_template = null, this.value = null, this.container && this.container.parentNode && this.container.parentNode.removeChild(this.container), this.container = null, this.jsoneditor = null, this.schema = null, this.path = null, this.key = null, this.parent = null;
        } }, { key: "isDefaultRequired", value: function() {
          return this.isRequired() || !!this.jsoneditor.options.use_default_values;
        } }, { key: "getDefault", value: function() {
          if (void 0 !== this.schema.default)
            return this.schema.default;
          if (void 0 !== this.schema.enum)
            return this.schema.enum[0];
          var t4 = this.schema.type || this.schema.oneOf;
          if (t4 && Array.isArray(t4) && (t4 = t4[0]), t4 && "object" === b2(t4) && (t4 = t4.type), t4 && Array.isArray(t4) && (t4 = t4[0]), "string" == typeof t4) {
            if ("number" === t4)
              return this.isDefaultRequired() ? 0 : void 0;
            if ("boolean" === t4)
              return !this.isDefaultRequired() && void 0;
            if ("integer" === t4)
              return this.isDefaultRequired() ? 0 : void 0;
            if ("string" === t4)
              return this.isDefaultRequired() ? "" : void 0;
            if ("null" === t4)
              return null;
            if ("object" === t4)
              return {};
            if ("array" === t4)
              return [];
          }
        } }, { key: "getTitle", value: function() {
          return this.translateProperty(this.schema.title || this.key);
        } }, { key: "enable", value: function() {
          this.disabled = false;
        } }, { key: "disable", value: function() {
          this.disabled = true;
        } }, { key: "isEnabled", value: function() {
          return !this.disabled;
        } }, { key: "isRequired", value: function() {
          return "boolean" == typeof this.schema.required ? this.schema.required : this.parent && this.parent.schema && Array.isArray(this.parent.schema.required) ? this.parent.schema.required.includes(this.key) : !!this.jsoneditor.options.required_by_default;
        } }, { key: "getDisplayText", value: function(t4) {
          var e4 = [], r3 = {};
          t4.forEach(function(t5) {
            t5.title && (r3[t5.title] = r3[t5.title] || 0, r3[t5.title]++), t5.description && (r3[t5.description] = r3[t5.description] || 0, r3[t5.description]++), t5.format && (r3[t5.format] = r3[t5.format] || 0, r3[t5.format]++), t5.type && (r3[t5.type] = r3[t5.type] || 0, r3[t5.type]++);
          }), t4.forEach(function(t5) {
            var n3;
            n3 = "string" == typeof t5 ? t5 : t5.title && r3[t5.title] <= 1 ? t5.title : t5.format && r3[t5.format] <= 1 ? t5.format : t5.type && r3[t5.type] <= 1 ? t5.type : t5.description && r3[t5.description] <= 1 ? t5.description : t5.title ? t5.title : t5.format ? t5.format : t5.type ? t5.type : t5.description ? t5.description : JSON.stringify(t5).length < 500 ? JSON.stringify(t5) : "type", e4.push(n3);
          });
          var n2 = {};
          return e4.forEach(function(t5, i2) {
            n2[t5] = n2[t5] || 0, n2[t5]++, r3[t5] > 1 && (e4[i2] = "".concat(t5, " ").concat(n2[t5]));
          }), e4;
        } }, { key: "getValidId", value: function(t4) {
          return (t4 = void 0 === t4 ? "" : t4.toString()).replace(/\s+/g, "-");
        } }, { key: "setInputAttributes", value: function(t4) {
          var e4 = this;
          if (this.schema.options && this.schema.options.inputAttributes) {
            var r3 = this.schema.options.inputAttributes, n2 = ["name", "type"].concat(t4);
            Object.keys(r3).forEach(function(t5) {
              n2.includes(t5.toLowerCase()) || e4.input.setAttribute(t5, r3[t5]);
            });
          }
        } }, { key: "setContainerAttributes", value: function() {
          var t4 = this;
          if (this.schema.options && this.schema.options.containerAttributes) {
            var e4 = this.schema.options.containerAttributes, r3 = ["data-schemapath", "data-schematype", "data-schemaid"];
            Object.keys(e4).forEach(function(n2) {
              r3.includes(n2.toLowerCase()) || t4.container.setAttribute(n2, e4[n2]);
            });
          }
        } }, { key: "expandCallbacks", value: function(t4, e4) {
          var r3 = this, n2 = this.defaults.callbacks[t4];
          return Object.entries(e4).forEach(function(i2) {
            var o2, a2, s2 = (a2 = 2, function(t5) {
              if (Array.isArray(t5))
                return t5;
            }(o2 = i2) || function(t5, e5) {
              var r4 = null == t5 ? null : "undefined" != typeof Symbol && t5[Symbol.iterator] || t5["@@iterator"];
              if (null != r4) {
                var n3, i3, o3, a3, s3 = [], l3 = true, c4 = false;
                try {
                  if (o3 = (r4 = r4.call(t5)).next, 0 === e5) {
                    if (Object(r4) !== r4)
                      return;
                    l3 = false;
                  } else
                    for (; !(l3 = (n3 = o3.call(r4)).done) && (s3.push(n3.value), s3.length !== e5); l3 = true)
                      ;
                } catch (t6) {
                  c4 = true, i3 = t6;
                } finally {
                  try {
                    if (!l3 && null != r4.return && (a3 = r4.return(), Object(a3) !== a3))
                      return;
                  } finally {
                    if (c4)
                      throw i3;
                  }
                }
                return s3;
              }
            }(o2, a2) || function(t5, e5) {
              if (t5) {
                if ("string" == typeof t5)
                  return v2(t5, e5);
                var r4 = Object.prototype.toString.call(t5).slice(8, -1);
                return "Object" === r4 && t5.constructor && (r4 = t5.constructor.name), "Map" === r4 || "Set" === r4 ? Array.from(t5) : "Arguments" === r4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r4) ? v2(t5, e5) : void 0;
              }
            }(o2, a2) || function() {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }()), l2 = s2[0], c3 = s2[1];
            c3 === Object(c3) ? e4[l2] = r3.expandCallbacks(t4, c3) : "string" == typeof c3 && "object" === b2(n2) && "function" == typeof n2[c3] && (e4[l2] = n2[c3].bind(null, r3));
          }), e4;
        } }, { key: "showValidationErrors", value: function(t4) {
        } }], r2 && g2(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), t3;
      }();
      function _2(t3) {
        return _2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, _2(t3);
      }
      function k2(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== _2(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== _2(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === _2(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      function j2() {
        return j2 = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t3, e3, r2) {
          var n2 = function(t4, e4) {
            for (; !Object.prototype.hasOwnProperty.call(t4, e4) && null !== (t4 = x2(t4)); )
              ;
            return t4;
          }(t3, e3);
          if (n2) {
            var i2 = Object.getOwnPropertyDescriptor(n2, e3);
            return i2.get ? i2.get.call(arguments.length < 3 ? t3 : r2) : i2.value;
          }
        }, j2.apply(this, arguments);
      }
      function O2(t3, e3) {
        return O2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, O2(t3, e3);
      }
      function x2(t3) {
        return x2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, x2(t3);
      }
      var C2 = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && O2(t4, e4);
        }(a2, t3);
        var e3, r2, n2, i2, o2 = (n2 = a2, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = x2(n2);
          if (i2) {
            var r3 = x2(this).constructor;
            t4 = Reflect.construct(e4, arguments, r3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === _2(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function a2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), o2.apply(this, arguments);
        }
        return e3 = a2, (r2 = [{ key: "register", value: function() {
          j2(x2(a2.prototype), "register", this).call(this), this.input && (this.jsoneditor.options.use_name_attributes && this.input.setAttribute("name", this.formname), this.input.setAttribute("aria-label", this.formname));
        } }, { key: "unregister", value: function() {
          j2(x2(a2.prototype), "unregister", this).call(this), this.input && (this.input.removeAttribute("name"), this.input.removeAttribute("aria-label"));
        } }, { key: "setValue", value: function(t4, e4, r3) {
          if ((!this.template || r3) && (this.shouldBeUnset() || null != t4 ? "object" === _2(t4) ? t4 = JSON.stringify(t4) : this.shouldBeUnset() || "string" == typeof t4 || (t4 = "".concat(t4)) : t4 = "", t4 !== this.serialized)) {
            var n3 = this.sanitize(t4);
            if (this.input.value !== n3) {
              if (this.setValueToInputField(n3), "range" === this.format) {
                var i3 = this.control.querySelector("output");
                i3 && (i3.value = n3);
              }
              var o3 = r3 || this.getValue() !== t4;
              return this.refreshValue(), e4 ? this.is_dirty = false : "change" === this.jsoneditor.options.show_errors && (this.is_dirty = true), this.adjust_height && this.adjust_height(this.input), this.onChange(o3), { changed: o3, value: n3 };
            }
          }
        } }, { key: "setValueToInputField", value: function(t4) {
          this.input.value = void 0 === t4 ? "" : t4;
        } }, { key: "getNumColumns", value: function() {
          var t4, e4 = Math.ceil(Math.max(this.getTitle().length, this.schema.maxLength || 0, this.schema.minLength || 0) / 5);
          return t4 = "textarea" === this.input_type ? 6 : ["text", "email"].includes(this.input_type) ? 4 : 2, Math.min(12, Math.max(e4, t4));
        } }, { key: "build", value: function() {
          var t4 = this;
          if (this.options.compact || (this.header = this.label = this.theme.getFormInputLabel(this.getTitle(), this.isRequired())), this.schema.description && (this.description = this.theme.getFormInputDescription(this.translateProperty(this.schema.description))), this.options.infoText && (this.infoButton = this.theme.getInfoButton(this.translateProperty(this.options.infoText))), this.format = this.schema.format, !this.format && this.schema.media && this.schema.media.type && (this.format = this.schema.media.type.replace(/(^(application|text)\/(x-)?(script\.)?)|(-source$)/g, "")), !this.format && this.options.default_format && (this.format = this.options.default_format), this.options.format && (this.format = this.options.format), this.format)
            if ("textarea" === this.format)
              this.input_type = "textarea", this.input = this.theme.getTextareaInput();
            else if ("range" === this.format) {
              this.input_type = "range";
              var e4 = this.schema.minimum || 0, r3 = this.schema.maximum || Math.max(100, e4 + 1), n3 = 1;
              this.schema.multipleOf && (e4 % this.schema.multipleOf && (e4 = Math.ceil(e4 / this.schema.multipleOf) * this.schema.multipleOf), r3 % this.schema.multipleOf && (r3 = Math.floor(r3 / this.schema.multipleOf) * this.schema.multipleOf), n3 = this.schema.multipleOf), this.input = this.theme.getRangeInput(e4, r3, n3);
            } else
              this.input_type = "text", ["button", "checkbox", "color", "date", "datetime-local", "email", "file", "hidden", "image", "month", "number", "password", "radio", "reset", "search", "submit", "tel", "text", "time", "url", "week"].includes(this.format) && (this.input_type = this.format), this.input = this.theme.getFormInputField(this.input_type);
          else
            this.input_type = "text", this.input = this.theme.getFormInputField(this.input_type);
          void 0 !== this.schema.maxLength && this.input.setAttribute("maxlength", this.schema.maxLength), void 0 !== this.schema.pattern ? this.input.setAttribute("pattern", this.schema.pattern) : void 0 !== this.schema.minLength && this.input.setAttribute("pattern", ".{".concat(this.schema.minLength, ",}")), this.options.compact ? this.container.classList.add("compact") : this.options.input_width && (this.input.style.width = this.options.input_width), (this.schema.readOnly || this.schema.readonly || this.schema.template) && (this.disable(true), this.input.setAttribute("readonly", "true")), this.setInputAttributes(["maxlength", "pattern", "readonly", "min", "max", "step"]), this.input.addEventListener("change", function(e5) {
            if (e5.preventDefault(), e5.stopPropagation(), t4.schema.template)
              e5.currentTarget.value = t4.value;
            else {
              var r4 = e5.currentTarget.value, n4 = t4.sanitize(r4);
              r4 !== n4 && (e5.currentTarget.value = n4), t4.is_dirty = true, t4.refreshValue(), t4.onChange(true);
            }
          }), this.options.input_height && (this.input.style.height = this.options.input_height), this.options.expand_height && (this.adjust_height = function(t5) {
            if (t5) {
              var e5, r4 = t5.offsetHeight;
              if (t5.offsetHeight < t5.scrollHeight)
                for (e5 = 0; t5.offsetHeight < t5.scrollHeight + 3 && !(e5 > 100); )
                  e5++, r4++, t5.style.height = "".concat(r4, "px");
              else {
                for (e5 = 0; t5.offsetHeight >= t5.scrollHeight + 3 && !(e5 > 100); )
                  e5++, r4--, t5.style.height = "".concat(r4, "px");
                t5.style.height = "".concat(r4 + 1, "px");
              }
            }
          }, this.input.addEventListener("keyup", function(e5) {
            t4.adjust_height(e5.currentTarget);
          }), this.input.addEventListener("change", function(e5) {
            t4.adjust_height(e5.currentTarget);
          }), this.adjust_height()), this.format && this.input.setAttribute("data-schemaformat", this.format);
          var i3 = this.input;
          if ("range" === this.format && (i3 = this.theme.getRangeControl(this.input, this.theme.getRangeOutput(this.input, this.schema.default || Math.max(this.schema.minimum || 0, 0)))), this.control = this.theme.getFormControl(this.label, i3, this.description, this.infoButton, this.formname), this.container.appendChild(this.control), window.requestAnimationFrame(function() {
            t4.input.parentNode && t4.afterInputReady(), t4.adjust_height && t4.adjust_height(t4.input), "range" === t4.format && (t4.control.querySelector("output").value = t4.input.value);
          }), this.schema.template) {
            var o3 = this.expandCallbacks("template", { template: this.schema.template });
            "function" == typeof o3.template ? this.template = o3.template : this.template = this.jsoneditor.compileTemplate(this.schema.template, this.template_engine), this.refreshValue();
          } else
            this.refreshValue();
        } }, { key: "setupCleave", value: function(t4) {
          var e4 = this.expandCallbacks("cleave", l({}, this.defaults.options.cleave || {}, this.options.cleave || {}));
          "object" === _2(e4) && Object.keys(e4).length > 0 && (this.cleave_instance = new window.Cleave(t4, e4));
        } }, { key: "setupImask", value: function(t4) {
          var e4 = this.expandCallbacks("imask", l({}, this.defaults.options.imask || {}, this.options.imask || {}));
          "object" === _2(e4) && Object.keys(e4).length > 0 && (this.imask_instance = window.IMask(t4, this.ajustIMaskOptions(e4)));
        } }, { key: "ajustIMaskOptions", value: function(t4) {
          var e4 = this;
          return Object.keys(t4).forEach(function(r3) {
            if (t4[r3] === Object(t4[r3]))
              t4[r3] = e4.ajustIMaskOptions(t4[r3]);
            else if ("mask" === r3)
              if ("regex:" === t4[r3].substr(0, 6)) {
                var n3 = t4[r3].match(/^regex:\/(.*)\/([gimsuy]*)$/);
                if (null !== n3)
                  try {
                    t4[r3] = new RegExp(n3[1], n3[2]);
                  } catch (t5) {
                  }
              } else
                t4[r3] = e4.getGlobalPropertyFromString(t4[r3]);
          }), t4;
        } }, { key: "getGlobalPropertyFromString", value: function(t4) {
          if (t4.includes(".")) {
            var e4 = t4.split("."), r3 = e4[0], n3 = e4[1];
            if (void 0 !== window[r3] && void 0 !== window[r3][n3])
              return window[r3][n3];
          } else if (void 0 !== window[t4])
            return window[t4];
          return t4;
        } }, { key: "shouldBeUnset", value: function() {
          return !this.jsoneditor.options.use_default_values && !this.is_dirty;
        } }, { key: "getValue", value: function() {
          var t4 = !(!this.input || !this.input.value);
          if (!this.shouldBeUnset() || t4)
            return this.imask_instance && this.dependenciesFulfilled && this.options.imask.returnUnmasked ? this.imask_instance.unmaskedValue : j2(x2(a2.prototype), "getValue", this).call(this);
        } }, { key: "enable", value: function() {
          this.always_disabled || (this.input.disabled = false, j2(x2(a2.prototype), "enable", this).call(this));
        } }, { key: "disable", value: function(t4) {
          t4 && (this.always_disabled = true), this.input.disabled = true, j2(x2(a2.prototype), "disable", this).call(this);
        } }, { key: "afterInputReady", value: function() {
          this.theme.afterInputReady(this.input), window.Cleave && !this.cleave_instance ? this.setupCleave(this.input) : window.IMask && !this.imask_instance && this.setupImask(this.input);
        } }, { key: "refreshValue", value: function() {
          this.value = this.input.value, "string" == typeof this.value || this.shouldBeUnset() || (this.value = ""), this.serialized = this.value;
        } }, { key: "destroy", value: function() {
          this.cleave_instance && this.cleave_instance.destroy(), this.imask_instance && this.imask_instance.destroy(), this.template = null, this.input && this.input.parentNode && this.input.parentNode.removeChild(this.input), this.label && this.label.parentNode && this.label.parentNode.removeChild(this.label), this.description && this.description.parentNode && this.description.parentNode.removeChild(this.description), j2(x2(a2.prototype), "destroy", this).call(this);
        } }, { key: "sanitize", value: function(t4) {
          return t4;
        } }, { key: "onWatchedFieldChange", value: function() {
          var t4;
          this.template && (t4 = this.getWatchedFieldValues(), this.setValue(this.template(t4), false, true)), j2(x2(a2.prototype), "onWatchedFieldChange", this).call(this);
        } }, { key: "showValidationErrors", value: function(t4) {
          var e4 = this;
          if ("always" === this.jsoneditor.options.show_errors)
            ;
          else if (!this.is_dirty && this.previous_error_setting === this.jsoneditor.options.show_errors)
            return;
          this.previous_error_setting = this.jsoneditor.options.show_errors;
          var r3 = t4.reduce(function(t5, r4) {
            return r4.path === e4.path && t5.push(r4.message), t5;
          }, []);
          r3.length ? this.theme.addInputError(this.input, "".concat(r3.join(". "), ".")) : this.theme.removeInputError(this.input);
        } }]) && k2(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), a2;
      }(w2);
      function E2(t3) {
        return E2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, E2(t3);
      }
      function S2(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== E2(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== E2(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === E2(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      function P2() {
        return P2 = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t3, e3, r2) {
          var n2 = function(t4, e4) {
            for (; !Object.prototype.hasOwnProperty.call(t4, e4) && null !== (t4 = L2(t4)); )
              ;
            return t4;
          }(t3, e3);
          if (n2) {
            var i2 = Object.getOwnPropertyDescriptor(n2, e3);
            return i2.get ? i2.get.call(arguments.length < 3 ? t3 : r2) : i2.value;
          }
        }, P2.apply(this, arguments);
      }
      function T2(t3, e3) {
        return T2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, T2(t3, e3);
      }
      function L2(t3) {
        return L2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, L2(t3);
      }
      var R2 = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && T2(t4, e4);
        }(a2, t3);
        var e3, r2, n2, i2, o2 = (n2 = a2, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = L2(n2);
          if (i2) {
            var r3 = L2(this).constructor;
            t4 = Reflect.construct(e4, arguments, r3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === E2(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function a2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), o2.apply(this, arguments);
        }
        return e3 = a2, (r2 = [{ key: "setValue", value: function(t4, e4, r3) {
          var n3 = P2(L2(a2.prototype), "setValue", this).call(this, t4, e4, r3);
          void 0 !== n3 && n3.changed && this.ace_editor_instance && (this.ace_editor_instance.setValue(n3.value), this.ace_editor_instance.session.getSelection().clearSelection(), this.ace_editor_instance.resize());
        } }, { key: "build", value: function() {
          this.options.format = "textarea", P2(L2(a2.prototype), "build", this).call(this), this.input_type = this.schema.format, this.input.setAttribute("data-schemaformat", this.input_type);
        } }, { key: "afterInputReady", value: function() {
          var t4, e4 = this;
          if (window.ace) {
            var r3 = this.input_type;
            "cpp" !== r3 && "c++" !== r3 && "c" !== r3 || (r3 = "c_cpp"), t4 = this.expandCallbacks("ace", l({}, { selectionStyle: "text", minLines: 30, maxLines: 30 }, this.defaults.options.ace || {}, this.options.ace || {}, { mode: "ace/mode/".concat(r3) })), this.ace_container = document.createElement("div"), this.ace_container.style.width = "100%", this.ace_container.style.position = "relative", this.input.parentNode.insertBefore(this.ace_container, this.input), this.input.style.display = "none", this.ace_editor_instance = window.ace.edit(this.ace_container, t4), this.ace_editor_instance.setValue(this.getValue()), this.ace_editor_instance.session.getSelection().clearSelection(), this.ace_editor_instance.resize(), (this.schema.readOnly || this.schema.readonly || this.schema.template) && this.ace_editor_instance.setReadOnly(true), this.ace_editor_instance.on("change", function() {
              e4.input.value = e4.ace_editor_instance.getValue(), e4.refreshValue(), e4.is_dirty = true, e4.onChange(true);
            }), this.theme.afterInputReady(this.input);
          } else
            P2(L2(a2.prototype), "afterInputReady", this).call(this);
        } }, { key: "getNumColumns", value: function() {
          return 6;
        } }, { key: "enable", value: function() {
          !this.always_disabled && this.ace_editor_instance && this.ace_editor_instance.setReadOnly(false), P2(L2(a2.prototype), "enable", this).call(this);
        } }, { key: "disable", value: function(t4) {
          this.ace_editor_instance && this.ace_editor_instance.setReadOnly(true), P2(L2(a2.prototype), "disable", this).call(this, t4);
        } }, { key: "destroy", value: function() {
          this.ace_editor_instance && (this.ace_editor_instance.destroy(), this.ace_editor_instance = null), P2(L2(a2.prototype), "destroy", this).call(this);
        } }]) && S2(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), a2;
      }(C2);
      function A2(t3) {
        return A2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, A2(t3);
      }
      function I2(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== A2(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== A2(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === A2(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      function B2() {
        return B2 = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t3, e3, r2) {
          var n2 = function(t4, e4) {
            for (; !Object.prototype.hasOwnProperty.call(t4, e4) && null !== (t4 = D2(t4)); )
              ;
            return t4;
          }(t3, e3);
          if (n2) {
            var i2 = Object.getOwnPropertyDescriptor(n2, e3);
            return i2.get ? i2.get.call(arguments.length < 3 ? t3 : r2) : i2.value;
          }
        }, B2.apply(this, arguments);
      }
      function N2(t3, e3) {
        return N2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, N2(t3, e3);
      }
      function D2(t3) {
        return D2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, D2(t3);
      }
      r(7327);
      var F2 = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && N2(t4, e4);
        }(a2, t3);
        var e3, r2, n2, i2, o2 = (n2 = a2, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = D2(n2);
          if (i2) {
            var r3 = D2(this).constructor;
            t4 = Reflect.construct(e4, arguments, r3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === A2(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function a2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), o2.apply(this, arguments);
        }
        return e3 = a2, r2 = [{ key: "askConfirmation", value: function() {
          return true !== this.jsoneditor.options.prompt_before_delete || false !== window.confirm(this.translate("button_delete_node_warning"));
        } }, { key: "getDefault", value: function() {
          return this.schema.default || [];
        } }, { key: "register", value: function() {
          B2(D2(a2.prototype), "register", this).call(this), this.rows && this.rows.forEach(function(t4) {
            return t4.register();
          });
        } }, { key: "unregister", value: function() {
          B2(D2(a2.prototype), "unregister", this).call(this), this.rows && this.rows.forEach(function(t4) {
            return t4.unregister();
          });
        } }, { key: "getNumColumns", value: function() {
          var t4 = this.getItemInfo(0);
          return this.tabs_holder && "tabs-top" !== this.schema.format ? Math.max(Math.min(12, t4.width + 2), 4) : t4.width;
        } }, { key: "enable", value: function() {
          var t4 = this;
          this.always_disabled || (this.setAvailability(this, false), this.rows && this.rows.forEach(function(e4) {
            e4.enable(), t4.setAvailability(e4, false);
          }), B2(D2(a2.prototype), "enable", this).call(this));
        } }, { key: "disable", value: function(t4) {
          var e4 = this;
          t4 && (this.always_disabled = true), this.setAvailability(this, true), this.rows && this.rows.forEach(function(r3) {
            r3.disable(t4), e4.setAvailability(r3, true);
          }), B2(D2(a2.prototype), "disable", this).call(this);
        } }, { key: "setAvailability", value: function(t4, e4) {
          t4.add_row_button && (t4.add_row_button.disabled = e4), t4.remove_all_rows_button && (t4.remove_all_rows_button.disabled = e4), t4.delete_last_row_button && (t4.delete_last_row_button.disabled = e4), t4.copy_button && (t4.copy_button.disabled = e4), t4.delete_button && (t4.delete_button.disabled = e4), t4.moveup_button && (t4.moveup_button.disabled = e4), t4.movedown_button && (t4.movedown_button.disabled = e4);
        } }, { key: "preBuild", value: function() {
          B2(D2(a2.prototype), "preBuild", this).call(this), this.rows = [], this.row_cache = [], this.hide_delete_buttons = this.options.disable_array_delete || this.jsoneditor.options.disable_array_delete, this.hide_delete_all_rows_buttons = this.hide_delete_buttons || this.options.disable_array_delete_all_rows || this.jsoneditor.options.disable_array_delete_all_rows, this.hide_delete_last_row_buttons = this.hide_delete_buttons || this.options.disable_array_delete_last_row || this.jsoneditor.options.disable_array_delete_last_row, this.hide_move_buttons = this.options.disable_array_reorder || this.jsoneditor.options.disable_array_reorder, this.hide_add_button = this.options.disable_array_add || this.jsoneditor.options.disable_array_add, this.show_copy_button = this.options.enable_array_copy || this.jsoneditor.options.enable_array_copy, this.array_controls_top = this.options.array_controls_top || this.jsoneditor.options.array_controls_top;
        } }, { key: "build", value: function() {
          this.options.compact ? (this.title = this.theme.getHeader("", this.getPathDepth()), this.container.appendChild(this.title), this.panel = this.theme.getIndentedPanel(), this.container.appendChild(this.panel), this.title_controls = this.theme.getHeaderButtonHolder(), this.title.appendChild(this.title_controls), this.controls = this.theme.getHeaderButtonHolder(), this.title.appendChild(this.controls), this.row_holder = document.createElement("div"), this.panel.appendChild(this.row_holder)) : (this.header = document.createElement("label"), this.header.textContent = this.getTitle(), this.title = this.theme.getHeader(this.header, this.getPathDepth()), this.container.appendChild(this.title), this.options.infoText && (this.infoButton = this.theme.getInfoButton(this.translateProperty(this.options.infoText)), this.container.appendChild(this.infoButton)), this.title_controls = this.theme.getHeaderButtonHolder(), this.title.appendChild(this.title_controls), this.schema.description && (this.description = this.theme.getDescription(this.translateProperty(this.schema.description)), this.container.appendChild(this.description)), this.error_holder = document.createElement("div"), this.container.appendChild(this.error_holder), "tabs-top" === this.schema.format ? (this.controls = this.theme.getHeaderButtonHolder(), this.title.appendChild(this.controls), this.tabs_holder = this.theme.getTopTabHolder(this.getValidId(this.getItemTitle())), this.container.appendChild(this.tabs_holder), this.row_holder = this.theme.getTopTabContentHolder(this.tabs_holder), this.active_tab = null) : "tabs" === this.schema.format ? (this.controls = this.theme.getHeaderButtonHolder(), this.title.appendChild(this.controls), this.tabs_holder = this.theme.getTabHolder(this.getValidId(this.getItemTitle())), this.container.appendChild(this.tabs_holder), this.row_holder = this.theme.getTabContentHolder(this.tabs_holder), this.active_tab = null) : (this.panel = this.theme.getIndentedPanel(), this.container.appendChild(this.panel), this.row_holder = document.createElement("div"), this.panel.appendChild(this.row_holder), this.controls = this.theme.getButtonHolder(), this.array_controls_top ? this.title.appendChild(this.controls) : this.panel.appendChild(this.controls))), this.addControls();
        } }, { key: "onChildEditorChange", value: function(t4) {
          this.refreshValue(), this.refreshTabs(true), B2(D2(a2.prototype), "onChildEditorChange", this).call(this, t4);
        } }, { key: "getItemTitle", value: function() {
          if (!this.item_title)
            if (this.schema.items && !Array.isArray(this.schema.items)) {
              var t4 = this.jsoneditor.expandRefs(this.schema.items);
              this.item_title = this.translateProperty(t4.title) || this.translate("default_array_item_title");
            } else
              this.item_title = this.translate("default_array_item_title");
          return this.cleanText(this.item_title);
        } }, { key: "getItemSchema", value: function(t4) {
          return Array.isArray(this.schema.items) ? t4 >= this.schema.items.length ? true === this.schema.additionalItems ? {} : this.schema.additionalItems ? l({}, this.schema.additionalItems) : void 0 : l({}, this.schema.items[t4]) : this.schema.items ? l({}, this.schema.items) : {};
        } }, { key: "getItemInfo", value: function(t4) {
          var e4 = this.getItemSchema(t4);
          this.item_info = this.item_info || {};
          var r3 = JSON.stringify(e4);
          return void 0 !== this.item_info[r3] || (e4 = this.jsoneditor.expandRefs(e4), this.item_info[r3] = { title: this.translateProperty(e4.title) || this.translate("default_array_item_title"), default: e4.default, width: 12, child_editors: e4.properties || e4.items }), this.item_info[r3];
        } }, { key: "getElementEditor", value: function(t4) {
          var e4 = this.getItemInfo(t4), r3 = this.getItemSchema(t4);
          (r3 = this.jsoneditor.expandRefs(r3)).title = "".concat(e4.title, " ").concat(t4 + 1);
          var n3, i3 = this.jsoneditor.getEditorClass(r3);
          this.tabs_holder ? (n3 = "tabs-top" === this.schema.format ? this.theme.getTopTabContent() : this.theme.getTabContent()).id = "".concat(this.path, ".").concat(t4) : n3 = e4.child_editors ? this.theme.getChildEditorHolder() : this.theme.getIndentedPanel(), this.row_holder.appendChild(n3);
          var o3 = this.jsoneditor.createEditor(i3, { jsoneditor: this.jsoneditor, schema: r3, container: n3, path: "".concat(this.path, ".").concat(t4), parent: this, required: true });
          return o3.preBuild(), o3.build(), o3.postBuild(), o3.title_controls || (o3.array_controls = this.theme.getButtonHolder(), n3.appendChild(o3.array_controls)), o3;
        } }, { key: "checkParent", value: function(t4) {
          return t4 && t4.parentNode;
        } }, { key: "destroy", value: function() {
          this.empty(true), this.checkParent(this.title) && this.title.parentNode.removeChild(this.title), this.checkParent(this.description) && this.description.parentNode.removeChild(this.description), this.checkParent(this.row_holder) && this.row_holder.parentNode.removeChild(this.row_holder), this.checkParent(this.controls) && this.controls.parentNode.removeChild(this.controls), this.checkParent(this.panel) && this.panel.parentNode.removeChild(this.panel), this.rows = this.row_cache = this.title = this.description = this.row_holder = this.panel = this.controls = null, B2(D2(a2.prototype), "destroy", this).call(this);
        } }, { key: "empty", value: function(t4) {
          var e4 = this;
          this.rows && (this.rows.forEach(function(r3, n3) {
            t4 && (e4.checkParent(r3.tab) && r3.tab.parentNode.removeChild(r3.tab), e4.destroyRow(r3, true), e4.row_cache[n3] = null), e4.rows[n3] = null;
          }), this.rows = [], t4 && (this.row_cache = []));
        } }, { key: "destroyRow", value: function(t4, e4) {
          var r3 = t4.container;
          e4 ? (t4.destroy(), r3.parentNode && r3.parentNode.removeChild(r3), this.checkParent(t4.tab) && t4.tab.parentNode.removeChild(t4.tab)) : (t4.tab && (t4.tab.style.display = "none"), r3.style.display = "none", t4.unregister());
        } }, { key: "getMax", value: function() {
          return Array.isArray(this.schema.items) && false === this.schema.additionalItems ? Math.min(this.schema.items.length, this.schema.maxItems || 1 / 0) : this.schema.maxItems || 1 / 0;
        } }, { key: "refreshTabs", value: function(t4) {
          var e4 = this;
          this.rows.forEach(function(r3) {
            r3.tab && (t4 ? r3.tab_text.textContent = r3.getHeaderText() : r3.tab === e4.active_tab ? e4.theme.markTabActive(r3) : e4.theme.markTabInactive(r3));
          });
        } }, { key: "ensureArraySize", value: function(t4) {
          if (Array.isArray(t4) || (t4 = [t4]), this.schema.minItems)
            for (; t4.length < this.schema.minItems; )
              t4.push(this.getItemInfo(t4.length).default);
          return this.getMax() && t4.length > this.getMax() && (t4 = t4.slice(0, this.getMax())), t4;
        } }, { key: "setValue", value: function() {
          var t4 = this, e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], r3 = arguments.length > 1 ? arguments[1] : void 0;
          if (e4 = this.ensureArraySize(e4), JSON.stringify(e4) !== this.serialized) {
            e4.forEach(function(e5, n4) {
              if (t4.rows[n4])
                t4.rows[n4].setValue(e5, r3);
              else if (t4.row_cache[n4])
                t4.rows[n4] = t4.row_cache[n4], t4.rows[n4].setValue(e5, r3), t4.rows[n4].container.style.display = "", t4.rows[n4].tab && (t4.rows[n4].tab.style.display = ""), t4.rows[n4].register(), t4.jsoneditor.trigger("addRow", t4.rows[n4]);
              else {
                var i4 = t4.addRow(e5, r3);
                t4.jsoneditor.trigger("addRow", i4);
              }
            });
            for (var n3 = e4.length; n3 < this.rows.length; n3++)
              this.destroyRow(this.rows[n3]), this.rows[n3] = null;
            this.rows = this.rows.slice(0, e4.length);
            var i3 = this.rows.find(function(e5) {
              return e5.tab === t4.active_tab;
            }), o3 = void 0 !== i3 ? i3.tab : null;
            !o3 && this.rows.length && (o3 = this.rows[0].tab), this.active_tab = o3, this.refreshValue(r3), this.refreshTabs(true), this.refreshTabs(), this.onChange();
          }
        } }, { key: "setVisibility", value: function(t4, e4) {
          t4.style.display = e4 ? "" : "none";
        } }, { key: "setupButtons", value: function(t4) {
          var e4 = [];
          if (this.value.length)
            if (1 === this.value.length) {
              this.remove_all_rows_button.style.display = "none";
              var r3 = !(t4 || this.hide_delete_last_row_buttons);
              this.setVisibility(this.delete_last_row_button, r3), e4.push(r3);
            } else {
              var n3 = !(t4 || this.hide_delete_last_row_buttons);
              this.setVisibility(this.delete_last_row_button, n3), e4.push(n3);
              var i3 = !(t4 || this.hide_delete_all_rows_buttons);
              this.setVisibility(this.remove_all_rows_button, i3), e4.push(i3);
            }
          else
            this.delete_last_row_button.style.display = "none", this.remove_all_rows_button.style.display = "none";
          var o3 = !(this.getMax() && this.getMax() <= this.rows.length || this.hide_add_button);
          return this.setVisibility(this.add_row_button, o3), e4.push(o3), e4.some(function(t5) {
            return t5;
          });
        } }, { key: "refreshValue", value: function(t4) {
          var e4 = this, r3 = this.value ? this.value.length : 0;
          if (this.value = this.rows.map(function(t5) {
            return t5.getValue();
          }), r3 !== this.value.length || t4) {
            var n3 = this.schema.minItems && this.schema.minItems >= this.rows.length;
            this.rows.forEach(function(t5, r4) {
              if (t5.movedown_button) {
                var i3 = r4 !== e4.rows.length - 1;
                e4.setVisibility(t5.movedown_button, i3);
              }
              t5.delete_button && e4.setVisibility(t5.delete_button, !n3), e4.value[r4] = t5.getValue();
            }), !this.collapsed && this.setupButtons(n3) ? this.controls.style.display = "inline-block" : this.controls.style.display = "none";
          }
          this.serialized = JSON.stringify(this.value);
        } }, { key: "addRow", value: function(t4, e4) {
          var r3 = this, n3 = this.rows.length;
          this.rows[n3] = this.getElementEditor(n3), this.row_cache[n3] = this.rows[n3], this.tabs_holder && (this.rows[n3].tab_text = document.createElement("span"), this.rows[n3].tab_text.textContent = this.rows[n3].getHeaderText(), "tabs-top" === this.schema.format ? (this.rows[n3].tab = this.theme.getTopTab(this.rows[n3].tab_text, this.getValidId(this.rows[n3].path)), this.theme.addTopTab(this.tabs_holder, this.rows[n3].tab)) : (this.rows[n3].tab = this.theme.getTab(this.rows[n3].tab_text, this.getValidId(this.rows[n3].path)), this.theme.addTab(this.tabs_holder, this.rows[n3].tab)), this.rows[n3].tab.addEventListener("click", function(t5) {
            r3.active_tab = r3.rows[n3].tab, r3.refreshTabs(), t5.preventDefault(), t5.stopPropagation();
          }));
          var i3 = this.rows[n3].title_controls || this.rows[n3].array_controls;
          return this.hide_delete_buttons || (this.rows[n3].delete_button = this._createDeleteButton(n3, i3)), this.show_copy_button && (this.rows[n3].copy_button = this._createCopyButton(n3, i3)), n3 && !this.hide_move_buttons && (this.rows[n3].moveup_button = this._createMoveUpButton(n3, i3)), this.hide_move_buttons || (this.rows[n3].movedown_button = this._createMoveDownButton(n3, i3)), void 0 !== t4 && this.rows[n3].setValue(t4, e4), this.refreshTabs(), this.rows[n3];
        } }, { key: "_createDeleteButton", value: function(t4, e4) {
          var r3 = this, n3 = this.getButton(this.getItemTitle(), "delete", "button_delete_row_title", [this.getItemTitle()]);
          return n3.classList.add("delete", "json-editor-btntype-delete"), n3.setAttribute("data-i", t4), n3.addEventListener("click", function(t5) {
            if (t5.preventDefault(), t5.stopPropagation(), !r3.askConfirmation())
              return false;
            var e5 = 1 * t5.currentTarget.getAttribute("data-i"), n4 = r3.getValue().filter(function(t6, r4) {
              return r4 !== e5;
            }), i3 = null, o3 = r3.rows[e5].getValue();
            r3.setValue(n4), r3.rows[e5] ? i3 = r3.rows[e5].tab : r3.rows[e5 - 1] && (i3 = r3.rows[e5 - 1].tab), i3 && (r3.active_tab = i3, r3.refreshTabs()), r3.onChange(true), r3.jsoneditor.trigger("deleteRow", o3);
          }), e4 && e4.appendChild(n3), n3;
        } }, { key: "_createCopyButton", value: function(t4, e4) {
          var r3 = this, n3 = this.getButton(this.getItemTitle(), "copy", "button_copy_row_title", [this.getItemTitle()]), i3 = this.schema;
          return n3.classList.add("copy", "json-editor-btntype-copy"), n3.setAttribute("data-i", t4), n3.addEventListener("click", function(t5) {
            var e5 = r3.getValue();
            t5.preventDefault(), t5.stopPropagation();
            var n4 = 1 * t5.currentTarget.getAttribute("data-i");
            e5.forEach(function(t6, r4) {
              if (r4 === n4) {
                if ("string" === i3.items.type && "uuid" === i3.items.format)
                  t6 = f2();
                else if ("object" === i3.items.type && i3.items.properties)
                  for (var o3 = 0, a3 = Object.keys(t6); o3 < a3.length; o3++) {
                    var s2 = a3[o3];
                    i3.items.properties && i3.items.properties[s2] && "uuid" === i3.items.properties[s2].format && (t6[s2] = f2());
                  }
                e5.push(t6);
              }
            }), r3.setValue(e5), r3.refreshValue(true), r3.onChange(true);
          }), e4.appendChild(n3), n3;
        } }, { key: "_createMoveUpButton", value: function(t4, e4) {
          var r3 = this, n3 = this.getButton("", "tabs-top" === this.schema.format ? "moveleft" : "moveup", "button_move_up_title");
          return n3.classList.add("moveup", "json-editor-btntype-move"), n3.setAttribute("data-i", t4), n3.addEventListener("click", function(t5) {
            t5.preventDefault(), t5.stopPropagation();
            var e5 = 1 * t5.currentTarget.getAttribute("data-i");
            if (!(e5 <= 0)) {
              var n4 = r3.getValue(), i3 = n4[e5 - 1];
              n4[e5 - 1] = n4[e5], n4[e5] = i3, r3.setValue(n4), r3.active_tab = r3.rows[e5 - 1].tab, r3.refreshTabs(), r3.onChange(true), r3.jsoneditor.trigger("moveRow", r3.rows[e5 - 1]);
            }
          }), e4 && e4.appendChild(n3), n3;
        } }, { key: "_createMoveDownButton", value: function(t4, e4) {
          var r3 = this, n3 = this.getButton("", "tabs-top" === this.schema.format ? "moveright" : "movedown", "button_move_down_title");
          return n3.classList.add("movedown", "json-editor-btntype-move"), n3.setAttribute("data-i", t4), n3.addEventListener("click", function(t5) {
            t5.preventDefault(), t5.stopPropagation();
            var e5 = 1 * t5.currentTarget.getAttribute("data-i"), n4 = r3.getValue();
            if (!(e5 >= n4.length - 1)) {
              var i3 = n4[e5 + 1];
              n4[e5 + 1] = n4[e5], n4[e5] = i3, r3.setValue(n4), r3.active_tab = r3.rows[e5 + 1].tab, r3.refreshTabs(), r3.onChange(true), r3.jsoneditor.trigger("moveRow", r3.rows[e5 + 1]);
            }
          }), e4 && e4.appendChild(n3), n3;
        } }, { key: "addControls", value: function() {
          this.collapsed = false, this.toggle_button = this._createToggleButton(), this.options.collapsed && c2(this.toggle_button, "click"), this.schema.options && void 0 !== this.schema.options.disable_collapse ? this.schema.options.disable_collapse && (this.toggle_button.style.display = "none") : this.jsoneditor.options.disable_collapse && (this.toggle_button.style.display = "none"), this.add_row_button = this._createAddRowButton(), this.delete_last_row_button = this._createDeleteLastRowButton(), this.remove_all_rows_button = this._createRemoveAllRowsButton(), this.tabs && (this.add_row_button.classList.add("je-array-control-btn"), this.delete_last_row_button.classList.add("je-array-control-btn"), this.remove_all_rows_button.classList.add("je-array-control-btn"));
        } }, { key: "_createToggleButton", value: function() {
          var t4 = this, e4 = this.getButton("", "collapse", "button_collapse");
          e4.classList.add("json-editor-btntype-toggle"), this.title.insertBefore(e4, this.title.childNodes[0]);
          var r3 = this.row_holder.style.display, n3 = this.controls.style.display;
          return e4.addEventListener("click", function(e5) {
            e5.preventDefault(), e5.stopPropagation(), t4.panel && t4.setVisibility(t4.panel, t4.collapsed), t4.tabs_holder && t4.setVisibility(t4.tabs_holder, t4.collapsed), t4.collapsed ? (t4.collapsed = false, t4.row_holder.style.display = r3, t4.controls.style.display = n3, t4.setButtonText(e5.currentTarget, "", "collapse", "button_collapse")) : (t4.collapsed = true, t4.row_holder.style.display = "none", t4.controls.style.display = "none", t4.setButtonText(e5.currentTarget, "", "expand", "button_expand"));
          }), e4;
        } }, { key: "_createAddRowButton", value: function() {
          var t4 = this, e4 = this.getButton(this.getItemTitle(), "add", "button_add_row_title", [this.getItemTitle()]);
          return e4.classList.add("json-editor-btntype-add"), e4.addEventListener("click", function(e5) {
            e5.preventDefault(), e5.stopPropagation();
            var r3, n3 = t4.rows.length;
            t4.row_cache[n3] ? (r3 = t4.rows[n3] = t4.row_cache[n3], t4.rows[n3].setValue(t4.rows[n3].getDefault(), true), t4.rows[n3].container.style.display = "", t4.rows[n3].tab && (t4.rows[n3].tab.style.display = ""), t4.rows[n3].register()) : r3 = t4.addRow(), t4.active_tab = t4.rows[n3].tab, t4.refreshTabs(), t4.refreshValue(), t4.onChange(true), t4.jsoneditor.trigger("addRow", r3);
          }), this.controls.appendChild(e4), e4;
        } }, { key: "_createDeleteLastRowButton", value: function() {
          var t4 = this, e4 = this.getButton("button_delete_last", "subtract", "button_delete_last_title", [this.getItemTitle()]);
          return e4.classList.add("json-editor-btntype-deletelast"), e4.addEventListener("click", function(e5) {
            if (e5.preventDefault(), e5.stopPropagation(), !t4.askConfirmation())
              return false;
            var r3 = t4.getValue(), n3 = null, i3 = r3.pop();
            t4.setValue(r3), t4.rows[t4.rows.length - 1] && (n3 = t4.rows[t4.rows.length - 1].tab), n3 && (t4.active_tab = n3, t4.refreshTabs()), t4.onChange(true), t4.jsoneditor.trigger("deleteRow", i3);
          }), this.controls.appendChild(e4), e4;
        } }, { key: "_createRemoveAllRowsButton", value: function() {
          var t4 = this, e4 = this.getButton("button_delete_all", "delete", "button_delete_all_title");
          return e4.classList.add("json-editor-btntype-deleteall"), e4.addEventListener("click", function(e5) {
            if (e5.preventDefault(), e5.stopPropagation(), !t4.askConfirmation())
              return false;
            var r3 = t4.getValue();
            t4.empty(true), t4.setValue([]), t4.onChange(true), t4.jsoneditor.trigger("deleteAllRows", r3);
          }), this.controls.appendChild(e4), e4;
        } }, { key: "showValidationErrors", value: function(t4) {
          var e4 = this, r3 = [], n3 = [];
          t4.forEach(function(t5) {
            t5.path === e4.path ? r3.push(t5) : n3.push(t5);
          }), this.error_holder && (r3.length ? (this.error_holder.innerHTML = "", this.error_holder.style.display = "", r3.forEach(function(t5) {
            e4.error_holder.appendChild(e4.theme.getErrorMessage(t5.message));
          })) : this.error_holder.style.display = "none"), this.rows.forEach(function(t5) {
            return t5.showValidationErrors(n3);
          });
        } }], r2 && I2(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), a2;
      }(w2);
      function V2(t3) {
        return V2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, V2(t3);
      }
      function z2(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== V2(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== V2(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === V2(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      function H2() {
        return H2 = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t3, e3, r2) {
          var n2 = function(t4, e4) {
            for (; !Object.prototype.hasOwnProperty.call(t4, e4) && null !== (t4 = q2(t4)); )
              ;
            return t4;
          }(t3, e3);
          if (n2) {
            var i2 = Object.getOwnPropertyDescriptor(n2, e3);
            return i2.get ? i2.get.call(arguments.length < 3 ? t3 : r2) : i2.value;
          }
        }, H2.apply(this, arguments);
      }
      function M2(t3, e3) {
        return M2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, M2(t3, e3);
      }
      function q2(t3) {
        return q2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, q2(t3);
      }
      F2.rules = { ".json-editor-btntype-toggle": "margin:0%2010px%200%200", ".je-array-control-btn": "width:100%25;text-align:left;margin-bottom:3px" };
      var G2 = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && M2(t4, e4);
        }(a2, t3);
        var e3, r2, n2, i2, o2 = (n2 = a2, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = q2(n2);
          if (i2) {
            var r3 = q2(this).constructor;
            t4 = Reflect.construct(e4, arguments, r3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === V2(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function a2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), o2.apply(this, arguments);
        }
        return e3 = a2, (r2 = [{ key: "onInputChange", value: function() {
          this.value = this.input.value, this.onChange(true);
        } }, { key: "register", value: function() {
          H2(q2(a2.prototype), "register", this).call(this), this.input && this.jsoneditor.options.use_name_attributes && this.input.setAttribute("name", this.formname);
        } }, { key: "unregister", value: function() {
          H2(q2(a2.prototype), "unregister", this).call(this), this.input && this.input.removeAttribute("name");
        } }, { key: "getNumColumns", value: function() {
          var t4 = this, e4 = this.getTitle().length;
          return Object.keys(this.select_values).forEach(function(r3) {
            return e4 = Math.max(e4, "".concat(t4.select_values[r3]).length + 4);
          }), Math.min(12, Math.max(e4 / 7, 2));
        } }, { key: "preBuild", value: function() {
          var t4;
          H2(q2(a2.prototype), "preBuild", this).call(this), this.select_options = {}, this.select_values = {}, this.option_titles = [], this.option_keys = [], this.option_enum = [];
          var e4 = this.jsoneditor.expandRefs(this.schema.items || {}), r3 = e4.enum || [], n3 = e4.options && e4.options.enum || [], i3 = e4.options && e4.options.enum_titles || [];
          for (t4 = 0; t4 < r3.length; t4++)
            if (this.sanitize(r3[t4]) === r3[t4]) {
              var o3 = n3[t4] || {};
              "title" in o3 || (o3.title = "".concat(i3[t4] || r3[t4])), this.option_keys.push("".concat(r3[t4])), this.option_enum.push(o3), this.select_values["".concat(r3[t4])] = r3[t4];
            }
        } }, { key: "build", value: function() {
          var t4, e4 = this;
          if (this.options.compact || (this.header = this.label = this.theme.getFormInputLabel(this.getTitle(), this.isRequired())), this.schema.description && (this.description = this.theme.getFormInputDescription(this.translateProperty(this.schema.description))), this.options.infoText && (this.infoButton = this.theme.getInfoButton(this.translateProperty(this.options.infoText))), this.options.compact && this.container.classList.add("compact"), !this.schema.format && this.option_keys.length < 8 || "checkbox" === this.schema.format) {
            for (this.input_type = "checkboxes", this.inputs = {}, this.controls = {}, t4 = 0; t4 < this.option_keys.length; t4++) {
              var r3 = this.formname + t4.toString();
              this.inputs[this.option_keys[t4]] = this.theme.getCheckbox(), this.inputs[this.option_keys[t4]].id = r3, this.select_options[this.option_keys[t4]] = this.inputs[this.option_keys[t4]];
              var n3 = this.theme.getCheckboxLabel(this.option_enum[t4].title);
              if (n3.htmlFor = r3, this.option_enum[t4].infoText) {
                var i3 = this.theme.getInfoButton(this.translateProperty(this.option_enum[t4].infoText));
                n3.appendChild(i3);
              }
              this.controls["_" + this.option_keys[t4]] = this.theme.getFormControl(n3, this.inputs[this.option_keys[t4]]);
            }
            this.control = this.theme.getMultiCheckboxHolder(this.controls, this.label, this.description, this.infoButton), this.inputs.controlgroup = this.inputs.controls = this.control;
          } else {
            for (this.input_type = "select", this.input = this.theme.getSelectInput(this.option_keys, true), this.theme.setSelectOptions(this.input, this.option_keys, this.option_enum.map(function(t5) {
              return t5.title;
            })), this.input.setAttribute("multiple", "multiple"), this.input.size = Math.min(10, this.option_keys.length), t4 = 0; t4 < this.option_keys.length; t4++)
              this.select_options[this.option_keys[t4]] = this.input.children[t4];
            this.control = this.theme.getFormControl(this.label, this.input, this.description, this.infoButton);
          }
          (this.schema.readOnly || this.schema.readonly) && this.disable(true), this.container.appendChild(this.control), this.multiselectChangeHandler = function(r4) {
            var n4 = [];
            for (t4 = 0; t4 < e4.option_keys.length; t4++)
              e4.select_options[e4.option_keys[t4]] && (e4.select_options[e4.option_keys[t4]].selected || e4.select_options[e4.option_keys[t4]].checked) && n4.push(e4.select_values[e4.option_keys[t4]]);
            e4.updateValue(n4), e4.onChange(true);
          }, this.control.addEventListener("change", this.multiselectChangeHandler, false), window.requestAnimationFrame(function() {
            e4.afterInputReady();
          });
        } }, { key: "postBuild", value: function() {
          H2(q2(a2.prototype), "postBuild", this).call(this);
        } }, { key: "afterInputReady", value: function() {
          this.theme.afterInputReady(this.input || this.inputs);
        } }, { key: "setValue", value: function(t4, e4) {
          var r3 = this;
          t4 = t4 || [], Array.isArray(t4) || (t4 = [t4]), t4 = t4.map(function(t5) {
            return "".concat(t5);
          }), Object.keys(this.select_options).forEach(function(e5) {
            r3.select_options[e5]["select" === r3.input_type ? "selected" : "checked"] = t4.includes(e5);
          }), this.updateValue(t4), this.onChange(true);
        } }, { key: "removeValue", value: function(t4) {
          t4 = [].concat(t4), this.setValue(this.getValue().filter(function(e4) {
            return !t4.includes(e4);
          }));
        } }, { key: "addValue", value: function(t4) {
          this.setValue(this.getValue().concat(t4));
        } }, { key: "updateValue", value: function(t4) {
          for (var e4 = false, r3 = [], n3 = 0; n3 < t4.length; n3++)
            if (this.select_options["".concat(t4[n3])]) {
              var i3 = this.sanitize(this.select_values[t4[n3]]);
              r3.push(i3), i3 !== t4[n3] && (e4 = true);
            } else
              e4 = true;
          return this.value = r3, e4;
        } }, { key: "sanitize", value: function(t4) {
          return "boolean" === this.schema.items.type ? !!t4 : "number" === this.schema.items.type ? 1 * t4 || 0 : "integer" === this.schema.items.type ? Math.floor(1 * t4 || 0) : "".concat(t4);
        } }, { key: "enable", value: function() {
          var t4 = this;
          this.always_disabled || (this.input ? this.input.disabled = false : this.inputs && Object.keys(this.inputs).forEach(function(e4) {
            return t4.inputs[e4].disabled = false;
          }), H2(q2(a2.prototype), "enable", this).call(this));
        } }, { key: "disable", value: function(t4) {
          var e4 = this;
          t4 && (this.always_disabled = true), this.input ? this.input.disabled = true : this.inputs && Object.keys(this.inputs).forEach(function(t5) {
            return e4.inputs[t5].disabled = true;
          }), H2(q2(a2.prototype), "disable", this).call(this);
        } }, { key: "destroy", value: function() {
          H2(q2(a2.prototype), "destroy", this).call(this);
        } }, { key: "escapeRegExp", value: function(t4) {
          return t4.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        } }, { key: "showValidationErrors", value: function(t4) {
          var e4 = new RegExp("^".concat(this.escapeRegExp(this.path), "(\\.\\d+)?$")), r3 = t4.reduce(function(t5, r4) {
            return r4.path.match(e4) && t5.push(r4.message), t5;
          }, []);
          r3.length ? this.theme.addInputError(this.input || this.inputs, "".concat(r3.join(". "), ".")) : this.theme.removeInputError(this.input || this.inputs);
        } }]) && z2(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), a2;
      }(w2);
      function U2(t3) {
        return U2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, U2(t3);
      }
      function $2(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== U2(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== U2(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === U2(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      function J2() {
        return J2 = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t3, e3, r2) {
          var n2 = function(t4, e4) {
            for (; !Object.prototype.hasOwnProperty.call(t4, e4) && null !== (t4 = Z2(t4)); )
              ;
            return t4;
          }(t3, e3);
          if (n2) {
            var i2 = Object.getOwnPropertyDescriptor(n2, e3);
            return i2.get ? i2.get.call(arguments.length < 3 ? t3 : r2) : i2.value;
          }
        }, J2.apply(this, arguments);
      }
      function W2(t3, e3) {
        return W2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, W2(t3, e3);
      }
      function Z2(t3) {
        return Z2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, Z2(t3);
      }
      var Y2 = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && W2(t4, e4);
        }(a2, t3);
        var e3, r2, n2, i2, o2 = (n2 = a2, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = Z2(n2);
          if (i2) {
            var r3 = Z2(this).constructor;
            t4 = Reflect.construct(e4, arguments, r3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === U2(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function a2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), o2.apply(this, arguments);
        }
        return e3 = a2, (r2 = [{ key: "setValue", value: function(t4, e4) {
          this.choices_instance ? (t4 = [].concat(t4).map(function(t5) {
            return "".concat(t5);
          }), this.updateValue(t4), this.choices_instance.removeActiveItems(), this.choices_instance.setChoiceByValue(this.value), this.onChange(true)) : J2(Z2(a2.prototype), "setValue", this).call(this, t4, e4);
        } }, { key: "afterInputReady", value: function() {
          var t4 = this;
          if (window.Choices && !this.choices_instance) {
            var e4 = this.expandCallbacks("choices", l({}, { removeItems: true, removeItemButton: true }, this.defaults.options.choices || {}, this.options.choices || {}, { addItems: true, editItems: false, duplicateItemsAllowed: false }));
            this.newEnumAllowed = false, this.choices_instance = new window.Choices(this.input, e4), this.control.removeEventListener("change", this.multiselectChangeHandler), this.multiselectChangeHandler = function(e5) {
              var r3 = t4.choices_instance.getValue(true);
              t4.updateValue(r3), t4.onChange(true);
            }, this.control.addEventListener("change", this.multiselectChangeHandler, false);
          }
          J2(Z2(a2.prototype), "afterInputReady", this).call(this);
        } }, { key: "updateValue", value: function(t4) {
          t4 = [].concat(t4);
          for (var e4 = false, r3 = [], n3 = 0; n3 < t4.length; n3++) {
            if (!this.select_values["".concat(t4[n3])]) {
              if (e4 = true, !this.newEnumAllowed)
                continue;
              if (!this.addNewOption(t4[n3]))
                continue;
            }
            var i3 = this.sanitize(this.select_values[t4[n3]]);
            r3.push(i3), i3 !== t4[n3] && (e4 = true);
          }
          return this.value = r3, e4;
        } }, { key: "addNewOption", value: function(t4) {
          return this.option_keys.push("".concat(t4)), this.option_titles.push("".concat(t4)), this.select_values["".concat(t4)] = t4, this.schema.items.enum.push(t4), this.choices_instance.setChoices([{ value: "".concat(t4), label: "".concat(t4) }], "value", "label", false), true;
        } }, { key: "enable", value: function() {
          !this.always_disabled && this.choices_instance && this.choices_instance.enable(), J2(Z2(a2.prototype), "enable", this).call(this);
        } }, { key: "disable", value: function(t4) {
          this.choices_instance && this.choices_instance.disable(), J2(Z2(a2.prototype), "disable", this).call(this, t4);
        } }, { key: "destroy", value: function() {
          this.choices_instance && (this.choices_instance.destroy(), this.choices_instance = null), J2(Z2(a2.prototype), "destroy", this).call(this);
        } }]) && $2(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), a2;
      }(G2);
      function Q2(t3) {
        return Q2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, Q2(t3);
      }
      function K2(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== Q2(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== Q2(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === Q2(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      function X2() {
        return X2 = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t3, e3, r2) {
          var n2 = function(t4, e4) {
            for (; !Object.prototype.hasOwnProperty.call(t4, e4) && null !== (t4 = et2(t4)); )
              ;
            return t4;
          }(t3, e3);
          if (n2) {
            var i2 = Object.getOwnPropertyDescriptor(n2, e3);
            return i2.get ? i2.get.call(arguments.length < 3 ? t3 : r2) : i2.value;
          }
        }, X2.apply(this, arguments);
      }
      function tt2(t3, e3) {
        return tt2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, tt2(t3, e3);
      }
      function et2(t3) {
        return et2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, et2(t3);
      }
      var rt2 = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && tt2(t4, e4);
        }(a2, t3);
        var e3, r2, n2, i2, o2 = (n2 = a2, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = et2(n2);
          if (i2) {
            var r3 = et2(this).constructor;
            t4 = Reflect.construct(e4, arguments, r3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === Q2(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function a2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), o2.apply(this, arguments);
        }
        return e3 = a2, (r2 = [{ key: "setValue", value: function(t4, e4) {
          this.select2_instance ? (t4 = [].concat(t4).map(function(t5) {
            return "".concat(t5);
          }), this.updateValue(t4), this.select2v4 ? this.select2_instance.val(this.value).change() : this.select2_instance.select2("val", this.value), this.onChange(true)) : X2(et2(a2.prototype), "setValue", this).call(this, t4, e4);
        } }, { key: "afterInputReady", value: function() {
          var t4, e4 = this;
          window.jQuery && window.jQuery.fn && window.jQuery.fn.select2 && !this.select2_instance && (t4 = this.expandCallbacks("select2", l({}, { tags: true, width: "100%" }, this.defaults.options.select2 || {}, this.options.select2 || {})), this.newEnumAllowed = t4.tags = !!t4.tags && this.schema.items && "string" === this.schema.items.type, this.select2_instance = window.jQuery(this.input).select2(t4), this.select2v4 = h2(this.select2_instance.select2, "amd"), this.selectChangeHandler = function() {
            var t5 = e4.select2v4 ? e4.select2_instance.val() : e4.select2_instance.select2("val");
            e4.updateValue(t5), e4.onChange(true);
          }, this.select2_instance.on("select2-blur", this.selectChangeHandler), this.select2_instance.on("change", this.selectChangeHandler)), X2(et2(a2.prototype), "afterInputReady", this).call(this);
        } }, { key: "updateValue", value: function(t4) {
          t4 = [].concat(t4);
          for (var e4 = false, r3 = [], n3 = 0; n3 < t4.length; n3++) {
            if (!this.select_values["".concat(t4[n3])]) {
              if (e4 = true, !this.newEnumAllowed)
                continue;
              if (!this.addNewOption(t4[n3]))
                continue;
            }
            var i3 = this.sanitize(this.select_values[t4[n3]]);
            r3.push(i3), i3 !== t4[n3] && (e4 = true);
          }
          return this.value = r3, e4;
        } }, { key: "addNewOption", value: function(t4) {
          this.option_keys.push("".concat(t4)), this.option_titles.push("".concat(t4)), this.select_values["".concat(t4)] = t4, this.schema.items.enum.push(t4);
          var e4 = this.input.querySelector('option[value="'.concat(t4, '"]'));
          return e4 ? e4.removeAttribute("data-select2-tag") : this.input.appendChild(new Option(t4, t4, false, false)).trigger("change"), true;
        } }, { key: "enable", value: function() {
          !this.always_disabled && this.select2_instance && (this.select2v4 ? this.select2_instance.prop("disabled", false) : this.select2_instance.select2("enable", true)), X2(et2(a2.prototype), "enable", this).call(this);
        } }, { key: "disable", value: function(t4) {
          this.select2_instance && (this.select2v4 ? this.select2_instance.prop("disabled", true) : this.select2_instance.select2("enable", false)), X2(et2(a2.prototype), "disable", this).call(this);
        } }, { key: "destroy", value: function() {
          this.select2_instance && (this.select2_instance.select2("destroy"), this.select2_instance = null), X2(et2(a2.prototype), "destroy", this).call(this);
        } }]) && K2(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), a2;
      }(G2);
      function nt2(t3) {
        return nt2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, nt2(t3);
      }
      function it2(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== nt2(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== nt2(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === nt2(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      function ot2() {
        return ot2 = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t3, e3, r2) {
          var n2 = function(t4, e4) {
            for (; !Object.prototype.hasOwnProperty.call(t4, e4) && null !== (t4 = st2(t4)); )
              ;
            return t4;
          }(t3, e3);
          if (n2) {
            var i2 = Object.getOwnPropertyDescriptor(n2, e3);
            return i2.get ? i2.get.call(arguments.length < 3 ? t3 : r2) : i2.value;
          }
        }, ot2.apply(this, arguments);
      }
      function at2(t3, e3) {
        return at2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, at2(t3, e3);
      }
      function st2(t3) {
        return st2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, st2(t3);
      }
      var lt2 = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && at2(t4, e4);
        }(a2, t3);
        var e3, r2, n2, i2, o2 = (n2 = a2, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = st2(n2);
          if (i2) {
            var r3 = st2(this).constructor;
            t4 = Reflect.construct(e4, arguments, r3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === nt2(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function a2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), o2.apply(this, arguments);
        }
        return e3 = a2, (r2 = [{ key: "setValue", value: function(t4, e4) {
          this.selectize_instance ? (t4 = [].concat(t4).map(function(t5) {
            return "".concat(t5);
          }), this.updateValue(t4), this.selectize_instance.setValue(this.value), this.onChange(true)) : ot2(st2(a2.prototype), "setValue", this).call(this, t4, e4);
        } }, { key: "afterInputReady", value: function() {
          var t4, e4 = this;
          window.jQuery && window.jQuery.fn && window.jQuery.fn.selectize && !this.selectize_instance && (t4 = this.expandCallbacks("selectize", l({}, { plugins: ["remove_button"], delimiter: false, createOnBlur: true, create: true }, this.defaults.options.selectize || {}, this.options.selectize || {})), this.newEnumAllowed = t4.create = !!t4.create && this.schema.items && "string" === this.schema.items.type, this.selectize_instance = window.jQuery(this.input).selectize(t4)[0].selectize, this.control.removeEventListener("change", this.multiselectChangeHandler), this.multiselectChangeHandler = function(t5) {
            var r3 = e4.selectize_instance.getValue();
            e4.updateValue(r3), e4.onChange(true);
          }, this.selectize_instance.on("change", this.multiselectChangeHandler)), ot2(st2(a2.prototype), "afterInputReady", this).call(this);
        } }, { key: "updateValue", value: function(t4) {
          t4 = [].concat(t4);
          for (var e4 = false, r3 = [], n3 = 0; n3 < t4.length; n3++) {
            if (!this.select_values["".concat(t4[n3])]) {
              if (e4 = true, !this.newEnumAllowed)
                continue;
              if (!this.addNewOption(t4[n3]))
                continue;
            }
            var i3 = this.sanitize(this.select_values[t4[n3]]);
            r3.push(i3), i3 !== t4[n3] && (e4 = true);
          }
          return this.value = r3, e4;
        } }, { key: "addNewOption", value: function(t4) {
          return this.option_keys.push("".concat(t4)), this.option_titles.push("".concat(t4)), this.select_values["".concat(t4)] = t4, this.schema.items.enum.push(t4), this.selectize_instance.addOption({ text: t4, value: t4 }), true;
        } }, { key: "enable", value: function() {
          !this.always_disabled && this.selectize_instance && this.selectize_instance.unlock(), ot2(st2(a2.prototype), "enable", this).call(this);
        } }, { key: "disable", value: function(t4) {
          this.selectize_instance && this.selectize_instance.lock(), ot2(st2(a2.prototype), "disable", this).call(this, t4);
        } }, { key: "destroy", value: function() {
          this.selectize_instance && (this.selectize_instance.destroy(), this.selectize_instance = null), ot2(st2(a2.prototype), "destroy", this).call(this);
        } }]) && it2(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), a2;
      }(G2);
      function ct2(t3) {
        return ct2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, ct2(t3);
      }
      function ut2(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== ct2(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== ct2(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === ct2(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      function ht2() {
        return ht2 = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t3, e3, r2) {
          var n2 = function(t4, e4) {
            for (; !Object.prototype.hasOwnProperty.call(t4, e4) && null !== (t4 = dt2(t4)); )
              ;
            return t4;
          }(t3, e3);
          if (n2) {
            var i2 = Object.getOwnPropertyDescriptor(n2, e3);
            return i2.get ? i2.get.call(arguments.length < 3 ? t3 : r2) : i2.value;
          }
        }, ht2.apply(this, arguments);
      }
      function pt2(t3, e3) {
        return pt2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, pt2(t3, e3);
      }
      function dt2(t3) {
        return dt2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, dt2(t3);
      }
      var ft2 = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && pt2(t4, e4);
        }(a2, t3);
        var e3, r2, n2, i2, o2 = (n2 = a2, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = dt2(n2);
          if (i2) {
            var r3 = dt2(this).constructor;
            t4 = Reflect.construct(e4, arguments, r3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === ct2(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function a2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), o2.apply(this, arguments);
        }
        return e3 = a2, (r2 = [{ key: "postBuild", value: function() {
          window.Autocomplete && (this.autocomplete_wrapper = document.createElement("div"), this.input.parentNode.insertBefore(this.autocomplete_wrapper, this.input.nextSibling), this.autocomplete_wrapper.appendChild(this.input), this.autocomplete_dropdown = document.createElement("ul"), this.input.parentNode.insertBefore(this.autocomplete_dropdown, this.input.nextSibling)), ht2(dt2(a2.prototype), "postBuild", this).call(this);
        } }, { key: "afterInputReady", value: function() {
          var t4, e4 = this;
          window.Autocomplete && !this.autocomplete_instance && (t4 = this.expandCallbacks("autocomplete", l({}, { search: function(t5) {
            return console.log('No "search" callback defined for autocomplete in property "'.concat(t5.key, '"')), [];
          }, onSubmit: function() {
            e4.input.blur();
          }, baseClass: "autocomplete" }, this.defaults.options.autocomplete || {}, this.options.autocomplete || {})), this.autocomplete_wrapper.classList.add(t4.baseClass), this.autocomplete_dropdown.classList.add("".concat(t4.baseClass, "-result-list")), this.autocomplete_instance = new window.Autocomplete(this.autocomplete_wrapper, t4)), ht2(dt2(a2.prototype), "afterInputReady", this).call(this);
        } }, { key: "destroy", value: function() {
          this.autocomplete_instance && (this.input && this.input.parentNode && this.input.parentNode.removeChild(this.input), this.autocomplete_dropdown && this.autocomplete_dropdown.parentNode && this.autocomplete_dropdown.parentNode.removeChild(this.autocomplete_dropdown), this.autocomplete_wrapper && this.autocomplete_wrapper.parentNode && this.autocomplete_wrapper.parentNode.removeChild(this.autocomplete_wrapper), this.autocomplete_instance = null), ht2(dt2(a2.prototype), "destroy", this).call(this);
        } }]) && ut2(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), a2;
      }(C2);
      function yt2(t3) {
        return yt2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, yt2(t3);
      }
      function mt2(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== yt2(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== yt2(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === yt2(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      function vt2() {
        return vt2 = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t3, e3, r2) {
          var n2 = function(t4, e4) {
            for (; !Object.prototype.hasOwnProperty.call(t4, e4) && null !== (t4 = gt2(t4)); )
              ;
            return t4;
          }(t3, e3);
          if (n2) {
            var i2 = Object.getOwnPropertyDescriptor(n2, e3);
            return i2.get ? i2.get.call(arguments.length < 3 ? t3 : r2) : i2.value;
          }
        }, vt2.apply(this, arguments);
      }
      function bt2(t3, e3) {
        return bt2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, bt2(t3, e3);
      }
      function gt2(t3) {
        return gt2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, gt2(t3);
      }
      r(561);
      var wt2 = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && bt2(t4, e4);
        }(a2, t3);
        var e3, r2, n2, i2, o2 = (n2 = a2, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = gt2(n2);
          if (i2) {
            var r3 = gt2(this).constructor;
            t4 = Reflect.construct(e4, arguments, r3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === yt2(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function a2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), o2.apply(this, arguments);
        }
        return e3 = a2, (r2 = [{ key: "getNumColumns", value: function() {
          return 4;
        } }, { key: "setFileReaderListener", value: function(t4) {
          var e4 = this;
          t4.addEventListener("load", function(t5) {
            if (e4.count === e4.current_item_index)
              e4.value[e4.count][e4.key] = t5.target.result;
            else {
              var r3 = {};
              for (var n3 in e4.parent.schema.properties)
                r3[n3] = "";
              r3[e4.key] = t5.target.result, e4.value.splice(e4.count, 0, r3);
            }
            e4.count += 1, e4.count === e4.total + e4.current_item_index && e4.arrayEditor.setValue(e4.value);
          });
        } }, { key: "build", value: function() {
          var t4 = this;
          if (this.options.compact || (this.title = this.header = this.label = this.theme.getFormInputLabel(this.getTitle(), this.isRequired())), this.options.infoText && (this.infoButton = this.theme.getInfoButton(this.translateProperty(this.options.infoText))), this.input = this.theme.getFormInputField("hidden"), this.container.appendChild(this.input), !this.schema.readOnly && !this.schema.readonly) {
            if (!window.FileReader)
              throw new Error("FileReader required for base64 editor");
            this.uploader = this.theme.getFormInputField("file"), this.schema.options && this.schema.options.multiple && true === this.schema.options.multiple && this.parent && "object" === this.parent.schema.type && this.parent.parent && "array" === this.parent.parent.schema.type && this.uploader.setAttribute("multiple", ""), this.uploader.addEventListener("change", function(e4) {
              if (e4.preventDefault(), e4.stopPropagation(), e4.currentTarget.files && e4.currentTarget.files.length)
                if (e4.currentTarget.files.length > 1 && t4.schema.options && t4.schema.options.multiple && true === t4.schema.options.multiple && t4.parent && "object" === t4.parent.schema.type && t4.parent.parent && "array" === t4.parent.parent.schema.type) {
                  t4.arrayEditor = t4.jsoneditor.getEditor(t4.parent.parent.path), t4.value = t4.arrayEditor.getValue(), t4.total = e4.currentTarget.files.length, t4.current_item_index = parseInt(t4.parent.key), t4.count = t4.current_item_index;
                  for (var r3 = 0; r3 < t4.total; r3++) {
                    var n3 = new FileReader();
                    t4.setFileReaderListener(n3), n3.readAsDataURL(e4.currentTarget.files[r3]);
                  }
                } else {
                  var i3 = new FileReader();
                  i3.onload = function(e5) {
                    t4.value = e5.target.result, t4.refreshPreview(), t4.onChange(true), i3 = null;
                  }, i3.readAsDataURL(e4.currentTarget.files[0]);
                }
            });
          }
          this.preview = this.theme.getFormInputDescription(this.translateProperty(this.schema.description)), this.container.appendChild(this.preview), this.control = this.theme.getFormControl(this.label, this.uploader || this.input, this.preview, this.infoButton), this.container.appendChild(this.control);
        } }, { key: "refreshPreview", value: function() {
          if (this.last_preview !== this.value && (this.last_preview = this.value, this.preview.innerHTML = "", this.value)) {
            var t4 = this.value.match(/^data:([^;,]+)[;,]/);
            if (t4 && (t4 = t4[1]), t4) {
              if (this.preview.innerHTML = "<strong>Type:</strong> ".concat(t4, ", <strong>Size:</strong> ").concat(Math.floor((this.value.length - this.value.split(",")[0].length - 1) / 1.33333), " bytes"), "image" === t4.substr(0, 5)) {
                this.preview.innerHTML += "<br>";
                var e4 = document.createElement("img");
                e4.style.maxWidth = "100%", e4.style.maxHeight = "100px", e4.src = this.value, this.preview.appendChild(e4);
              }
            } else
              this.preview.innerHTML = "<em>Invalid data URI</em>";
          }
        } }, { key: "enable", value: function() {
          this.always_disabled || (this.uploader && (this.uploader.disabled = false), vt2(gt2(a2.prototype), "enable", this).call(this));
        } }, { key: "disable", value: function(t4) {
          t4 && (this.always_disabled = true), this.uploader && (this.uploader.disabled = true), vt2(gt2(a2.prototype), "disable", this).call(this);
        } }, { key: "setValue", value: function(t4) {
          this.value !== t4 && (this.schema.readOnly && this.schema.enum && !this.schema.enum.includes(t4) ? this.value = this.schema.enum[0] : this.value = t4, this.input.value = this.value, this.refreshPreview(), this.onChange());
        } }, { key: "destroy", value: function() {
          this.preview && this.preview.parentNode && this.preview.parentNode.removeChild(this.preview), this.title && this.title.parentNode && this.title.parentNode.removeChild(this.title), this.input && this.input.parentNode && this.input.parentNode.removeChild(this.input), this.uploader && this.uploader.parentNode && this.uploader.parentNode.removeChild(this.uploader), vt2(gt2(a2.prototype), "destroy", this).call(this);
        } }]) && mt2(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), a2;
      }(w2);
      function _t2(t3) {
        return _t2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, _t2(t3);
      }
      function kt2(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== _t2(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== _t2(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === _t2(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      function jt2() {
        return jt2 = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t3, e3, r2) {
          var n2 = function(t4, e4) {
            for (; !Object.prototype.hasOwnProperty.call(t4, e4) && null !== (t4 = xt2(t4)); )
              ;
            return t4;
          }(t3, e3);
          if (n2) {
            var i2 = Object.getOwnPropertyDescriptor(n2, e3);
            return i2.get ? i2.get.call(arguments.length < 3 ? t3 : r2) : i2.value;
          }
        }, jt2.apply(this, arguments);
      }
      function Ot2(t3, e3) {
        return Ot2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, Ot2(t3, e3);
      }
      function xt2(t3) {
        return xt2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, xt2(t3);
      }
      var Ct2 = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && Ot2(t4, e4);
        }(a2, t3);
        var e3, r2, n2, i2, o2 = (n2 = a2, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = xt2(n2);
          if (i2) {
            var r3 = xt2(this).constructor;
            t4 = Reflect.construct(e4, arguments, r3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === _t2(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function a2(t4, e4) {
          var r3;
          return function(t5, e5) {
            if (!(t5 instanceof e5))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), (r3 = o2.call(this, t4, e4)).active = false, r3.parent && r3.parent.schema && (Array.isArray(r3.parent.schema.required) ? r3.parent.schema.required.includes(r3.key) || r3.parent.schema.required.push(r3.key) : r3.parent.schema.required = [r3.key]), r3;
        }
        return e3 = a2, (r2 = [{ key: "build", value: function() {
          var t4 = this;
          this.options.compact = true;
          var e4 = this.translateProperty(this.schema.title) || this.key, r3 = this.expandCallbacks("button", l({}, { icon: "", validated: false, align: "left", action: function(t5, e5) {
            window.alert('No button action defined for "'.concat(t5.path, '"'));
          } }, this.defaults.options.button || {}, this.options.button || {}));
          this.input = this.getButton(e4, r3.icon, e4), this.input.addEventListener("click", r3.action, false), (this.schema.readOnly || this.schema.readonly || this.schema.template) && (this.disable(true), this.input.setAttribute("readonly", "true")), this.setInputAttributes(["readonly"]), this.control = this.theme.getFormButtonHolder(r3.align), this.control.appendChild(this.input), this.container.appendChild(this.control), this.changeHandler = function() {
            t4.jsoneditor.validate(t4.jsoneditor.getValue()).length > 0 ? t4.disable() : t4.enable();
          }, r3.validated && this.jsoneditor.on("change", this.changeHandler);
        } }, { key: "enable", value: function() {
          this.always_disabled || (this.input.disabled = false, jt2(xt2(a2.prototype), "enable", this).call(this));
        } }, { key: "disable", value: function(t4) {
          t4 && (this.always_disabled = true), this.input.disabled = true, jt2(xt2(a2.prototype), "disable", this).call(this);
        } }, { key: "getNumColumns", value: function() {
          return 2;
        } }, { key: "activate", value: function() {
          this.active = false, this.enable();
        } }, { key: "deactivate", value: function() {
          this.isRequired() || (this.active = false, this.disable());
        } }, { key: "destroy", value: function() {
          this.jsoneditor.off("change", this.changeHandler), this.changeHandler = null, jt2(xt2(a2.prototype), "destroy", this).call(this);
        } }]) && kt2(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), a2;
      }(w2);
      function Et2(t3) {
        return Et2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, Et2(t3);
      }
      function St2(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== Et2(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== Et2(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === Et2(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      function Pt2() {
        return Pt2 = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t3, e3, r2) {
          var n2 = function(t4, e4) {
            for (; !Object.prototype.hasOwnProperty.call(t4, e4) && null !== (t4 = Lt2(t4)); )
              ;
            return t4;
          }(t3, e3);
          if (n2) {
            var i2 = Object.getOwnPropertyDescriptor(n2, e3);
            return i2.get ? i2.get.call(arguments.length < 3 ? t3 : r2) : i2.value;
          }
        }, Pt2.apply(this, arguments);
      }
      function Tt2(t3, e3) {
        return Tt2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, Tt2(t3, e3);
      }
      function Lt2(t3) {
        return Lt2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, Lt2(t3);
      }
      var Rt2 = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && Tt2(t4, e4);
        }(a2, t3);
        var e3, r2, n2, i2, o2 = (n2 = a2, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = Lt2(n2);
          if (i2) {
            var r3 = Lt2(this).constructor;
            t4 = Reflect.construct(e4, arguments, r3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === Et2(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function a2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), o2.apply(this, arguments);
        }
        return e3 = a2, (r2 = [{ key: "setValue", value: function(t4, e4) {
          t4 = !!t4;
          var r3 = this.getValue() !== t4;
          this.value = t4, this.input.checked = this.value, this.onChange(r3);
        } }, { key: "register", value: function() {
          Pt2(Lt2(a2.prototype), "register", this).call(this), this.input && this.jsoneditor.options.use_name_attributes && this.input.setAttribute("name", this.formname);
        } }, { key: "unregister", value: function() {
          Pt2(Lt2(a2.prototype), "unregister", this).call(this), this.input && this.input.removeAttribute("name");
        } }, { key: "getNumColumns", value: function() {
          return Math.min(12, Math.max(this.getTitle().length / 7, 2));
        } }, { key: "build", value: function() {
          var t4 = this;
          this.parent.options.table_row || (this.label = this.header = this.theme.getCheckboxLabel(this.getTitle(), this.isRequired()), this.label.htmlFor = this.formname), this.schema.description && (this.description = this.theme.getFormInputDescription(this.translateProperty(this.schema.description))), this.options.infoText && !this.options.compact && (this.infoButton = this.theme.getInfoButton(this.translateProperty(this.options.infoText))), this.options.compact && this.container.classList.add("compact"), this.input = this.theme.getCheckbox(), this.input.id = this.formname, this.control = this.theme.getFormControl(this.label, this.input, this.description, this.infoButton), (this.schema.readOnly || this.schema.readonly) && (this.disable(true), this.input.disabled = true), this.input.addEventListener("change", function(e4) {
            e4.preventDefault(), e4.stopPropagation(), t4.value = e4.currentTarget.checked, t4.onChange(true);
          }), this.container.appendChild(this.control);
        } }, { key: "enable", value: function() {
          this.always_disabled || (this.input.disabled = false, Pt2(Lt2(a2.prototype), "enable", this).call(this));
        } }, { key: "disable", value: function(t4) {
          t4 && (this.always_disabled = true), this.input.disabled = true, Pt2(Lt2(a2.prototype), "disable", this).call(this);
        } }, { key: "destroy", value: function() {
          this.label && this.label.parentNode && this.label.parentNode.removeChild(this.label), this.description && this.description.parentNode && this.description.parentNode.removeChild(this.description), this.input && this.input.parentNode && this.input.parentNode.removeChild(this.input), Pt2(Lt2(a2.prototype), "destroy", this).call(this);
        } }, { key: "showValidationErrors", value: function(t4) {
          var e4 = this;
          this.previous_error_setting = this.jsoneditor.options.show_errors;
          var r3 = t4.reduce(function(t5, r4) {
            return r4.path === e4.path && t5.push(r4.message), t5;
          }, []);
          this.input.controlgroup = this.control, r3.length ? this.theme.addInputError(this.input, "".concat(r3.join(". "), ".")) : this.theme.removeInputError(this.input);
        } }]) && St2(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), a2;
      }(w2);
      function At2(t3) {
        return At2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, At2(t3);
      }
      function It2(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== At2(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== At2(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === At2(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      function Bt2() {
        return Bt2 = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t3, e3, r2) {
          var n2 = function(t4, e4) {
            for (; !Object.prototype.hasOwnProperty.call(t4, e4) && null !== (t4 = Dt2(t4)); )
              ;
            return t4;
          }(t3, e3);
          if (n2) {
            var i2 = Object.getOwnPropertyDescriptor(n2, e3);
            return i2.get ? i2.get.call(arguments.length < 3 ? t3 : r2) : i2.value;
          }
        }, Bt2.apply(this, arguments);
      }
      function Nt2(t3, e3) {
        return Nt2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, Nt2(t3, e3);
      }
      function Dt2(t3) {
        return Dt2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, Dt2(t3);
      }
      r(2772), r(2707);
      var Ft2 = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && Nt2(t4, e4);
        }(a2, t3);
        var e3, r2, n2, i2, o2 = (n2 = a2, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = Dt2(n2);
          if (i2) {
            var r3 = Dt2(this).constructor;
            t4 = Reflect.construct(e4, arguments, r3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === At2(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function a2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), o2.apply(this, arguments);
        }
        return e3 = a2, (r2 = [{ key: "setValue", value: function(t4, e4) {
          var r3 = this.typecast(t4), n3 = !!this.jsoneditor.options.use_default_values || void 0 !== this.schema.default;
          (this.enum_options.length > 0 && !this.enum_values.includes(r3) || e4 && !this.isRequired() && !n3) && (r3 = this.enum_values[0]), this.value !== r3 && (e4 ? this.is_dirty = false : "change" === this.jsoneditor.options.show_errors && (this.is_dirty = true), this.input.value = this.enum_options[this.enum_values.indexOf(r3)], this.value = r3, this.onChange(), this.change());
        } }, { key: "register", value: function() {
          Bt2(Dt2(a2.prototype), "register", this).call(this), this.input && this.jsoneditor.options.use_name_attributes && this.input.setAttribute("name", this.formname);
        } }, { key: "unregister", value: function() {
          Bt2(Dt2(a2.prototype), "unregister", this).call(this), this.input && this.input.removeAttribute("name");
        } }, { key: "getNumColumns", value: function() {
          if (!this.enum_options)
            return 3;
          for (var t4 = this.getTitle().length, e4 = 0; e4 < this.enum_options.length; e4++)
            t4 = Math.max(t4, this.enum_options[e4].length + 4);
          return Math.min(12, Math.max(t4 / 7, 2));
        } }, { key: "typecast", value: function(t4) {
          return "boolean" === this.schema.type ? "undefined" === t4 || void 0 === t4 ? void 0 : !!t4 : "number" === this.schema.type ? 1 * t4 || 0 : "integer" === this.schema.type ? Math.floor(1 * t4 || 0) : this.schema.enum && void 0 === t4 ? void 0 : "".concat(t4);
        } }, { key: "getValue", value: function() {
          if (this.dependenciesFulfilled)
            return this.typecast(this.value);
        } }, { key: "preBuild", value: function() {
          var t4, e4, r3 = this;
          if (this.input_type = "select", this.enum_options = [], this.enum_values = [], this.enum_display = [], this.schema.enum) {
            var n3 = this.schema.options && this.schema.options.enum_titles || [];
            this.schema.enum.forEach(function(t5, e5) {
              r3.enum_options[e5] = "".concat(t5), r3.enum_display[e5] = "".concat(r3.translateProperty(n3[e5]) || t5), r3.enum_values[e5] = r3.typecast(t5);
            });
          } else if ("boolean" === this.schema.type)
            this.enum_display = this.schema.options && this.schema.options.enum_titles || ["true", "false"], this.enum_options = ["1", ""], this.enum_values = [true, false], this.isRequired() || (this.enum_display.unshift(" "), this.enum_options.unshift("undefined"), this.enum_values.unshift(void 0));
          else {
            if (!this.schema.enumSource)
              throw new Error("'select' editor requires the enum property to be set.");
            if (this.enumSource = [], this.enum_display = [], this.enum_options = [], this.enum_values = [], Array.isArray(this.schema.enumSource))
              for (t4 = 0; t4 < this.schema.enumSource.length; t4++)
                "string" == typeof this.schema.enumSource[t4] ? this.enumSource[t4] = { source: this.schema.enumSource[t4] } : Array.isArray(this.schema.enumSource[t4]) ? this.enumSource[t4] = this.schema.enumSource[t4] : this.enumSource[t4] = l({}, this.schema.enumSource[t4]);
            else
              this.schema.enumValue ? this.enumSource = [{ source: this.schema.enumSource, value: this.schema.enumValue }] : this.enumSource = [{ source: this.schema.enumSource }];
            for (t4 = 0; t4 < this.enumSource.length; t4++)
              this.enumSource[t4].value && ("function" == typeof (e4 = this.expandCallbacks("template", { template: this.enumSource[t4].value })).template ? this.enumSource[t4].value = e4.template : this.enumSource[t4].value = this.jsoneditor.compileTemplate(this.enumSource[t4].value, this.template_engine)), this.enumSource[t4].title && ("function" == typeof (e4 = this.expandCallbacks("template", { template: this.enumSource[t4].title })).template ? this.enumSource[t4].title = e4.template : this.enumSource[t4].title = this.jsoneditor.compileTemplate(this.enumSource[t4].title, this.template_engine)), this.enumSource[t4].filter && this.enumSource[t4].value && ("function" == typeof (e4 = this.expandCallbacks("template", { template: this.enumSource[t4].filter })).template ? this.enumSource[t4].filter = e4.template : this.enumSource[t4].filter = this.jsoneditor.compileTemplate(this.enumSource[t4].filter, this.template_engine));
          }
        } }, { key: "build", value: function() {
          var t4 = this;
          this.options.compact || (this.header = this.label = this.theme.getFormInputLabel(this.getTitle(), this.isRequired())), this.schema.description && (this.description = this.theme.getFormInputDescription(this.translateProperty(this.schema.description))), this.options.infoText && (this.infoButton = this.theme.getInfoButton(this.translateProperty(this.options.infoText))), this.options.compact && this.container.classList.add("compact"), this.input = this.theme.getSelectInput(this.enum_options, false), this.theme.setSelectOptions(this.input, this.enum_options, this.enum_display), (this.schema.readOnly || this.schema.readonly) && (this.disable(true), this.input.disabled = true), this.setInputAttributes([]), this.input.addEventListener("change", function(e4) {
            e4.preventDefault(), e4.stopPropagation(), t4.onInputChange();
          }), this.control = this.theme.getFormControl(this.label, this.input, this.description, this.infoButton), this.container.appendChild(this.control), this.value = this.enum_values[0], window.requestAnimationFrame(function() {
            t4.input.parentNode && t4.afterInputReady();
          });
        } }, { key: "afterInputReady", value: function() {
          this.theme.afterInputReady(this.input);
        } }, { key: "onInputChange", value: function() {
          var t4, e4 = this.typecast(this.input.value);
          (t4 = this.enum_values.includes(e4) ? this.enum_values[this.enum_values.indexOf(e4)] : this.enum_values[0]) !== this.value && (this.is_dirty = true, this.value = t4, this.onChange(true));
        } }, { key: "onWatchedFieldChange", value: function() {
          var t4, e4, r3 = [], n3 = [];
          if (this.enumSource) {
            t4 = this.getWatchedFieldValues();
            for (var i3 = 0; i3 < this.enumSource.length; i3++)
              if (Array.isArray(this.enumSource[i3]))
                r3 = r3.concat(this.enumSource[i3]), n3 = n3.concat(this.enumSource[i3]);
              else {
                var o3 = [];
                if (o3 = Array.isArray(this.enumSource[i3].source) ? this.enumSource[i3].source : t4[this.enumSource[i3].source]) {
                  if (this.enumSource[i3].slice && (o3 = Array.prototype.slice.apply(o3, this.enumSource[i3].slice)), this.enumSource[i3].filter) {
                    var s2 = [];
                    for (e4 = 0; e4 < o3.length; e4++)
                      this.enumSource[i3].filter({ i: e4, item: o3[e4], watched: t4 }) && s2.push(o3[e4]);
                    o3 = s2;
                  }
                  var l2 = [], c3 = [];
                  for (e4 = 0; e4 < o3.length; e4++) {
                    var u2 = o3[e4];
                    this.enumSource[i3].value ? c3[e4] = this.typecast(this.enumSource[i3].value({ i: e4, item: u2 })) : c3[e4] = o3[e4], this.enumSource[i3].title ? l2[e4] = this.enumSource[i3].title({ i: e4, item: u2 }) : l2[e4] = c3[e4];
                  }
                  this.enumSource[i3].sort && (function(t5, e5, r4) {
                    t5.map(function(t6, r5) {
                      return { v: t6, t: e5[r5] };
                    }).sort(function(t6, e6) {
                      return t6.v < e6.v ? -r4 : t6.v === e6.v ? 0 : r4;
                    }).forEach(function(r5, n4) {
                      t5[n4] = r5.v, e5[n4] = r5.t;
                    });
                  }).bind(null, c3, l2, "desc" === this.enumSource[i3].sort ? 1 : -1)(), r3 = r3.concat(c3), n3 = n3.concat(l2);
                }
              }
            var h3 = this.value;
            this.theme.setSelectOptions(this.input, r3, n3), this.enum_options = r3, this.enum_display = n3, this.enum_values = r3, r3.includes(h3) || false !== this.jsoneditor.options.enum_source_value_auto_select ? (this.input.value = h3, this.value = h3) : (this.input.value = r3[0], this.value = this.typecast(r3[0] || ""), this.parent && !this.watchLoop ? this.parent.onChildEditorChange(this) : this.jsoneditor.onChange(), this.jsoneditor.notifyWatchers(this.path));
          }
          Bt2(Dt2(a2.prototype), "onWatchedFieldChange", this).call(this);
        } }, { key: "enable", value: function() {
          this.always_disabled || (this.input.disabled = false, Bt2(Dt2(a2.prototype), "enable", this).call(this));
        } }, { key: "disable", value: function(t4) {
          t4 && (this.always_disabled = true), this.input.disabled = true, Bt2(Dt2(a2.prototype), "disable", this).call(this, t4);
        } }, { key: "destroy", value: function() {
          this.label && this.label.parentNode && this.label.parentNode.removeChild(this.label), this.description && this.description.parentNode && this.description.parentNode.removeChild(this.description), this.input && this.input.parentNode && this.input.parentNode.removeChild(this.input), Bt2(Dt2(a2.prototype), "destroy", this).call(this);
        } }, { key: "showValidationErrors", value: function(t4) {
          var e4 = this;
          this.previous_error_setting = this.jsoneditor.options.show_errors;
          var r3 = t4.reduce(function(t5, r4) {
            return r4.path === e4.path && t5.push(r4.message), t5;
          }, []);
          r3.length ? this.theme.addInputError(this.input, "".concat(r3.join(". "), ".")) : this.theme.removeInputError(this.input);
        } }]) && It2(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), a2;
      }(w2);
      function Vt2(t3) {
        return Vt2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, Vt2(t3);
      }
      function zt2(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== Vt2(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== Vt2(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === Vt2(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      function Ht2() {
        return Ht2 = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t3, e3, r2) {
          var n2 = function(t4, e4) {
            for (; !Object.prototype.hasOwnProperty.call(t4, e4) && null !== (t4 = qt2(t4)); )
              ;
            return t4;
          }(t3, e3);
          if (n2) {
            var i2 = Object.getOwnPropertyDescriptor(n2, e3);
            return i2.get ? i2.get.call(arguments.length < 3 ? t3 : r2) : i2.value;
          }
        }, Ht2.apply(this, arguments);
      }
      function Mt2(t3, e3) {
        return Mt2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, Mt2(t3, e3);
      }
      function qt2(t3) {
        return qt2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, qt2(t3);
      }
      var Gt2 = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && Mt2(t4, e4);
        }(a2, t3);
        var e3, r2, n2, i2, o2 = (n2 = a2, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = qt2(n2);
          if (i2) {
            var r3 = qt2(this).constructor;
            t4 = Reflect.construct(e4, arguments, r3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === Vt2(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function a2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), o2.apply(this, arguments);
        }
        return e3 = a2, (r2 = [{ key: "setValue", value: function(t4, e4) {
          if (this.choices_instance) {
            var r3 = this.typecast(t4 || "");
            if (this.enum_values.includes(r3) || (r3 = this.enum_values[0]), this.value === r3)
              return;
            e4 ? this.is_dirty = false : "change" === this.jsoneditor.options.show_errors && (this.is_dirty = true), this.input.value = this.enum_options[this.enum_values.indexOf(r3)], this.choices_instance.setChoiceByValue(this.input.value), this.value = r3, this.onChange();
          } else
            Ht2(qt2(a2.prototype), "setValue", this).call(this, t4, e4);
        } }, { key: "afterInputReady", value: function() {
          if (window.Choices && !this.choices_instance) {
            var t4 = this.expandCallbacks("choices", l({}, this.defaults.options.choices || {}, this.options.choices || {}));
            this.choices_instance = new window.Choices(this.input, t4);
          }
          Ht2(qt2(a2.prototype), "afterInputReady", this).call(this);
        } }, { key: "onWatchedFieldChange", value: function() {
          var t4 = this;
          if (Ht2(qt2(a2.prototype), "onWatchedFieldChange", this).call(this), this.choices_instance) {
            var e4 = this.enum_options.map(function(e5, r3) {
              return { value: e5, label: t4.enum_display[r3] };
            });
            this.choices_instance.setChoices(e4, "value", "label", true), this.choices_instance.setChoiceByValue("".concat(this.value));
          }
        } }, { key: "enable", value: function() {
          !this.always_disabled && this.choices_instance && this.choices_instance.enable(), Ht2(qt2(a2.prototype), "enable", this).call(this);
        } }, { key: "disable", value: function(t4) {
          this.choices_instance && this.choices_instance.disable(), Ht2(qt2(a2.prototype), "disable", this).call(this, t4);
        } }, { key: "destroy", value: function() {
          this.choices_instance && (this.choices_instance.destroy(), this.choices_instance = null), Ht2(qt2(a2.prototype), "destroy", this).call(this);
        } }]) && zt2(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), a2;
      }(Ft2);
      function Ut2(t3) {
        return Ut2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, Ut2(t3);
      }
      function $t2(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== Ut2(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== Ut2(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === Ut2(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      function Jt2() {
        return Jt2 = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t3, e3, r2) {
          var n2 = function(t4, e4) {
            for (; !Object.prototype.hasOwnProperty.call(t4, e4) && null !== (t4 = Zt2(t4)); )
              ;
            return t4;
          }(t3, e3);
          if (n2) {
            var i2 = Object.getOwnPropertyDescriptor(n2, e3);
            return i2.get ? i2.get.call(arguments.length < 3 ? t3 : r2) : i2.value;
          }
        }, Jt2.apply(this, arguments);
      }
      function Wt2(t3, e3) {
        return Wt2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, Wt2(t3, e3);
      }
      function Zt2(t3) {
        return Zt2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, Zt2(t3);
      }
      Gt2.rules = { ".choices > *": "box-sizing:border-box" };
      var Yt2 = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && Wt2(t4, e4);
        }(a2, t3);
        var e3, r2, n2, i2, o2 = (n2 = a2, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = Zt2(n2);
          if (i2) {
            var r3 = Zt2(this).constructor;
            t4 = Reflect.construct(e4, arguments, r3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === Ut2(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function a2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), o2.apply(this, arguments);
        }
        return e3 = a2, (r2 = [{ key: "build", value: function() {
          if (Jt2(Zt2(a2.prototype), "build", this).call(this), this.input && (this.schema.max && "string" == typeof this.schema.max && this.input.setAttribute("max", this.schema.max), this.schema.min && "string" == typeof this.schema.max && this.input.setAttribute("min", this.schema.min), window.flatpickr && "object" === Ut2(this.options.flatpickr))) {
            this.options.flatpickr.enableTime = "date" !== this.schema.format, this.options.flatpickr.noCalendar = "time" === this.schema.format, "integer" === this.schema.type && (this.options.flatpickr.mode = "single"), this.input.setAttribute("data-input", "");
            var t4 = this.input;
            if (true === this.options.flatpickr.wrap) {
              var e4 = [];
              if (false !== this.options.flatpickr.showToggleButton) {
                var r3 = this.getButton("", "time" === this.schema.format ? "time" : "calendar", "flatpickr_toggle_button");
                r3.setAttribute("data-toggle", ""), e4.push(r3);
              }
              if (false !== this.options.flatpickr.showClearButton) {
                var n3 = this.getButton("", "clear", "flatpickr_clear_button");
                n3.setAttribute("data-clear", ""), e4.push(n3);
              }
              var i3 = this.input.parentNode, o3 = this.input.nextSibling, s2 = this.theme.getInputGroup(this.input, e4);
              void 0 !== s2 ? (this.options.flatpickr.inline = false, i3.insertBefore(s2, o3), t4 = s2) : this.options.flatpickr.wrap = false;
            }
            this.flatpickr = window.flatpickr(t4, this.options.flatpickr), true === this.options.flatpickr.inline && true === this.options.flatpickr.inlineHideInput && this.input.setAttribute("type", "hidden");
          }
        } }, { key: "getValue", value: function() {
          if (this.dependenciesFulfilled) {
            if ("string" === this.schema.type)
              return this.value;
            if ("" !== this.value && void 0 !== this.value) {
              var t4 = "time" === this.schema.format ? "1970-01-01 ".concat(this.value) : this.value;
              return parseInt(new Date(t4).getTime() / 1e3);
            }
          }
        } }, { key: "setValue", value: function(t4, e4, r3) {
          if ("string" === this.schema.type)
            Jt2(Zt2(a2.prototype), "setValue", this).call(this, t4, e4, r3), this.flatpickr && this.flatpickr.setDate(t4);
          else if (t4 > 0) {
            var n3 = new Date(1e3 * t4), i3 = n3.getFullYear(), o3 = this.zeroPad(n3.getMonth() + 1), s2 = this.zeroPad(n3.getDate()), l2 = this.zeroPad(n3.getHours()), c3 = this.zeroPad(n3.getMinutes()), u2 = this.zeroPad(n3.getSeconds()), h3 = [i3, o3, s2].join("-"), p3 = [l2, c3, u2].join(":"), d2 = "".concat(h3, "T").concat(p3);
            "date" === this.schema.format ? d2 = h3 : "time" === this.schema.format && (d2 = p3), this.input.value = d2, this.refreshValue(), this.flatpickr && this.flatpickr.setDate(d2);
          }
        } }, { key: "destroy", value: function() {
          this.flatpickr && this.flatpickr.destroy(), this.flatpickr = null, Jt2(Zt2(a2.prototype), "destroy", this).call(this);
        } }, { key: "zeroPad", value: function(t4) {
          return "0".concat(t4).slice(-2);
        } }]) && $t2(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), a2;
      }(C2);
      function Qt2(t3) {
        return Qt2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, Qt2(t3);
      }
      function Kt2(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== Qt2(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== Qt2(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === Qt2(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      function Xt2() {
        return Xt2 = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t3, e3, r2) {
          var n2 = function(t4, e4) {
            for (; !Object.prototype.hasOwnProperty.call(t4, e4) && null !== (t4 = ee2(t4)); )
              ;
            return t4;
          }(t3, e3);
          if (n2) {
            var i2 = Object.getOwnPropertyDescriptor(n2, e3);
            return i2.get ? i2.get.call(arguments.length < 3 ? t3 : r2) : i2.value;
          }
        }, Xt2.apply(this, arguments);
      }
      function te2(t3, e3) {
        return te2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, te2(t3, e3);
      }
      function ee2(t3) {
        return ee2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, ee2(t3);
      }
      var re2 = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && te2(t4, e4);
        }(a2, t3);
        var e3, r2, n2, i2, o2 = (n2 = a2, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = ee2(n2);
          if (i2) {
            var r3 = ee2(this).constructor;
            t4 = Reflect.construct(e4, arguments, r3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === Qt2(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function a2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), o2.apply(this, arguments);
        }
        return e3 = a2, (r2 = [{ key: "register", value: function() {
          if (this.editors) {
            for (var t4 = 0; t4 < this.editors.length; t4++)
              this.editors[t4] && this.editors[t4].unregister();
            this.editors[this.currentEditor] && this.editors[this.currentEditor].register();
          }
          Xt2(ee2(a2.prototype), "register", this).call(this);
        } }, { key: "unregister", value: function() {
          if (Xt2(ee2(a2.prototype), "unregister", this).call(this), this.editors)
            for (var t4 = 0; t4 < this.editors.length; t4++)
              this.editors[t4] && this.editors[t4].unregister();
        } }, { key: "getNumColumns", value: function() {
          return this.editors[this.currentEditor] ? Math.max(this.editors[this.currentEditor].getNumColumns(), 4) : 4;
        } }, { key: "enable", value: function() {
          if (this.editors)
            for (var t4 = 0; t4 < this.editors.length; t4++)
              this.editors[t4] && this.editors[t4].enable();
          Xt2(ee2(a2.prototype), "enable", this).call(this);
        } }, { key: "disable", value: function() {
          if (this.editors)
            for (var t4 = 0; t4 < this.editors.length; t4++)
              this.editors[t4] && this.editors[t4].disable();
          Xt2(ee2(a2.prototype), "disable", this).call(this);
        } }, { key: "switchEditor", value: function() {
          var t4 = this, e4 = this.getWatchedFieldValues();
          if (e4) {
            var r3 = document.location.origin + document.location.pathname + this.template(e4);
            this.editors[this.refs[r3]] || this.buildChildEditor(r3), this.currentEditor = this.refs[r3], this.register(), this.editors.forEach(function(e5, r4) {
              e5 && (t4.currentEditor === r4 ? e5.container.style.display = "" : e5.container.style.display = "none");
            }), this.refreshValue(), this.onChange(true);
          }
        } }, { key: "buildChildEditor", value: function(t4) {
          this.refs[t4] = this.editors.length;
          var e4 = this.theme.getChildEditorHolder();
          this.editor_holder.appendChild(e4);
          var r3 = l({}, this.schema, this.jsoneditor.refs[t4]), n3 = this.jsoneditor.getEditorClass(r3, this.jsoneditor), i3 = this.jsoneditor.createEditor(n3, { jsoneditor: this.jsoneditor, schema: r3, container: e4, path: this.path, parent: this, required: true });
          this.editors.push(i3), i3.preBuild(), i3.build(), i3.postBuild();
        } }, { key: "preBuild", value: function() {
          var t4;
          for (this.refs = {}, this.editors = [], this.currentEditor = "", t4 = 0; t4 < this.schema.links.length; t4++)
            if ("describedby" === this.schema.links[t4].rel.toLowerCase()) {
              this.template = this.jsoneditor.compileTemplate(this.schema.links[t4].href, this.template_engine);
              break;
            }
          this.schema.links = this.schema.links.slice(0, t4).concat(this.schema.links.slice(t4 + 1)), 0 === this.schema.links.length && delete this.schema.links, this.baseSchema = l({}, this.schema);
        } }, { key: "build", value: function() {
          this.editor_holder = document.createElement("div"), this.container.appendChild(this.editor_holder), this.switchEditor();
        } }, { key: "onWatchedFieldChange", value: function() {
          this.switchEditor();
        } }, { key: "onChildEditorChange", value: function(t4) {
          this.editors[this.currentEditor] && this.refreshValue(), Xt2(ee2(a2.prototype), "onChildEditorChange", this).call(this, t4);
        } }, { key: "refreshValue", value: function() {
          this.editors[this.currentEditor] && (this.value = this.editors[this.currentEditor].getValue());
        } }, { key: "setValue", value: function(t4, e4) {
          this.editors[this.currentEditor] && (this.editors[this.currentEditor].setValue(t4, e4), this.refreshValue(), this.onChange());
        } }, { key: "destroy", value: function() {
          this.editors.forEach(function(t4) {
            t4 && t4.destroy();
          }), this.editor_holder && this.editor_holder.parentNode && this.editor_holder.parentNode.removeChild(this.editor_holder), Xt2(ee2(a2.prototype), "destroy", this).call(this);
        } }, { key: "showValidationErrors", value: function(t4) {
          this.editors.forEach(function(e4) {
            e4 && e4.showValidationErrors(t4);
          });
        } }]) && Kt2(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), a2;
      }(w2);
      function ne(t3) {
        return ne = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, ne(t3);
      }
      function ie(t3, e3) {
        (null == e3 || e3 > t3.length) && (e3 = t3.length);
        for (var r2 = 0, n2 = new Array(e3); r2 < e3; r2++)
          n2[r2] = t3[r2];
        return n2;
      }
      function oe2(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== ne(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== ne(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === ne(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      function ae2() {
        return ae2 = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t3, e3, r2) {
          var n2 = function(t4, e4) {
            for (; !Object.prototype.hasOwnProperty.call(t4, e4) && null !== (t4 = le2(t4)); )
              ;
            return t4;
          }(t3, e3);
          if (n2) {
            var i2 = Object.getOwnPropertyDescriptor(n2, e3);
            return i2.get ? i2.get.call(arguments.length < 3 ? t3 : r2) : i2.value;
          }
        }, ae2.apply(this, arguments);
      }
      function se2(t3, e3) {
        return se2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, se2(t3, e3);
      }
      function le2(t3) {
        return le2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, le2(t3);
      }
      var ce2 = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && se2(t4, e4);
        }(a2, t3);
        var e3, r2, n2, i2, o2 = (n2 = a2, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = le2(n2);
          if (i2) {
            var r3 = le2(this).constructor;
            t4 = Reflect.construct(e4, arguments, r3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === ne(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function a2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), o2.apply(this, arguments);
        }
        return e3 = a2, (r2 = [{ key: "getNumColumns", value: function() {
          return 4;
        } }, { key: "build", value: function() {
          var t4 = this;
          this.title = this.header = this.label = this.theme.getFormInputLabel(this.getTitle(), this.isRequired()), this.container.appendChild(this.title), this.options.enum_titles = this.options.enum_titles || [], this.enum = this.schema.enum, this.selected = 0, this.select_options = [], this.html_values = [];
          for (var e4 = 0; e4 < this.enum.length; e4++)
            this.select_options[e4] = this.options.enum_titles[e4] || "Value ".concat(e4 + 1), this.html_values[e4] = this.getHTML(this.enum[e4]);
          this.switcher = this.theme.getSwitcher(this.select_options), this.container.appendChild(this.switcher), this.display_area = this.theme.getIndentedPanel(), this.container.appendChild(this.display_area), this.options.hide_display && (this.display_area.style.display = "none"), this.switcher.addEventListener("change", function(e5) {
            t4.selected = t4.select_options.indexOf(e5.currentTarget.value), t4.value = t4.enum[t4.selected], t4.refreshValue(), t4.onChange(true);
          }), this.value = this.enum[0], this.refreshValue(), 1 === this.enum.length && (this.switcher.style.display = "none");
        } }, { key: "refreshValue", value: function() {
          var t4 = this;
          this.selected = -1;
          var e4 = JSON.stringify(this.value);
          this.enum.forEach(function(r3, n3) {
            if (e4 === JSON.stringify(r3))
              return t4.selected = n3, false;
          }), this.selected < 0 ? this.setValue(this.enum[0]) : (this.switcher.value = this.select_options[this.selected], this.display_area.innerHTML = this.html_values[this.selected]);
        } }, { key: "enable", value: function() {
          this.always_disabled || (this.switcher.disabled = false, ae2(le2(a2.prototype), "enable", this).call(this));
        } }, { key: "disable", value: function(t4) {
          t4 && (this.always_disabled = true), this.switcher.disabled = true, ae2(le2(a2.prototype), "disable", this).call(this);
        } }, { key: "getHTML", value: function(t4) {
          var e4, r3, n3 = this;
          if (null === t4)
            return "<em>null</em>";
          if ("object" === ne(t4)) {
            var i3 = "";
            return e4 = t4, r3 = function(e5, r4) {
              var o3 = n3.getHTML(r4);
              Array.isArray(t4) || (o3 = "<div><em>".concat(e5, "</em>: ").concat(o3, "</div>")), i3 += "<li>".concat(o3, "</li>");
            }, Array.isArray(e4) || "number" == typeof e4.length && e4.length > 0 && e4.length - 1 in e4 ? Array.from(e4).forEach(function(t5, e5) {
              return r3(e5, t5);
            }) : Object.entries(e4).forEach(function(t5) {
              var e5, n4, i4 = (n4 = 2, function(t6) {
                if (Array.isArray(t6))
                  return t6;
              }(e5 = t5) || function(t6, e6) {
                var r4 = null == t6 ? null : "undefined" != typeof Symbol && t6[Symbol.iterator] || t6["@@iterator"];
                if (null != r4) {
                  var n5, i5, o4, a4, s2 = [], l2 = true, c3 = false;
                  try {
                    if (o4 = (r4 = r4.call(t6)).next, 0 === e6) {
                      if (Object(r4) !== r4)
                        return;
                      l2 = false;
                    } else
                      for (; !(l2 = (n5 = o4.call(r4)).done) && (s2.push(n5.value), s2.length !== e6); l2 = true)
                        ;
                  } catch (t7) {
                    c3 = true, i5 = t7;
                  } finally {
                    try {
                      if (!l2 && null != r4.return && (a4 = r4.return(), Object(a4) !== a4))
                        return;
                    } finally {
                      if (c3)
                        throw i5;
                    }
                  }
                  return s2;
                }
              }(e5, n4) || function(t6, e6) {
                if (t6) {
                  if ("string" == typeof t6)
                    return ie(t6, e6);
                  var r4 = Object.prototype.toString.call(t6).slice(8, -1);
                  return "Object" === r4 && t6.constructor && (r4 = t6.constructor.name), "Map" === r4 || "Set" === r4 ? Array.from(t6) : "Arguments" === r4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r4) ? ie(t6, e6) : void 0;
                }
              }(e5, n4) || function() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
              }()), o3 = i4[0], a3 = i4[1];
              return r3(o3, a3);
            }), i3 = Array.isArray(t4) ? "<ol>".concat(i3, "</ol>") : "<ul style='margin-top:0;margin-bottom:0;padding-top:0;padding-bottom:0;'>".concat(i3, "</ul>");
          }
          return "boolean" == typeof t4 ? t4 ? "true" : "false" : "string" == typeof t4 ? t4.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;") : t4;
        } }, { key: "setValue", value: function(t4) {
          this.value !== t4 && (this.value = t4, this.refreshValue(), this.onChange());
        } }, { key: "destroy", value: function() {
          this.display_area && this.display_area.parentNode && this.display_area.parentNode.removeChild(this.display_area), this.title && this.title.parentNode && this.title.parentNode.removeChild(this.title), this.switcher && this.switcher.parentNode && this.switcher.parentNode.removeChild(this.switcher), ae2(le2(a2.prototype), "destroy", this).call(this);
        } }]) && oe2(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), a2;
      }(w2);
      function ue2(t3) {
        return ue2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, ue2(t3);
      }
      function he2(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== ue2(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== ue2(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === ue2(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      function pe2() {
        return pe2 = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t3, e3, r2) {
          var n2 = function(t4, e4) {
            for (; !Object.prototype.hasOwnProperty.call(t4, e4) && null !== (t4 = fe2(t4)); )
              ;
            return t4;
          }(t3, e3);
          if (n2) {
            var i2 = Object.getOwnPropertyDescriptor(n2, e3);
            return i2.get ? i2.get.call(arguments.length < 3 ? t3 : r2) : i2.value;
          }
        }, pe2.apply(this, arguments);
      }
      function de(t3, e3) {
        return de = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, de(t3, e3);
      }
      function fe2(t3) {
        return fe2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, fe2(t3);
      }
      var ye = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && de(t4, e4);
        }(a2, t3);
        var e3, r2, n2, i2, o2 = (n2 = a2, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = fe2(n2);
          if (i2) {
            var r3 = fe2(this).constructor;
            t4 = Reflect.construct(e4, arguments, r3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === ue2(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function a2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), o2.apply(this, arguments);
        }
        return e3 = a2, (r2 = [{ key: "register", value: function() {
          pe2(fe2(a2.prototype), "register", this).call(this), this.input && this.jsoneditor.options.use_name_attributes && this.input.setAttribute("name", this.formname);
        } }, { key: "unregister", value: function() {
          pe2(fe2(a2.prototype), "unregister", this).call(this), this.input && this.input.removeAttribute("name");
        } }, { key: "setValue", value: function(t4, e4, r3) {
          if ((!this.template || r3) && (null == t4 ? t4 = "" : "object" === ue2(t4) ? t4 = JSON.stringify(t4) : "string" != typeof t4 && (t4 = "".concat(t4)), t4 !== this.serialized)) {
            var n3 = this.sanitize(t4);
            if (this.input.value !== n3) {
              this.input.value = n3;
              var i3 = r3 || this.getValue() !== t4;
              this.refreshValue(), e4 ? this.is_dirty = false : "change" === this.jsoneditor.options.show_errors && (this.is_dirty = true), this.adjust_height && this.adjust_height(this.input), this.onChange(i3);
            }
          }
        } }, { key: "getNumColumns", value: function() {
          return 2;
        } }, { key: "enable", value: function() {
          pe2(fe2(a2.prototype), "enable", this).call(this);
        } }, { key: "disable", value: function() {
          pe2(fe2(a2.prototype), "disable", this).call(this);
        } }, { key: "refreshValue", value: function() {
          this.value = this.input.value, "string" != typeof this.value && (this.value = ""), this.serialized = this.value;
        } }, { key: "destroy", value: function() {
          this.template = null, this.input && this.input.parentNode && this.input.parentNode.removeChild(this.input), this.label && this.label.parentNode && this.label.parentNode.removeChild(this.label), this.description && this.description.parentNode && this.description.parentNode.removeChild(this.description), pe2(fe2(a2.prototype), "destroy", this).call(this);
        } }, { key: "sanitize", value: function(t4) {
          return t4;
        } }, { key: "onWatchedFieldChange", value: function() {
          var t4;
          this.template && (t4 = this.getWatchedFieldValues(), this.setValue(this.template(t4), false, true)), pe2(fe2(a2.prototype), "onWatchedFieldChange", this).call(this);
        } }, { key: "build", value: function() {
          if (this.format = this.schema.format, !this.format && this.options.default_format && (this.format = this.options.default_format), this.options.format && (this.format = this.options.format), this.input_type = "hidden", this.input = this.theme.getFormInputField(this.input_type), this.format && this.input.setAttribute("data-schemaformat", this.format), this.container.appendChild(this.input), this.schema.template) {
            var t4 = this.expandCallbacks("template", { template: this.schema.template });
            "function" == typeof t4.template ? this.template = t4.template : this.template = this.jsoneditor.compileTemplate(this.schema.template, this.template_engine), this.refreshValue();
          } else
            this.refreshValue();
        } }]) && he2(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), a2;
      }(w2);
      function me(t3) {
        return me = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, me(t3);
      }
      function ve2(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== me(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== me(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === me(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      function be2(t3, e3) {
        return be2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, be2(t3, e3);
      }
      function ge2(t3) {
        return ge2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, ge2(t3);
      }
      var we = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && be2(t4, e4);
        }(a2, t3);
        var e3, r2, n2, i2, o2 = (n2 = a2, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = ge2(n2);
          if (i2) {
            var r3 = ge2(this).constructor;
            t4 = Reflect.construct(e4, arguments, r3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === me(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function a2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), o2.apply(this, arguments);
        }
        return e3 = a2, (r2 = [{ key: "build", value: function() {
          this.options.compact = false, this.header = this.label = this.theme.getFormInputLabel(this.getTitle()), this.description = this.theme.getDescription(this.schema.description || ""), this.control = this.theme.getFormControl(this.label, this.description, null), this.container.appendChild(this.control);
        } }, { key: "getTitle", value: function() {
          return this.translateProperty(this.schema.title);
        } }, { key: "getNumColumns", value: function() {
          return 12;
        } }]) && ve2(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), a2;
      }(Ct2);
      function _e(t3) {
        return _e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, _e(t3);
      }
      function ke(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== _e(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== _e(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === _e(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      function je() {
        return je = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t3, e3, r2) {
          var n2 = function(t4, e4) {
            for (; !Object.prototype.hasOwnProperty.call(t4, e4) && null !== (t4 = xe(t4)); )
              ;
            return t4;
          }(t3, e3);
          if (n2) {
            var i2 = Object.getOwnPropertyDescriptor(n2, e3);
            return i2.get ? i2.get.call(arguments.length < 3 ? t3 : r2) : i2.value;
          }
        }, je.apply(this, arguments);
      }
      function Oe(t3, e3) {
        return Oe = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, Oe(t3, e3);
      }
      function xe(t3) {
        return xe = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, xe(t3);
      }
      var Ce = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && Oe(t4, e4);
        }(a2, t3);
        var e3, r2, n2, i2, o2 = (n2 = a2, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = xe(n2);
          if (i2) {
            var r3 = xe(this).constructor;
            t4 = Reflect.construct(e4, arguments, r3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === _e(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function a2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), o2.apply(this, arguments);
        }
        return e3 = a2, (r2 = [{ key: "build", value: function() {
          if (je(xe(a2.prototype), "build", this).call(this), void 0 !== this.schema.minimum) {
            var t4 = this.schema.minimum;
            void 0 !== this.schema.exclusiveMinimum && (t4 += 1), this.input.setAttribute("min", t4);
          }
          if (void 0 !== this.schema.maximum) {
            var e4 = this.schema.maximum;
            void 0 !== this.schema.exclusiveMaximum && (e4 -= 1), this.input.setAttribute("max", e4);
          }
          if (void 0 !== this.schema.step) {
            var r3 = this.schema.step || 1;
            this.input.setAttribute("step", r3);
          }
          this.setInputAttributes(["maxlength", "pattern", "readonly", "min", "max", "step"]);
        } }, { key: "getNumColumns", value: function() {
          return 2;
        } }, { key: "getValue", value: function() {
          if (this.dependenciesFulfilled)
            return this.schema.default || this.jsoneditor.options.use_default_values || "" !== this.value ? function(t4) {
              if (null == t4)
                return false;
              var e4 = t4.match(p2), r3 = parseFloat(t4);
              return null !== e4 && !isNaN(r3) && isFinite(r3);
            }(this.value) ? parseFloat(this.value) : this.value : void (this.input.value = "");
        } }]) && ke(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), a2;
      }(C2);
      function Ee(t3) {
        return Ee = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, Ee(t3);
      }
      function Se(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== Ee(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== Ee(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === Ee(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      function Pe(t3, e3) {
        return Pe = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, Pe(t3, e3);
      }
      function Te(t3) {
        return Te = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, Te(t3);
      }
      var Le = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && Pe(t4, e4);
        }(a2, t3);
        var e3, r2, n2, i2, o2 = (n2 = a2, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = Te(n2);
          if (i2) {
            var r3 = Te(this).constructor;
            t4 = Reflect.construct(e4, arguments, r3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === Ee(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function a2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), o2.apply(this, arguments);
        }
        return e3 = a2, (r2 = [{ key: "getNumColumns", value: function() {
          return 2;
        } }, { key: "getValue", value: function() {
          if (this.dependenciesFulfilled)
            return this.schema.default || this.jsoneditor.options.use_default_values || "" !== this.value ? function(t4) {
              if (null == t4)
                return false;
              var e4 = t4.match(d), r3 = parseInt(t4);
              return null !== e4 && !isNaN(r3) && isFinite(r3);
            }(this.value) ? parseInt(this.value) : this.value : void (this.input.value = "");
        } }]) && Se(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), a2;
      }(Ce);
      function Re(t3) {
        return Re = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, Re(t3);
      }
      function Ae(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== Re(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== Re(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === Re(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      function Ie() {
        return Ie = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t3, e3, r2) {
          var n2 = function(t4, e4) {
            for (; !Object.prototype.hasOwnProperty.call(t4, e4) && null !== (t4 = Ne(t4)); )
              ;
            return t4;
          }(t3, e3);
          if (n2) {
            var i2 = Object.getOwnPropertyDescriptor(n2, e3);
            return i2.get ? i2.get.call(arguments.length < 3 ? t3 : r2) : i2.value;
          }
        }, Ie.apply(this, arguments);
      }
      function Be(t3, e3) {
        return Be = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, Be(t3, e3);
      }
      function Ne(t3) {
        return Ne = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, Ne(t3);
      }
      var De = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && Be(t4, e4);
        }(a2, t3);
        var e3, r2, n2, i2, o2 = (n2 = a2, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = Ne(n2);
          if (i2) {
            var r3 = Ne(this).constructor;
            t4 = Reflect.construct(e4, arguments, r3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === Re(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function a2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), o2.apply(this, arguments);
        }
        return e3 = a2, (r2 = [{ key: "preBuild", value: function() {
          if (Ie(Ne(a2.prototype), "preBuild", this).call(this), this.schema.options || (this.schema.options = {}), !this.schema.options.cleave)
            switch (this.format) {
              case "ipv6":
                this.schema.options.cleave = { delimiters: [":"], blocks: [4, 4, 4, 4, 4, 4, 4, 4], uppercase: true };
                break;
              case "ipv4":
                this.schema.options.cleave = { delimiters: ["."], blocks: [3, 3, 3, 3], numericOnly: true };
            }
          this.options = l(this.options, this.schema.options || {});
        } }]) && Ae(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), a2;
      }(C2);
      function Fe(t3) {
        return Fe = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, Fe(t3);
      }
      function Ve(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== Fe(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== Fe(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === Fe(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      function ze() {
        return ze = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t3, e3, r2) {
          var n2 = function(t4, e4) {
            for (; !Object.prototype.hasOwnProperty.call(t4, e4) && null !== (t4 = Me(t4)); )
              ;
            return t4;
          }(t3, e3);
          if (n2) {
            var i2 = Object.getOwnPropertyDescriptor(n2, e3);
            return i2.get ? i2.get.call(arguments.length < 3 ? t3 : r2) : i2.value;
          }
        }, ze.apply(this, arguments);
      }
      function He(t3, e3) {
        return He = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, He(t3, e3);
      }
      function Me(t3) {
        return Me = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, Me(t3);
      }
      var qe = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && He(t4, e4);
        }(a2, t3);
        var e3, r2, n2, i2, o2 = (n2 = a2, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = Me(n2);
          if (i2) {
            var r3 = Me(this).constructor;
            t4 = Reflect.construct(e4, arguments, r3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === Fe(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function a2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), o2.apply(this, arguments);
        }
        return e3 = a2, (r2 = [{ key: "setValue", value: function(t4, e4, r3) {
          var n3 = ze(Me(a2.prototype), "setValue", this).call(this, t4, e4, r3);
          void 0 !== n3 && n3.changed && this.jodit_instance && this.jodit_instance.setEditorValue(n3.value);
        } }, { key: "build", value: function() {
          this.options.format = "textarea", ze(Me(a2.prototype), "build", this).call(this), this.input_type = this.schema.format, this.input.setAttribute("data-schemaformat", this.input_type);
        } }, { key: "afterInputReady", value: function() {
          var t4, e4 = this;
          window.Jodit ? (t4 = this.expandCallbacks("jodit", l({}, { height: 300 }, this.defaults.options.jodit || {}, this.options.jodit || {})), this.jodit_instance = new window.Jodit(this.input, t4), (this.schema.readOnly || this.schema.readonly || this.schema.template) && this.jodit_instance.setReadOnly(true), this.jodit_instance.events.on("change", function() {
            e4.value = e4.jodit_instance.getEditorValue(), e4.is_dirty = true, e4.onChange(true);
          }), this.theme.afterInputReady(this.input)) : ze(Me(a2.prototype), "afterInputReady", this).call(this);
        } }, { key: "getNumColumns", value: function() {
          return 6;
        } }, { key: "enable", value: function() {
          !this.always_disabled && this.jodit_instance && this.jodit_instance.setReadOnly(false), ze(Me(a2.prototype), "enable", this).call(this);
        } }, { key: "disable", value: function(t4) {
          this.jodit_instance && this.jodit_instance.setReadOnly(true), ze(Me(a2.prototype), "disable", this).call(this, t4);
        } }, { key: "destroy", value: function() {
          this.jodit_instance && (this.jodit_instance.destruct(), this.jodit_instance = null), ze(Me(a2.prototype), "destroy", this).call(this);
        } }]) && Ve(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), a2;
      }(C2), Ge = (r(6541), r(9337), r(3321), function(t3) {
        var e3 = t3.split(".");
        if (4 !== e3.length)
          throw new Error("error_ipv4");
        e3.forEach(function(t4) {
          if (isNaN(+t4) || +t4 < 0 || +t4 > 255)
            throw new Error("error_ipv4");
        });
      }), Ue = function(t3) {
        if (!t3.match("^(?:(?:(?:[a-fA-F0-9]{1,4}:){6}|(?=(?:[a-fA-F0-9]{0,4}:){2,6}(?:[0-9]{1,3}.){3}[0-9]{1,3}$)(([0-9a-fA-F]{1,4}:){1,5}|:)((:[0-9a-fA-F]{1,4}){1,5}:|:)|::(?:[a-fA-F0-9]{1,4}:){5})(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9]).){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])|(?:[a-fA-F0-9]{1,4}:){7}[a-fA-F0-9]{1,4}|(?=(?:[a-fA-F0-9]{0,4}:){0,7}[a-fA-F0-9]{0,4}$)(([0-9a-fA-F]{1,4}:){1,7}|:)((:[0-9a-fA-F]{1,4}){1,7}|:)|(?:[a-fA-F0-9]{1,4}:){7}:|:(:[a-fA-F0-9]{1,4}){7})$"))
          throw new Error("error_ipv6");
      }, $e = function(t3) {
        if (!t3.match("(?=^.{4,253}$)(^((?!-)[a-zA-Z0-9-]{0,62}[a-zA-Z0-9].)+[a-zA-Z]{2,63}$)"))
          throw new Error("error_hostname");
      };
      function Je(t3, e3, r2, n2) {
        try {
          switch (t3.format) {
            case "ipv4":
              Ge(e3);
              break;
            case "ipv6":
              Ue(e3);
              break;
            case "hostname":
              $e(e3);
          }
          return [];
        } catch (t4) {
          return [{ path: r2, property: "format", message: n2(t4.message) }];
        }
      }
      function We(t3, e3) {
        var r2 = Object.keys(t3);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t3);
          e3 && (n2 = n2.filter(function(e4) {
            return Object.getOwnPropertyDescriptor(t3, e4).enumerable;
          })), r2.push.apply(r2, n2);
        }
        return r2;
      }
      function Ze(t3, e3, r2) {
        return (e3 = rr(e3)) in t3 ? Object.defineProperty(t3, e3, { value: r2, enumerable: true, configurable: true, writable: true }) : t3[e3] = r2, t3;
      }
      function Ye(t3, e3) {
        return function(t4) {
          if (Array.isArray(t4))
            return t4;
        }(t3) || function(t4, e4) {
          var r2 = null == t4 ? null : "undefined" != typeof Symbol && t4[Symbol.iterator] || t4["@@iterator"];
          if (null != r2) {
            var n2, i2, o2, a2, s2 = [], l2 = true, c3 = false;
            try {
              if (o2 = (r2 = r2.call(t4)).next, 0 === e4) {
                if (Object(r2) !== r2)
                  return;
                l2 = false;
              } else
                for (; !(l2 = (n2 = o2.call(r2)).done) && (s2.push(n2.value), s2.length !== e4); l2 = true)
                  ;
            } catch (t5) {
              c3 = true, i2 = t5;
            } finally {
              try {
                if (!l2 && null != r2.return && (a2 = r2.return(), Object(a2) !== a2))
                  return;
              } finally {
                if (c3)
                  throw i2;
              }
            }
            return s2;
          }
        }(t3, e3) || Xe(t3, e3) || function() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function Qe(t3) {
        return Qe = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, Qe(t3);
      }
      function Ke(t3) {
        return function(t4) {
          if (Array.isArray(t4))
            return tr(t4);
        }(t3) || function(t4) {
          if ("undefined" != typeof Symbol && null != t4[Symbol.iterator] || null != t4["@@iterator"])
            return Array.from(t4);
        }(t3) || Xe(t3) || function() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function Xe(t3, e3) {
        if (t3) {
          if ("string" == typeof t3)
            return tr(t3, e3);
          var r2 = Object.prototype.toString.call(t3).slice(8, -1);
          return "Object" === r2 && t3.constructor && (r2 = t3.constructor.name), "Map" === r2 || "Set" === r2 ? Array.from(t3) : "Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2) ? tr(t3, e3) : void 0;
        }
      }
      function tr(t3, e3) {
        (null == e3 || e3 > t3.length) && (e3 = t3.length);
        for (var r2 = 0, n2 = new Array(e3); r2 < e3; r2++)
          n2[r2] = t3[r2];
        return n2;
      }
      function er(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, rr(n2.key), n2);
        }
      }
      function rr(t3) {
        var e3 = function(t4, e4) {
          if ("object" !== Qe(t4) || null === t4)
            return t4;
          var r2 = t4[Symbol.toPrimitive];
          if (void 0 !== r2) {
            var n2 = r2.call(t4, "string");
            if ("object" !== Qe(n2))
              return n2;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(t4);
        }(t3);
        return "symbol" === Qe(e3) ? e3 : String(e3);
      }
      var nr = function() {
        function t3(e4, r3, n2, i2) {
          !function(t4, e5) {
            if (!(t4 instanceof e5))
              throw new TypeError("Cannot call a class as a function");
          }(this, t3), this.jsoneditor = e4, this.schema = r3 || this.jsoneditor.schema, this.options = n2 || {}, this.translate = this.jsoneditor.translate || i2.translate, this.translateProperty = this.jsoneditor.translateProperty || i2.translateProperty, this.defaults = i2, this._validateSubSchema = { dependentSchemas: function(t4, e5, r4) {
            var n3 = this, i3 = [];
            return Object.keys(t4.dependentSchemas).forEach(function(o2) {
              if (void 0 !== e5[o2]) {
                var a2 = t4.dependentSchemas[o2], s2 = n3._validateSchema(a2, e5, r4);
                i3 = [].concat(Ke(i3), Ke(s2));
              }
            }), i3;
          }, contains: function(t4, e5, r4) {
            var n3 = this, i3 = [], o2 = 0;
            e5.forEach(function(e6) {
              0 === n3._validateSchema(t4.contains, e6, r4).length && o2++;
            });
            var a2 = 0 === o2;
            return void 0 !== t4.minContains ? o2 < t4.minContains && i3.push({ message: this.translate("error_minContains", [o2, t4.minContains], t4), path: r4 }) : a2 && i3.push({ message: this.translate("error_contains", null, t4), path: r4 }), void 0 !== t4.maxContains && o2 > t4.maxContains && i3.push({ message: this.translate("error_maxContains", [o2, t4.maxContains], t4), path: r4 }), i3;
          }, if: function(t4, e5, r4) {
            if (void 0 === t4.then && void 0 === t4.else)
              return [];
            var n3 = this._validateSchema(t4.if, e5, r4), i3 = [], o2 = [];
            return void 0 !== t4.then && (i3 = this._validateSchema(t4.then, e5, r4)), void 0 !== t4.else && (o2 = this._validateSchema(t4.else, e5, r4)), true === t4.if ? i3 : false === t4.if ? o2 : 0 === n3.length ? i3 : n3.length > 0 ? o2 : [];
          }, const: function(t4, e5, r4) {
            return JSON.stringify(t4.const) !== JSON.stringify(e5) || Array.isArray(e5) || "object" === Qe(e5) ? [{ path: r4, property: "const", message: this.translate("error_const", null, t4) }] : [];
          }, enum: function(t4, e5, r4) {
            var n3 = JSON.stringify(e5);
            return t4.enum.some(function(t5) {
              return n3 === JSON.stringify(t5);
            }) ? [] : [{ path: r4, property: "enum", message: this.translate("error_enum", null, t4) }];
          }, extends: function(t4, e5, r4) {
            var n3 = this;
            return t4.extends.reduce(function(t5, i3) {
              return t5.push.apply(t5, Ke(n3._validateSchema(i3, e5, r4))), t5;
            }, []);
          }, allOf: function(t4, e5, r4) {
            var n3 = this;
            return t4.allOf.reduce(function(t5, i3) {
              return t5.push.apply(t5, Ke(n3._validateSchema(i3, e5, r4))), t5;
            }, []);
          }, anyOf: function(t4, e5, r4) {
            var n3 = this;
            return t4.anyOf.some(function(t5) {
              return !n3._validateSchema(t5, e5, r4).length;
            }) ? [] : [{ path: r4, property: "anyOf", message: this.translate("error_anyOf", null, t4) }];
          }, oneOf: function(t4, e5, r4) {
            var n3 = this, i3 = 0, o2 = [];
            t4.oneOf.forEach(function(t5, a3) {
              var s2 = n3._validateSchema(t5, e5, r4);
              s2.length || i3++, s2.forEach(function(t6) {
                t6.path = "".concat(r4, ".oneOf[").concat(a3, "]").concat(t6.path.substr(r4.length));
              }), o2.push.apply(o2, Ke(s2));
            });
            var a2 = [];
            return 1 !== i3 && (a2.push({ path: r4, property: "oneOf", message: this.translate("error_oneOf", [i3], t4) }), a2.push.apply(a2, o2)), a2;
          }, not: function(t4, e5, r4) {
            return this._validateSchema(t4.not, e5, r4).length ? [] : [{ path: r4, property: "not", message: this.translate("error_not", null, t4) }];
          }, type: function(t4, e5, r4) {
            var n3 = this;
            if (Array.isArray(t4.type)) {
              if (!t4.type.some(function(t5) {
                return n3._checkType(t5, e5);
              }))
                return [{ path: r4, property: "type", message: this.translate("error_type_union", null, t4) }];
            } else if (["date", "time", "datetime-local"].includes(t4.format) && "integer" === t4.type) {
              if (!this._checkType("string", "".concat(e5)))
                return [{ path: r4, property: "type", message: this.translate("error_type", [t4.format], t4) }];
            } else if (!this._checkType(t4.type, e5))
              return [{ path: r4, property: "type", message: this.translate("error_type", [t4.type], t4) }];
            return [];
          }, disallow: function(t4, e5, r4) {
            var n3 = this;
            if (Array.isArray(t4.disallow)) {
              if (t4.disallow.some(function(t5) {
                return n3._checkType(t5, e5);
              }))
                return [{ path: r4, property: "disallow", message: this.translate("error_disallow_union", null, t4) }];
            } else if (this._checkType(t4.disallow, e5))
              return [{ path: r4, property: "disallow", message: this.translate("error_disallow", [t4.disallow], t4) }];
            return [];
          } }, this._validateNumberSubSchema = { multipleOf: function(t4, e5, r4) {
            return this._validateNumberSubSchemaMultipleDivisible(t4, e5, r4);
          }, divisibleBy: function(t4, e5, r4) {
            return this._validateNumberSubSchemaMultipleDivisible(t4, e5, r4);
          }, maximum: function(t4, e5, r4) {
            var n3 = t4.exclusiveMaximum ? e5 < t4.maximum : e5 <= t4.maximum;
            return window.math ? n3 = window.math[t4.exclusiveMaximum ? "smaller" : "smallerEq"](window.math.bignumber(e5), window.math.bignumber(t4.maximum)) : window.Decimal && (n3 = new window.Decimal(e5)[t4.exclusiveMaximum ? "lt" : "lte"](new window.Decimal(t4.maximum))), n3 ? [] : [{ path: r4, property: "maximum", message: this.translate(t4.exclusiveMaximum ? "error_maximum_excl" : "error_maximum_incl", [t4.maximum], t4) }];
          }, minimum: function(t4, e5, r4) {
            var n3 = t4.exclusiveMinimum ? e5 > t4.minimum : e5 >= t4.minimum;
            return window.math ? n3 = window.math[t4.exclusiveMinimum ? "larger" : "largerEq"](window.math.bignumber(e5), window.math.bignumber(t4.minimum)) : window.Decimal && (n3 = new window.Decimal(e5)[t4.exclusiveMinimum ? "gt" : "gte"](new window.Decimal(t4.minimum))), n3 ? [] : [{ path: r4, property: "minimum", message: this.translate(t4.exclusiveMinimum ? "error_minimum_excl" : "error_minimum_incl", [t4.minimum], t4) }];
          } }, this._validateStringSubSchema = { maxLength: function(t4, e5, r4) {
            var n3 = [];
            return "".concat(e5).length > t4.maxLength && n3.push({ path: r4, property: "maxLength", message: this.translate("error_maxLength", [t4.maxLength], t4) }), n3;
          }, minLength: function(t4, e5, r4) {
            return "".concat(e5).length < t4.minLength ? [{ path: r4, property: "minLength", message: this.translate(1 === t4.minLength ? "error_notempty" : "error_minLength", [t4.minLength], t4) }] : [];
          }, pattern: function(t4, e5, r4) {
            return new RegExp(t4.pattern).test(e5) ? [] : [{ path: r4, property: "pattern", message: t4.options && t4.options.patternmessage ? t4.options.patternmessage : this.translate("error_pattern", [t4.pattern], t4) }];
          } }, this._validateArraySubSchema = { items: function(t4, e5, r4) {
            var n3 = this, i3 = [];
            if (Array.isArray(t4.items))
              for (var o2 = 0; o2 < e5.length; o2++)
                if (t4.items[o2])
                  i3.push.apply(i3, Ke(this._validateSchema(t4.items[o2], e5[o2], "".concat(r4, ".").concat(o2))));
                else {
                  if (true === t4.additionalItems)
                    break;
                  if (!t4.additionalItems) {
                    if (false === t4.additionalItems) {
                      i3.push({ path: r4, property: "additionalItems", message: this.translate("error_additionalItems", null, t4) });
                      break;
                    }
                    break;
                  }
                  i3.push.apply(i3, Ke(this._validateSchema(t4.additionalItems, e5[o2], "".concat(r4, ".").concat(o2))));
                }
            else
              e5.forEach(function(e6, o3) {
                i3.push.apply(i3, Ke(n3._validateSchema(t4.items, e6, "".concat(r4, ".").concat(o3))));
              });
            return i3;
          }, maxItems: function(t4, e5, r4) {
            return e5.length > t4.maxItems ? [{ path: r4, property: "maxItems", message: this.translate("error_maxItems", [t4.maxItems], t4) }] : [];
          }, minItems: function(t4, e5, r4) {
            return e5.length < t4.minItems ? [{ path: r4, property: "minItems", message: this.translate("error_minItems", [t4.minItems], t4) }] : [];
          }, uniqueItems: function(t4, e5, r4) {
            for (var n3 = {}, i3 = 0; i3 < e5.length; i3++) {
              var o2 = JSON.stringify(e5[i3]);
              if (n3[o2])
                return [{ path: r4, property: "uniqueItems", message: this.translate("error_uniqueItems", null, t4) }];
              n3[o2] = true;
            }
            return [];
          } }, this._validateObjectSubSchema = { maxProperties: function(t4, e5, r4) {
            return Object.keys(e5).length > t4.maxProperties ? [{ path: r4, property: "maxProperties", message: this.translate("error_maxProperties", [t4.maxProperties], t4) }] : [];
          }, minProperties: function(t4, e5, r4) {
            return Object.keys(e5).length < t4.minProperties ? [{ path: r4, property: "minProperties", message: this.translate("error_minProperties", [t4.minProperties], t4) }] : [];
          }, required: function(t4, e5, r4) {
            var n3 = this, i3 = [];
            return Array.isArray(t4.required) && t4.required.forEach(function(o2) {
              if (void 0 === e5[o2]) {
                var a2 = n3.jsoneditor.getEditor("".concat(r4, ".").concat(o2));
                a2 && false === a2.dependenciesFulfilled || a2 && ["button", "info"].includes(a2.schema.format || a2.schema.type) || i3.push({ path: r4, property: "required", message: n3.translate("error_required", [t4 && t4.properties && t4.properties[o2] && t4.properties[o2].title ? t4.properties[o2].title : o2], t4) });
              }
            }), i3;
          }, properties: function(t4, e5, r4, n3) {
            var i3 = this, o2 = [];
            return Object.entries(t4.properties).forEach(function(t5) {
              var a2 = Ye(t5, 2), s2 = a2[0], l2 = a2[1];
              n3[s2] = true, o2.push.apply(o2, Ke(i3._validateSchema(l2, e5[s2], "".concat(r4, ".").concat(s2))));
            }), o2;
          }, patternProperties: function(t4, e5, r4, n3) {
            var i3 = this, o2 = [];
            return Object.entries(t4.patternProperties).forEach(function(t5) {
              var a2 = Ye(t5, 2), s2 = a2[0], l2 = a2[1], c3 = new RegExp(s2);
              Object.entries(e5).forEach(function(t6) {
                var e6 = Ye(t6, 2), a3 = e6[0], s3 = e6[1];
                c3.test(a3) && (n3[a3] = true, o2.push.apply(o2, Ke(i3._validateSchema(l2, s3, "".concat(r4, ".").concat(a3)))));
              });
            }), o2;
          } }, this._validateObjectSubSchema2 = { propertyNames: function(t4, e5, r4, n3) {
            for (var i3 = this, o2 = [], a2 = Object.keys(e5), s2 = null, l2 = function() {
              var e6 = "";
              return s2 = a2[c3], "boolean" == typeof t4.propertyNames ? true === t4.propertyNames ? "continue" : (o2.push({ path: r4, property: "propertyNames", message: i3.translate("error_property_names_false", [s2], t4) }), "break") : Object.entries(t4.propertyNames).every(function(n4) {
                var a3 = Ye(n4, 2), l3 = a3[0], c4 = a3[1], u3 = false;
                switch (l3) {
                  case "maxLength":
                    if ("number" != typeof c4) {
                      e6 = "error_property_names_maxlength";
                      break;
                    }
                    if (s2.length > c4) {
                      e6 = "error_property_names_exceeds_maxlength";
                      break;
                    }
                    return true;
                  case "const":
                    if (c4 !== s2) {
                      e6 = "error_property_names_const_mismatch";
                      break;
                    }
                    return true;
                  case "enum":
                    if (!Array.isArray(c4)) {
                      e6 = "error_property_names_enum";
                      break;
                    }
                    if (c4.forEach(function(t5) {
                      t5 === s2 && (u3 = true);
                    }), !u3) {
                      e6 = "error_property_names_enum_mismatch";
                      break;
                    }
                    return true;
                  case "pattern":
                    if ("string" != typeof c4) {
                      e6 = "error_property_names_pattern";
                      break;
                    }
                    if (!new RegExp(c4).test(s2)) {
                      e6 = "error_property_names_pattern_mismatch";
                      break;
                    }
                    return true;
                  default:
                    return o2.push({ path: r4, property: "propertyNames", message: i3.translate("error_property_names_unsupported", [l3], t4) }), false;
                }
                return o2.push({ path: r4, property: "propertyNames", message: i3.translate(e6, [s2], t4) }), false;
              }) ? void 0 : "break";
            }, c3 = 0; c3 < a2.length; c3++) {
              var u2 = l2();
              if ("continue" !== u2 && "break" === u2)
                break;
            }
            return o2;
          }, additionalProperties: function(t4, e5, r4, n3) {
            for (var i3 = [], o2 = Object.keys(e5), a2 = 0; a2 < o2.length; a2++) {
              var s2 = o2[a2];
              if (!n3[s2]) {
                if (!t4.additionalProperties) {
                  i3.push({ path: r4, property: "additionalProperties", message: this.translate("error_additional_properties", [s2], t4) });
                  break;
                }
                if (true === t4.additionalProperties)
                  break;
                i3.push.apply(i3, Ke(this._validateSchema(t4.additionalProperties, e5[s2], "".concat(r4, ".").concat(s2))));
              }
            }
            return i3;
          }, dependencies: function(t4, e5, r4) {
            var n3 = this, i3 = [];
            return Object.entries(t4.dependencies).forEach(function(o2) {
              var a2 = Ye(o2, 2), s2 = a2[0], l2 = a2[1];
              void 0 !== e5[s2] && (Array.isArray(l2) ? l2.forEach(function(o3) {
                void 0 === e5[o3] && i3.push({ path: r4, property: "dependencies", message: n3.translate("error_dependency", [o3], t4) });
              }) : i3.push.apply(i3, Ke(n3._validateSchema(l2, e5, r4))));
            }), i3;
          } };
        }
        var e3, r2;
        return e3 = t3, r2 = [{ key: "fitTest", value: function(t4, e4) {
          var r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1e7, n2 = { match: 0, extra: 0 };
          if ("object" === Qe(t4) && null !== t4) {
            var i2 = this._getSchema(e4);
            if (i2.anyOf) {
              var o2, a2 = function(t5) {
                for (var e5 = 1; e5 < arguments.length; e5++) {
                  var r4 = null != arguments[e5] ? arguments[e5] : {};
                  e5 % 2 ? We(Object(r4), true).forEach(function(e6) {
                    Ze(t5, e6, r4[e6]);
                  }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t5, Object.getOwnPropertyDescriptors(r4)) : We(Object(r4)).forEach(function(e6) {
                    Object.defineProperty(t5, e6, Object.getOwnPropertyDescriptor(r4, e6));
                  });
                }
                return t5;
              }({}, n2), s2 = function(t5, e5) {
                var r4 = "undefined" != typeof Symbol && t5[Symbol.iterator] || t5["@@iterator"];
                if (!r4) {
                  if (Array.isArray(t5) || (r4 = Xe(t5))) {
                    r4 && (t5 = r4);
                    var n3 = 0, i3 = function() {
                    };
                    return { s: i3, n: function() {
                      return n3 >= t5.length ? { done: true } : { done: false, value: t5[n3++] };
                    }, e: function(t6) {
                      throw t6;
                    }, f: i3 };
                  }
                  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                var o3, a3 = true, s3 = false;
                return { s: function() {
                  r4 = r4.call(t5);
                }, n: function() {
                  var t6 = r4.next();
                  return a3 = t6.done, t6;
                }, e: function(t6) {
                  s3 = true, o3 = t6;
                }, f: function() {
                  try {
                    a3 || null == r4.return || r4.return();
                  } finally {
                    if (s3)
                      throw o3;
                  }
                } };
              }(i2.anyOf);
              try {
                for (s2.s(); !(o2 = s2.n()).done; ) {
                  var l2 = o2.value, c3 = this.fitTest(t4, l2, r3);
                  (c3.match > a2.match || c3.match === a2.match && c3.extra < a2.extra) && (a2 = c3);
                }
              } catch (t5) {
                s2.e(t5);
              } finally {
                s2.f();
              }
              return a2;
            }
            var u2 = this._getSchema(e4).properties;
            for (var p3 in u2)
              if (h2(u2, p3)) {
                if ("object" === Qe(t4[p3]) && "object" === Qe(u2[p3]) && "object" === Qe(u2[p3].properties)) {
                  var d2 = this.fitTest(t4[p3], u2[p3], r3 / 100);
                  n2.match += d2.match, n2.extra += d2.extra;
                }
                void 0 !== t4[p3] && (n2.match += r3);
              } else
                n2.extra += r3;
          }
          return n2;
        } }, { key: "_getSchema", value: function(t4) {
          return void 0 === t4 ? l({}, this.jsoneditor.expandRefs(this.schema)) : t4;
        } }, { key: "validate", value: function(t4) {
          return this._validateSchema(this.schema, t4);
        } }, { key: "_validateSchema", value: function(t4, e4, r3) {
          var n2 = this, i2 = [];
          return r3 = r3 || this.jsoneditor.root.formname, t4 = l({}, this.jsoneditor.expandRefs(t4)), void 0 === e4 ? this._validateV3Required(t4, e4, r3) : (Object.keys(t4).forEach(function(o2) {
            n2._validateSubSchema[o2] && i2.push.apply(i2, Ke(n2._validateSubSchema[o2].call(n2, t4, e4, r3)));
          }), i2.push.apply(i2, Ke(this._validateByValueType(t4, e4, r3))), t4.links && t4.links.forEach(function(o2, a2) {
            o2.rel && "describedby" === o2.rel.toLowerCase() && (t4 = n2._expandSchemaLink(t4, a2), i2.push.apply(i2, Ke(n2._validateSchema(t4, e4, r3, n2.translate))));
          }), ["date", "time", "datetime-local"].includes(t4.format) && i2.push.apply(i2, Ke(this._validateDateTimeSubSchema(t4, e4, r3))), ["uuid"].includes(t4.format) && i2.push.apply(i2, Ke(this._validateUUIDSchema(t4, e4, r3))), i2.push.apply(i2, Ke(this._validateCustomValidator(t4, e4, r3))), this._removeDuplicateErrors(i2));
        } }, { key: "_expandSchemaLink", value: function(t4, e4) {
          var r3 = t4.links[e4].href, n2 = this.jsoneditor.root.getValue(), i2 = this.jsoneditor.compileTemplate(r3, this.jsoneditor.template), o2 = document.location.origin + document.location.pathname + i2(n2);
          return t4.links = t4.links.slice(0, e4).concat(t4.links.slice(e4 + 1)), l({}, t4, this.jsoneditor.refs[o2]);
        } }, { key: "_validateV3Required", value: function(t4, e4, r3) {
          return (void 0 !== t4.required && true === t4.required || void 0 === t4.required && true === this.jsoneditor.options.required_by_default) && "info" !== t4.type ? [{ path: r3, property: "required", message: this.translate("error_notset", null, t4) }] : [];
        } }, { key: "_validateByValueType", value: function(t4, e4, r3) {
          var n2 = this, i2 = [];
          if (null === e4)
            return i2;
          if ("number" == typeof e4)
            Object.keys(t4).forEach(function(o3) {
              n2._validateNumberSubSchema[o3] && i2.push.apply(i2, Ke(n2._validateNumberSubSchema[o3].call(n2, t4, e4, r3)));
            });
          else if ("string" == typeof e4)
            Object.keys(t4).forEach(function(o3) {
              n2._validateStringSubSchema[o3] && i2.push.apply(i2, Ke(n2._validateStringSubSchema[o3].call(n2, t4, e4, r3)));
            });
          else if (Array.isArray(e4))
            Object.keys(t4).forEach(function(o3) {
              n2._validateArraySubSchema[o3] && i2.push.apply(i2, Ke(n2._validateArraySubSchema[o3].call(n2, t4, e4, r3)));
            });
          else if ("object" === Qe(e4)) {
            var o2 = {};
            Object.keys(t4).forEach(function(a2) {
              n2._validateObjectSubSchema[a2] && i2.push.apply(i2, Ke(n2._validateObjectSubSchema[a2].call(n2, t4, e4, r3, o2)));
            }), void 0 !== t4.additionalProperties || !this.jsoneditor.options.no_additional_properties || t4.oneOf || t4.anyOf || t4.allOf || (t4.additionalProperties = false), Object.keys(t4).forEach(function(a2) {
              void 0 !== n2._validateObjectSubSchema2[a2] && i2.push.apply(i2, Ke(n2._validateObjectSubSchema2[a2].call(n2, t4, e4, r3, o2)));
            });
          }
          return i2;
        } }, { key: "_validateUUIDSchema", value: function(t4, e4, r3) {
          return /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(e4) ? [] : [{ path: r3, property: "format", message: this.translate("error_pattern", ["^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$"], t4) }];
        } }, { key: "_validateNumberSubSchemaMultipleDivisible", value: function(t4, e4, r3) {
          var n2 = t4.multipleOf || t4.divisibleBy, i2 = e4 / n2 === Math.floor(e4 / n2);
          return window.math ? i2 = window.math.mod(window.math.bignumber(e4), window.math.bignumber(n2)).equals(0) : window.Decimal && (i2 = new window.Decimal(e4).mod(new window.Decimal(n2)).equals(0)), i2 ? [] : [{ path: r3, property: t4.multipleOf ? "multipleOf" : "divisibleBy", message: this.translate("error_multipleOf", [n2], t4) }];
        } }, { key: "_validateDateTimeSubSchema", value: function(t4, e4, r3) {
          var n2 = this, i2 = this.jsoneditor.getEditor(r3), o2 = i2 && i2.flatpickr ? i2.flatpickr.config.dateFormat : { date: '"YYYY-MM-DD"', time: '"HH:MM"', "datetime-local": '"YYYY-MM-DD HH:MM"' }[t4.format];
          if ("integer" === t4.type)
            return function(t5, e5, r4) {
              return 1 * e5 < 1 ? [{ path: r4, property: "format", message: n2.translate("error_invalid_epoch", null, t5) }] : e5 !== Math.abs(parseInt(e5)) ? [{ path: r4, property: "format", message: n2.translate("error_".concat(t5.format.replace(/-/g, "_")), [o2], t5) }] : [];
            }(t4, e4, r3);
          if (i2 && i2.flatpickr) {
            if (i2)
              return function(t5, e5, r4, i3) {
                if ("" !== e5) {
                  var o3;
                  if ("single" !== i3.flatpickr.config.mode) {
                    var a2 = "range" === i3.flatpickr.config.mode ? i3.flatpickr.l10n.rangeSeparator : ", ";
                    o3 = i3.flatpickr.selectedDates.map(function(t6) {
                      return i3.flatpickr.formatDate(t6, i3.flatpickr.config.dateFormat);
                    }).join(a2);
                  }
                  try {
                    if (o3) {
                      if (o3 !== e5)
                        throw new Error("".concat(i3.flatpickr.config.mode, " mismatch"));
                    } else if (i3.flatpickr.formatDate(i3.flatpickr.parseDate(e5, i3.flatpickr.config.dateFormat), i3.flatpickr.config.dateFormat) !== e5)
                      throw new Error("mismatch");
                  } catch (e6) {
                    var s2 = void 0 !== i3.flatpickr.config.errorDateFormat ? i3.flatpickr.config.errorDateFormat : i3.flatpickr.config.dateFormat;
                    return [{ path: r4, property: "format", message: n2.translate("error_".concat(i3.format.replace(/-/g, "_")), [s2], t5) }];
                  }
                }
                return [];
              }(t4, e4, r3, i2);
          } else if (!{ date: /^(\d{4}\D\d{2}\D\d{2})?$/, time: /^(\d{2}:\d{2}(?::\d{2})?)?$/, "datetime-local": /^(\d{4}\D\d{2}\D\d{2}[ T]\d{2}:\d{2}(?::\d{2})?)?$/ }[t4.format].test(e4))
            return [{ path: r3, property: "format", message: this.translate("error_".concat(t4.format.replace(/-/g, "_")), [o2], t4) }];
          return [];
        } }, { key: "_validateCustomValidator", value: function(t4, e4, r3) {
          var n2 = this, i2 = [];
          i2.push.apply(i2, Ke(Je.call(this, t4, e4, r3, this.translate)));
          var o2 = function(o3) {
            i2.push.apply(i2, Ke(o3.call(n2, t4, e4, r3)));
          };
          return this.defaults.custom_validators.forEach(o2), this.options.custom_validators && this.options.custom_validators.forEach(o2), i2;
        } }, { key: "_removeDuplicateErrors", value: function(t4) {
          return t4.reduce(function(t5, e4) {
            var r3 = true;
            return t5 || (t5 = []), t5.forEach(function(t6) {
              t6.message === e4.message && t6.path === e4.path && t6.property === e4.property && (t6.errorcount++, r3 = false);
            }), r3 && (e4.errorcount = 1, t5.push(e4)), t5;
          }, []);
        } }, { key: "_checkType", value: function(t4, e4) {
          var r3 = { string: function(t5) {
            return "string" == typeof t5;
          }, number: function(t5) {
            return "number" == typeof t5;
          }, integer: function(t5) {
            return "number" == typeof t5 && t5 === Math.floor(t5);
          }, boolean: function(t5) {
            return "boolean" == typeof t5;
          }, array: function(t5) {
            return Array.isArray(t5);
          }, object: function(t5) {
            return null !== t5 && !Array.isArray(t5) && "object" === Qe(t5);
          }, null: function(t5) {
            return null === t5;
          } };
          return "string" == typeof t4 ? !r3[t4] || r3[t4](e4) : !this._validateSchema(t4, e4).length;
        } }], r2 && er(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), t3;
      }();
      function ir(t3) {
        return ir = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, ir(t3);
      }
      function or(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== ir(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== ir(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === ir(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      function ar() {
        return ar = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t3, e3, r2) {
          var n2 = function(t4, e4) {
            for (; !Object.prototype.hasOwnProperty.call(t4, e4) && null !== (t4 = lr(t4)); )
              ;
            return t4;
          }(t3, e3);
          if (n2) {
            var i2 = Object.getOwnPropertyDescriptor(n2, e3);
            return i2.get ? i2.get.call(arguments.length < 3 ? t3 : r2) : i2.value;
          }
        }, ar.apply(this, arguments);
      }
      function sr(t3, e3) {
        return sr = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, sr(t3, e3);
      }
      function lr(t3) {
        return lr = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, lr(t3);
      }
      var cr = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && sr(t4, e4);
        }(a2, t3);
        var e3, r2, n2, i2, o2 = (n2 = a2, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = lr(n2);
          if (i2) {
            var r3 = lr(this).constructor;
            t4 = Reflect.construct(e4, arguments, r3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === ir(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function a2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), o2.apply(this, arguments);
        }
        return e3 = a2, (r2 = [{ key: "register", value: function() {
          if (this.editors) {
            for (var t4 = 0; t4 < this.editors.length; t4++)
              this.editors[t4] && this.editors[t4].unregister();
            this.editors[this.type] && this.editors[this.type].register();
          }
          ar(lr(a2.prototype), "register", this).call(this);
        } }, { key: "unregister", value: function() {
          if (ar(lr(a2.prototype), "unregister", this).call(this), this.editors)
            for (var t4 = 0; t4 < this.editors.length; t4++)
              this.editors[t4] && this.editors[t4].unregister();
        } }, { key: "getNumColumns", value: function() {
          return this.editors[this.type] ? Math.max(this.editors[this.type].getNumColumns(), 4) : 4;
        } }, { key: "enable", value: function() {
          if (!this.always_disabled) {
            if (this.editors)
              for (var t4 = 0; t4 < this.editors.length; t4++)
                this.editors[t4] && this.editors[t4].enable();
            this.switcher.disabled = false, ar(lr(a2.prototype), "enable", this).call(this);
          }
        } }, { key: "disable", value: function(t4) {
          if (t4 && (this.always_disabled = true), this.editors)
            for (var e4 = 0; e4 < this.editors.length; e4++)
              this.editors[e4] && this.editors[e4].disable(t4);
          this.switcher.disabled = true, ar(lr(a2.prototype), "disable", this).call(this);
        } }, { key: "switchEditor", value: function(t4) {
          var e4 = this;
          this.lastType = this.type, this.editors[t4] || this.buildChildEditor(t4);
          var r3 = this.getValue();
          this.type = t4, this.register(), this.editors.forEach(function(t5, n3) {
            var i3, o3;
            t5 && (e4.type === n3 ? (e4.keep_only_existing_values && (i3 = t5.getValue(), o3 = r3, Object.keys(o3).forEach(function(t6) {
              t6 in i3 && (i3[t6] = o3[t6]);
            }), r3 = i3), (e4.keep_values || e4.if) && t5.setValue(r3, true), t5.container.style.display = "") : t5.container.style.display = "none");
          }), this.refreshValue(), this.refreshHeaderText();
        } }, { key: "buildChildEditor", value: function(t4) {
          var e4, r3 = this, n3 = this.types[t4], i3 = this.theme.getChildEditorHolder();
          this.editor_holder.appendChild(i3), "string" == typeof n3 ? (e4 = l({}, this.schema)).type = n3 : (e4 = l({}, this.schema, n3), e4 = this.jsoneditor.expandRefs(e4), n3 && n3.required && Array.isArray(n3.required) && this.schema.required && Array.isArray(this.schema.required) && (e4.required = this.schema.required.concat(n3.required)));
          var o3 = this.jsoneditor.getEditorClass(e4);
          this.editors[t4] = this.jsoneditor.createEditor(o3, { jsoneditor: this.jsoneditor, schema: e4, container: i3, path: this.path, parent: this, required: true }), this.editors[t4].preBuild(), this.editors[t4].build(), this.editors[t4].postBuild(), this.editors[t4].header && (this.editors[t4].header.style.display = "none"), this.editors[t4].option = this.switcher_options[t4], i3.addEventListener("change_header_text", function() {
            r3.refreshHeaderText();
          }), t4 !== this.type && (i3.style.display = "none");
        } }, { key: "preBuild", value: function() {
          if (this.types = [], this.type = 0, this.editors = [], this.validators = [], this.keep_values = true, void 0 !== this.jsoneditor.options.keep_oneof_values && (this.keep_values = this.jsoneditor.options.keep_oneof_values), void 0 !== this.options.keep_oneof_values && (this.keep_values = this.options.keep_oneof_values), this.keep_only_existing_values = false, void 0 !== this.jsoneditor.options.keep_only_existing_values && (this.keep_only_existing_values = this.jsoneditor.options.keep_only_existing_values), void 0 !== this.options.keep_only_existing_values && (this.keep_only_existing_values = this.options.keep_only_existing_values), this.schema.oneOf)
            this.oneOf = true, this.types = this.schema.oneOf, delete this.schema.oneOf;
          else if (this.schema.anyOf)
            this.anyOf = true, this.types = this.schema.anyOf, delete this.schema.anyOf;
          else if (this.schema.if)
            this.if = true, this.ifSchema = JSON.parse(JSON.stringify(this.schema.if)), this.thenSchema = { title: "then" }, this.elseSchema = { title: "else" }, this.types = [], this.schema.then && m(this.thenSchema, this.schema, this.schema.then), this.schema.else && m(this.elseSchema, this.schema, this.schema.else), this.types.push(this.thenSchema), this.types.push(this.elseSchema), this.types.forEach(function(t5) {
              delete t5.if, delete t5.then, delete t5.else;
            }), delete this.schema.if;
          else {
            if (this.schema.type && "any" !== this.schema.type)
              Array.isArray(this.schema.type) ? this.types = this.schema.type : this.types = [this.schema.type];
            else if (this.types = ["string", "number", "integer", "boolean", "object", "array", "null"], this.schema.disallow) {
              var t4 = this.schema.disallow;
              "object" === ir(t4) && Array.isArray(t4) || (t4 = [t4]);
              var e4 = [];
              this.types.forEach(function(r3) {
                t4.includes(r3) || e4.push(r3);
              }), this.types = e4;
            }
            delete this.schema.type;
          }
          this.display_text = this.getDisplayText(this.types);
        } }, { key: "build", value: function() {
          var t4 = this, e4 = this.container;
          this.header = this.label = this.theme.getFormInputLabel(this.getTitle(), this.isRequired()), this.switcher = this.theme.getSwitcher(this.display_text), this.if || (this.container.appendChild(this.header), e4.appendChild(this.switcher)), this.switcher.addEventListener("change", function(e5) {
            e5.preventDefault(), e5.stopPropagation(), t4.switchEditor(t4.display_text.indexOf(e5.currentTarget.value)), t4.onChange(true);
          }), this.editor_holder = document.createElement("div"), e4.appendChild(this.editor_holder);
          var r3 = {};
          this.jsoneditor.options.custom_validators && (r3.custom_validators = this.jsoneditor.options.custom_validators), this.switcher_options = this.theme.getSwitcherOptions(this.switcher), this.types.forEach(function(e5, n3) {
            var i3;
            t4.editors[n3] = false, "string" == typeof e5 ? (i3 = l({}, t4.schema)).type = e5 : (i3 = l({}, t4.schema, e5), e5.required && Array.isArray(e5.required) && t4.schema.required && Array.isArray(t4.schema.required) && (i3.required = t4.schema.required.concat(e5.required))), t4.validators[n3] = new nr(t4.jsoneditor, i3, r3, t4.defaults);
          }), this.jsoneditor.on("change", function() {
            t4.switchIf();
          }), this.switchEditor(0);
        } }, { key: "onChildEditorChange", value: function(t4) {
          this.editors[this.type] && (this.refreshValue(), this.refreshHeaderText()), ar(lr(a2.prototype), "onChildEditorChange", this).call(this);
        } }, { key: "refreshHeaderText", value: function() {
          var t4 = this.getDisplayText(this.types);
          Array.from(this.switcher_options).forEach(function(e4, r3) {
            e4.textContent = t4[r3];
          });
        } }, { key: "refreshValue", value: function() {
          this.value = this.editors[this.type].getValue();
        } }, { key: "switchIf", value: function() {
          if (this.ifSchema && this.value) {
            var t4 = this.getIfType(this.value);
            this.lastType !== t4 && (this.switchEditor(t4), this.editors[this.type].setValue(this.value, true)), this.switcher.value = this.display_text[this.type];
          }
        } }, { key: "getIfType", value: function(t4) {
          return 0 === this.jsoneditor.validator._validateSchema(this.ifSchema, t4).length ? 0 : 1;
        } }, { key: "setValue", value: function(t4, e4) {
          var r3 = this, n3 = this.type, i3 = { match: 0, extra: 0, i: this.type }, o3 = { match: 0, i: null };
          this.validators.forEach(function(e5, n4) {
            var a4 = null;
            void 0 !== r3.anyOf && r3.anyOf && (a4 = e5.fitTest(t4), (i3.match < a4.match || i3.match === a4.match && i3.extra > a4.extra) && ((i3 = a4).i = n4)), e5.validate(t4).length || null !== o3.i ? i3 = o3 : (o3.i = n4, null !== a4 && (o3.match = a4.match));
          });
          var a3 = o3.i;
          void 0 !== this.anyOf && this.anyOf && o3.match < i3.match && (a3 = i3.i), this.if && (a3 = this.getIfType(t4)), null === a3 && (a3 = this.type), this.type = a3, this.switcher.value = this.display_text[a3];
          var s2 = this.type !== n3;
          s2 && (this.switchEditor(this.type), this.editors[this.type].setValue(t4, e4)), void 0 !== t4 && this.editors[this.type].setValue(t4, e4), this.refreshValue(), this.onChange(s2);
        } }, { key: "destroy", value: function() {
          this.editors.forEach(function(t4) {
            t4 && t4.destroy();
          }), this.editor_holder && this.editor_holder.parentNode && this.editor_holder.parentNode.removeChild(this.editor_holder), this.switcher && this.switcher.parentNode && this.switcher.parentNode.removeChild(this.switcher), ar(lr(a2.prototype), "destroy", this).call(this);
        } }, { key: "showValidationErrors", value: function(t4) {
          var e4 = this;
          if (this.oneOf || this.anyOf) {
            var r3 = this.oneOf ? "oneOf" : "anyOf";
            this.editors.forEach(function(n3, i3) {
              if (n3) {
                var o3 = "".concat(e4.path, ".").concat(r3, "[").concat(i3, "]");
                n3.showValidationErrors(t4.reduce(function(t5, r4) {
                  if (r4.path.startsWith(o3) || r4.path === o3.substr(0, r4.path.length)) {
                    var n4 = l({}, r4);
                    r4.path.startsWith(o3) && (n4.path = e4.path + n4.path.substr(o3.length)), t5.push(n4);
                  }
                  return t5;
                }, []));
              }
            });
          } else
            this.editors.forEach(function(e5) {
              e5 && e5.showValidationErrors(t4);
            });
        } }, { key: "addLinks", value: function() {
        } }]) && or(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), a2;
      }(w2);
      function ur(t3) {
        return ur = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, ur(t3);
      }
      function hr(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== ur(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== ur(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === ur(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      function pr(t3, e3) {
        return pr = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, pr(t3, e3);
      }
      function dr(t3) {
        return dr = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, dr(t3);
      }
      var fr = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && pr(t4, e4);
        }(a2, t3);
        var e3, r2, n2, i2, o2 = (n2 = a2, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = dr(n2);
          if (i2) {
            var r3 = dr(this).constructor;
            t4 = Reflect.construct(e4, arguments, r3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === ur(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function a2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), o2.apply(this, arguments);
        }
        return e3 = a2, (r2 = [{ key: "getValue", value: function() {
          if (this.dependenciesFulfilled)
            return null;
        } }, { key: "setValue", value: function() {
          this.onChange();
        } }, { key: "getNumColumns", value: function() {
          return 2;
        } }]) && hr(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), a2;
      }(w2);
      function yr(t3, e3) {
        var r2 = Object.keys(t3);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t3);
          e3 && (n2 = n2.filter(function(e4) {
            return Object.getOwnPropertyDescriptor(t3, e4).enumerable;
          })), r2.push.apply(r2, n2);
        }
        return r2;
      }
      function mr(t3) {
        for (var e3 = 1; e3 < arguments.length; e3++) {
          var r2 = null != arguments[e3] ? arguments[e3] : {};
          e3 % 2 ? yr(Object(r2), true).forEach(function(e4) {
            vr(t3, e4, r2[e4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t3, Object.getOwnPropertyDescriptors(r2)) : yr(Object(r2)).forEach(function(e4) {
            Object.defineProperty(t3, e4, Object.getOwnPropertyDescriptor(r2, e4));
          });
        }
        return t3;
      }
      function vr(t3, e3, r2) {
        return (e3 = kr(e3)) in t3 ? Object.defineProperty(t3, e3, { value: r2, enumerable: true, configurable: true, writable: true }) : t3[e3] = r2, t3;
      }
      function br(t3, e3) {
        return function(t4) {
          if (Array.isArray(t4))
            return t4;
        }(t3) || function(t4, e4) {
          var r2 = null == t4 ? null : "undefined" != typeof Symbol && t4[Symbol.iterator] || t4["@@iterator"];
          if (null != r2) {
            var n2, i2, o2, a2, s2 = [], l2 = true, c3 = false;
            try {
              if (o2 = (r2 = r2.call(t4)).next, 0 === e4) {
                if (Object(r2) !== r2)
                  return;
                l2 = false;
              } else
                for (; !(l2 = (n2 = o2.call(r2)).done) && (s2.push(n2.value), s2.length !== e4); l2 = true)
                  ;
            } catch (t5) {
              c3 = true, i2 = t5;
            } finally {
              try {
                if (!l2 && null != r2.return && (a2 = r2.return(), Object(a2) !== a2))
                  return;
              } finally {
                if (c3)
                  throw i2;
              }
            }
            return s2;
          }
        }(t3, e3) || function(t4, e4) {
          if (t4) {
            if ("string" == typeof t4)
              return gr(t4, e4);
            var r2 = Object.prototype.toString.call(t4).slice(8, -1);
            return "Object" === r2 && t4.constructor && (r2 = t4.constructor.name), "Map" === r2 || "Set" === r2 ? Array.from(t4) : "Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2) ? gr(t4, e4) : void 0;
          }
        }(t3, e3) || function() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function gr(t3, e3) {
        (null == e3 || e3 > t3.length) && (e3 = t3.length);
        for (var r2 = 0, n2 = new Array(e3); r2 < e3; r2++)
          n2[r2] = t3[r2];
        return n2;
      }
      function wr(t3) {
        return wr = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, wr(t3);
      }
      function _r(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, kr(n2.key), n2);
        }
      }
      function kr(t3) {
        var e3 = function(t4, e4) {
          if ("object" !== wr(t4) || null === t4)
            return t4;
          var r2 = t4[Symbol.toPrimitive];
          if (void 0 !== r2) {
            var n2 = r2.call(t4, "string");
            if ("object" !== wr(n2))
              return n2;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(t4);
        }(t3);
        return "symbol" === wr(e3) ? e3 : String(e3);
      }
      function jr() {
        return jr = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t3, e3, r2) {
          var n2 = function(t4, e4) {
            for (; !Object.prototype.hasOwnProperty.call(t4, e4) && null !== (t4 = xr(t4)); )
              ;
            return t4;
          }(t3, e3);
          if (n2) {
            var i2 = Object.getOwnPropertyDescriptor(n2, e3);
            return i2.get ? i2.get.call(arguments.length < 3 ? t3 : r2) : i2.value;
          }
        }, jr.apply(this, arguments);
      }
      function Or(t3, e3) {
        return Or = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, Or(t3, e3);
      }
      function xr(t3) {
        return xr = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, xr(t3);
      }
      var Cr = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && Or(t4, e4);
        }(a2, t3);
        var e3, r2, n2, i2, o2 = (n2 = a2, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = xr(n2);
          if (i2) {
            var r3 = xr(this).constructor;
            t4 = Reflect.construct(e4, arguments, r3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === wr(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function a2(t4, e4, r3) {
          var n3;
          return function(t5, e5) {
            if (!(t5 instanceof e5))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), (n3 = o2.call(this, t4, e4)).currentDepth = r3, n3;
        }
        return e3 = a2, (r2 = [{ key: "getDefault", value: function() {
          return l({}, this.schema.default || {});
        } }, { key: "getChildEditors", value: function() {
          return this.editors;
        } }, { key: "register", value: function() {
          jr(xr(a2.prototype), "register", this).call(this), this.editors && Object.values(this.editors).forEach(function(t4) {
            return t4.register();
          });
        } }, { key: "unregister", value: function() {
          jr(xr(a2.prototype), "unregister", this).call(this), this.editors && Object.values(this.editors).forEach(function(t4) {
            return t4.unregister();
          });
        } }, { key: "getNumColumns", value: function() {
          return Math.max(Math.min(12, this.maxwidth), 3);
        } }, { key: "enable", value: function() {
          this.always_disabled || (this.editjson_control && (this.editjson_control.disabled = false), this.addproperty_button && (this.addproperty_button.disabled = false), jr(xr(a2.prototype), "enable", this).call(this), this.editors && Object.values(this.editors).forEach(function(t4) {
            t4.isActive() && t4.enable(), t4.optInCheckbox.disabled = false;
          }));
        } }, { key: "disable", value: function(t4) {
          t4 && (this.always_disabled = true), this.editjson_control && (this.editjson_control.disabled = true), this.addproperty_button && (this.addproperty_button.disabled = true), this.hideEditJSON(), jr(xr(a2.prototype), "disable", this).call(this), this.editors && Object.values(this.editors).forEach(function(e4) {
            e4.isActive() && e4.disable(t4), e4.optInCheckbox.disabled = true;
          });
        } }, { key: "layoutEditors", value: function() {
          var t4, e4, r3 = this;
          if (this.row_container) {
            var n3;
            this.property_order = Object.keys(this.editors), this.property_order = this.property_order.sort(function(t5, e5) {
              var n4 = r3.editors[t5].schema.propertyOrder, i4 = r3.editors[e5].schema.propertyOrder;
              return "number" != typeof n4 && (n4 = 1e3), "number" != typeof i4 && (i4 = 1e3), n4 - i4;
            });
            var i3, o3 = "categories" === this.format, a3 = [], s2 = null, l2 = null;
            if ("grid-strict" === this.format) {
              var u2 = 0;
              if (i3 = [], this.property_order.forEach(function(t5) {
                var e5 = r3.editors[t5];
                if (!e5.property_removed) {
                  var n4 = e5.options.hidden ? 0 : e5.options.grid_columns || e5.getNumColumns(), o4 = e5.options.hidden ? 0 : e5.options.grid_offset || 0, s3 = !e5.options.hidden && (e5.options.grid_break || false), l3 = { key: t5, width: n4, offset: o4, height: e5.options.hidden ? 0 : e5.container.offsetHeight };
                  i3.push(l3), a3[u2] = i3, s3 && (u2++, i3 = []);
                }
              }), this.layout === JSON.stringify(a3))
                return false;
              for (this.layout = JSON.stringify(a3), n3 = document.createElement("div"), t4 = 0; t4 < a3.length; t4++)
                for (i3 = this.theme.getGridRow(), n3.appendChild(i3), e4 = 0; e4 < a3[t4].length; e4++)
                  s2 = a3[t4][e4].key, (l2 = this.editors[s2]).options.hidden ? l2.container.style.display = "none" : this.theme.setGridColumnSize(l2.container, a3[t4][e4].width, a3[t4][e4].offset), i3.appendChild(l2.container);
            } else if ("grid" === this.format) {
              for (this.property_order.forEach(function(t5) {
                var e5 = r3.editors[t5];
                if (!e5.property_removed) {
                  for (var n4 = false, i4 = e5.options.hidden ? 0 : e5.options.grid_columns || e5.getNumColumns(), o4 = e5.options.hidden ? 0 : e5.container.offsetHeight, s3 = 0; s3 < a3.length; s3++)
                    a3[s3].width + i4 <= 12 && (!o4 || 0.5 * a3[s3].minh < o4 && 2 * a3[s3].maxh > o4) && (n4 = s3);
                  false === n4 && (a3.push({ width: 0, minh: 999999, maxh: 0, editors: [] }), n4 = a3.length - 1), a3[n4].editors.push({ key: t5, width: i4, height: o4 }), a3[n4].width += i4, a3[n4].minh = Math.min(a3[n4].minh, o4), a3[n4].maxh = Math.max(a3[n4].maxh, o4);
                }
              }), t4 = 0; t4 < a3.length; t4++)
                if (a3[t4].width < 12) {
                  var h3 = false, p3 = 0;
                  for (e4 = 0; e4 < a3[t4].editors.length; e4++)
                    (false === h3 || a3[t4].editors[e4].width > a3[t4].editors[h3].width) && (h3 = e4), a3[t4].editors[e4].width *= 12 / a3[t4].width, a3[t4].editors[e4].width = Math.floor(a3[t4].editors[e4].width), p3 += a3[t4].editors[e4].width;
                  p3 < 12 && (a3[t4].editors[h3].width += 12 - p3), a3[t4].width = 12;
                }
              if (this.layout === JSON.stringify(a3))
                return false;
              for (this.layout = JSON.stringify(a3), n3 = document.createElement("div"), t4 = 0; t4 < a3.length; t4++)
                for (i3 = this.theme.getGridRow(), n3.appendChild(i3), e4 = 0; e4 < a3[t4].editors.length; e4++)
                  s2 = a3[t4].editors[e4].key, (l2 = this.editors[s2]).options.hidden ? l2.container.style.display = "none" : this.theme.setGridColumnSize(l2.container, a3[t4].editors[e4].width), i3.appendChild(l2.container);
            } else {
              if (n3 = document.createElement("div"), o3) {
                var d2 = document.createElement("div"), f3 = this.theme.getTopTabHolder(this.translateProperty(this.schema.title)), y3 = this.theme.getTopTabContentHolder(f3);
                for (this.property_order.forEach(function(t5) {
                  var e5 = r3.editors[t5];
                  if (!e5.property_removed) {
                    var n4 = r3.theme.getTabContent(), i4 = e5.schema && ("object" === e5.schema.type || "array" === e5.schema.type);
                    n4.isObjOrArray = i4;
                    var o4 = r3.theme.getGridRow();
                    e5.tab || (void 0 === r3.basicPane ? r3.addRow(e5, f3, n4) : r3.addRow(e5, f3, r3.basicPane)), n4.id = r3.getValidId(e5.tab_text.textContent), i4 ? (n4.appendChild(o4), y3.appendChild(n4), r3.theme.addTopTab(f3, e5.tab)) : (d2.appendChild(o4), y3.childElementCount > 0 ? y3.firstChild.isObjOrArray && (n4.appendChild(d2), y3.insertBefore(n4, y3.firstChild), r3.theme.insertBasicTopTab(e5.tab, f3), e5.basicPane = n4) : (n4.appendChild(d2), y3.appendChild(n4), r3.theme.addTopTab(f3, e5.tab), e5.basicPane = n4)), e5.options.hidden ? e5.container.style.display = "none" : r3.theme.setGridColumnSize(e5.container, 12), o4.appendChild(e5.container), e5.rowPane = n4;
                  }
                }); this.tabPanesContainer.firstChild; )
                  this.tabPanesContainer.removeChild(this.tabPanesContainer.firstChild);
                var m2 = this.tabs_holder.parentNode;
                m2.removeChild(m2.firstChild), m2.appendChild(f3), this.tabPanesContainer = y3, this.tabs_holder = f3;
                var v3 = this.theme.getFirstTab(this.tabs_holder);
                return void (v3 && c2(v3, "click"));
              }
              this.property_order.forEach(function(t5) {
                var e5 = r3.editors[t5];
                e5.property_removed || (i3 = r3.theme.getGridRow(), n3.appendChild(i3), e5.options.hidden ? e5.container.style.display = "none" : r3.theme.setGridColumnSize(e5.container, 12), i3.appendChild(e5.container));
              });
            }
            for (; this.row_container.firstChild; )
              this.row_container.removeChild(this.row_container.firstChild);
            this.row_container.appendChild(n3);
          }
        } }, { key: "getPropertySchema", value: function(t4) {
          var e4 = this, r3 = this.schema.properties[t4] || {};
          r3 = l({}, r3);
          var n3 = !!this.schema.properties[t4];
          return this.schema.patternProperties && Object.keys(this.schema.patternProperties).forEach(function(i3) {
            new RegExp(i3).test(t4) && (r3.allOf = r3.allOf || [], r3.allOf.push(e4.schema.patternProperties[i3]), n3 = true);
          }), !n3 && this.schema.additionalProperties && "object" === wr(this.schema.additionalProperties) && (r3 = l({}, this.schema.additionalProperties)), r3;
        } }, { key: "preBuild", value: function() {
          var t4 = this;
          if (jr(xr(a2.prototype), "preBuild", this).call(this), this.editors = {}, this.cached_editors = {}, this.format = this.options.layout || this.options.object_layout || this.schema.format || this.jsoneditor.options.object_layout || "normal", this.schema.properties = this.schema.properties || {}, this.minwidth = 0, this.maxwidth = 0, this.options.table_row)
            Object.entries(this.schema.properties).forEach(function(e4) {
              var r3 = br(e4, 2), n3 = r3[0], i3 = r3[1], o3 = t4.jsoneditor.getEditorClass(i3);
              t4.editors[n3] = t4.jsoneditor.createEditor(o3, { jsoneditor: t4.jsoneditor, schema: i3, path: "".concat(t4.path, ".").concat(n3), parent: t4, compact: true, required: true }, t4.currentDepth + 1), t4.editors[n3].preBuild();
              var a3 = t4.editors[n3].options.hidden ? 0 : t4.editors[n3].options.grid_columns || t4.editors[n3].getNumColumns();
              t4.minwidth += a3, t4.maxwidth += a3;
            }), this.no_link_holder = true;
          else {
            if (this.options.table)
              throw new Error("Not supported yet");
            this.schema.defaultProperties || (this.jsoneditor.options.display_required_only || this.options.display_required_only ? this.schema.defaultProperties = Object.keys(this.schema.properties).filter(function(e4) {
              return t4.isRequiredObject({ key: e4, schema: t4.schema.properties[e4] });
            }) : this.schema.defaultProperties = Object.keys(this.schema.properties)), this.maxwidth += 1, Array.isArray(this.schema.defaultProperties) && this.schema.defaultProperties.forEach(function(e4) {
              t4.addObjectProperty(e4, true), t4.editors[e4] && (t4.minwidth = Math.max(t4.minwidth, t4.editors[e4].options.grid_columns || t4.editors[e4].getNumColumns()), t4.maxwidth += t4.editors[e4].options.grid_columns || t4.editors[e4].getNumColumns());
            });
          }
          this.property_order = Object.keys(this.editors), this.property_order = this.property_order.sort(function(e4, r3) {
            var n3 = t4.editors[e4].schema.propertyOrder, i3 = t4.editors[r3].schema.propertyOrder;
            return "number" != typeof n3 && (n3 = 1e3), "number" != typeof i3 && (i3 = 1e3), n3 - i3;
          });
        } }, { key: "addTab", value: function(t4) {
          var e4 = this, r3 = this.rows[t4].schema && ("object" === this.rows[t4].schema.type || "array" === this.rows[t4].schema.type);
          this.tabs_holder && (this.rows[t4].tab_text = document.createElement("span"), this.rows[t4].tab_text.textContent = r3 ? this.rows[t4].getHeaderText() : void 0 === this.schema.basicCategoryTitle ? "Basic" : this.schema.basicCategoryTitle, this.rows[t4].tab = this.theme.getTopTab(this.rows[t4].tab_text, this.getValidId(this.rows[t4].tab_text.textContent)), this.rows[t4].tab.addEventListener("click", function(r4) {
            e4.active_tab = e4.rows[t4].tab, e4.refreshTabs(), r4.preventDefault(), r4.stopPropagation();
          }));
        } }, { key: "addRow", value: function(t4, e4, r3) {
          var n3 = this.rows.length, i3 = "object" === t4.schema.type || "array" === t4.schema.type;
          this.rows[n3] = t4, this.rows[n3].rowPane = r3, i3 ? (this.addTab(n3), this.theme.addTopTab(e4, this.rows[n3].tab)) : void 0 === this.basicTab ? (this.addTab(n3), this.basicTab = n3, this.basicPane = r3, this.theme.addTopTab(e4, this.rows[n3].tab)) : (this.rows[n3].tab = this.rows[this.basicTab].tab, this.rows[n3].tab_text = this.rows[this.basicTab].tab_text, this.rows[n3].rowPane = this.rows[this.basicTab].rowPane);
        } }, { key: "refreshTabs", value: function(t4) {
          var e4 = this, r3 = void 0 !== this.basicTab, n3 = false;
          this.rows.forEach(function(i3) {
            i3.tab && i3.rowPane && i3.rowPane.parentNode && (r3 && i3.tab === e4.rows[e4.basicTab].tab && n3 || (t4 ? i3.tab_text.textContent = i3.getHeaderText() : (r3 && i3.tab === e4.rows[e4.basicTab].tab && (n3 = true), i3.tab === e4.active_tab ? e4.theme.markTabActive(i3) : e4.theme.markTabInactive(i3))));
          });
        } }, { key: "build", value: function() {
          var t4 = this, e4 = "categories" === this.format;
          if (this.rows = [], this.active_tab = null, this.options.table_row)
            this.editor_holder = this.container, Object.entries(this.editors).forEach(function(e5) {
              var r4 = br(e5, 2), n3 = r4[0], i3 = r4[1], o3 = t4.theme.getTableCell();
              t4.editor_holder.appendChild(o3), i3.setContainer(o3), i3.build(), i3.postBuild(), i3.setOptInCheckbox(i3.header), i3.setValue(i3.getDefault(), true), t4.editors[n3].options.hidden && (o3.style.display = "none"), t4.editors[n3].options.input_width && (o3.style.width = t4.editors[n3].options.input_width);
            });
          else {
            if (this.options.table)
              throw new Error("Not supported yet");
            this.header = "", this.options.compact || (this.header = document.createElement("label"), this.header.textContent = this.getTitle()), this.title = this.theme.getHeader(this.header, this.getPathDepth()), this.title.classList.add("je-object__title"), this.controls = this.theme.getButtonHolder(), this.controls.classList.add("je-object__controls"), this.container.appendChild(this.title), this.container.appendChild(this.controls), this.container.classList.add("je-object__container"), this.editjson_holder = this.theme.getModal(), this.editjson_textarea = this.theme.getTextareaInput(), this.editjson_textarea.classList.add("je-edit-json--textarea"), this.editjson_save = this.getButton("button_save", "save", "button_save"), this.editjson_save.classList.add("json-editor-btntype-save"), this.editjson_save.addEventListener("click", function(e5) {
              e5.preventDefault(), e5.stopPropagation(), t4.saveJSON();
            }), this.editjson_copy = this.getButton("button_copy", "copy", "button_copy"), this.editjson_copy.classList.add("json-editor-btntype-copy"), this.editjson_copy.addEventListener("click", function(e5) {
              e5.preventDefault(), e5.stopPropagation(), t4.copyJSON();
            }), this.editjson_cancel = this.getButton("button_cancel", "cancel", "button_cancel"), this.editjson_cancel.classList.add("json-editor-btntype-cancel"), this.editjson_cancel.addEventListener("click", function(e5) {
              e5.preventDefault(), e5.stopPropagation(), t4.hideEditJSON();
            }), this.editjson_holder.appendChild(this.editjson_textarea), this.editjson_holder.appendChild(this.editjson_save), this.editjson_holder.appendChild(this.editjson_copy), this.editjson_holder.appendChild(this.editjson_cancel), this.addproperty_holder = this.theme.getModal(), this.addproperty_list = document.createElement("div"), this.addproperty_list.classList.add("property-selector"), this.addproperty_add = this.getButton("button_add", "add", "button_add"), this.addproperty_add.classList.add("json-editor-btntype-add"), this.addproperty_input = this.theme.getFormInputField("text"), this.addproperty_input.setAttribute("placeholder", "Property name..."), this.addproperty_input.classList.add("property-selector-input"), this.addproperty_add.addEventListener("click", function(e5) {
              if (e5.preventDefault(), e5.stopPropagation(), t4.addproperty_input.value) {
                if (t4.editors[t4.addproperty_input.value])
                  return void window.alert("there is already a property with that name");
                t4.addObjectProperty(t4.addproperty_input.value), t4.editors[t4.addproperty_input.value] && t4.editors[t4.addproperty_input.value].disable(), t4.onChange(true);
              }
            }), this.addproperty_input.addEventListener("input", function(t5) {
              t5.target.previousSibling.childNodes.forEach(function(e5) {
                e5.innerText.includes(t5.target.value) ? e5.style.display = "" : e5.style.display = "none";
              });
            }), this.addproperty_holder.appendChild(this.addproperty_list), this.addproperty_holder.appendChild(this.addproperty_input), this.addproperty_holder.appendChild(this.addproperty_add);
            var r3 = document.createElement("div");
            r3.style.clear = "both", this.addproperty_holder.appendChild(r3), this.onOutsideModalClickListener = this.onOutsideModalClick.bind(this), document.addEventListener("click", this.onOutsideModalClickListener, true), this.schema.description && (this.description = this.theme.getDescription(this.translateProperty(this.schema.description)), this.container.appendChild(this.description)), this.error_holder = document.createElement("div"), this.container.appendChild(this.error_holder), this.editor_holder = this.theme.getIndentedPanel(), this.container.appendChild(this.editor_holder), this.row_container = this.theme.getGridContainer(), e4 ? (this.tabs_holder = this.theme.getTopTabHolder(this.getValidId(this.translateProperty(this.schema.title))), this.tabPanesContainer = this.theme.getTopTabContentHolder(this.tabs_holder), this.editor_holder.appendChild(this.tabs_holder)) : (this.tabs_holder = this.theme.getTabHolder(this.getValidId(this.translateProperty(this.schema.title))), this.tabPanesContainer = this.theme.getTabContentHolder(this.tabs_holder), this.editor_holder.appendChild(this.row_container)), Object.values(this.editors).forEach(function(r4) {
              var n3 = t4.theme.getTabContent(), i3 = t4.theme.getGridColumn(), o3 = !(!r4.schema || "object" !== r4.schema.type && "array" !== r4.schema.type);
              if (n3.isObjOrArray = o3, e4) {
                if (o3) {
                  var a3 = t4.theme.getGridContainer();
                  a3.appendChild(i3), n3.appendChild(a3), t4.tabPanesContainer.appendChild(n3), t4.row_container = a3;
                } else
                  void 0 === t4.row_container_basic && (t4.row_container_basic = t4.theme.getGridContainer(), n3.appendChild(t4.row_container_basic), 0 === t4.tabPanesContainer.childElementCount ? t4.tabPanesContainer.appendChild(n3) : t4.tabPanesContainer.insertBefore(n3, t4.tabPanesContainer.childNodes[1])), t4.row_container_basic.appendChild(i3);
                t4.addRow(r4, t4.tabs_holder, n3), n3.id = t4.getValidId(r4.schema.title);
              } else
                t4.row_container.appendChild(i3);
              r4.setContainer(i3), r4.build(), r4.postBuild(), r4.setOptInCheckbox(r4.header);
            }), this.rows[0] && c2(this.rows[0].tab, "click"), this.collapsed = false, this.collapse_control = this.getButton("", "collapse", "button_collapse"), this.collapse_control.classList.add("json-editor-btntype-toggle"), this.title.insertBefore(this.collapse_control, this.title.childNodes[0]), this.collapse_control.addEventListener("click", function(e5) {
              e5.preventDefault(), e5.stopPropagation(), t4.collapsed ? (t4.editor_holder.style.display = "", t4.collapsed = false, t4.setButtonText(t4.collapse_control, "", "collapse", "button_collapse")) : (t4.editor_holder.style.display = "none", t4.collapsed = true, t4.setButtonText(t4.collapse_control, "", "expand", "button_expand"));
            }), this.options.collapsed && c2(this.collapse_control, "click"), this.schema.options && void 0 !== this.schema.options.disable_collapse ? this.schema.options.disable_collapse && (this.collapse_control.style.display = "none") : this.jsoneditor.options.disable_collapse && (this.collapse_control.style.display = "none"), this.editjson_control = this.getButton("JSON", "edit", "button_edit_json"), this.editjson_control.classList.add("json-editor-btntype-editjson"), this.editjson_control.addEventListener("click", function(e5) {
              e5.preventDefault(), e5.stopPropagation(), t4.toggleEditJSON();
            }), this.controls.appendChild(this.editjson_control), this.controls.insertBefore(this.editjson_holder, this.controls.childNodes[0]), this.schema.options && void 0 !== this.schema.options.disable_edit_json ? this.schema.options.disable_edit_json && (this.editjson_control.style.display = "none") : this.jsoneditor.options.disable_edit_json && (this.editjson_control.style.display = "none"), this.addproperty_button = this.getButton("properties", "edit_properties", "button_object_properties"), this.addproperty_button.classList.add("json-editor-btntype-properties"), this.addproperty_button.addEventListener("click", function(e5) {
              e5.preventDefault(), e5.stopPropagation(), t4.toggleAddProperty();
            }), this.controls.appendChild(this.addproperty_button), this.controls.insertBefore(this.addproperty_holder, this.controls.childNodes[1]), this.refreshAddProperties(), this.deactivateNonRequiredProperties();
          }
          this.options.table_row ? (this.editor_holder = this.container, this.property_order.forEach(function(e5) {
            t4.editor_holder.appendChild(t4.editors[e5].container);
          })) : (this.layoutEditors(), this.layoutEditors());
        } }, { key: "deactivateNonRequiredProperties", value: function() {
          var t4 = this, e4 = this.jsoneditor.options.show_opt_in, r3 = void 0 !== this.options.show_opt_in, n3 = r3 && true === this.options.show_opt_in, i3 = r3 && false === this.options.show_opt_in;
          (n3 || !i3 && e4 || !r3 && e4) && Object.entries(this.editors).forEach(function(e5) {
            var r4 = br(e5, 2), n4 = r4[0], i4 = r4[1];
            t4.isRequiredObject(i4) || t4.editors[n4].deactivate();
          });
        } }, { key: "showEditJSON", value: function() {
          this.editjson_holder && (this.hideAddProperty(), this.editjson_holder.style.left = "".concat(this.editjson_control.offsetLeft, "px"), this.editjson_holder.style.top = "".concat(this.editjson_control.offsetTop + this.editjson_control.offsetHeight, "px"), this.editjson_textarea.value = JSON.stringify(this.getValue(), null, 2), this.disable(), this.editjson_holder.style.display = "", this.editjson_control.disabled = false, this.editing_json = true);
        } }, { key: "hideEditJSON", value: function() {
          this.editjson_holder && this.editing_json && (this.editjson_holder.style.display = "none", this.enable(), this.editing_json = false);
        } }, { key: "copyJSON", value: function() {
          if (this.editjson_holder) {
            var t4 = document.createElement("textarea");
            t4.value = this.editjson_textarea.value, t4.setAttribute("readonly", ""), t4.style.position = "absolute", t4.style.left = "-9999px", document.body.appendChild(t4), t4.select(), document.execCommand("copy"), document.body.removeChild(t4);
          }
        } }, { key: "saveJSON", value: function() {
          if (this.editjson_holder)
            try {
              var t4 = JSON.parse(this.editjson_textarea.value);
              this.setValue(t4), this.hideEditJSON(), this.onChange(true);
            } catch (t5) {
              throw window.alert("invalid JSON"), t5;
            }
        } }, { key: "toggleEditJSON", value: function() {
          this.editing_json ? this.hideEditJSON() : this.showEditJSON();
        } }, { key: "insertPropertyControlUsingPropertyOrder", value: function(t4, e4, r3) {
          var n3;
          this.schema.properties[t4] && (n3 = this.schema.properties[t4].propertyOrder), "number" != typeof n3 && (n3 = 1e3), e4.propertyOrder = n3;
          for (var i3 = 0; i3 < r3.childNodes.length; i3++) {
            var o3 = r3.childNodes[i3];
            if (e4.propertyOrder < o3.propertyOrder) {
              this.addproperty_list.insertBefore(e4, o3), e4 = null;
              break;
            }
          }
          e4 && this.addproperty_list.appendChild(e4);
        } }, { key: "addPropertyCheckbox", value: function(t4) {
          var e4, r3 = this, n3 = this.theme.getCheckbox();
          e4 = this.schema.properties[t4] && this.schema.properties[t4].title ? this.schema.properties[t4].title : t4;
          var i3 = this.theme.getCheckboxLabel(e4), o3 = this.theme.getFormControl(i3, n3);
          return o3.style.paddingBottom = o3.style.marginBottom = o3.style.paddingTop = o3.style.marginTop = 0, o3.style.height = "auto", this.insertPropertyControlUsingPropertyOrder(t4, o3, this.addproperty_list), n3.checked = t4 in this.editors, n3.addEventListener("change", function() {
            n3.checked ? r3.addObjectProperty(t4) : r3.removeObjectProperty(t4), r3.onChange(true);
          }), this.addproperty_checkboxes[t4] = n3, n3;
        } }, { key: "showAddProperty", value: function() {
          this.addproperty_holder && (this.hideEditJSON(), this.addproperty_holder.style.left = "".concat(this.addproperty_button.offsetLeft, "px"), this.addproperty_holder.style.top = "".concat(this.addproperty_button.offsetTop + this.addproperty_button.offsetHeight, "px"), this.disable(), this.adding_property = true, this.addproperty_button.disabled = false, this.addproperty_holder.style.display = "", this.refreshAddProperties());
        } }, { key: "hideAddProperty", value: function() {
          this.addproperty_holder && this.adding_property && (this.addproperty_holder.style.display = "none", this.enable(), this.adding_property = false);
        } }, { key: "toggleAddProperty", value: function() {
          this.adding_property ? this.hideAddProperty() : this.showAddProperty();
        } }, { key: "removeObjectProperty", value: function(t4) {
          this.editors[t4] && (this.editors[t4].unregister(), delete this.editors[t4], this.refreshValue(), this.layoutEditors());
        } }, { key: "getSchemaOnMaxDepth", value: function(t4) {
          return Object.keys(t4).reduce(function(e4, r3) {
            switch (r3) {
              case "$ref":
                return e4;
              case "properties":
              case "items":
                return mr(mr({}, e4), {}, vr({}, r3, {}));
              case "additionalProperties":
              case "propertyNames":
                return mr(mr({}, e4), {}, vr({}, r3, true));
              default:
                return mr(mr({}, e4), {}, vr({}, r3, t4[r3]));
            }
          }, {});
        } }, { key: "addObjectProperty", value: function(t4, e4) {
          if (!this.editors[t4]) {
            if (this.cached_editors[t4]) {
              if (this.editors[t4] = this.cached_editors[t4], e4)
                return;
              this.editors[t4].register();
            } else {
              if (!(this.canHaveAdditionalProperties() || this.schema.properties && this.schema.properties[t4] || this.schema.patternProperties && Object.keys(this.schema.patternProperties).find(function(e5) {
                return new RegExp(e5).test(t4);
              })))
                return;
              var r3 = this.getPropertySchema(t4);
              "number" != typeof r3.propertyOrder && (r3.propertyOrder = Object.keys(this.editors).length + 1e3);
              var n3 = this.jsoneditor.getEditorClass(r3), i3 = this.jsoneditor.options.max_depth;
              if (this.editors[t4] = this.jsoneditor.createEditor(n3, { jsoneditor: this.jsoneditor, schema: i3 && this.currentDepth >= i3 ? this.getSchemaOnMaxDepth(r3) : r3, path: "".concat(this.path, ".").concat(t4), parent: this }, this.currentDepth + 1), this.editors[t4].preBuild(), !e4) {
                var o3 = this.theme.getChildEditorHolder();
                this.editor_holder.appendChild(o3), this.editors[t4].setContainer(o3), this.editors[t4].build(), this.editors[t4].postBuild(), this.editors[t4].setOptInCheckbox(n3.header), this.editors[t4].activate();
              }
              this.cached_editors[t4] = this.editors[t4];
            }
            e4 || (this.refreshValue(), this.layoutEditors());
          }
        } }, { key: "onOutsideModalClick", value: function(t4) {
          var e4 = t4.path || t4.composedPath && t4.composedPath();
          this.addproperty_holder && !this.addproperty_holder.contains(e4[0]) && this.adding_property && (t4.preventDefault(), t4.stopPropagation(), this.toggleAddProperty());
        } }, { key: "onChildEditorChange", value: function(t4) {
          this.refreshValue(), jr(xr(a2.prototype), "onChildEditorChange", this).call(this, t4);
        } }, { key: "canHaveAdditionalProperties", value: function() {
          return "boolean" == typeof this.schema.additionalProperties ? this.schema.additionalProperties : !this.jsoneditor.options.no_additional_properties;
        } }, { key: "destroy", value: function() {
          Object.values(this.cached_editors).forEach(function(t4) {
            return t4.destroy();
          }), this.editor_holder && (this.editor_holder.innerHTML = ""), this.title && this.title.parentNode && this.title.parentNode.removeChild(this.title), this.error_holder && this.error_holder.parentNode && this.error_holder.parentNode.removeChild(this.error_holder), this.editors = null, this.cached_editors = null, this.editor_holder && this.editor_holder.parentNode && this.editor_holder.parentNode.removeChild(this.editor_holder), this.editor_holder = null, document.removeEventListener("click", this.onOutsideModalClickListener, true), jr(xr(a2.prototype), "destroy", this).call(this);
        } }, { key: "getValue", value: function() {
          if (this.dependenciesFulfilled) {
            var t4 = jr(xr(a2.prototype), "getValue", this).call(this);
            return t4 && (this.jsoneditor.options.remove_empty_properties || this.options.remove_empty_properties) && Object.keys(t4).forEach(function(e4) {
              var r3;
              (void 0 === (r3 = t4[e4]) || "" === r3 || r3 === Object(r3) && 0 === Object.keys(r3).length && r3.constructor === Object) && delete t4[e4];
            }), t4;
          }
        } }, { key: "refreshValue", value: function() {
          var t4 = this;
          this.value = {}, this.editors && (Object.keys(this.editors).forEach(function(e4) {
            t4.editors[e4].isActive() && (t4.value[e4] = t4.editors[e4].getValue());
          }), this.adding_property && this.refreshAddProperties());
        } }, { key: "refreshAddProperties", value: function() {
          var t4 = this;
          if (this.options.disable_properties || false !== this.options.disable_properties && this.jsoneditor.options.disable_properties)
            this.addproperty_button.style.display = "none";
          else {
            var e4, r3 = 0, n3 = false;
            Object.keys(this.editors).forEach(function(t5) {
              return r3++;
            }), e4 = this.canHaveAdditionalProperties() && !(void 0 !== this.schema.maxProperties && r3 >= this.schema.maxProperties), this.addproperty_checkboxes && (this.addproperty_list.innerHTML = ""), this.addproperty_checkboxes = {}, Object.keys(this.cached_editors).forEach(function(i3) {
              t4.addPropertyCheckbox(i3), t4.isRequiredObject(t4.cached_editors[i3]) && i3 in t4.editors && (t4.addproperty_checkboxes[i3].disabled = true), void 0 !== t4.schema.minProperties && r3 <= t4.schema.minProperties ? (t4.addproperty_checkboxes[i3].disabled = t4.addproperty_checkboxes[i3].checked, t4.addproperty_checkboxes[i3].checked || (n3 = true)) : i3 in t4.editors ? n3 = true : e4 || h2(t4.schema.properties, i3) ? (t4.addproperty_checkboxes[i3].disabled = false, n3 = true) : t4.addproperty_checkboxes[i3].disabled = true;
            }), this.canHaveAdditionalProperties() && (n3 = true), Object.keys(this.schema.properties).forEach(function(e5) {
              t4.cached_editors[e5] || (n3 = true, t4.addPropertyCheckbox(e5));
            }), n3 ? this.canHaveAdditionalProperties() ? this.addproperty_add.disabled = !e4 : (this.addproperty_add.style.display = "none", this.addproperty_input.style.display = "none") : (this.hideAddProperty(), this.addproperty_button.style.display = "none");
          }
        } }, { key: "isRequiredObject", value: function(t4) {
          if (t4)
            return "boolean" == typeof t4.schema.required ? t4.schema.required : Array.isArray(this.schema.required) ? this.schema.required.includes(t4.key) : !!this.jsoneditor.options.required_by_default;
        } }, { key: "setValue", value: function(t4, e4) {
          var r3 = this;
          ("object" !== wr(t4 = t4 || {}) || Array.isArray(t4)) && (t4 = {}), Object.entries(this.cached_editors).forEach(function(n3) {
            var i3 = br(n3, 2), o3 = i3[0], a3 = i3[1];
            void 0 !== t4[o3] ? (r3.addObjectProperty(o3), a3.setValue(t4[o3], e4), a3.activate()) : e4 || r3.isRequiredObject(a3) ? a3.setValue(a3.getDefault(), e4) : r3.jsoneditor.options.show_opt_in || r3.options.show_opt_in ? a3.deactivate() : r3.removeObjectProperty(o3);
          }), Object.entries(t4).forEach(function(t5) {
            var n3 = br(t5, 2), i3 = n3[0], o3 = n3[1];
            r3.cached_editors[i3] || (r3.addObjectProperty(i3), r3.editors[i3] && r3.editors[i3].setValue(o3, e4, !!r3.editors[i3].template));
          }), this.refreshValue(), this.layoutEditors(), this.onChange();
        } }, { key: "showValidationErrors", value: function(t4) {
          var e4 = this, r3 = [], n3 = [];
          t4.forEach(function(t5) {
            t5.path === e4.path ? r3.push(t5) : n3.push(t5);
          }), this.error_holder && (r3.length ? (this.error_holder.innerHTML = "", this.error_holder.style.display = "", r3.forEach(function(t5) {
            t5.errorcount && t5.errorcount > 1 && (t5.message += " (".concat(t5.errorcount, " errors)")), e4.error_holder.appendChild(e4.theme.getErrorMessage(t5.message));
          })) : this.error_holder.style.display = "none"), this.options.table_row && (r3.length ? this.theme.addTableRowError(this.container) : this.theme.removeTableRowError(this.container)), Object.values(this.editors).forEach(function(t5) {
            t5.showValidationErrors(n3);
          });
        } }]) && _r(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), a2;
      }(w2);
      function Er(t3) {
        return Er = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, Er(t3);
      }
      function Sr(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== Er(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== Er(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === Er(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      function Pr() {
        return Pr = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t3, e3, r2) {
          var n2 = function(t4, e4) {
            for (; !Object.prototype.hasOwnProperty.call(t4, e4) && null !== (t4 = Lr(t4)); )
              ;
            return t4;
          }(t3, e3);
          if (n2) {
            var i2 = Object.getOwnPropertyDescriptor(n2, e3);
            return i2.get ? i2.get.call(arguments.length < 3 ? t3 : r2) : i2.value;
          }
        }, Pr.apply(this, arguments);
      }
      function Tr(t3, e3) {
        return Tr = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, Tr(t3, e3);
      }
      function Lr(t3) {
        return Lr = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, Lr(t3);
      }
      Cr.rules = { ".je-object__title": "display:inline-block", ".je-object__controls": "margin:0%200%200%2010px", ".je-object__container": "position:relative", ".je-object__property-checkbox": "margin:0;height:auto", ".property-selector": "width:295px;max-height:160px;padding:5px%200;overflow-y:auto;overflow-x:hidden;padding-left:5px", ".property-selector-input": "width:220px;margin-bottom:0;display:inline-block", ".json-editor-btntype-toggle": "margin:0%2010px%200%200", ".je-edit-json--textarea": "height:170px;width:300px;display:block" };
      var Rr = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && Tr(t4, e4);
        }(a2, t3);
        var e3, r2, n2, i2, o2 = (n2 = a2, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = Lr(n2);
          if (i2) {
            var r3 = Lr(this).constructor;
            t4 = Reflect.construct(e4, arguments, r3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === Er(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function a2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), o2.apply(this, arguments);
        }
        return e3 = a2, (r2 = [{ key: "preBuild", value: function() {
          Pr(Lr(a2.prototype), "preBuild", this).call(this);
        } }, { key: "build", value: function() {
          var t4 = this;
          this.label = "", this.options.compact || (this.header = this.label = this.theme.getFormInputLabel(this.getTitle(), this.isRequired())), this.schema.description && (this.description = this.theme.getFormInputDescription(this.translateProperty(this.schema.description))), this.options.infoText && (this.infoButton = this.theme.getInfoButton(this.translateProperty(this.options.infoText))), this.options.compact && this.container.classList.add("compact"), this.radioContainer = document.createElement("div"), this.radioGroup = [];
          for (var e4 = function(e5) {
            t4.setValue(e5.currentTarget.value), t4.onChange(true);
          }, r3 = 0; r3 < this.enum_values.length; r3++) {
            var n3 = { id: "".concat(this.formname, "[").concat(r3, "]"), value: this.enum_values[r3] };
            this.jsoneditor.options.use_name_attributes && (n3.name = this.formname), this.input = this.theme.getFormRadio(n3), this.setInputAttributes(["id", "value", "name"]), this.input.addEventListener("change", e4, false), this.radioGroup.push(this.input);
            var i3 = this.theme.getFormRadioLabel(this.enum_display[r3]);
            i3.htmlFor = this.input.id;
            var o3 = this.theme.getFormRadioControl(i3, this.input, !("horizontal" !== this.options.layout && !this.options.compact));
            this.radioContainer.appendChild(o3);
          }
          if (this.schema.readOnly || this.schema.readonly) {
            this.disable(true);
            for (var a3 = 0; a3 < this.radioGroup.length; a3++)
              this.radioGroup[a3].disabled = true;
            this.radioContainer.classList.add("readonly");
          }
          var s2 = this.theme.getContainer();
          s2.appendChild(this.radioContainer), s2.dataset.containerFor = "radio", this.input = s2, this.control = this.theme.getFormControl(this.label, s2, this.description, this.infoButton), this.container.appendChild(this.control), window.requestAnimationFrame(function() {
            t4.input.parentNode && t4.afterInputReady();
          });
        } }, { key: "enable", value: function() {
          if (!this.always_disabled) {
            for (var t4 = 0; t4 < this.radioGroup.length; t4++)
              this.radioGroup[t4].disabled = false;
            this.radioContainer.classList.remove("readonly"), Pr(Lr(a2.prototype), "enable", this).call(this);
          }
        } }, { key: "disable", value: function(t4) {
          t4 && (this.always_disabled = true);
          for (var e4 = 0; e4 < this.radioGroup.length; e4++)
            this.radioGroup[e4].disabled = true;
          this.radioContainer.classList.add("readonly"), Pr(Lr(a2.prototype), "disable", this).call(this);
        } }, { key: "destroy", value: function() {
          this.radioContainer.parentNode && this.radioContainer.parentNode.parentNode && this.radioContainer.parentNode.parentNode.removeChild(this.radioContainer.parentNode), this.label && this.label.parentNode && this.label.parentNode.removeChild(this.label), this.description && this.description.parentNode && this.description.parentNode.removeChild(this.description), Pr(Lr(a2.prototype), "destroy", this).call(this);
        } }, { key: "getNumColumns", value: function() {
          return 2;
        } }, { key: "setValue", value: function(t4) {
          "string" != typeof t4 && (t4 = String(t4));
          for (var e4 = 0; e4 < this.radioGroup.length; e4++)
            if (this.radioGroup[e4].value === t4) {
              this.radioGroup[e4].checked = true, this.value = t4, this.onChange();
              break;
            }
        } }]) && Sr(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), a2;
      }(Ft2);
      function Ar(t3) {
        return Ar = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, Ar(t3);
      }
      function Ir(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== Ar(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== Ar(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === Ar(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      function Br() {
        return Br = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t3, e3, r2) {
          var n2 = function(t4, e4) {
            for (; !Object.prototype.hasOwnProperty.call(t4, e4) && null !== (t4 = Dr(t4)); )
              ;
            return t4;
          }(t3, e3);
          if (n2) {
            var i2 = Object.getOwnPropertyDescriptor(n2, e3);
            return i2.get ? i2.get.call(arguments.length < 3 ? t3 : r2) : i2.value;
          }
        }, Br.apply(this, arguments);
      }
      function Nr(t3, e3) {
        return Nr = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, Nr(t3, e3);
      }
      function Dr(t3) {
        return Dr = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, Dr(t3);
      }
      var Fr = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && Nr(t4, e4);
        }(a2, t3);
        var e3, r2, n2, i2, o2 = (n2 = a2, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = Dr(n2);
          if (i2) {
            var r3 = Dr(this).constructor;
            t4 = Reflect.construct(e4, arguments, r3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === Ar(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function a2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), o2.apply(this, arguments);
        }
        return e3 = a2, (r2 = [{ key: "setValue", value: function(t4, e4, r3) {
          var n3 = Br(Dr(a2.prototype), "setValue", this).call(this, t4, e4, r3);
          void 0 !== n3 && n3.changed && this.sceditor_instance && this.sceditor_instance.val(n3.value);
        } }, { key: "build", value: function() {
          this.options.format = "textarea", Br(Dr(a2.prototype), "build", this).call(this), this.input_type = this.schema.format, this.input.setAttribute("data-schemaformat", this.input_type);
        } }, { key: "afterInputReady", value: function() {
          var t4 = this;
          if (window.sceditor) {
            var e4 = this.expandCallbacks("sceditor", l({}, { format: this.input_type, emoticonsEnabled: false, width: "100%", height: 300, readOnly: this.schema.readOnly || this.schema.readonly || this.schema.template }, this.defaults.options.sceditor || {}, this.options.sceditor || {}, { element: this.input })), r3 = window.sceditor.instance(this.input);
            void 0 === r3 && window.sceditor.create(this.input, e4), this.sceditor_instance = r3 || window.sceditor.instance(this.input), this.sceditor_instance.blur(function() {
              t4.value = t4.sceditor_instance.val(), t4.sceditor_instance.updateOriginal(), t4.is_dirty = true, t4.onChange(true);
            }), this.theme.afterInputReady(this.input);
          } else
            Br(Dr(a2.prototype), "afterInputReady", this).call(this);
        } }, { key: "getNumColumns", value: function() {
          return 6;
        } }, { key: "enable", value: function() {
          !this.always_disabled && this.sceditor_instance && this.sceditor_instance.readOnly(false), Br(Dr(a2.prototype), "enable", this).call(this);
        } }, { key: "disable", value: function(t4) {
          this.sceditor_instance && this.sceditor_instance.readOnly(true), Br(Dr(a2.prototype), "disable", this).call(this, t4);
        } }, { key: "destroy", value: function() {
          this.sceditor_instance && (this.sceditor_instance.destroy(), this.sceditor_instance = null), Br(Dr(a2.prototype), "destroy", this).call(this);
        } }]) && Ir(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), a2;
      }(C2);
      function Vr(t3) {
        return Vr = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, Vr(t3);
      }
      function zr(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== Vr(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== Vr(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === Vr(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      function Hr() {
        return Hr = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t3, e3, r2) {
          var n2 = function(t4, e4) {
            for (; !Object.prototype.hasOwnProperty.call(t4, e4) && null !== (t4 = qr(t4)); )
              ;
            return t4;
          }(t3, e3);
          if (n2) {
            var i2 = Object.getOwnPropertyDescriptor(n2, e3);
            return i2.get ? i2.get.call(arguments.length < 3 ? t3 : r2) : i2.value;
          }
        }, Hr.apply(this, arguments);
      }
      function Mr(t3, e3) {
        return Mr = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, Mr(t3, e3);
      }
      function qr(t3) {
        return qr = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, qr(t3);
      }
      var Gr = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && Mr(t4, e4);
        }(a2, t3);
        var e3, r2, n2, i2, o2 = (n2 = a2, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = qr(n2);
          if (i2) {
            var r3 = qr(this).constructor;
            t4 = Reflect.construct(e4, arguments, r3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === Vr(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function a2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), o2.apply(this, arguments);
        }
        return e3 = a2, (r2 = [{ key: "setValue", value: function(t4, e4) {
          if (this.select2_instance) {
            e4 ? this.is_dirty = false : "change" === this.jsoneditor.options.show_errors && (this.is_dirty = true);
            var r3 = this.updateValue(t4);
            this.input.value = r3, this.select2v4 ? this.select2_instance.val(r3).trigger("change") : this.select2_instance.select2("val", r3), this.onChange(true);
          } else
            Hr(qr(a2.prototype), "setValue", this).call(this, t4, e4);
        } }, { key: "afterInputReady", value: function() {
          var t4 = this;
          if (window.jQuery && window.jQuery.fn && window.jQuery.fn.select2 && !this.select2_instance) {
            var e4 = this.expandCallbacks("select2", l({}, this.defaults.options.select2 || {}, this.options.select2 || {}));
            this.newEnumAllowed = e4.tags = !!e4.tags && "string" === this.schema.type, this.select2_instance = window.jQuery(this.input).select2(e4), this.select2v4 = h2(this.select2_instance.select2, "amd"), this.selectChangeHandler = function() {
              var e5 = t4.select2v4 ? t4.select2_instance.val() : t4.select2_instance.select2("val");
              t4.updateValue(e5), t4.onChange(true);
            }, this.select2_instance.on("change", this.selectChangeHandler), this.select2_instance.on("select2-blur", this.selectChangeHandler);
          }
          Hr(qr(a2.prototype), "afterInputReady", this).call(this);
        } }, { key: "updateValue", value: function(t4) {
          var e4 = this.enum_values[0];
          return t4 = this.typecast(t4 || ""), this.enum_values.includes(t4) ? e4 = t4 : this.newEnumAllowed && (e4 = this.addNewOption(t4) ? t4 : e4), this.value = e4, e4;
        } }, { key: "addNewOption", value: function(t4) {
          var e4, r3 = this.typecast(t4), n3 = false;
          return this.enum_values.includes(r3) || "" === r3 || (this.enum_options.push("".concat(r3)), this.enum_display.push("".concat(r3)), this.enum_values.push(r3), this.schema.enum.push(r3), (e4 = this.input.querySelector('option[value="'.concat(r3, '"]'))) ? e4.removeAttribute("data-select2-tag") : this.input.appendChild(new Option(r3, r3, false, false)).trigger("change"), n3 = true), n3;
        } }, { key: "enable", value: function() {
          this.always_disabled || this.select2_instance && (this.select2v4 ? this.select2_instance.prop("disabled", false) : this.select2_instance.select2("enable", true)), Hr(qr(a2.prototype), "enable", this).call(this);
        } }, { key: "disable", value: function(t4) {
          this.select2_instance && (this.select2v4 ? this.select2_instance.prop("disabled", true) : this.select2_instance.select2("enable", false)), Hr(qr(a2.prototype), "disable", this).call(this, t4);
        } }, { key: "destroy", value: function() {
          this.select2_instance && (this.select2_instance.select2("destroy"), this.select2_instance = null), Hr(qr(a2.prototype), "destroy", this).call(this);
        } }]) && zr(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), a2;
      }(Ft2);
      function Ur(t3) {
        return Ur = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, Ur(t3);
      }
      function $r(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== Ur(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== Ur(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === Ur(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      function Jr() {
        return Jr = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t3, e3, r2) {
          var n2 = function(t4, e4) {
            for (; !Object.prototype.hasOwnProperty.call(t4, e4) && null !== (t4 = Zr(t4)); )
              ;
            return t4;
          }(t3, e3);
          if (n2) {
            var i2 = Object.getOwnPropertyDescriptor(n2, e3);
            return i2.get ? i2.get.call(arguments.length < 3 ? t3 : r2) : i2.value;
          }
        }, Jr.apply(this, arguments);
      }
      function Wr(t3, e3) {
        return Wr = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, Wr(t3, e3);
      }
      function Zr(t3) {
        return Zr = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, Zr(t3);
      }
      var Yr = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && Wr(t4, e4);
        }(a2, t3);
        var e3, r2, n2, i2, o2 = (n2 = a2, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = Zr(n2);
          if (i2) {
            var r3 = Zr(this).constructor;
            t4 = Reflect.construct(e4, arguments, r3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === Ur(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function a2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), o2.apply(this, arguments);
        }
        return e3 = a2, (r2 = [{ key: "setValue", value: function(t4, e4) {
          if (this.selectize_instance) {
            e4 ? this.is_dirty = false : "change" === this.jsoneditor.options.show_errors && (this.is_dirty = true);
            var r3 = this.updateValue(t4);
            this.input.value = r3, this.selectize_instance.clear(true), this.selectize_instance.setValue(r3), this.onChange(true);
          } else
            Jr(Zr(a2.prototype), "setValue", this).call(this, t4, e4);
        } }, { key: "afterInputReady", value: function() {
          var t4 = this;
          if (window.jQuery && window.jQuery.fn && window.jQuery.fn.selectize && !this.selectize_instance) {
            var e4 = this.expandCallbacks("selectize", l({}, this.defaults.options.selectize || {}, this.options.selectize || {}));
            this.newEnumAllowed = e4.create = !!e4.create && "string" === this.schema.type, this.selectize_instance = window.jQuery(this.input).selectize(e4)[0].selectize, this.control.removeEventListener("change", this.multiselectChangeHandler), this.multiselectChangeHandler = function(e5) {
              t4.updateValue(e5), t4.onChange(true);
            }, this.selectize_instance.on("change", this.multiselectChangeHandler);
          }
          Jr(Zr(a2.prototype), "afterInputReady", this).call(this);
        } }, { key: "updateValue", value: function(t4) {
          var e4 = this.enum_values[0];
          return t4 = this.typecast(t4 || ""), this.enum_values.includes(t4) ? e4 = t4 : this.newEnumAllowed && (e4 = this.addNewOption(t4) ? t4 : e4), this.value = e4, e4;
        } }, { key: "addNewOption", value: function(t4) {
          var e4 = this.typecast(t4), r3 = false;
          return this.enum_values.includes(e4) || "" === e4 || (this.enum_options.push("".concat(e4)), this.enum_display.push("".concat(e4)), this.enum_values.push(e4), this.schema.enum.push(e4), this.selectize_instance.addItem(e4), this.selectize_instance.refreshOptions(false), r3 = true), r3;
        } }, { key: "onWatchedFieldChange", value: function() {
          var t4 = this;
          Jr(Zr(a2.prototype), "onWatchedFieldChange", this).call(this), this.selectize_instance && (this.selectize_instance.clear(true), this.selectize_instance.clearOptions(true), this.enum_options.forEach(function(e4, r3) {
            t4.selectize_instance.addOption({ value: e4, text: t4.enum_display[r3] });
          }), this.selectize_instance.addItem("".concat(this.value), true));
        } }, { key: "enable", value: function() {
          !this.always_disabled && this.selectize_instance && this.selectize_instance.unlock(), Jr(Zr(a2.prototype), "enable", this).call(this);
        } }, { key: "disable", value: function(t4) {
          this.selectize_instance && this.selectize_instance.lock(), Jr(Zr(a2.prototype), "disable", this).call(this, t4);
        } }, { key: "destroy", value: function() {
          this.selectize_instance && (this.selectize_instance.destroy(), this.selectize_instance = null), Jr(Zr(a2.prototype), "destroy", this).call(this);
        } }]) && $r(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), a2;
      }(Ft2);
      function Qr(t3) {
        return Qr = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, Qr(t3);
      }
      function Kr(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== Qr(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== Qr(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === Qr(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      function Xr(t3, e3) {
        return Xr = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, Xr(t3, e3);
      }
      function tn(t3) {
        return tn = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, tn(t3);
      }
      var en2 = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && Xr(t4, e4);
        }(a2, t3);
        var e3, r2, n2, i2, o2 = (n2 = a2, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = tn(n2);
          if (i2) {
            var r3 = tn(this).constructor;
            t4 = Reflect.construct(e4, arguments, r3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === Qr(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function a2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), o2.apply(this, arguments);
        }
        return e3 = a2, (r2 = [{ key: "build", value: function() {
          var t4 = this;
          this.options.compact || (this.header = this.label = this.theme.getFormInputLabel(this.getTitle(), this.isRequired())), this.schema.description && (this.description = this.theme.getFormInputDescription(this.translateProperty(this.schema.description)));
          var e4 = this.formname.replace(/\W/g, "");
          if ("function" == typeof SignaturePad) {
            this.input = this.theme.getFormInputField("hidden"), this.container.appendChild(this.input);
            var r3 = document.createElement("div");
            r3.classList.add("signature-container");
            var n3 = document.createElement("canvas");
            this.jsoneditor.options.use_name_attributes && n3.setAttribute("name", e4), n3.classList.add("signature"), r3.appendChild(n3), this.signaturePad = new window.SignaturePad(n3, { onEnd: function() {
              this.signaturePad.isEmpty() ? this.input.value = "" : this.input.value = this.signaturePad.toDataURL(), this.is_dirty = true, this.refreshValue(), this.watch_listener(), this.jsoneditor.notifyWatchers(this.path), this.parent ? this.parent.onChildEditorChange(this) : this.jsoneditor.onChange();
            } });
            var i3 = document.createElement("div"), o3 = document.createElement("button");
            o3.classList.add("tiny", "button"), o3.innerHTML = "Clear signature", i3.appendChild(o3), r3.appendChild(i3), this.options.compact && this.container.setAttribute("class", "".concat(this.container.getAttribute("class"), " compact")), (this.schema.readOnly || this.schema.readonly) && (this.disable(true), Array.from(this.inputs).forEach(function(t5) {
              n3.setAttribute("readOnly", "readOnly"), t5.disabled = true;
            })), o3.addEventListener("click", function(e5) {
              e5.preventDefault(), e5.stopPropagation(), t4.signaturePad.clear(), t4.signaturePad.strokeEnd();
            }), this.control = this.theme.getFormControl(this.label, r3, this.description), this.container.appendChild(this.control), this.refreshValue(), n3.width = r3.offsetWidth, this.options && this.options.canvas_height ? n3.height = this.options.canvas_height : n3.height = "300";
          } else {
            var a3 = document.createElement("p");
            a3.innerHTML = "Signature pad is not available, please include SignaturePad from https://github.com/szimek/signature_pad", this.container.appendChild(a3);
          }
        } }, { key: "setValue", value: function(t4) {
          if ("function" == typeof SignaturePad) {
            var e4 = this.sanitize(t4);
            if (this.value === e4)
              return;
            return this.value = e4, this.input.value = this.value, this.signaturePad.clear(), t4 && "" !== t4 && this.signaturePad.fromDataURL(t4), this.watch_listener(), this.jsoneditor.notifyWatchers(this.path), false;
          }
        } }, { key: "destroy", value: function() {
          this.signaturePad.off(), delete this.signaturePad;
        } }]) && Kr(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), a2;
      }(C2);
      function rn(t3) {
        return rn = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, rn(t3);
      }
      function nn(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== rn(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== rn(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === rn(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      function on2() {
        return on2 = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t3, e3, r2) {
          var n2 = function(t4, e4) {
            for (; !Object.prototype.hasOwnProperty.call(t4, e4) && null !== (t4 = sn(t4)); )
              ;
            return t4;
          }(t3, e3);
          if (n2) {
            var i2 = Object.getOwnPropertyDescriptor(n2, e3);
            return i2.get ? i2.get.call(arguments.length < 3 ? t3 : r2) : i2.value;
          }
        }, on2.apply(this, arguments);
      }
      function an(t3, e3) {
        return an = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, an(t3, e3);
      }
      function sn(t3) {
        return sn = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, sn(t3);
      }
      r(2564);
      var ln = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && an(t4, e4);
        }(a2, t3);
        var e3, r2, n2, i2, o2 = (n2 = a2, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = sn(n2);
          if (i2) {
            var r3 = sn(this).constructor;
            t4 = Reflect.construct(e4, arguments, r3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === rn(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function a2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), o2.apply(this, arguments);
        }
        return e3 = a2, (r2 = [{ key: "setValue", value: function(t4, e4, r3) {
          var n3 = on2(sn(a2.prototype), "setValue", this).call(this, t4, e4, r3);
          void 0 !== n3 && n3.changed && this.simplemde_instance && this.simplemde_instance.value(n3.value);
        } }, { key: "build", value: function() {
          this.options.format = "textarea", on2(sn(a2.prototype), "build", this).call(this), this.input_type = this.schema.format, this.input.setAttribute("data-schemaformat", this.input_type);
        } }, { key: "afterInputReady", value: function() {
          var t4, e4 = this;
          window.SimpleMDE ? (t4 = this.expandCallbacks("simplemde", l({}, { height: 300 }, this.defaults.options.simplemde || {}, this.options.simplemde || {}, { element: this.input })), this.simplemde_instance = new window.SimpleMDE(t4), (this.schema.readOnly || this.schema.readonly || this.schema.template) && (this.simplemde_instance.codemirror.options.readOnly = true), this.simplemde_instance.codemirror.on("change", function() {
            e4.value = e4.simplemde_instance.value(), e4.is_dirty = true, e4.onChange(true);
          }), t4.autorefresh && this.startListening(this.simplemde_instance.codemirror, this.simplemde_instance.codemirror.state.autoRefresh = { delay: 250 }), this.theme.afterInputReady(this.input)) : on2(sn(a2.prototype), "afterInputReady", this).call(this);
        } }, { key: "getNumColumns", value: function() {
          return 6;
        } }, { key: "enable", value: function() {
          !this.always_disabled && this.simplemde_instance && (this.simplemde_instance.codemirror.options.readOnly = false), on2(sn(a2.prototype), "enable", this).call(this);
        } }, { key: "disable", value: function(t4) {
          this.simplemde_instance && (this.simplemde_instance.codemirror.options.readOnly = true), on2(sn(a2.prototype), "disable", this).call(this, t4);
        } }, { key: "destroy", value: function() {
          this.simplemde_instance && (this.simplemde_instance.toTextArea(), this.simplemde_instance = null), on2(sn(a2.prototype), "destroy", this).call(this);
        } }, { key: "startListening", value: function(t4, e4) {
          function r3() {
            t4.display.wrapper.offsetHeight ? (this.stopListening(t4, e4), t4.display.lastWrapHeight !== t4.display.wrapper.clientHeight && t4.refresh()) : e4.timeout = window.setTimeout(r3, e4.delay);
          }
          e4.timeout = window.setTimeout(r3, e4.delay), e4.hurry = function() {
            window.clearTimeout(e4.timeout), e4.timeout = window.setTimeout(r3, 50);
          }, t4.on(window, "mouseup", e4.hurry), t4.on(window, "keyup", e4.hurry);
        } }, { key: "stopListening", value: function(t4, e4) {
          window.clearTimeout(e4.timeout), t4.off(window, "mouseup", e4.hurry), t4.off(window, "keyup", e4.hurry);
        } }]) && nn(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), a2;
      }(C2);
      function cn(t3) {
        return cn = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, cn(t3);
      }
      function un(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== cn(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== cn(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === cn(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      function hn() {
        return hn = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t3, e3, r2) {
          var n2 = function(t4, e4) {
            for (; !Object.prototype.hasOwnProperty.call(t4, e4) && null !== (t4 = dn(t4)); )
              ;
            return t4;
          }(t3, e3);
          if (n2) {
            var i2 = Object.getOwnPropertyDescriptor(n2, e3);
            return i2.get ? i2.get.call(arguments.length < 3 ? t3 : r2) : i2.value;
          }
        }, hn.apply(this, arguments);
      }
      function pn(t3, e3) {
        return pn = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, pn(t3, e3);
      }
      function dn(t3) {
        return dn = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, dn(t3);
      }
      var fn = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && pn(t4, e4);
        }(a2, t3);
        var e3, r2, n2, i2, o2 = (n2 = a2, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = dn(n2);
          if (i2) {
            var r3 = dn(this).constructor;
            t4 = Reflect.construct(e4, arguments, r3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === cn(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function a2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), o2.apply(this, arguments);
        }
        return e3 = a2, (r2 = [{ key: "build", value: function() {
          var t4 = this;
          if (this.options.compact || (this.header = this.label = this.theme.getFormInputLabel(this.getTitle(), this.isRequired())), this.schema.description && (this.description = this.theme.getFormInputDescription(this.translateProperty(this.schema.description))), this.options.infoText && (this.infoButton = this.theme.getInfoButton(this.translateProperty(this.options.infoText))), this.options.compact && this.container.classList.add("compact"), this.ratingContainer = document.createElement("div"), this.ratingContainer.classList.add("starrating"), void 0 === this.schema.enum) {
            var e4 = this.schema.maximum ? this.schema.maximum : 5;
            this.schema.exclusiveMaximum && e4--, this.enum_values = [];
            for (var r3 = 0; r3 < e4; r3++)
              this.enum_values.push(r3 + 1);
          } else
            this.enum_values = this.schema.enum;
          this.radioGroup = [];
          for (var n3 = function(e5) {
            e5.preventDefault(), e5.stopPropagation(), t4.setValue(e5.currentTarget.value), t4.onChange(true);
          }, i3 = this.enum_values.length - 1; i3 > -1; i3--) {
            var o3 = this.formname + (i3 + 1), a3 = this.theme.getFormInputField("radio");
            a3.name = "".concat(this.formname, "[starrating]"), a3.value = this.enum_values[i3], a3.id = o3, a3.addEventListener("change", n3, false), this.radioGroup.push(a3);
            var s2 = document.createElement("label");
            s2.htmlFor = o3, s2.title = this.enum_values[i3], this.options.displayValue && s2.classList.add("starrating-display-enabled"), this.ratingContainer.appendChild(a3), this.ratingContainer.appendChild(s2);
          }
          if (this.options.displayValue && (this.displayRating = document.createElement("div"), this.displayRating.classList.add("starrating-display"), this.displayRating.innerText = this.enum_values[0], this.ratingContainer.appendChild(this.displayRating)), this.schema.readOnly || this.schema.readonly) {
            this.disable(true);
            for (var l2 = 0; l2 < this.radioGroup.length; l2++)
              this.radioGroup[l2].disabled = true;
            this.ratingContainer.classList.add("readonly");
          }
          var c3 = this.theme.getContainer();
          c3.appendChild(this.ratingContainer), this.input = c3, this.control = this.theme.getFormControl(this.label, c3, this.description, this.infoButton), this.container.appendChild(this.control), this.refreshValue();
        } }, { key: "enable", value: function() {
          if (!this.always_disabled) {
            for (var t4 = 0; t4 < this.radioGroup.length; t4++)
              this.radioGroup[t4].disabled = false;
            this.ratingContainer.classList.remove("readonly"), this.disabled = false;
          }
        } }, { key: "disable", value: function(t4) {
          t4 && (this.always_disabled = true);
          for (var e4 = 0; e4 < this.radioGroup.length; e4++)
            this.radioGroup[e4].disabled = true;
          this.ratingContainer.classList.add("readonly"), this.disabled = true;
        } }, { key: "destroy", value: function() {
          this.ratingContainer.parentNode && this.ratingContainer.parentNode.parentNode && this.ratingContainer.parentNode.parentNode.removeChild(this.ratingContainer.parentNode), this.label && this.label.parentNode && this.label.parentNode.removeChild(this.label), this.description && this.description.parentNode && this.description.parentNode.removeChild(this.description), hn(dn(a2.prototype), "destroy", this).call(this);
        } }, { key: "getNumColumns", value: function() {
          return 2;
        } }, { key: "getValue", value: function() {
          if (this.dependenciesFulfilled)
            return "integer" === this.schema.type ? "" === this.value ? void 0 : 1 * this.value : this.value;
        } }, { key: "setValue", value: function(t4) {
          for (var e4 = 0; e4 < this.radioGroup.length; e4++)
            if (this.radioGroup[e4].value === "".concat(t4)) {
              this.radioGroup[e4].checked = true, this.value = t4, this.options.displayValue && (this.displayRating.innerHTML = this.value), this.onChange(true);
              break;
            }
        } }]) && un(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), a2;
      }(C2);
      function yn(t3) {
        return yn = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, yn(t3);
      }
      function mn(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== yn(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== yn(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === yn(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      function vn() {
        return vn = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t3, e3, r2) {
          var n2 = function(t4, e4) {
            for (; !Object.prototype.hasOwnProperty.call(t4, e4) && null !== (t4 = gn(t4)); )
              ;
            return t4;
          }(t3, e3);
          if (n2) {
            var i2 = Object.getOwnPropertyDescriptor(n2, e3);
            return i2.get ? i2.get.call(arguments.length < 3 ? t3 : r2) : i2.value;
          }
        }, vn.apply(this, arguments);
      }
      function bn(t3, e3) {
        return bn = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, bn(t3, e3);
      }
      function gn(t3) {
        return gn = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, gn(t3);
      }
      fn.rules = { ".starrating": "direction:rtl;display:inline-block;white-space:nowrap", ".starrating > input": "display:none", ".starrating > label:before": "content:'%5C2606';margin:1px;font-size:18px;font-style:normal;font-weight:400;line-height:1;font-family:'Arial';display:inline-block", ".starrating > label": "color:%23888;cursor:pointer;margin:8px%200%202px%200", ".starrating > label.starrating-display-enabled": "margin:1px%200%200%200", ".starrating > input:checked ~ label": "color:%23ffca08", ".starrating:not(.readonly) > input:hover ~ label": "color:%23ffca08", ".starrating > input:checked ~ label:before": "content:'%5C2605';text-shadow:0%200%201px%20rgba(0%2C20%2C20%2C1)", ".starrating:not(.readonly) > input:hover ~ label:before": "content:'%5C2605';text-shadow:0%200%201px%20rgba(0%2C20%2C20%2C1)", ".starrating .starrating-display": "position:relative;direction:rtl;text-align:center;font-size:10px;line-height:0px" };
      var wn = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && bn(t4, e4);
        }(a2, t3);
        var e3, r2, n2, i2, o2 = (n2 = a2, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = gn(n2);
          if (i2) {
            var r3 = gn(this).constructor;
            t4 = Reflect.construct(e4, arguments, r3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === yn(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function a2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), o2.apply(this, arguments);
        }
        return e3 = a2, (r2 = [{ key: "build", value: function() {
          vn(gn(a2.prototype), "build", this).call(this), this.input.setAttribute("type", "number"), this.input.getAttribute("step") || this.input.setAttribute("step", "1");
          var t4 = this.theme.getStepperButtons(this.input);
          this.control.appendChild(t4), this.stepperDown = this.control.querySelector(".stepper-down"), this.stepperUp = this.control.querySelector(".stepper-up");
        } }, { key: "enable", value: function() {
          vn(gn(a2.prototype), "enable", this).call(this), this.stepperDown.removeAttribute("disabled"), this.stepperUp.removeAttribute("disabled");
        } }, { key: "disable", value: function() {
          vn(gn(a2.prototype), "disable", this).call(this), this.stepperDown.setAttribute("disabled", true), this.stepperUp.setAttribute("disabled", true);
        } }]) && mn(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), a2;
      }(Le);
      function _n(t3) {
        return _n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, _n(t3);
      }
      function kn(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== _n(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== _n(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === _n(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      function jn() {
        return jn = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t3, e3, r2) {
          var n2 = function(t4, e4) {
            for (; !Object.prototype.hasOwnProperty.call(t4, e4) && null !== (t4 = xn(t4)); )
              ;
            return t4;
          }(t3, e3);
          if (n2) {
            var i2 = Object.getOwnPropertyDescriptor(n2, e3);
            return i2.get ? i2.get.call(arguments.length < 3 ? t3 : r2) : i2.value;
          }
        }, jn.apply(this, arguments);
      }
      function On(t3, e3) {
        return On = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, On(t3, e3);
      }
      function xn(t3) {
        return xn = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, xn(t3);
      }
      var Cn = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && On(t4, e4);
        }(a2, t3);
        var e3, r2, n2, i2, o2 = (n2 = a2, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = xn(n2);
          if (i2) {
            var r3 = xn(this).constructor;
            t4 = Reflect.construct(e4, arguments, r3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === _n(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function a2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), o2.apply(this, arguments);
        }
        return e3 = a2, r2 = [{ key: "register", value: function() {
          if (jn(xn(a2.prototype), "register", this).call(this), this.rows)
            for (var t4 = 0; t4 < this.rows.length; t4++)
              this.rows[t4].register();
        } }, { key: "unregister", value: function() {
          if (jn(xn(a2.prototype), "unregister", this).call(this), this.rows)
            for (var t4 = 0; t4 < this.rows.length; t4++)
              this.rows[t4].unregister();
        } }, { key: "getNumColumns", value: function() {
          return Math.max(Math.min(12, this.width), 3);
        } }, { key: "preBuild", value: function() {
          var t4 = this.jsoneditor.expandRefs(this.schema.items || {});
          this.item_title = t4.title || "row", this.item_default = t4.default || null, this.item_has_child_editors = t4.properties || t4.items, this.width = 12, this.array_controls_top = this.options.array_controls_top || this.jsoneditor.options.array_controls_top, jn(xn(a2.prototype), "preBuild", this).call(this);
        } }, { key: "build", value: function() {
          this.table = this.theme.getTable(), this.container.appendChild(this.table), this.thead = this.theme.getTableHead(), this.table.appendChild(this.thead), this.header_row = this.theme.getTableRow(), this.thead.appendChild(this.header_row), this.row_holder = this.theme.getTableBody(), this.table.appendChild(this.row_holder);
          var t4 = this.getElementEditor(0, true);
          if (this.item_default = t4.getDefault(), this.width = t4.getNumColumns() + 2, this.options.compact ? (this.panel = document.createElement("div"), this.container.appendChild(this.panel)) : (this.header = document.createElement("label"), this.header.textContent = this.getTitle(), this.title = this.theme.getHeader(this.header, this.getPathDepth()), this.container.appendChild(this.title), this.options.infoText && (this.infoButton = this.theme.getInfoButton(this.translateProperty(this.options.infoText)), this.container.appendChild(this.infoButton)), this.title_controls = this.theme.getHeaderButtonHolder(), this.title.appendChild(this.title_controls), this.schema.description && (this.description = this.theme.getDescription(this.translateProperty(this.schema.description)), this.container.appendChild(this.description)), this.panel = this.theme.getIndentedPanel(), this.container.appendChild(this.panel), this.error_holder = document.createElement("div"), this.panel.appendChild(this.error_holder)), this.panel.appendChild(this.table), this.controls = this.theme.getButtonHolder(), this.array_controls_top ? this.title.appendChild(this.controls) : this.panel.appendChild(this.controls), this.item_has_child_editors)
            for (var e4 = t4.getChildEditors(), r3 = t4.property_order || Object.keys(e4), n3 = 0; n3 < r3.length; n3++) {
              var i3 = this.theme.getTableHeaderCell(e4[r3[n3]].getTitle());
              e4[r3[n3]].options.hidden && (i3.style.display = "none"), this.header_row.appendChild(i3);
            }
          else
            this.header_row.appendChild(this.theme.getTableHeaderCell(this.item_title));
          t4.destroy(), this.row_holder.innerHTML = "", this.controls_header_cell = this.theme.getTableHeaderCell(" "), this.controls_header_cell.setAttribute("aria-hidden", "true"), this.header_row.appendChild(this.controls_header_cell), this.addControls();
        } }, { key: "onChildEditorChange", value: function(t4) {
          this.refreshValue(), jn(xn(a2.prototype), "onChildEditorChange", this).call(this);
        } }, { key: "getItemDefault", value: function() {
          return l({}, { default: this.item_default }).default;
        } }, { key: "getItemTitle", value: function() {
          return this.item_title;
        } }, { key: "getElementEditor", value: function(t4, e4) {
          var r3 = l({}, this.schema.items), n3 = this.jsoneditor.getEditorClass(r3, this.jsoneditor), i3 = this.row_holder.appendChild(this.theme.getTableRow()), o3 = i3;
          this.item_has_child_editors || (o3 = this.theme.getTableCell(), i3.appendChild(o3));
          var a3 = this.jsoneditor.createEditor(n3, { jsoneditor: this.jsoneditor, schema: r3, container: o3, path: "".concat(this.path, ".").concat(t4), parent: this, compact: true, table_row: true });
          return a3.preBuild(), e4 || (a3.build(), a3.postBuild(), a3.controls_cell = i3.appendChild(this.theme.getTableCell()), a3.row = i3, a3.table_controls = this.theme.getButtonHolder(), a3.controls_cell.appendChild(a3.table_controls), a3.table_controls.style.margin = 0, a3.table_controls.style.padding = 0), a3;
        } }, { key: "destroy", value: function() {
          this.innerHTML = "", this.checkParent(this.title) && this.title.parentNode.removeChild(this.title), this.checkParent(this.description) && this.description.parentNode.removeChild(this.description), this.checkParent(this.row_holder) && this.row_holder.parentNode.removeChild(this.row_holder), this.checkParent(this.table) && this.table.parentNode.removeChild(this.table), this.checkParent(this.panel) && this.panel.parentNode.removeChild(this.panel), this.rows = this.title = this.description = this.row_holder = this.table = this.panel = null, jn(xn(a2.prototype), "destroy", this).call(this);
        } }, { key: "ensureArraySize", value: function(t4) {
          if (Array.isArray(t4) || (t4 = [t4]), this.schema.minItems)
            for (; t4.length < this.schema.minItems; )
              t4.push(this.getItemDefault());
          return this.schema.maxItems && t4.length > this.schema.maxItems && (t4 = t4.slice(0, this.schema.maxItems)), t4;
        } }, { key: "setValue", value: function() {
          var t4 = this, e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], r3 = arguments.length > 1 ? arguments[1] : void 0;
          if (e4 = this.ensureArraySize(e4), JSON.stringify(e4) !== this.serialized) {
            var n3 = false;
            e4.forEach(function(e5, r4) {
              t4.rows[r4] ? t4.rows[r4].setValue(e5) : (t4.addRow(e5), n3 = true);
            });
            for (var i3 = e4.length; i3 < this.rows.length; i3++) {
              var o3 = this.rows[i3].container;
              this.item_has_child_editors || this.rows[i3].row.parentNode.removeChild(this.rows[i3].row), this.rows[i3].destroy(), o3.parentNode && o3.parentNode.removeChild(o3), this.rows[i3] = null, n3 = true;
            }
            this.rows = this.rows.slice(0, e4.length), this.refreshValue(), (n3 || r3) && this.refreshRowButtons(), this.onChange();
          }
        } }, { key: "refreshRowButtons", value: function() {
          var t4 = this, e4 = this.schema.minItems && this.schema.minItems >= this.rows.length, r3 = this.schema.maxItems && this.schema.maxItems <= this.rows.length, n3 = [];
          this.rows.forEach(function(i4, o4) {
            if (i4.delete_button) {
              var a4 = !e4;
              t4.setVisibility(i4.delete_button, a4), n3.push(a4);
            }
            if (i4.copy_button) {
              var s3 = !r3;
              t4.setVisibility(i4.copy_button, s3), n3.push(s3);
            }
            if (i4.moveup_button) {
              var l3 = 0 !== o4;
              t4.setVisibility(i4.moveup_button, l3), n3.push(l3);
            }
            if (i4.movedown_button) {
              var c3 = o4 !== t4.rows.length - 1;
              t4.setVisibility(i4.movedown_button, c3), n3.push(c3);
            }
          });
          var i3 = n3.some(function(t5) {
            return t5;
          });
          this.rows.forEach(function(e5) {
            return t4.setVisibility(e5.controls_cell, i3);
          }), this.setVisibility(this.controls_header_cell, i3), this.setVisibility(this.table, this.value.length);
          var o3 = !(r3 || this.hide_add_button);
          this.setVisibility(this.add_row_button, o3);
          var a3 = !(!this.value.length || e4 || this.hide_delete_last_row_buttons);
          this.setVisibility(this.delete_last_row_button, a3);
          var s2 = !(this.value.length <= 1 || e4 || this.hide_delete_all_rows_buttons);
          this.setVisibility(this.remove_all_rows_button, s2);
          var l2 = o3 || a3 || s2;
          this.setVisibility(this.controls, l2);
        } }, { key: "refreshValue", value: function() {
          var t4 = this;
          this.value = [], this.rows.forEach(function(e4, r3) {
            t4.value[r3] = e4.getValue();
          }), this.serialized = JSON.stringify(this.value);
        } }, { key: "addRow", value: function(t4) {
          var e4 = this.rows.length;
          this.rows[e4] = this.getElementEditor(e4);
          var r3 = this.rows[e4].table_controls;
          return this.hide_delete_buttons || (this.rows[e4].delete_button = this._createDeleteButton(e4, r3)), this.show_copy_button && (this.rows[e4].copy_button = this._createCopyButton(e4, r3)), this.hide_move_buttons || (this.rows[e4].moveup_button = this._createMoveUpButton(e4, r3)), this.hide_move_buttons || (this.rows[e4].movedown_button = this._createMoveDownButton(e4, r3)), void 0 !== t4 && this.rows[e4].setValue(t4), this.rows[e4];
        } }, { key: "_createDeleteButton", value: function(t4, e4) {
          var r3 = this, n3 = this.getButton("", "delete", "button_delete_row_title_short");
          return n3.classList.add("delete", "json-editor-btntype-delete"), n3.setAttribute("data-i", t4), n3.addEventListener("click", function(t5) {
            if (t5.preventDefault(), t5.stopPropagation(), !r3.askConfirmation())
              return false;
            var e5 = 1 * t5.currentTarget.getAttribute("data-i"), n4 = r3.getValue(), i3 = r3.getValue()[e5];
            n4.splice(e5, 1), r3.setValue(n4), r3.onChange(true), r3.jsoneditor.trigger("deleteRow", i3);
          }), e4.appendChild(n3), n3;
        } }, { key: "_createCopyButton", value: function(t4, e4) {
          var r3 = this, n3 = this.getButton("", "copy", "button_copy_row_title_short"), i3 = this.schema;
          return n3.classList.add("copy", "json-editor-btntype-copy"), n3.setAttribute("data-i", t4), n3.addEventListener("click", function(t5) {
            t5.preventDefault(), t5.stopPropagation();
            var e5 = 1 * t5.currentTarget.getAttribute("data-i"), n4 = r3.getValue(), o3 = n4[e5];
            "string" === i3.items.type && "uuid" === i3.items.format ? o3 = f2() : "object" === i3.items.type && i3.items.properties && n4.forEach(function(t6, r4) {
              if (e5 === r4)
                for (var a3 = 0, s2 = Object.keys(t6); a3 < s2.length; a3++) {
                  var l2 = s2[a3];
                  i3.items.properties && i3.items.properties[l2] && "uuid" === i3.items.properties[l2].format && ((o3 = Object.assign({}, n4[e5]))[l2] = f2());
                }
            }), n4.splice(e5 + 1, 0, o3), r3.setValue(n4), r3.onChange(true), r3.jsoneditor.trigger("copyRow", r3.rows[e5 + 1]);
          }), e4.appendChild(n3), n3;
        } }, { key: "_createMoveUpButton", value: function(t4, e4) {
          var r3 = this, n3 = this.getButton("", "moveup", "button_move_up_title");
          return n3.classList.add("moveup", "json-editor-btntype-move"), n3.setAttribute("data-i", t4), n3.addEventListener("click", function(t5) {
            t5.preventDefault(), t5.stopPropagation();
            var e5 = 1 * t5.currentTarget.getAttribute("data-i"), n4 = r3.getValue();
            n4.splice(e5 - 1, 0, n4.splice(e5, 1)[0]), r3.setValue(n4), r3.onChange(true), r3.jsoneditor.trigger("moveRow", r3.rows[e5 - 1]);
          }), e4.appendChild(n3), n3;
        } }, { key: "_createMoveDownButton", value: function(t4, e4) {
          var r3 = this, n3 = this.getButton("", "movedown", "button_move_down_title");
          return n3.classList.add("movedown", "json-editor-btntype-move"), n3.setAttribute("data-i", t4), n3.addEventListener("click", function(t5) {
            t5.preventDefault(), t5.stopPropagation();
            var e5 = 1 * t5.currentTarget.getAttribute("data-i"), n4 = r3.getValue();
            n4.splice(e5 + 1, 0, n4.splice(e5, 1)[0]), r3.setValue(n4), r3.onChange(true), r3.jsoneditor.trigger("moveRow", r3.rows[e5 + 1]);
          }), e4.appendChild(n3), n3;
        } }, { key: "addControls", value: function() {
          var t4 = this;
          this.collapsed = false, this.toggle_button = this._createToggleButton(), this.title_controls && (this.title.insertBefore(this.toggle_button, this.title.childNodes[0]), this.toggle_button.addEventListener("click", function(e4) {
            e4.preventDefault(), e4.stopPropagation(), t4.setVisibility(t4.panel, t4.collapsed), t4.collapsed ? (t4.collapsed = false, t4.setButtonText(e4.currentTarget, "", "collapse", "button_collapse")) : (t4.collapsed = true, t4.setButtonText(e4.currentTarget, "", "expand", "button_expand"));
          }), this.options.collapsed && c2(this.toggle_button, "click"), this.schema.options && void 0 !== this.schema.options.disable_collapse ? this.schema.options.disable_collapse && (this.toggle_button.style.display = "none") : this.jsoneditor.options.disable_collapse && (this.toggle_button.style.display = "none")), this.add_row_button = this._createAddRowButton(), this.delete_last_row_button = this._createDeleteLastRowButton(), this.remove_all_rows_button = this._createRemoveAllRowsButton();
        } }, { key: "_createToggleButton", value: function() {
          var t4 = this.getButton("", "collapse", "button_collapse");
          return t4.classList.add("json-editor-btntype-toggle"), t4;
        } }, { key: "_createAddRowButton", value: function() {
          var t4 = this, e4 = this.getButton(this.getItemTitle(), "add", "button_add_row_title", [this.getItemTitle()]);
          return e4.classList.add("json-editor-btntype-add"), e4.addEventListener("click", function(e5) {
            e5.preventDefault(), e5.stopPropagation();
            var r3 = t4.addRow();
            t4.refreshValue(), t4.refreshRowButtons(), t4.onChange(true), t4.jsoneditor.trigger("addRow", r3);
          }), this.controls.appendChild(e4), e4;
        } }, { key: "_createDeleteLastRowButton", value: function() {
          var t4 = this, e4 = this.getButton("button_delete_last", "subtract", "button_delete_last_title", [this.getItemTitle()]);
          return e4.classList.add("json-editor-btntype-deletelast"), e4.addEventListener("click", function(e5) {
            if (e5.preventDefault(), e5.stopPropagation(), !t4.askConfirmation())
              return false;
            var r3 = t4.getValue(), n3 = r3.pop();
            t4.setValue(r3), t4.onChange(true), t4.jsoneditor.trigger("deleteRow", n3);
          }), this.controls.appendChild(e4), e4;
        } }, { key: "_createRemoveAllRowsButton", value: function() {
          var t4 = this, e4 = this.getButton("button_delete_all", "delete", "button_delete_all_title");
          return e4.classList.add("json-editor-btntype-deleteall"), e4.addEventListener("click", function(e5) {
            if (e5.preventDefault(), e5.stopPropagation(), !t4.askConfirmation())
              return false;
            var r3 = t4.getValue();
            t4.setValue([]), t4.onChange(true), t4.jsoneditor.trigger("deleteAllRows", r3);
          }), this.controls.appendChild(e4), e4;
        } }], r2 && kn(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), a2;
      }(F2);
      function En(t3) {
        return En = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, En(t3);
      }
      function Sn(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== En(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== En(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === En(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      function Pn() {
        return Pn = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t3, e3, r2) {
          var n2 = function(t4, e4) {
            for (; !Object.prototype.hasOwnProperty.call(t4, e4) && null !== (t4 = Ln(t4)); )
              ;
            return t4;
          }(t3, e3);
          if (n2) {
            var i2 = Object.getOwnPropertyDescriptor(n2, e3);
            return i2.get ? i2.get.call(arguments.length < 3 ? t3 : r2) : i2.value;
          }
        }, Pn.apply(this, arguments);
      }
      function Tn(t3, e3) {
        return Tn = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, Tn(t3, e3);
      }
      function Ln(t3) {
        return Ln = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, Ln(t3);
      }
      function Rn(t3) {
        return Rn = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, Rn(t3);
      }
      function An(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== Rn(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== Rn(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === Rn(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      function In() {
        return In = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t3, e3, r2) {
          var n2 = function(t4, e4) {
            for (; !Object.prototype.hasOwnProperty.call(t4, e4) && null !== (t4 = Nn(t4)); )
              ;
            return t4;
          }(t3, e3);
          if (n2) {
            var i2 = Object.getOwnPropertyDescriptor(n2, e3);
            return i2.get ? i2.get.call(arguments.length < 3 ? t3 : r2) : i2.value;
          }
        }, In.apply(this, arguments);
      }
      function Bn(t3, e3) {
        return Bn = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, Bn(t3, e3);
      }
      function Nn(t3) {
        return Nn = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, Nn(t3);
      }
      function Dn(t3) {
        return Dn = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, Dn(t3);
      }
      function Fn(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== Dn(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== Dn(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === Dn(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      function Vn() {
        return Vn = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t3, e3, r2) {
          var n2 = function(t4, e4) {
            for (; !Object.prototype.hasOwnProperty.call(t4, e4) && null !== (t4 = Hn(t4)); )
              ;
            return t4;
          }(t3, e3);
          if (n2) {
            var i2 = Object.getOwnPropertyDescriptor(n2, e3);
            return i2.get ? i2.get.call(arguments.length < 3 ? t3 : r2) : i2.value;
          }
        }, Vn.apply(this, arguments);
      }
      function zn(t3, e3) {
        return zn = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, zn(t3, e3);
      }
      function Hn(t3) {
        return Hn = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, Hn(t3);
      }
      r(6977);
      var Mn = { ace: R2, array: F2, arrayChoices: Y2, arraySelect2: rt2, arraySelectize: lt2, autocomplete: ft2, base64: wt2, button: Ct2, checkbox: Rt2, choices: Gt2, datetime: Yt2, describedBy: re2, enum: ce2, hidden: ye, info: we, integer: Le, ip: De, jodit: qe, multiple: cr, multiselect: G2, null: fr, number: Ce, object: Cr, radio: Rr, sceditor: Fr, select: Ft2, select2: Gr, selectize: Yr, signature: en2, simplemde: ln, starrating: fn, stepper: wn, string: C2, table: Cn, upload: function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && Tn(t4, e4);
        }(a2, t3);
        var e3, r2, n2, i2, o2 = (n2 = a2, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = Ln(n2);
          if (i2) {
            var r3 = Ln(this).constructor;
            t4 = Reflect.construct(e4, arguments, r3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === En(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function a2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), o2.apply(this, arguments);
        }
        return e3 = a2, (r2 = [{ key: "getNumColumns", value: function() {
          return 4;
        } }, { key: "build", value: function() {
          var t4 = this;
          if (this.options.compact || (this.header = this.label = this.theme.getFormInputLabel(this.getTitle(), this.isRequired())), this.schema.description && (this.description = this.theme.getFormInputDescription(this.translateProperty(this.schema.description))), this.options.infoText && (this.infoButton = this.theme.getInfoButton(this.translateProperty(this.options.infoText))), this.options.hidden && (this.container.style.display = "none"), this.options = this.expandCallbacks("upload", l({}, { title: "Browse", icon: "", auto_upload: false, hide_input: false, enable_drag_drop: false, drop_zone_text: "Drag & Drop file here", drop_zone_top: false, alt_drop_zone: "", mime_type: "", max_upload_size: 0, upload_handler: function(t5, e5, r4, n3) {
            window.alert('No upload_handler defined for "'.concat(t5.path, '". You must create your own handler to enable upload to server'));
          } }, this.defaults.options.upload || {}, this.options.upload || {})), this.options.mime_type = this.options.mime_type ? [].concat(this.options.mime_type) : [], this.input = this.theme.getFormInputField("hidden"), this.container.appendChild(this.input), !this.schema.readOnly && !this.schema.readonly) {
            if ("function" != typeof this.options.upload_handler)
              throw new Error("Upload handler required for upload editor");
            if (this.uploader = this.theme.getFormInputField("file"), this.uploader.style.display = "none", this.options.mime_type.length && this.uploader.setAttribute("accept", this.options.mime_type), true === this.options.enable_drag_drop && true === this.options.hide_input || (this.clickHandler = function(e5) {
              t4.uploader.dispatchEvent(new window.MouseEvent("click", { view: window, bubbles: true, cancelable: false }));
            }, this.browseButton = this.getButton(this.options.title, this.options.icon, this.options.title), this.browseButton.addEventListener("click", this.clickHandler), this.fileDisplay = this.theme.getFormInputField("input"), this.fileDisplay.setAttribute("readonly", true), this.fileDisplay.value = "No file selected.", this.fileDisplay.addEventListener("dblclick", this.clickHandler), this.fileUploadGroup = this.theme.getInputGroup(this.fileDisplay, [this.browseButton]), this.fileUploadGroup || (this.fileUploadGroup = document.createElement("div"), this.fileUploadGroup.appendChild(this.fileDisplay), this.fileUploadGroup.appendChild(this.browseButton))), true === this.options.enable_drag_drop) {
              if ("" !== this.options.alt_drop_zone) {
                if (this.altDropZone = document.querySelector(this.options.alt_drop_zone), !this.altDropZone)
                  throw new Error('Error: alt_drop_zone selector "'.concat(this.options.alt_drop_zone, '" not found!'));
                this.dropZone = this.altDropZone;
              } else
                this.dropZone = this.theme.getDropZone(this.options.drop_zone_text);
              this.dropZone && (this.dropZone.classList.add("upload-dropzone"), this.dropZone.addEventListener("dblclick", this.clickHandler));
            }
            this.uploadHandler = function(e5) {
              e5.preventDefault(), e5.stopPropagation();
              var r4 = e5.target.files || e5.dataTransfer.files;
              if (r4 && r4.length)
                if (0 !== t4.options.max_upload_size && r4[0].size > t4.options.max_upload_size)
                  t4.theme.addInputError(t4.uploader, "".concat(t4.translate("upload_max_size"), " ").concat(t4.options.max_upload_size));
                else if (0 === t4.options.mime_type.length || t4.isValidMimeType(r4[0].type, t4.options.mime_type)) {
                  t4.fileDisplay && (t4.fileDisplay.value = r4[0].name);
                  var n3 = new window.FileReader();
                  n3.onload = function(e6) {
                    t4.preview_value = e6.target.result, t4.refreshPreview(r4), t4.onChange(true), n3 = null;
                  }, n3.readAsDataURL(r4[0]);
                } else
                  t4.theme.addInputError(t4.uploader, "".concat(t4.translate("upload_wrong_file_format"), " ").concat(t4.options.mime_type.toString()));
            }, this.uploader.addEventListener("change", this.uploadHandler), this.dragHandler = function(e5) {
              var r4 = e5.dataTransfer.items || e5.dataTransfer.files, n3 = r4 && r4.length && (0 === t4.options.mime_type.length || t4.isValidMimeType(r4[0].type, t4.options.mime_type)), i3 = e5.currentTarget.classList && e5.currentTarget.classList.contains("upload-dropzone") && n3;
              switch ((e5.currentTarget === window ? "w_" : "e_") + e5.type) {
                case "w_drop":
                case "w_dragover":
                  i3 || (e5.dataTransfer.dropEffect = "none");
                  break;
                case "e_dragenter":
                  i3 ? (t4.dropZone.classList.add("valid-dropzone"), e5.dataTransfer.dropEffect = "copy") : t4.dropZone.classList.add("invalid-dropzone");
                  break;
                case "e_dragover":
                  i3 && (e5.dataTransfer.dropEffect = "copy");
                  break;
                case "e_dragleave":
                  t4.dropZone.classList.remove("valid-dropzone", "invalid-dropzone");
                  break;
                case "e_drop":
                  t4.dropZone.classList.remove("valid-dropzone", "invalid-dropzone"), i3 && t4.uploadHandler(e5);
              }
              i3 || e5.preventDefault();
            }, true === this.options.enable_drag_drop && (["dragover", "drop"].forEach(function(e5) {
              window.addEventListener(e5, t4.dragHandler, true);
            }), ["dragenter", "dragover", "dragleave", "drop"].forEach(function(e5) {
              t4.dropZone.addEventListener(e5, t4.dragHandler, true);
            }));
          }
          this.preview = document.createElement("div"), this.control = this.input.controlgroup = this.theme.getFormControl(this.label, this.uploader || this.input, this.description, this.infoButton), this.uploader && (this.uploader.controlgroup = this.control);
          var e4 = this.uploader || this.input, r3 = document.createElement("div");
          this.dropZone && !this.altDropZone && true === this.options.drop_zone_top && r3.appendChild(this.dropZone), this.fileUploadGroup && r3.appendChild(this.fileUploadGroup), this.dropZone && !this.altDropZone && true !== this.options.drop_zone_top && r3.appendChild(this.dropZone), r3.appendChild(this.preview), e4.parentNode.insertBefore(r3, e4.nextSibling), this.container.appendChild(this.control), window.requestAnimationFrame(function() {
            t4.afterInputReady();
          });
        } }, { key: "afterInputReady", value: function() {
          var t4 = this;
          if (this.value) {
            var e4 = document.createElement("img");
            e4.style.maxWidth = "100%", e4.style.maxHeight = "100px", e4.onload = function(r3) {
              t4.preview.appendChild(e4);
            }, e4.onerror = function(t5) {
              console.error("upload error", t5, t5.currentTarget);
            }, e4.src = this.container.querySelector("a").href;
          }
          this.theme.afterInputReady(this.input);
        } }, { key: "refreshPreview", value: function(t4) {
          var e4 = this;
          if (this.last_preview !== this.preview_value && (this.last_preview = this.preview_value, this.preview.innerHTML = "", this.preview_value)) {
            var r3 = t4[0], n3 = this.preview_value.match(/^data:([^;,]+)[;,]/);
            if (r3.mimeType = n3 ? n3[1] : "unknown", r3.size > 0) {
              var i3 = Math.floor(Math.log(r3.size) / Math.log(1024));
              r3.formattedSize = "".concat(parseFloat((r3.size / Math.pow(1024, i3)).toFixed(2)), " ").concat(["Bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"][i3]);
            } else
              r3.formattedSize = "0 Bytes";
            var o3 = this.getButton("button_upload", "upload", "button_upload");
            o3.addEventListener("click", function(t5) {
              t5.preventDefault(), o3.setAttribute("disabled", "disabled"), e4.theme.removeInputError(e4.uploader), e4.theme.getProgressBar && (e4.progressBar = e4.theme.getProgressBar(), e4.preview.appendChild(e4.progressBar)), e4.options.upload_handler(e4.path, r3, { success: function(t6) {
                e4.setValue(t6), e4.parent ? e4.parent.onChildEditorChange(e4) : e4.jsoneditor.onChange(), e4.progressBar && e4.preview.removeChild(e4.progressBar), o3.removeAttribute("disabled");
              }, failure: function(t6) {
                e4.theme.addInputError(e4.uploader, t6), e4.progressBar && e4.preview.removeChild(e4.progressBar), o3.removeAttribute("disabled");
              }, updateProgress: function(t6) {
                e4.progressBar && (t6 ? e4.theme.updateProgressBar(e4.progressBar, t6) : e4.theme.updateProgressBarUnknown(e4.progressBar));
              } });
            }), this.preview.appendChild(this.theme.getUploadPreview(r3, o3, this.preview_value)), this.options.auto_upload && (o3.dispatchEvent(new window.MouseEvent("click")), o3.parentNode.removeChild(o3));
          }
        } }, { key: "enable", value: function() {
          this.always_disabled || (this.uploader && (this.uploader.disabled = false), Pn(Ln(a2.prototype), "enable", this).call(this));
        } }, { key: "disable", value: function(t4) {
          t4 && (this.always_disabled = true), this.uploader && (this.uploader.disabled = true), Pn(Ln(a2.prototype), "disable", this).call(this);
        } }, { key: "setValue", value: function(t4) {
          this.value !== t4 && (this.value = t4, this.input.value = this.value, this.onChange());
        } }, { key: "destroy", value: function() {
          var t4 = this;
          true === this.options.enable_drag_drop && (["dragover", "drop"].forEach(function(e4) {
            window.removeEventListener(e4, t4.dragHandler, true);
          }), ["dragenter", "dragover", "dragleave", "drop"].forEach(function(e4) {
            t4.dropZone.removeEventListener(e4, t4.dragHandler, true);
          }), this.dropZone.removeEventListener("dblclick", this.clickHandler), this.dropZone && this.dropZone.parentNode && this.dropZone.parentNode.removeChild(this.dropZone)), this.uploader && this.uploader.parentNode && (this.uploader.removeEventListener("change", this.uploadHandler), this.uploader.parentNode.removeChild(this.uploader)), this.browseButton && this.browseButton.parentNode && (this.browseButton.removeEventListener("click", this.clickHandler), this.browseButton.parentNode.removeChild(this.browseButton)), this.fileDisplay && this.fileDisplay.parentNode && (this.fileDisplay.removeEventListener("dblclick", this.clickHandler), this.fileDisplay.parentNode.removeChild(this.fileDisplay)), this.fileUploadGroup && this.fileUploadGroup.parentNode && this.fileUploadGroup.parentNode.removeChild(this.fileUploadGroup), this.preview && this.preview.parentNode && this.preview.parentNode.removeChild(this.preview), this.header && this.header.parentNode && this.header.parentNode.removeChild(this.header), this.input && this.input.parentNode && this.input.parentNode.removeChild(this.input), Pn(Ln(a2.prototype), "destroy", this).call(this);
        } }, { key: "isValidMimeType", value: function(t4, e4) {
          return e4.reduce(function(e5, r3) {
            return e5 || new RegExp(r3.replace(/\*/g, ".*"), "gi").test(t4);
          }, false);
        } }]) && Sn(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), a2;
      }(w2), uuid: function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && Bn(t4, e4);
        }(a2, t3);
        var e3, r2, n2, i2, o2 = (n2 = a2, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = Nn(n2);
          if (i2) {
            var r3 = Nn(this).constructor;
            t4 = Reflect.construct(e4, arguments, r3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === Rn(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function a2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), o2.apply(this, arguments);
        }
        return e3 = a2, (r2 = [{ key: "preBuild", value: function() {
          In(Nn(a2.prototype), "preBuild", this).call(this), this.schema.default = this.uuid = this.getUuid(), this.schema.options || (this.schema.options = {}), this.schema.options.cleave || (this.schema.options.cleave = { delimiters: ["-"], blocks: [8, 4, 4, 4, 12] });
        } }, { key: "build", value: function() {
          In(Nn(a2.prototype), "build", this).call(this), this.disable(true), this.input.setAttribute("readonly", "true");
        } }, { key: "sanitize", value: function(t4) {
          return this.testUuid(t4) || (t4 = this.uuid), t4;
        } }, { key: "setValue", value: function(t4, e4, r3) {
          this.testUuid(t4) || (t4 = this.uuid), this.uuid = t4, In(Nn(a2.prototype), "setValue", this).call(this, t4, e4, r3);
        } }, { key: "getUuid", value: function() {
          return f2();
        } }, { key: "testUuid", value: function(t4) {
          return /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t4);
        } }]) && An(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), a2;
      }(C2), colorpicker: function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && zn(t4, e4);
        }(a2, t3);
        var e3, r2, n2, i2, o2 = (n2 = a2, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = Hn(n2);
          if (i2) {
            var r3 = Hn(this).constructor;
            t4 = Reflect.construct(e4, arguments, r3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === Dn(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function a2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), o2.apply(this, arguments);
        }
        return e3 = a2, (r2 = [{ key: "postBuild", value: function() {
          window.Picker && (this.input.type = "text"), this.input.style.padding = "3px";
        } }, { key: "setValue", value: function(t4, e4, r3) {
          var n3 = Vn(Hn(a2.prototype), "setValue", this).call(this, t4, e4, r3);
          return this.picker_instance && this.picker_instance.domElement && n3 && n3.changed && this.picker_instance.setColor(n3.value, true), n3;
        } }, { key: "getNumColumns", value: function() {
          return 2;
        } }, { key: "afterInputReady", value: function() {
          Vn(Hn(a2.prototype), "afterInputReady", this).call(this), this.createPicker(true);
        } }, { key: "disable", value: function() {
          if (Vn(Hn(a2.prototype), "disable", this).call(this), this.picker_instance && this.picker_instance.domElement) {
            this.picker_instance.domElement.style.pointerEvents = "none";
            for (var t4 = this.picker_instance.domElement.querySelectorAll("button"), e4 = 0; e4 < t4.length; e4++)
              t4[e4].disabled = true;
          }
        } }, { key: "enable", value: function() {
          if (Vn(Hn(a2.prototype), "enable", this).call(this), this.picker_instance && this.picker_instance.domElement) {
            this.picker_instance.domElement.style.pointerEvents = "auto";
            for (var t4 = this.picker_instance.domElement.querySelectorAll("button"), e4 = 0; e4 < t4.length; e4++)
              t4[e4].disabled = false;
          }
        } }, { key: "destroy", value: function() {
          this.createPicker(false), Vn(Hn(a2.prototype), "destroy", this).call(this);
        } }, { key: "createPicker", value: function(t4) {
          var e4 = this;
          if (t4) {
            if (window.Picker && !this.picker_instance) {
              var r3 = this.expandCallbacks("colorpicker", l({}, { editor: false, alpha: false, color: this.value, popup: "bottom" }, this.defaults.options.colorpicker || {}, this.options.colorpicker || {}, { parent: this.container })), n3 = function(t5) {
                var r4 = e4.picker_instance.settings.editorFormat, n4 = e4.picker_instance.settings.alpha;
                e4.setValue("hex" === r4 ? n4 ? t5.hex : t5.hex.slice(0, 7) : t5["".concat(r4 + (n4 ? "a" : ""), "String")]);
              };
              r3.popup || "function" == typeof r3.onChange ? r3.popup && "function" != typeof r3.onDone && (r3.onDone = n3) : r3.onChange = n3, this.picker_instance = new window.Picker(r3), r3.popup || (this.input.style.display = "none", this.theme.afterInputReady(this.picker_instance.domElement));
            }
          } else
            this.picker_instance && (this.picker_instance.destroy(), this.picker_instance = null, this.input.style.display = "");
        } }]) && Fn(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), a2;
      }(C2) };
      function qn(t3, e3) {
        (null == e3 || e3 > t3.length) && (e3 = t3.length);
        for (var r2 = 0, n2 = new Array(e3); r2 < e3; r2++)
          n2[r2] = t3[r2];
        return n2;
      }
      var Gn = {}, Un = "en", $n = Un;
      Gn.en = { error_notset: "Property must be set", error_notempty: "Value required", error_enum: "Value must be one of the enumerated values", error_const: "Value must be the constant value", error_anyOf: "Value must validate against at least one of the provided schemas", error_oneOf: "Value must validate against exactly one of the provided schemas. It currently validates against {{0}} of the schemas.", error_not: "Value must not validate against the provided schema", error_type_union: "Value must be one of the provided types", error_type: "Value must be of type {{0}}", error_disallow_union: "Value must not be one of the provided disallowed types", error_disallow: "Value must not be of type {{0}}", error_multipleOf: "Value must be a multiple of {{0}}", error_maximum_excl: "Value must be less than {{0}}", error_maximum_incl: "Value must be at most {{0}}", error_minimum_excl: "Value must be greater than {{0}}", error_minimum_incl: "Value must be at least {{0}}", error_maxLength: "Value must be at most {{0}} characters long", error_contains: "No items match contains", error_minContains: "Contains match count {{0}} is less than minimum contains count of {{1}}", error_maxContains: "Contains match count {{0}} exceeds maximum contains count of {{1}}", error_minLength: "Value must be at least {{0}} characters long", error_pattern: "Value must match the pattern {{0}}", error_additionalItems: "No additional items allowed in this array", error_maxItems: "Value must have at most {{0}} items", error_minItems: "Value must have at least {{0}} items", error_uniqueItems: "Array must have unique items", error_maxProperties: "Object must have at most {{0}} properties", error_minProperties: "Object must have at least {{0}} properties", error_required: "Object is missing the required property '{{0}}'", error_additional_properties: "No additional properties allowed, but property {{0}} is set", error_property_names_exceeds_maxlength: "Property name {{0}} exceeds maxLength", error_property_names_enum_mismatch: "Property name {{0}} does not match any enum values", error_property_names_const_mismatch: "Property name {{0}} does not match the const value", error_property_names_pattern_mismatch: "Property name {{0}} does not match pattern", error_property_names_false: "Property name {{0}} fails when propertyName is false", error_property_names_maxlength: "Property name {{0}} cannot match invalid maxLength", error_property_names_enum: "Property name {{0}} cannot match invalid enum", error_property_names_pattern: "Property name {{0}} cannot match invalid pattern", error_property_names_unsupported: "Unsupported propertyName {{0}}", error_dependency: "Must have property {{0}}", error_date: "Date must be in the format {{0}}", error_time: "Time must be in the format {{0}}", error_datetime_local: "Datetime must be in the format {{0}}", error_invalid_epoch: "Date must be greater than 1 January 1970", error_ipv4: "Value must be a valid IPv4 address in the form of 4 numbers between 0 and 255, separated by dots", error_ipv6: "Value must be a valid IPv6 address", error_hostname: "The hostname has the wrong format", upload_max_size: "Filesize too large. Max size is ", upload_wrong_file_format: "Wrong file format. Allowed format(s): ", button_save: "Save", button_copy: "Copy", button_cancel: "Cancel", button_add: "Add", button_delete_all: "All", button_delete_all_title: "Delete All", button_delete_last: "Last {{0}}", button_delete_last_title: "Delete Last {{0}}", button_add_row_title: "Add {{0}}", button_move_down_title: "Move down", button_move_up_title: "Move up", button_properties: "Properties", button_object_properties: "Object Properties", button_copy_row_title: "Copy {{0}}", button_delete_row_title: "Delete {{0}}", button_delete_row_title_short: "Delete", button_copy_row_title_short: "Copy", button_collapse: "Collapse", button_expand: "Expand", button_edit_json: "Edit JSON", button_upload: "Upload", flatpickr_toggle_button: "Toggle", flatpickr_clear_button: "Clear", choices_placeholder_text: "Start typing to add value", default_array_item_title: "item", button_delete_node_warning: "Are you sure you want to remove this item?" }, Object.entries(Mn).forEach(function(t3) {
        var e3 = function(t4, e4) {
          return function(t5) {
            if (Array.isArray(t5))
              return t5;
          }(t4) || function(t5, e5) {
            var r3 = null == t5 ? null : "undefined" != typeof Symbol && t5[Symbol.iterator] || t5["@@iterator"];
            if (null != r3) {
              var n3, i2, o2, a2, s2 = [], l2 = true, c3 = false;
              try {
                if (o2 = (r3 = r3.call(t5)).next, 0 === e5) {
                  if (Object(r3) !== r3)
                    return;
                  l2 = false;
                } else
                  for (; !(l2 = (n3 = o2.call(r3)).done) && (s2.push(n3.value), s2.length !== e5); l2 = true)
                    ;
              } catch (t6) {
                c3 = true, i2 = t6;
              } finally {
                try {
                  if (!l2 && null != r3.return && (a2 = r3.return(), Object(a2) !== a2))
                    return;
                } finally {
                  if (c3)
                    throw i2;
                }
              }
              return s2;
            }
          }(t4, e4) || function(t5, e5) {
            if (t5) {
              if ("string" == typeof t5)
                return qn(t5, e5);
              var r3 = Object.prototype.toString.call(t5).slice(8, -1);
              return "Object" === r3 && t5.constructor && (r3 = t5.constructor.name), "Map" === r3 || "Set" === r3 ? Array.from(t5) : "Arguments" === r3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3) ? qn(t5, e5) : void 0;
            }
          }(t4, e4) || function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }();
        }(t3, 2), r2 = e3[0], n2 = e3[1];
        Mn[r2].options = n2.options || {};
      });
      var Jn = { options: { upload: function(t3, e3, r2) {
        console.log("Upload handler required for upload editor");
      }, use_name_attributes: true, prompt_before_delete: true, use_default_values: true, max_depth: 0 }, theme: "html", template: "default", themes: {}, callbacks: {}, templates: {}, iconlibs: {}, editors: Mn, languages: Gn, resolvers: e2, custom_validators: [], default_language: Un, language: $n, translate: function(t3, e3, r2) {
        var n2 = {};
        r2 && r2.options && r2.options.error_messages && r2.options.error_messages[Jn.language] && (n2 = r2.options.error_messages[Jn.language]);
        var i2 = Jn.languages[Jn.language];
        if (!i2)
          throw new Error("Unknown language ".concat(Jn.language));
        var o2 = n2[t3] || i2[t3] || Jn.languages[Un][t3] || t3;
        if (e3)
          for (var a2 = 0; a2 < e3.length; a2++)
            o2 = o2.replace(new RegExp("\\{\\{".concat(a2, "}}"), "g"), e3[a2]);
        return o2;
      }, translateProperty: function(t3, e3) {
        return t3;
      } };
      function Wn() {
        Wn = function() {
          return t3;
        };
        var t3 = {}, e3 = Object.prototype, r2 = e3.hasOwnProperty, n2 = Object.defineProperty || function(t4, e4, r3) {
          t4[e4] = r3.value;
        }, i2 = "function" == typeof Symbol ? Symbol : {}, o2 = i2.iterator || "@@iterator", a2 = i2.asyncIterator || "@@asyncIterator", s2 = i2.toStringTag || "@@toStringTag";
        function l2(t4, e4, r3) {
          return Object.defineProperty(t4, e4, { value: r3, enumerable: true, configurable: true, writable: true }), t4[e4];
        }
        try {
          l2({}, "");
        } catch (t4) {
          l2 = function(t5, e4, r3) {
            return t5[e4] = r3;
          };
        }
        function c3(t4, e4, r3, i3) {
          var o3 = e4 && e4.prototype instanceof p3 ? e4 : p3, a3 = Object.create(o3.prototype), s3 = new x3(i3 || []);
          return n2(a3, "_invoke", { value: _3(t4, r3, s3) }), a3;
        }
        function u2(t4, e4, r3) {
          try {
            return { type: "normal", arg: t4.call(e4, r3) };
          } catch (t5) {
            return { type: "throw", arg: t5 };
          }
        }
        t3.wrap = c3;
        var h3 = {};
        function p3() {
        }
        function d2() {
        }
        function f3() {
        }
        var y3 = {};
        l2(y3, o2, function() {
          return this;
        });
        var m2 = Object.getPrototypeOf, v3 = m2 && m2(m2(C3([])));
        v3 && v3 !== e3 && r2.call(v3, o2) && (y3 = v3);
        var b3 = f3.prototype = p3.prototype = Object.create(y3);
        function g3(t4) {
          ["next", "throw", "return"].forEach(function(e4) {
            l2(t4, e4, function(t5) {
              return this._invoke(e4, t5);
            });
          });
        }
        function w3(t4, e4) {
          function i3(n3, o4, a3, s3) {
            var l3 = u2(t4[n3], t4, o4);
            if ("throw" !== l3.type) {
              var c4 = l3.arg, h4 = c4.value;
              return h4 && "object" == Xn(h4) && r2.call(h4, "__await") ? e4.resolve(h4.__await).then(function(t5) {
                i3("next", t5, a3, s3);
              }, function(t5) {
                i3("throw", t5, a3, s3);
              }) : e4.resolve(h4).then(function(t5) {
                c4.value = t5, a3(c4);
              }, function(t5) {
                return i3("throw", t5, a3, s3);
              });
            }
            s3(l3.arg);
          }
          var o3;
          n2(this, "_invoke", { value: function(t5, r3) {
            function n3() {
              return new e4(function(e5, n4) {
                i3(t5, r3, e5, n4);
              });
            }
            return o3 = o3 ? o3.then(n3, n3) : n3();
          } });
        }
        function _3(t4, e4, r3) {
          var n3 = "suspendedStart";
          return function(i3, o3) {
            if ("executing" === n3)
              throw new Error("Generator is already running");
            if ("completed" === n3) {
              if ("throw" === i3)
                throw o3;
              return { value: void 0, done: true };
            }
            for (r3.method = i3, r3.arg = o3; ; ) {
              var a3 = r3.delegate;
              if (a3) {
                var s3 = k3(a3, r3);
                if (s3) {
                  if (s3 === h3)
                    continue;
                  return s3;
                }
              }
              if ("next" === r3.method)
                r3.sent = r3._sent = r3.arg;
              else if ("throw" === r3.method) {
                if ("suspendedStart" === n3)
                  throw n3 = "completed", r3.arg;
                r3.dispatchException(r3.arg);
              } else
                "return" === r3.method && r3.abrupt("return", r3.arg);
              n3 = "executing";
              var l3 = u2(t4, e4, r3);
              if ("normal" === l3.type) {
                if (n3 = r3.done ? "completed" : "suspendedYield", l3.arg === h3)
                  continue;
                return { value: l3.arg, done: r3.done };
              }
              "throw" === l3.type && (n3 = "completed", r3.method = "throw", r3.arg = l3.arg);
            }
          };
        }
        function k3(t4, e4) {
          var r3 = e4.method, n3 = t4.iterator[r3];
          if (void 0 === n3)
            return e4.delegate = null, "throw" === r3 && t4.iterator.return && (e4.method = "return", e4.arg = void 0, k3(t4, e4), "throw" === e4.method) || "return" !== r3 && (e4.method = "throw", e4.arg = new TypeError("The iterator does not provide a '" + r3 + "' method")), h3;
          var i3 = u2(n3, t4.iterator, e4.arg);
          if ("throw" === i3.type)
            return e4.method = "throw", e4.arg = i3.arg, e4.delegate = null, h3;
          var o3 = i3.arg;
          return o3 ? o3.done ? (e4[t4.resultName] = o3.value, e4.next = t4.nextLoc, "return" !== e4.method && (e4.method = "next", e4.arg = void 0), e4.delegate = null, h3) : o3 : (e4.method = "throw", e4.arg = new TypeError("iterator result is not an object"), e4.delegate = null, h3);
        }
        function j3(t4) {
          var e4 = { tryLoc: t4[0] };
          1 in t4 && (e4.catchLoc = t4[1]), 2 in t4 && (e4.finallyLoc = t4[2], e4.afterLoc = t4[3]), this.tryEntries.push(e4);
        }
        function O3(t4) {
          var e4 = t4.completion || {};
          e4.type = "normal", delete e4.arg, t4.completion = e4;
        }
        function x3(t4) {
          this.tryEntries = [{ tryLoc: "root" }], t4.forEach(j3, this), this.reset(true);
        }
        function C3(t4) {
          if (t4) {
            var e4 = t4[o2];
            if (e4)
              return e4.call(t4);
            if ("function" == typeof t4.next)
              return t4;
            if (!isNaN(t4.length)) {
              var n3 = -1, i3 = function e5() {
                for (; ++n3 < t4.length; )
                  if (r2.call(t4, n3))
                    return e5.value = t4[n3], e5.done = false, e5;
                return e5.value = void 0, e5.done = true, e5;
              };
              return i3.next = i3;
            }
          }
          return { next: E3 };
        }
        function E3() {
          return { value: void 0, done: true };
        }
        return d2.prototype = f3, n2(b3, "constructor", { value: f3, configurable: true }), n2(f3, "constructor", { value: d2, configurable: true }), d2.displayName = l2(f3, s2, "GeneratorFunction"), t3.isGeneratorFunction = function(t4) {
          var e4 = "function" == typeof t4 && t4.constructor;
          return !!e4 && (e4 === d2 || "GeneratorFunction" === (e4.displayName || e4.name));
        }, t3.mark = function(t4) {
          return Object.setPrototypeOf ? Object.setPrototypeOf(t4, f3) : (t4.__proto__ = f3, l2(t4, s2, "GeneratorFunction")), t4.prototype = Object.create(b3), t4;
        }, t3.awrap = function(t4) {
          return { __await: t4 };
        }, g3(w3.prototype), l2(w3.prototype, a2, function() {
          return this;
        }), t3.AsyncIterator = w3, t3.async = function(e4, r3, n3, i3, o3) {
          void 0 === o3 && (o3 = Promise);
          var a3 = new w3(c3(e4, r3, n3, i3), o3);
          return t3.isGeneratorFunction(r3) ? a3 : a3.next().then(function(t4) {
            return t4.done ? t4.value : a3.next();
          });
        }, g3(b3), l2(b3, s2, "Generator"), l2(b3, o2, function() {
          return this;
        }), l2(b3, "toString", function() {
          return "[object Generator]";
        }), t3.keys = function(t4) {
          var e4 = Object(t4), r3 = [];
          for (var n3 in e4)
            r3.push(n3);
          return r3.reverse(), function t5() {
            for (; r3.length; ) {
              var n4 = r3.pop();
              if (n4 in e4)
                return t5.value = n4, t5.done = false, t5;
            }
            return t5.done = true, t5;
          };
        }, t3.values = C3, x3.prototype = { constructor: x3, reset: function(t4) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(O3), !t4)
            for (var e4 in this)
              "t" === e4.charAt(0) && r2.call(this, e4) && !isNaN(+e4.slice(1)) && (this[e4] = void 0);
        }, stop: function() {
          this.done = true;
          var t4 = this.tryEntries[0].completion;
          if ("throw" === t4.type)
            throw t4.arg;
          return this.rval;
        }, dispatchException: function(t4) {
          if (this.done)
            throw t4;
          var e4 = this;
          function n3(r3, n4) {
            return a3.type = "throw", a3.arg = t4, e4.next = r3, n4 && (e4.method = "next", e4.arg = void 0), !!n4;
          }
          for (var i3 = this.tryEntries.length - 1; i3 >= 0; --i3) {
            var o3 = this.tryEntries[i3], a3 = o3.completion;
            if ("root" === o3.tryLoc)
              return n3("end");
            if (o3.tryLoc <= this.prev) {
              var s3 = r2.call(o3, "catchLoc"), l3 = r2.call(o3, "finallyLoc");
              if (s3 && l3) {
                if (this.prev < o3.catchLoc)
                  return n3(o3.catchLoc, true);
                if (this.prev < o3.finallyLoc)
                  return n3(o3.finallyLoc);
              } else if (s3) {
                if (this.prev < o3.catchLoc)
                  return n3(o3.catchLoc, true);
              } else {
                if (!l3)
                  throw new Error("try statement without catch or finally");
                if (this.prev < o3.finallyLoc)
                  return n3(o3.finallyLoc);
              }
            }
          }
        }, abrupt: function(t4, e4) {
          for (var n3 = this.tryEntries.length - 1; n3 >= 0; --n3) {
            var i3 = this.tryEntries[n3];
            if (i3.tryLoc <= this.prev && r2.call(i3, "finallyLoc") && this.prev < i3.finallyLoc) {
              var o3 = i3;
              break;
            }
          }
          o3 && ("break" === t4 || "continue" === t4) && o3.tryLoc <= e4 && e4 <= o3.finallyLoc && (o3 = null);
          var a3 = o3 ? o3.completion : {};
          return a3.type = t4, a3.arg = e4, o3 ? (this.method = "next", this.next = o3.finallyLoc, h3) : this.complete(a3);
        }, complete: function(t4, e4) {
          if ("throw" === t4.type)
            throw t4.arg;
          return "break" === t4.type || "continue" === t4.type ? this.next = t4.arg : "return" === t4.type ? (this.rval = this.arg = t4.arg, this.method = "return", this.next = "end") : "normal" === t4.type && e4 && (this.next = e4), h3;
        }, finish: function(t4) {
          for (var e4 = this.tryEntries.length - 1; e4 >= 0; --e4) {
            var r3 = this.tryEntries[e4];
            if (r3.finallyLoc === t4)
              return this.complete(r3.completion, r3.afterLoc), O3(r3), h3;
          }
        }, catch: function(t4) {
          for (var e4 = this.tryEntries.length - 1; e4 >= 0; --e4) {
            var r3 = this.tryEntries[e4];
            if (r3.tryLoc === t4) {
              var n3 = r3.completion;
              if ("throw" === n3.type) {
                var i3 = n3.arg;
                O3(r3);
              }
              return i3;
            }
          }
          throw new Error("illegal catch attempt");
        }, delegateYield: function(t4, e4, r3) {
          return this.delegate = { iterator: C3(t4), resultName: e4, nextLoc: r3 }, "next" === this.method && (this.arg = void 0), h3;
        } }, t3;
      }
      function Zn(t3, e3, r2, n2, i2, o2, a2) {
        try {
          var s2 = t3[o2](a2), l2 = s2.value;
        } catch (t4) {
          return void r2(t4);
        }
        s2.done ? e3(l2) : Promise.resolve(l2).then(n2, i2);
      }
      function Yn(t3) {
        return function() {
          var e3 = this, r2 = arguments;
          return new Promise(function(n2, i2) {
            var o2 = t3.apply(e3, r2);
            function a2(t4) {
              Zn(o2, n2, i2, a2, s2, "next", t4);
            }
            function s2(t4) {
              Zn(o2, n2, i2, a2, s2, "throw", t4);
            }
            a2(void 0);
          });
        };
      }
      function Qn(t3, e3) {
        return function(t4) {
          if (Array.isArray(t4))
            return t4;
        }(t3) || function(t4, e4) {
          var r2 = null == t4 ? null : "undefined" != typeof Symbol && t4[Symbol.iterator] || t4["@@iterator"];
          if (null != r2) {
            var n2, i2, o2, a2, s2 = [], l2 = true, c3 = false;
            try {
              if (o2 = (r2 = r2.call(t4)).next, 0 === e4) {
                if (Object(r2) !== r2)
                  return;
                l2 = false;
              } else
                for (; !(l2 = (n2 = o2.call(r2)).done) && (s2.push(n2.value), s2.length !== e4); l2 = true)
                  ;
            } catch (t5) {
              c3 = true, i2 = t5;
            } finally {
              try {
                if (!l2 && null != r2.return && (a2 = r2.return(), Object(a2) !== a2))
                  return;
              } finally {
                if (c3)
                  throw i2;
              }
            }
            return s2;
          }
        }(t3, e3) || function(t4, e4) {
          if (t4) {
            if ("string" == typeof t4)
              return Kn(t4, e4);
            var r2 = Object.prototype.toString.call(t4).slice(8, -1);
            return "Object" === r2 && t4.constructor && (r2 = t4.constructor.name), "Map" === r2 || "Set" === r2 ? Array.from(t4) : "Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2) ? Kn(t4, e4) : void 0;
          }
        }(t3, e3) || function() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function Kn(t3, e3) {
        (null == e3 || e3 > t3.length) && (e3 = t3.length);
        for (var r2 = 0, n2 = new Array(e3); r2 < e3; r2++)
          n2[r2] = t3[r2];
        return n2;
      }
      function Xn(t3) {
        return Xn = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, Xn(t3);
      }
      function ti(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== Xn(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== Xn(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === Xn(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      r(8733);
      var ei = function() {
        function t3(e4) {
          !function(t4, e5) {
            if (!(t4 instanceof e5))
              throw new TypeError("Cannot call a class as a function");
          }(this, t3), this.options = e4 || {}, this.schema = {}, this.refs = this.options.refs || {}, this.refs_with_info = {}, this.refs_prefix = "#/counter/", this.refs_counter = 1, this._subSchema1 = { type: function(t4) {
            "object" === Xn(t4.type) && (t4.type = this._expandSubSchema(t4.type));
          }, disallow: function(t4) {
            "object" === Xn(t4.disallow) && (t4.disallow = this._expandSubSchema(t4.disallow));
          }, anyOf: function(t4) {
            var e5 = this;
            Object.entries(t4.anyOf).forEach(function(r3) {
              var n3 = Qn(r3, 2), i3 = n3[0], o2 = n3[1];
              t4.anyOf[i3] = e5.expandSchema(o2);
            });
          }, dependencies: function(t4) {
            var e5 = this;
            Object.entries(t4.dependencies).forEach(function(r3) {
              var n3 = Qn(r3, 2), i3 = n3[0], o2 = n3[1];
              "object" !== Xn(o2) || Array.isArray(o2) || (t4.dependencies[i3] = e5.expandSchema(o2));
            });
          }, not: function(t4) {
            t4.not = this.expandSchema(t4.not);
          } }, this._subSchema2 = { allOf: function(t4, e5) {
            var r3 = this, n3 = l({}, e5);
            return Object.entries(t4.allOf).forEach(function(e6) {
              var i3 = Qn(e6, 2), o2 = i3[0], a2 = i3[1];
              t4.allOf[o2] = r3.expandRefs(a2, true), n3 = r3.extendSchemas(n3, r3.expandSchema(a2));
            }), delete n3.allOf, n3;
          }, extends: function(t4, e5) {
            var r3, n3 = this;
            return delete (r3 = Array.isArray(t4.extends) ? t4.extends.reduce(function(t5, e6, r4) {
              return n3.extendSchemas(t5, n3.expandSchema(e6));
            }, e5) : this.extendSchemas(e5, this.expandSchema(t4.extends))).extends, r3;
          }, oneOf: function(t4, e5) {
            var r3 = this, n3 = l({}, e5);
            return delete n3.oneOf, t4.oneOf.reduce(function(t5, e6, i3) {
              return t5.oneOf[i3] = r3.extendSchemas(r3.expandSchema(e6), n3), t5;
            }, e5), e5;
          } };
        }
        var e3, r2, n2, i2;
        return e3 = t3, r2 = [{ key: "load", value: (i2 = Yn(Wn().mark(function t4(e4, r3, n3) {
          return Wn().wrap(function(t5) {
            for (; ; )
              switch (t5.prev = t5.next) {
                case 0:
                  return this.schema = e4, t5.next = 3, this._asyncloadExternalRefs(e4, r3, this._getFileBase(n3), true);
                case 3:
                  return t5.abrupt("return", this.expandRefs(e4));
                case 4:
                case "end":
                  return t5.stop();
              }
          }, t4, this);
        })), function(t4, e4, r3) {
          return i2.apply(this, arguments);
        }) }, { key: "expandRefs", value: function(t4, e4) {
          var r3 = this, n3 = l({}, t4);
          if (!n3.$ref)
            return n3;
          var i3 = n3.$ref.split("#");
          if (2 === i3.length && !this.refs_with_info[n3.$ref]) {
            var o2 = this.expandRecursivePointer(this.schema, i3[1]), a2 = this.extendSchemas(n3, this.expandSchema(o2));
            return delete a2.$ref, a2;
          }
          var s2 = i3.length > 2 ? this.refs_with_info["#" + i3[1]] : this.refs_with_info[n3.$ref];
          delete n3.$ref;
          var c3 = s2.$ref.startsWith("#") ? s2.fetchUrl : "", u2 = this._getRef(c3, s2);
          if (this.refs[u2]) {
            if (e4 && h2(this.refs[u2], "allOf")) {
              var p3 = this.refs[u2].allOf;
              Object.keys(p3).forEach(function(t5) {
                p3[t5] = r3.expandRefs(p3[t5], true);
              });
            }
          } else
            console.warn("reference:'".concat(u2, "' not found!"));
          return i3.length > 2 ? this.extendSchemas(n3, this.expandSchema(this.expandRecursivePointer(this.refs[u2], i3[2]))) : this.extendSchemas(n3, this.expandSchema(this.refs[u2]));
        } }, { key: "expandRecursivePointer", value: function(t4, e4) {
          var r3 = t4;
          return e4.split("/").slice(1).forEach(function(t5) {
            r3[t5] && (r3 = r3[t5]);
          }), r3.$refs && r3.$refs.startsWith("#") ? this.expandRecursivePointer(t4, r3.$refs) : r3;
        } }, { key: "expandSchema", value: function(t4) {
          var e4 = this;
          Object.entries(this._subSchema1).forEach(function(r4) {
            var n3 = Qn(r4, 2), i3 = n3[0], o2 = n3[1];
            t4[i3] && o2.call(e4, t4);
          });
          var r3 = l({}, t4);
          return Object.entries(this._subSchema2).forEach(function(n3) {
            var i3 = Qn(n3, 2), o2 = i3[0], a2 = i3[1];
            t4[o2] && (r3 = a2.call(e4, t4, r3));
          }), this.expandRefs(r3);
        } }, { key: "_getRef", value: function(t4, e4) {
          var r3 = t4 + e4;
          return this.refs[r3] ? r3 : t4 + decodeURIComponent(e4.$ref);
        } }, { key: "_expandSubSchema", value: function(t4) {
          var e4 = this;
          return Array.isArray(t4) ? t4.map(function(t5) {
            return "object" === Xn(t5) ? e4.expandSchema(t5) : t5;
          }) : this.expandSchema(t4);
        } }, { key: "_manageRecursivePointer", value: function(t4, e4) {
          Object.keys(t4).forEach(function(r3) {
            t4[r3].$ref && 0 === t4[r3].$ref.indexOf("#") && (t4[r3].$ref = e4 + t4[r3].$ref);
          });
        } }, { key: "_getExternalRefs", value: function(t4, e4) {
          var r3 = this, n3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
          n3 || this._manageRecursivePointer(t4, e4);
          var i3 = {}, o2 = function(t5) {
            return Object.keys(t5).forEach(function(t6) {
              i3[t6] = true;
            });
          };
          if (t4.$ref && "object" !== Xn(t4.$ref) && (0 !== t4.$ref.indexOf("#") || !n3)) {
            var a2 = t4.$ref, s2 = "";
            a2.indexOf("#") > 0 && (a2 = a2.substr(0, a2.indexOf("#"))), a2 !== t4.$ref && (s2 = t4.$ref.substr(t4.$ref.indexOf("#")));
            var l2 = this.refs_prefix + this.refs_counter++, c3 = l2 + s2;
            "#" === t4.$ref.substr(0, 1) || this.refs[t4.$ref] || (i3[a2] = true), this.refs_with_info[l2] = { fetchUrl: e4, $ref: a2 }, t4.$ref = c3;
          }
          return Object.values(t4).forEach(function(t5) {
            t5 && "object" === Xn(t5) && (Array.isArray(t5) ? Object.values(t5).forEach(function(t6) {
              t6 && "object" === Xn(t6) && o2(r3._getExternalRefs(t6, e4, n3));
            }) : t5.$ref && "string" == typeof t5.$ref && t5.$ref.startsWith("#") || o2(r3._getExternalRefs(t5, e4, n3)));
          }), t4.id && "string" == typeof t4.id && "urn:" === t4.id.substr(0, 4) ? this.refs[t4.id] = t4 : t4.$id && "string" == typeof t4.$id && "urn:" === t4.$id.substr(0, 4) && (this.refs[t4.$id] = t4), i3;
        } }, { key: "_getFileBase", value: function(t4) {
          if (!t4)
            return "/";
          var e4 = this.options.ajaxBase;
          return void 0 === e4 ? this._getFileBaseFromFileLocation(t4) : e4;
        } }, { key: "_getFileBaseFromFileLocation", value: function(t4) {
          var e4 = t4.split("/");
          return e4.pop(), "".concat(e4.join("/"), "/");
        } }, { key: "_joinUrl", value: function(t4, e4) {
          var r3 = t4;
          return "http://" !== t4.substr(0, 7) && "https://" !== t4.substr(0, 8) && "blob:" !== t4.substr(0, 5) && "data:" !== t4.substr(0, 5) && "#" !== t4.substr(0, 1) && "/" !== t4.substr(0, 1) && (r3 = e4 + t4), r3.indexOf("#") > 0 && (r3 = r3.substr(0, r3.indexOf("#"))), r3;
        } }, { key: "_isUniformResourceName", value: function(t4) {
          return "urn:" === t4.substr(0, 4);
        } }, { key: "_asyncloadExternalRefs", value: (n2 = Yn(Wn().mark(function t4(e4, r3, n3) {
          var i3, o2, a2, s2, l2, c3, u2 = this, h3 = arguments;
          return Wn().wrap(function(t5) {
            for (; ; )
              switch (t5.prev = t5.next) {
                case 0:
                  i3 = h3.length > 3 && void 0 !== h3[3] && h3[3], o2 = this._getExternalRefs(e4, r3, i3), a2 = 0, s2 = Wn().mark(function t6() {
                    var e5, r4, i4, o3, s3, h4, p3, d2, f3, y3, m2;
                    return Wn().wrap(function(t7) {
                      for (; ; )
                        switch (t7.prev = t7.next) {
                          case 0:
                            if (void 0 !== (e5 = c3[l2])) {
                              t7.next = 3;
                              break;
                            }
                            return t7.abrupt("return", "continue");
                          case 3:
                            if (!u2.refs[e5]) {
                              t7.next = 5;
                              break;
                            }
                            return t7.abrupt("return", "continue");
                          case 5:
                            if (!u2._isUniformResourceName(e5)) {
                              t7.next = 40;
                              break;
                            }
                            if (u2.refs[e5] = "loading", a2++, r4 = u2.options.urn_resolver, i4 = e5, "function" == typeof r4) {
                              t7.next = 13;
                              break;
                            }
                            throw console.log('No "urn_resolver" callback defined to resolve "'.concat(i4, '"')), new Error("Must set urn_resolver option to a callback to resolve ".concat(i4));
                          case 13:
                            return i4.indexOf("#") > 0 && (i4 = i4.substr(0, i4.indexOf("#"))), t7.prev = 14, t7.next = 17, r4(i4);
                          case 17:
                            o3 = t7.sent, t7.prev = 18, s3 = JSON.parse(o3), t7.next = 26;
                            break;
                          case 22:
                            throw t7.prev = 22, t7.t0 = t7.catch(18), console.log(t7.t0), new Error("Failed to parse external ref ".concat(i4));
                          case 26:
                            if (!("boolean" != typeof s3 && "object" !== Xn(s3) || null === s3 || Array.isArray(s3))) {
                              t7.next = 28;
                              break;
                            }
                            throw new Error("External ref does not contain a valid schema - ".concat(i4));
                          case 28:
                            return u2.refs[e5] = s3, t7.next = 31, u2._asyncloadExternalRefs(s3, e5, n3);
                          case 31:
                            t7.next = 37;
                            break;
                          case 33:
                            throw t7.prev = 33, t7.t1 = t7.catch(14), console.log(t7.t1), new Error("Failed to parse external ref ".concat(i4));
                          case 37:
                            if ("boolean" != typeof o3) {
                              t7.next = 39;
                              break;
                            }
                            throw new Error("External ref does not contain a valid schema - ".concat(i4));
                          case 39:
                            return t7.abrupt("return", "continue");
                          case 40:
                            if (u2.options.ajax) {
                              t7.next = 42;
                              break;
                            }
                            throw new Error("Must set ajax option to true to load external ref ".concat(e5));
                          case 42:
                            if (a2++, h4 = u2._joinUrl(e5, n3), u2.options.ajax_cache_responses && (d2 = u2.cacheGet(h4)) && (p3 = d2), p3) {
                              t7.next = 60;
                              break;
                            }
                            return t7.next = 48, new Promise(function(t8) {
                              var e6 = new XMLHttpRequest();
                              u2.options.ajaxCredentials && (e6.withCredentials = u2.options.ajaxCredentials), e6.overrideMimeType("application/json"), e6.open("GET", h4, true), e6.onload = function() {
                                t8(e6);
                              }, e6.onerror = function(e7) {
                                t8(void 0);
                              }, e6.send();
                            });
                          case 48:
                            if (void 0 !== (f3 = t7.sent)) {
                              t7.next = 51;
                              break;
                            }
                            throw new Error("Failed to fetch ref via ajax - ".concat(e5));
                          case 51:
                            t7.prev = 51, p3 = JSON.parse(f3.responseText), u2.options.ajax_cache_responses && u2.cacheSet(h4, p3), t7.next = 60;
                            break;
                          case 56:
                            throw t7.prev = 56, t7.t2 = t7.catch(51), console.log(t7.t2), new Error("Failed to parse external ref ".concat(h4));
                          case 60:
                            if (!("boolean" != typeof p3 && "object" !== Xn(p3) || null === p3 || Array.isArray(p3))) {
                              t7.next = 62;
                              break;
                            }
                            throw new Error("External ref does not contain a valid schema - ".concat(h4));
                          case 62:
                            return u2.refs[e5] = p3, y3 = u2._getFileBaseFromFileLocation(h4), h4 !== e5 && (m2 = h4.split("/"), h4 = ("/" === e5.substr(0, 1) ? "/" : "") + m2.pop()), t7.next = 67, u2._asyncloadExternalRefs(p3, h4, y3);
                          case 67:
                          case "end":
                            return t7.stop();
                        }
                    }, t6, null, [[14, 33], [18, 22], [51, 56]]);
                  }), l2 = 0, c3 = Object.keys(o2);
                case 5:
                  if (!(l2 < c3.length)) {
                    t5.next = 13;
                    break;
                  }
                  return t5.delegateYield(s2(), "t0", 7);
                case 7:
                  if ("continue" !== t5.t0) {
                    t5.next = 10;
                    break;
                  }
                  return t5.abrupt("continue", 10);
                case 10:
                  l2++, t5.next = 5;
                  break;
                case 13:
                  if (a2) {
                    t5.next = 15;
                    break;
                  }
                  return t5.abrupt("return", true);
                case 15:
                case "end":
                  return t5.stop();
              }
          }, t4, this);
        })), function(t4, e4, r3) {
          return n2.apply(this, arguments);
        }) }, { key: "extendSchemas", value: function(t4, e4) {
          var r3 = this;
          t4 = l({}, t4), e4 = l({}, e4);
          var n3 = {}, i3 = function(t5) {
            "string" == typeof t5 && (t5 = [t5]), "string" == typeof e4.type && (e4.type = [e4.type]), e4.type && e4.type.length ? n3.type = t5.filter(function(t6) {
              return e4.type.includes(t6);
            }) : n3.type = t5, 1 === n3.type.length && "string" == typeof n3.type[0] ? n3.type = n3.type[0] : 0 === n3.type.length && delete n3.type;
          };
          return Object.entries(t4).forEach(function(t5) {
            var o2 = Qn(t5, 2), a2 = o2[0], s2 = o2[1];
            void 0 !== e4[a2] ? function(t6, o3) {
              !function(t7, e5) {
                return ("required" === t7 || "defaultProperties" === t7) && "object" === Xn(e5) && Array.isArray(e5);
              }(t6, o3) ? "type" !== t6 || "string" != typeof o3 && !Array.isArray(o3) ? "object" !== Xn(o3) || Array.isArray(o3) || null === o3 ? n3[t6] = o3 : n3[t6] = r3.extendSchemas(o3, e4[t6]) : i3(o3) : n3[t6] = o3.concat(e4[t6]).reduce(function(t7, e5) {
                return t7.includes(e5) || t7.push(e5), t7;
              }, []);
            }(a2, s2) : n3[a2] = s2;
          }), Object.entries(e4).forEach(function(e5) {
            var r4 = Qn(e5, 2), i4 = r4[0], o2 = r4[1];
            void 0 === t4[i4] && (n3[i4] = o2);
          }), n3;
        } }, { key: "getCacheKey", value: function(t4) {
          return ["je-cache", t4].join("::");
        } }, { key: "getCacheBuster", value: function() {
          return this.options.ajax_cache_buster || (/* @__PURE__ */ new Date()).toISOString().slice(0, 10);
        } }, { key: "cacheSet", value: function(t4, e4) {
          try {
            window.localStorage.setItem(this.getCacheKey(t4), JSON.stringify({ cacheBuster: this.getCacheBuster(), schema: e4 }));
          } catch (t5) {
            console.error(t5);
          }
        } }, { key: "cacheGet", value: function(t4) {
          try {
            var e4 = window.localStorage.getItem(this.getCacheKey(t4));
            if (e4) {
              var r3 = JSON.parse(e4);
              if (r3.cacheBuster && r3.schema && r3.cacheBuster === this.getCacheBuster())
                return r3.schema;
              this.cacheDelete(t4);
            }
          } catch (t5) {
            console.error(t5);
          }
        } }, { key: "cacheDelete", value: function(t4) {
          window.localStorage.removeItem(this.getCacheKey(t4));
        } }], r2 && ti(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), t3;
      }(), ri = (r(3210), { default: function() {
        return { compile: function(t3) {
          var e3 = t3.match(/{{\s*([a-zA-Z0-9\-_ .]+)\s*}}/g), r2 = e3 && e3.length;
          if (!r2)
            return function() {
              return t3;
            };
          for (var n2 = [], i2 = function(t4) {
            var r3, i3, o3 = e3[t4].replace(/[{}]+/g, "").trim().split("."), a2 = o3.length;
            a2 > 1 ? r3 = function(e4) {
              for (i3 = e4, t4 = 0; t4 < a2 && (i3 = i3[o3[t4]]); t4++)
                ;
              return i3;
            } : (o3 = o3[0], r3 = function(t5) {
              return t5[o3];
            }), n2.push({ s: e3[t4], r: r3 });
          }, o2 = 0; o2 < r2; o2++)
            i2(o2);
          return function(e4) {
            var i3, a2 = "".concat(t3);
            for (o2 = 0; o2 < r2; o2++)
              i3 = n2[o2], a2 = a2.replace(i3.s, i3.r(e4));
            return a2;
          };
        } };
      }, ejs: function() {
        return !!window.EJS && { compile: function(t3) {
          var e3 = new window.EJS({ text: t3 });
          return function(t4) {
            return e3.render(t4);
          };
        } };
      }, handlebars: function() {
        return window.Handlebars;
      }, hogan: function() {
        return !!window.Hogan && { compile: function(t3) {
          var e3 = window.Hogan.compile(t3);
          return function(t4) {
            return e3.render(t4);
          };
        } };
      }, lodash: function() {
        return !!window._ && { compile: function(t3) {
          return function(e3) {
            return window._.template(t3)(e3);
          };
        } };
      }, markup: function() {
        return !(!window.Mark || !window.Mark.up) && { compile: function(t3) {
          return function(e3) {
            return window.Mark.up(t3, e3);
          };
        } };
      }, mustache: function() {
        return !!window.Mustache && { compile: function(t3) {
          return function(e3) {
            return window.Mustache.render(t3, e3);
          };
        } };
      }, swig: function() {
        return window.swig;
      }, underscore: function() {
        return !!window._ && { compile: function(t3) {
          return function(e3) {
            return window._.template(t3)(e3);
          };
        } };
      } });
      function ni(t3) {
        return ni = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, ni(t3);
      }
      function ii(t3, e3) {
        (null == e3 || e3 > t3.length) && (e3 = t3.length);
        for (var r2 = 0, n2 = new Array(e3); r2 < e3; r2++)
          n2[r2] = t3[r2];
        return n2;
      }
      function oi(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== ni(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== ni(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === ni(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      var ai = { collapse: "", expand: "", delete: "", edit: "", add: "", cancel: "", save: "", moveup: "", movedown: "" }, si = function() {
        function t3() {
          var e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "", r3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ai;
          !function(t4, e5) {
            if (!(t4 instanceof e5))
              throw new TypeError("Cannot call a class as a function");
          }(this, t3), this.mapping = r3, this.icon_prefix = e4;
        }
        var e3, r2;
        return e3 = t3, (r2 = [{ key: "getIconClass", value: function(t4) {
          return this.mapping[t4] ? this.icon_prefix + this.mapping[t4] : this.icon_prefix + t4;
        } }, { key: "getIcon", value: function(t4) {
          var e4, r3 = this.getIconClass(t4);
          if (!r3)
            return null;
          var n2, i2 = document.createElement("i");
          return (e4 = i2.classList).add.apply(e4, function(t5) {
            if (Array.isArray(t5))
              return ii(t5);
          }(n2 = r3.split(" ")) || function(t5) {
            if ("undefined" != typeof Symbol && null != t5[Symbol.iterator] || null != t5["@@iterator"])
              return Array.from(t5);
          }(n2) || function(t5, e5) {
            if (t5) {
              if ("string" == typeof t5)
                return ii(t5, e5);
              var r4 = Object.prototype.toString.call(t5).slice(8, -1);
              return "Object" === r4 && t5.constructor && (r4 = t5.constructor.name), "Map" === r4 || "Set" === r4 ? Array.from(t5) : "Arguments" === r4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r4) ? ii(t5, e5) : void 0;
            }
          }(n2) || function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }()), i2;
        } }]) && oi(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), t3;
      }();
      function li(t3) {
        return li = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, li(t3);
      }
      function ci(t3, e3) {
        return ci = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, ci(t3, e3);
      }
      function ui(t3) {
        return ui = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, ui(t3);
      }
      var hi = "glyphicon glyphicon-", pi = { collapse: "chevron-down", expand: "chevron-right", delete: "trash", edit: "pencil", add: "plus", subtract: "minus", cancel: "floppy-remove", save: "floppy-saved", moveup: "arrow-up", moveright: "arrow-right", movedown: "arrow-down", moveleft: "arrow-left", copy: "copy", clear: "remove-circle", time: "time", calendar: "calendar", edit_properties: "list" }, di = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && ci(t4, e4);
        }(o2, t3);
        var e3, r2, n2, i2 = (r2 = o2, n2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = ui(r2);
          if (n2) {
            var i3 = ui(this).constructor;
            t4 = Reflect.construct(e4, arguments, i3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === li(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function o2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, o2), i2.call(this, hi, pi);
        }
        return e3 = o2, Object.defineProperty(e3, "prototype", { writable: false }), e3;
      }(si);
      function fi(t3) {
        return fi = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, fi(t3);
      }
      function yi(t3, e3) {
        return yi = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, yi(t3, e3);
      }
      function mi(t3) {
        return mi = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, mi(t3);
      }
      var vi = "icon-", bi = { collapse: "chevron-down", expand: "chevron-right", delete: "trash", edit: "pencil", add: "plus", subtract: "minus", cancel: "ban-circle", save: "save", moveup: "arrow-up", moveright: "arrow-right", movedown: "arrow-down", moveleft: "arrow-left", copy: "copy", clear: "remove-circle", time: "time", calendar: "calendar", edit_properties: "list" }, gi = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && yi(t4, e4);
        }(o2, t3);
        var e3, r2, n2, i2 = (r2 = o2, n2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = mi(r2);
          if (n2) {
            var i3 = mi(this).constructor;
            t4 = Reflect.construct(e4, arguments, i3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === fi(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function o2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, o2), i2.call(this, vi, bi);
        }
        return e3 = o2, Object.defineProperty(e3, "prototype", { writable: false }), e3;
      }(si);
      function wi(t3) {
        return wi = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, wi(t3);
      }
      function _i(t3, e3) {
        return _i = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, _i(t3, e3);
      }
      function ki(t3) {
        return ki = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, ki(t3);
      }
      var ji = "fa fa-", Oi = { collapse: "caret-square-o-down", expand: "caret-square-o-right", delete: "times", edit: "pencil", add: "plus", subtract: "minus", cancel: "ban", save: "save", moveup: "arrow-up", moveright: "arrow-right", movedown: "arrow-down", moveleft: "arrow-left", copy: "files-o", clear: "times-circle-o", time: "clock-o", calendar: "calendar", edit_properties: "list" }, xi = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && _i(t4, e4);
        }(o2, t3);
        var e3, r2, n2, i2 = (r2 = o2, n2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = ki(r2);
          if (n2) {
            var i3 = ki(this).constructor;
            t4 = Reflect.construct(e4, arguments, i3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === wi(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function o2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, o2), i2.call(this, ji, Oi);
        }
        return e3 = o2, Object.defineProperty(e3, "prototype", { writable: false }), e3;
      }(si);
      function Ci(t3) {
        return Ci = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, Ci(t3);
      }
      function Ei(t3, e3) {
        return Ei = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, Ei(t3, e3);
      }
      function Si(t3) {
        return Si = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, Si(t3);
      }
      var Pi = "fas fa-", Ti = { collapse: "caret-down", expand: "caret-right", delete: "trash", edit: "pen", add: "plus", subtract: "minus", cancel: "ban", save: "save", moveup: "arrow-up", moveright: "arrow-right", movedown: "arrow-down", moveleft: "arrow-left", copy: "copy", clear: "times-circle", time: "clock", calendar: "calendar", edit_properties: "list" }, Li = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && Ei(t4, e4);
        }(o2, t3);
        var e3, r2, n2, i2 = (r2 = o2, n2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = Si(r2);
          if (n2) {
            var i3 = Si(this).constructor;
            t4 = Reflect.construct(e4, arguments, i3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === Ci(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function o2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, o2), i2.call(this, Pi, Ti);
        }
        return e3 = o2, Object.defineProperty(e3, "prototype", { writable: false }), e3;
      }(si);
      function Ri(t3) {
        return Ri = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, Ri(t3);
      }
      function Ai(t3, e3) {
        return Ai = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, Ai(t3, e3);
      }
      function Ii(t3) {
        return Ii = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, Ii(t3);
      }
      var Bi = "ui-icon ui-icon-", Ni = { collapse: "triangle-1-s", expand: "triangle-1-e", delete: "trash", edit: "pencil", add: "plusthick", subtract: "minusthick", cancel: "closethick", save: "disk", moveup: "arrowthick-1-n", moveright: "arrowthick-1-e", movedown: "arrowthick-1-s", moveleft: "arrowthick-1-w", copy: "copy", clear: "circle-close", time: "time", calendar: "calendar", edit_properties: "note" }, Di = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && Ai(t4, e4);
        }(o2, t3);
        var e3, r2, n2, i2 = (r2 = o2, n2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = Ii(r2);
          if (n2) {
            var i3 = Ii(this).constructor;
            t4 = Reflect.construct(e4, arguments, i3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === Ri(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function o2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, o2), i2.call(this, Bi, Ni);
        }
        return e3 = o2, Object.defineProperty(e3, "prototype", { writable: false }), e3;
      }(si);
      function Fi(t3) {
        return Fi = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, Fi(t3);
      }
      function Vi(t3, e3) {
        return Vi = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, Vi(t3, e3);
      }
      function zi(t3) {
        return zi = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, zi(t3);
      }
      var Hi = "oi oi-", Mi = { collapse: "collapse-down", expand: "expand-right", delete: "trash", edit: "pencil", add: "plus", subtract: "minus", cancel: "ban", save: "file", moveup: "arrow-thick-top", moveright: "arrow-thick-right", movedown: "arrow-thick-bottom", moveleft: "arrow-thick-left", copy: "clipboard", clear: "circle-x", time: "clock", calendar: "calendar", edit_properties: "list" }, qi = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && Vi(t4, e4);
        }(o2, t3);
        var e3, r2, n2, i2 = (r2 = o2, n2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = zi(r2);
          if (n2) {
            var i3 = zi(this).constructor;
            t4 = Reflect.construct(e4, arguments, i3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === Fi(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function o2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, o2), i2.call(this, Hi, Mi);
        }
        return e3 = o2, Object.defineProperty(e3, "prototype", { writable: false }), e3;
      }(si);
      function Gi(t3) {
        return Gi = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, Gi(t3);
      }
      function Ui(t3, e3) {
        return Ui = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, Ui(t3, e3);
      }
      function $i(t3) {
        return $i = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, $i(t3);
      }
      var Ji = "icon icon-", Wi = { collapse: "arrow-down", expand: "arrow-right", delete: "delete", edit: "edit", add: "plus", subtract: "minus", cancel: "cross", save: "check", moveup: "upward", moveright: "forward", movedown: "downward", moveleft: "back", copy: "copy", clear: "close", time: "time", calendar: "bookmark", edit_properties: "menu" }, Zi = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && Ui(t4, e4);
        }(o2, t3);
        var e3, r2, n2, i2 = (r2 = o2, n2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = $i(r2);
          if (n2) {
            var i3 = $i(this).constructor;
            t4 = Reflect.construct(e4, arguments, i3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === Gi(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function o2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, o2), i2.call(this, Ji, Wi);
        }
        return e3 = o2, Object.defineProperty(e3, "prototype", { writable: false }), e3;
      }(si);
      function Yi(t3) {
        return Yi = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, Yi(t3);
      }
      function Qi(t3, e3) {
        return Qi = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, Qi(t3, e3);
      }
      function Ki(t3) {
        return Ki = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, Ki(t3);
      }
      var Xi = "bi bi-", to = { collapse: "chevron-down", expand: "chevron-right", delete: "trash", edit: "pencil", add: "plus", subtract: "dash", cancel: "x-circle", save: "save", moveup: "arrow-up", moveright: "arrow-right", movedown: "arrow-down", moveleft: "arrow-left", copy: "clipboard", clear: "x-circle", time: "clock", calendar: "calendar", edit_properties: "list-ul" }, eo = { bootstrap: function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && Qi(t4, e4);
        }(o2, t3);
        var e3, r2, n2, i2 = (r2 = o2, n2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = Ki(r2);
          if (n2) {
            var i3 = Ki(this).constructor;
            t4 = Reflect.construct(e4, arguments, i3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === Yi(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function o2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, o2), i2.call(this, Xi, to);
        }
        return e3 = o2, Object.defineProperty(e3, "prototype", { writable: false }), e3;
      }(si), bootstrap3: di, fontawesome3: gi, fontawesome4: xi, fontawesome5: Li, jqueryui: Di, openiconic: qi, spectre: Zi };
      function ro(t3) {
        return ro = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, ro(t3);
      }
      function no(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== ro(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== ro(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === ro(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      var io = ["matches", "webkitMatchesSelector", "mozMatchesSelector", "msMatchesSelector", "oMatchesSelector"].find(function(t3) {
        return t3 in document.documentElement;
      }), oo = function() {
        function t3(e4) {
          var r3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { disable_theme_rules: false };
          !function(t4, e5) {
            if (!(t4 instanceof e5))
              throw new TypeError("Cannot call a class as a function");
          }(this, t3), this.jsoneditor = e4, Object.keys(r3).forEach(function(t4) {
            void 0 !== e4.options[t4] && (r3[t4] = e4.options[t4]);
          }), this.options = r3;
        }
        var e3, r2;
        return e3 = t3, r2 = [{ key: "getContainer", value: function() {
          return document.createElement("div");
        } }, { key: "getFloatRightLinkHolder", value: function() {
          var t4 = document.createElement("div");
          return t4.classList.add("je-float-right-linkholder"), t4;
        } }, { key: "getModal", value: function() {
          var t4 = document.createElement("div");
          return t4.style.display = "none", t4.classList.add("je-modal"), t4;
        } }, { key: "getGridContainer", value: function() {
          return document.createElement("div");
        } }, { key: "getGridRow", value: function() {
          var t4 = document.createElement("div");
          return t4.classList.add("row"), t4;
        } }, { key: "getGridColumn", value: function() {
          return document.createElement("div");
        } }, { key: "setGridColumnSize", value: function(t4, e4) {
        } }, { key: "getLink", value: function(t4) {
          var e4 = document.createElement("a");
          return e4.setAttribute("href", "#"), e4.appendChild(document.createTextNode(t4)), e4;
        } }, { key: "disableHeader", value: function(t4) {
          t4.style.color = "#ccc";
        } }, { key: "disableLabel", value: function(t4) {
          t4.style.color = "#ccc";
        } }, { key: "enableHeader", value: function(t4) {
          t4.style.color = "";
        } }, { key: "enableLabel", value: function(t4) {
          t4.style.color = "";
        } }, { key: "getInfoButton", value: function(t4) {
          var e4 = document.createElement("span");
          e4.innerText = "ⓘ", e4.classList.add("je-infobutton-icon");
          var r3 = document.createElement("span");
          return r3.classList.add("je-infobutton-tooltip"), r3.innerText = t4, e4.onmouseover = function() {
            r3.style.visibility = "visible";
          }, e4.onmouseleave = function() {
            r3.style.visibility = "hidden";
          }, e4.appendChild(r3), e4;
        } }, { key: "getFormInputLabel", value: function(t4, e4) {
          var r3 = document.createElement("label");
          return r3.appendChild(document.createTextNode(t4)), e4 && r3.classList.add("required"), r3;
        } }, { key: "getHeader", value: function(t4, e4) {
          var r3 = document.createElement("h3");
          return "string" == typeof t4 ? r3.textContent = t4 : r3.appendChild(t4), r3.classList.add("je-header"), r3;
        } }, { key: "getCheckbox", value: function() {
          var t4 = this.getFormInputField("checkbox");
          return t4.classList.add("je-checkbox"), t4;
        } }, { key: "getCheckboxLabel", value: function(t4, e4) {
          var r3 = document.createElement("label");
          return r3.appendChild(document.createTextNode(" ".concat(t4))), e4 && r3.classList.add("required"), r3;
        } }, { key: "getMultiCheckboxHolder", value: function(t4, e4, r3, n2) {
          var i2 = document.createElement("div");
          return i2.classList.add("control-group"), e4 && (e4.style.display = "block", i2.appendChild(e4), n2 && e4.appendChild(n2)), Object.values(t4).forEach(function(t5) {
            t5.style.display = "inline-block", t5.style.marginRight = "20px", i2.appendChild(t5);
          }), r3 && i2.appendChild(r3), i2;
        } }, { key: "getFormCheckboxControl", value: function(t4, e4, r3) {
          var n2 = document.createElement("div");
          return n2.appendChild(t4), e4.style.width = "auto", t4.insertBefore(e4, t4.firstChild), r3 && n2.classList.add("je-checkbox-control--compact"), n2;
        } }, { key: "getFormRadio", value: function(t4) {
          var e4 = this.getFormInputField("radio");
          return Object.keys(t4).forEach(function(r3) {
            return e4.setAttribute(r3, t4[r3]);
          }), e4.classList.add("je-radio"), e4;
        } }, { key: "getFormRadioLabel", value: function(t4, e4) {
          var r3 = document.createElement("label");
          return r3.appendChild(document.createTextNode(" ".concat(t4))), e4 && r3.classList.add("required"), r3;
        } }, { key: "getFormRadioControl", value: function(t4, e4, r3) {
          var n2 = document.createElement("div");
          return n2.appendChild(t4), e4.style.width = "auto", t4.insertBefore(e4, t4.firstChild), r3 && n2.classList.add("je-radio-control--compact"), n2;
        } }, { key: "getSelectInput", value: function(t4, e4) {
          var r3 = document.createElement("select");
          return t4 && this.setSelectOptions(r3, t4), r3;
        } }, { key: "getSwitcher", value: function(t4) {
          var e4 = this.getSelectInput(t4, false);
          return e4.classList.add("je-switcher"), e4;
        } }, { key: "getSwitcherOptions", value: function(t4) {
          return t4.getElementsByTagName("option");
        } }, { key: "setSwitcherOptions", value: function(t4, e4, r3) {
          this.setSelectOptions(t4, e4, r3);
        } }, { key: "setSelectOptions", value: function(t4, e4) {
          var r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [];
          t4.innerHTML = "";
          for (var n2 = 0; n2 < e4.length; n2++) {
            var i2 = document.createElement("option");
            i2.setAttribute("value", e4[n2]), i2.textContent = r3[n2] || e4[n2], t4.appendChild(i2);
          }
        } }, { key: "getTextareaInput", value: function() {
          var t4 = document.createElement("textarea");
          return t4.classList.add("je-textarea"), t4;
        } }, { key: "getRangeInput", value: function(t4, e4, r3) {
          var n2 = this.getFormInputField("range");
          return n2.setAttribute("min", t4), n2.setAttribute("max", e4), n2.setAttribute("step", r3), n2;
        } }, { key: "getStepperButtons", value: function(t4) {
          var e4 = document.createElement("div"), r3 = document.createElement("button");
          r3.setAttribute("type", "button"), r3.classList.add("stepper-down");
          var n2 = document.createElement("button");
          n2.setAttribute("type", "button"), n2.classList.add("stepper-up"), t4.getAttribute("readonly") && (r3.setAttribute("disabled", true), n2.setAttribute("disabled", true)), r3.textContent = "-", n2.textContent = "+";
          var i2 = function(t5, e5) {
            t5.value = Number(e5 || t5.value), t5.setAttribute("initialized", "1");
          }, o2 = t4.getAttribute("min"), a2 = t4.getAttribute("max");
          return r3.addEventListener("click", function() {
            t4.getAttribute("initialized") ? o2 ? Number(t4.value) > Number(o2) && t4.stepDown() : t4.stepDown() : i2(t4, o2), c2(t4, "change");
          }), n2.addEventListener("click", function() {
            t4.getAttribute("initialized") ? a2 ? Number(t4.value) < Number(a2) && t4.stepUp() : t4.stepUp() : i2(t4, o2), c2(t4, "change");
          }), e4.appendChild(r3), e4.appendChild(n2), e4;
        } }, { key: "getRangeOutput", value: function(t4, e4) {
          var r3 = document.createElement("output"), n2 = function(t5) {
            r3.value = t5.currentTarget.value;
          };
          return t4.addEventListener("change", n2, false), t4.addEventListener("input", n2, false), r3;
        } }, { key: "getRangeControl", value: function(t4, e4) {
          var r3 = document.createElement("div");
          return r3.classList.add("je-range-control"), e4 && r3.appendChild(e4), r3.appendChild(t4), r3;
        } }, { key: "getFormInputField", value: function(t4) {
          var e4 = document.createElement("input");
          return e4.setAttribute("type", t4), e4;
        } }, { key: "afterInputReady", value: function(t4) {
        } }, { key: "getFormControl", value: function(t4, e4, r3, n2, i2) {
          var o2 = document.createElement("div");
          return o2.classList.add("form-control"), t4 && (o2.appendChild(t4), i2 && t4.setAttribute("for", i2)), "checkbox" !== e4.type && "radio" !== e4.type || !t4 ? (n2 && t4 && t4.appendChild(n2), o2.appendChild(e4)) : (e4.style.width = "auto", t4.insertBefore(e4, t4.firstChild), n2 && t4.appendChild(n2)), r3 && o2.appendChild(r3), o2;
        } }, { key: "getIndentedPanel", value: function() {
          var t4 = document.createElement("div");
          return t4.classList.add("je-indented-panel"), t4;
        } }, { key: "getTopIndentedPanel", value: function() {
          var t4 = document.createElement("div");
          return t4.classList.add("je-indented-panel--top"), t4;
        } }, { key: "getChildEditorHolder", value: function() {
          return document.createElement("div");
        } }, { key: "getDescription", value: function(t4) {
          var e4 = document.createElement("p");
          return window.DOMPurify ? e4.innerHTML = window.DOMPurify.sanitize(t4) : e4.textContent = this.cleanText(t4), e4;
        } }, { key: "getCheckboxDescription", value: function(t4) {
          return this.getDescription(t4);
        } }, { key: "getFormInputDescription", value: function(t4) {
          return this.getDescription(t4);
        } }, { key: "getButtonHolder", value: function() {
          return document.createElement("span");
        } }, { key: "getHeaderButtonHolder", value: function() {
          return this.getButtonHolder();
        } }, { key: "getFormButtonHolder", value: function(t4) {
          return this.getButtonHolder();
        } }, { key: "getButton", value: function(t4, e4, r3) {
          var n2 = document.createElement("button");
          return n2.type = "button", this.setButtonText(n2, t4, e4, r3), n2;
        } }, { key: "getFormButton", value: function(t4, e4, r3) {
          return this.getButton(t4, e4, r3);
        } }, { key: "setButtonText", value: function(t4, e4, r3, n2) {
          for (; t4.firstChild; )
            t4.removeChild(t4.firstChild);
          if (r3 && (t4.appendChild(r3), e4 = " ".concat(e4)), !this.jsoneditor.options.iconlib || !this.jsoneditor.options.remove_button_labels || !r3) {
            var i2 = document.createElement("span");
            i2.appendChild(document.createTextNode(e4)), t4.appendChild(i2);
          }
          n2 && t4.setAttribute("title", n2);
        } }, { key: "getTable", value: function() {
          return document.createElement("table");
        } }, { key: "getTableRow", value: function() {
          return document.createElement("tr");
        } }, { key: "getTableHead", value: function() {
          return document.createElement("thead");
        } }, { key: "getTableBody", value: function() {
          return document.createElement("tbody");
        } }, { key: "getTableHeaderCell", value: function(t4) {
          var e4 = document.createElement("th");
          return e4.textContent = t4, e4;
        } }, { key: "getTableCell", value: function() {
          return document.createElement("td");
        } }, { key: "getErrorMessage", value: function(t4) {
          var e4 = document.createElement("p");
          return e4.style = e4.style || {}, e4.style.color = "red", e4.appendChild(document.createTextNode(t4)), e4;
        } }, { key: "addInputError", value: function(t4, e4) {
        } }, { key: "removeInputError", value: function(t4) {
        } }, { key: "addTableRowError", value: function(t4) {
        } }, { key: "removeTableRowError", value: function(t4) {
        } }, { key: "getTabHolder", value: function(t4) {
          var e4 = void 0 === t4 ? "" : t4, r3 = document.createElement("div");
          return r3.innerHTML = "<div class='je-tabholder tabs'></div><div class='content' id='".concat(e4, "'></div><div class='je-tabholder--clear'></div>"), r3;
        } }, { key: "getTopTabHolder", value: function(t4) {
          var e4 = void 0 === t4 ? "" : t4, r3 = document.createElement("div");
          return r3.innerHTML = "<div class='tabs je-tabholder--top'></div><div class='je-tabholder--clear'></div><div class='content' id='".concat(e4, "'></div>"), r3;
        } }, { key: "applyStyles", value: function(t4, e4) {
          Object.keys(e4).forEach(function(r3) {
            return t4.style[r3] = e4[r3];
          });
        } }, { key: "closest", value: function(t4, e4) {
          for (; t4 && t4 !== document; ) {
            if (!t4[io])
              return false;
            if (t4[io](e4))
              return t4;
            t4 = t4.parentNode;
          }
          return false;
        } }, { key: "insertBasicTopTab", value: function(t4, e4) {
          e4.firstChild.insertBefore(t4, e4.firstChild.firstChild);
        } }, { key: "getTab", value: function(t4, e4) {
          var r3 = document.createElement("div");
          return r3.appendChild(t4), r3.id = e4, r3.classList.add("je-tab"), r3;
        } }, { key: "getTopTab", value: function(t4, e4) {
          var r3 = document.createElement("div");
          return r3.appendChild(t4), r3.id = e4, r3.classList.add("je-tab--top"), r3;
        } }, { key: "getTabContentHolder", value: function(t4) {
          return t4.children[1];
        } }, { key: "getTopTabContentHolder", value: function(t4) {
          return t4.children[1];
        } }, { key: "getTabContent", value: function() {
          return this.getIndentedPanel();
        } }, { key: "getTopTabContent", value: function() {
          return this.getTopIndentedPanel();
        } }, { key: "markTabActive", value: function(t4) {
          this.applyStyles(t4.tab, { opacity: 1, background: "white" }), void 0 !== t4.rowPane ? t4.rowPane.style.display = "" : t4.container.style.display = "";
        } }, { key: "markTabInactive", value: function(t4) {
          this.applyStyles(t4.tab, { opacity: 0.5, background: "" }), void 0 !== t4.rowPane ? t4.rowPane.style.display = "none" : t4.container.style.display = "none";
        } }, { key: "addTab", value: function(t4, e4) {
          t4.children[0].appendChild(e4);
        } }, { key: "addTopTab", value: function(t4, e4) {
          t4.children[0].appendChild(e4);
        } }, { key: "getBlockLink", value: function() {
          var t4 = document.createElement("a");
          return t4.classList.add("je-block-link"), t4;
        } }, { key: "getBlockLinkHolder", value: function() {
          return document.createElement("div");
        } }, { key: "getLinksHolder", value: function() {
          return document.createElement("div");
        } }, { key: "createMediaLink", value: function(t4, e4, r3) {
          t4.appendChild(e4), r3.classList.add("je-media"), t4.appendChild(r3);
        } }, { key: "createImageLink", value: function(t4, e4, r3) {
          t4.appendChild(e4), e4.appendChild(r3);
        } }, { key: "getFirstTab", value: function(t4) {
          return t4.firstChild.firstChild;
        } }, { key: "getInputGroup", value: function(t4, e4) {
        } }, { key: "cleanText", value: function(t4) {
          var e4 = document.createElement("div");
          return e4.innerHTML = t4, e4.textContent || e4.innerText;
        } }, { key: "getDropZone", value: function(t4) {
          var e4 = document.createElement("div");
          return e4.setAttribute("data-text", t4), e4.classList.add("je-dropzone"), e4;
        } }, { key: "getUploadPreview", value: function(t4, e4, r3) {
          var n2 = document.createElement("div");
          if (n2.classList.add("je-upload-preview"), "image" === t4.mimeType.substr(0, 5)) {
            var i2 = document.createElement("img");
            i2.src = r3, n2.appendChild(i2);
          }
          var o2 = document.createElement("div");
          o2.innerHTML += "<strong>Name:</strong> ".concat(t4.name, "<br><strong>Type:</strong> ").concat(t4.type, "<br><strong>Size:</strong> ").concat(t4.formattedSize), n2.appendChild(o2), n2.appendChild(e4);
          var a2 = document.createElement("div");
          return a2.style.clear = "left", n2.appendChild(a2), n2;
        } }, { key: "getProgressBar", value: function() {
          var t4 = document.createElement("progress");
          return t4.setAttribute("max", 100), t4.setAttribute("value", 0), t4;
        } }, { key: "updateProgressBar", value: function(t4, e4) {
          t4 && t4.setAttribute("value", e4);
        } }, { key: "updateProgressBarUnknown", value: function(t4) {
          t4 && t4.removeAttribute("value");
        } }], r2 && no(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), t3;
      }();
      function ao(t3) {
        return ao = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, ao(t3);
      }
      function so(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== ao(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== ao(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === ao(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      function lo() {
        return lo = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t3, e3, r2) {
          var n2 = function(t4, e4) {
            for (; !Object.prototype.hasOwnProperty.call(t4, e4) && null !== (t4 = uo(t4)); )
              ;
            return t4;
          }(t3, e3);
          if (n2) {
            var i2 = Object.getOwnPropertyDescriptor(n2, e3);
            return i2.get ? i2.get.call(arguments.length < 3 ? t3 : r2) : i2.value;
          }
        }, lo.apply(this, arguments);
      }
      function co(t3, e3) {
        return co = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, co(t3, e3);
      }
      function uo(t3) {
        return uo = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, uo(t3);
      }
      var ho = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && co(t4, e4);
        }(a2, t3);
        var e3, r2, n2, i2, o2 = (n2 = a2, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = uo(n2);
          if (i2) {
            var r3 = uo(this).constructor;
            t4 = Reflect.construct(e4, arguments, r3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === ao(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function a2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), o2.apply(this, arguments);
        }
        return e3 = a2, (r2 = [{ key: "getFormInputLabel", value: function(t4, e4) {
          var r3 = lo(uo(a2.prototype), "getFormInputLabel", this).call(this, t4, e4);
          return r3.classList.add("je-form-input-label"), r3;
        } }, { key: "getFormInputDescription", value: function(t4) {
          var e4 = lo(uo(a2.prototype), "getFormInputDescription", this).call(this, t4);
          return e4.classList.add("je-form-input-label"), e4;
        } }, { key: "getIndentedPanel", value: function() {
          var t4 = lo(uo(a2.prototype), "getIndentedPanel", this).call(this);
          return t4.classList.add("je-indented-panel"), t4;
        } }, { key: "getTopIndentedPanel", value: function() {
          return this.getIndentedPanel();
        } }, { key: "getChildEditorHolder", value: function() {
          var t4 = lo(uo(a2.prototype), "getChildEditorHolder", this).call(this);
          return t4.classList.add("je-child-editor-holder"), t4;
        } }, { key: "getHeaderButtonHolder", value: function() {
          var t4 = this.getButtonHolder();
          return t4.classList.add("je-header-button-holder"), t4;
        } }, { key: "getTable", value: function() {
          var t4 = lo(uo(a2.prototype), "getTable", this).call(this);
          return t4.classList.add("je-table"), t4;
        } }, { key: "addInputError", value: function(t4, e4) {
          var r3 = this.closest(t4, ".form-control") || t4.controlgroup;
          t4.errmsg ? t4.errmsg.style.display = "block" : (t4.errmsg = document.createElement("div"), t4.errmsg.setAttribute("class", "errmsg"), t4.errmsg.style = t4.errmsg.style || {}, t4.errmsg.style.color = "red", r3.appendChild(t4.errmsg)), t4.errmsg.innerHTML = "", t4.errmsg.appendChild(document.createTextNode(e4));
        } }, { key: "removeInputError", value: function(t4) {
          t4.style && (t4.style.borderColor = ""), t4.errmsg && (t4.errmsg.style.display = "none");
        } }]) && so(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), a2;
      }(oo);
      function po(t3) {
        return po = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, po(t3);
      }
      function fo(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== po(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== po(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === po(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      function yo() {
        return yo = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t3, e3, r2) {
          var n2 = function(t4, e4) {
            for (; !Object.prototype.hasOwnProperty.call(t4, e4) && null !== (t4 = vo(t4)); )
              ;
            return t4;
          }(t3, e3);
          if (n2) {
            var i2 = Object.getOwnPropertyDescriptor(n2, e3);
            return i2.get ? i2.get.call(arguments.length < 3 ? t3 : r2) : i2.value;
          }
        }, yo.apply(this, arguments);
      }
      function mo(t3, e3) {
        return mo = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, mo(t3, e3);
      }
      function vo(t3) {
        return vo = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, vo(t3);
      }
      ho.rules = { ".je-form-input-label": "display:block;margin-bottom:3px;font-weight:bold", ".je-form-input-description": "display:inline-block;margin:0;font-size:0.8em;font-style:italic", ".je-indented-panel": "padding:5px;margin:10px;border-radius:3px;border:1px%20solid%20%23ddd", ".je-child-editor-holder": "margin-bottom:8px", ".je-header-button-holder": "display:inline-block;margin-left:10px;font-size:0.8em;vertical-align:middle", ".je-table": "margin-bottom:5px;border-bottom:1px%20solid%20%23ccc", ".je-upload-preview img": "float:left;margin:0%200.5rem%200.5rem%200;max-width:100%25;max-height:5rem", ".je-dropzone": "position:relative;margin:0.5rem%200;border:2px%20dashed%20black;width:100%25;height:60px;background:teal;transition:all%200.5s", ".je-dropzone:before": "position:absolute;content:attr(data-text);color:rgba(0%2C%200%2C%200%2C%200.6);left:50%25;top:50%25;transform:translate(-50%25%2C%20-50%25)", ".je-dropzone.valid-dropzone": "background:green", ".je-dropzone.invalid-dropzone": "background:red" };
      var bo = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && mo(t4, e4);
        }(a2, t3);
        var e3, r2, n2, i2, o2 = (n2 = a2, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = vo(n2);
          if (i2) {
            var r3 = vo(this).constructor;
            t4 = Reflect.construct(e4, arguments, r3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === po(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function a2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), o2.apply(this, arguments);
        }
        return e3 = a2, (r2 = [{ key: "getSelectInput", value: function(t4, e4) {
          var r3 = yo(vo(a2.prototype), "getSelectInput", this).call(this, t4);
          return r3.classList.add("form-control"), r3;
        } }, { key: "setGridColumnSize", value: function(t4, e4, r3) {
          t4.classList.add("col-md-".concat(e4)), r3 && t4.classList.add("col-md-offset-".concat(r3));
        } }, { key: "afterInputReady", value: function(t4) {
          if (!t4.controlgroup && (t4.controlgroup = this.closest(t4, ".form-group"), this.closest(t4, ".compact") && (t4.controlgroup.style.marginBottom = 0), this.queuedInputErrorText)) {
            var e4 = this.queuedInputErrorText;
            delete this.queuedInputErrorText, this.addInputError(t4, e4);
          }
        } }, { key: "getTextareaInput", value: function() {
          var t4 = document.createElement("textarea");
          return t4.classList.add("form-control"), t4;
        } }, { key: "getRangeInput", value: function(t4, e4, r3) {
          return yo(vo(a2.prototype), "getRangeInput", this).call(this, t4, e4, r3);
        } }, { key: "getFormInputField", value: function(t4) {
          var e4 = yo(vo(a2.prototype), "getFormInputField", this).call(this, t4);
          return "checkbox" !== t4 && "radio" !== t4 && e4.classList.add("form-control"), e4;
        } }, { key: "getFormControl", value: function(t4, e4, r3, n3) {
          var i3 = document.createElement("div");
          return !t4 || "checkbox" !== e4.type && "radio" !== e4.type ? (i3.classList.add("form-group"), t4 && (t4.classList.add("control-label"), i3.appendChild(t4), n3 && t4.appendChild(n3)), i3.appendChild(e4)) : (i3.classList.add(e4.type), n3 && t4.appendChild(n3), t4.insertBefore(e4, t4.firstChild), i3.appendChild(t4)), r3 && i3.appendChild(r3), i3;
        } }, { key: "getIndentedPanel", value: function() {
          var t4 = document.createElement("div");
          return t4.classList.add("well", "well-sm"), t4.style.paddingBottom = 0, t4;
        } }, { key: "getInfoButton", value: function(t4) {
          var e4 = document.createElement("span");
          e4.classList.add("glyphicon", "glyphicon-info-sign", "pull-right"), e4.style.padding = ".25rem", e4.style.position = "relative", e4.style.display = "inline-block";
          var r3 = document.createElement("span");
          return r3.style["font-family"] = "sans-serif", r3.style.visibility = "hidden", r3.style["background-color"] = "rgba(50, 50, 50, .75)", r3.style.margin = "0 .25rem", r3.style.color = "#FAFAFA", r3.style.padding = ".5rem 1rem", r3.style["border-radius"] = ".25rem", r3.style.width = "25rem", r3.style.position = "absolute", r3.innerText = t4, e4.onmouseover = function() {
            r3.style.visibility = "visible";
          }, e4.onmouseleave = function() {
            r3.style.visibility = "hidden";
          }, e4.appendChild(r3), e4;
        } }, { key: "getFormInputDescription", value: function(t4) {
          var e4 = document.createElement("p");
          return e4.classList.add("help-block"), window.DOMPurify ? e4.innerHTML = window.DOMPurify.sanitize(t4) : e4.textContent = this.cleanText(t4), e4;
        } }, { key: "getHeaderButtonHolder", value: function() {
          var t4 = this.getButtonHolder();
          return t4.style.marginLeft = "10px", t4;
        } }, { key: "getButtonHolder", value: function() {
          var t4 = document.createElement("span");
          return t4.classList.add("btn-group"), t4;
        } }, { key: "getButton", value: function(t4, e4, r3) {
          var n3 = yo(vo(a2.prototype), "getButton", this).call(this, t4, e4, r3);
          return n3.classList.add("btn", "btn-default"), n3;
        } }, { key: "getTable", value: function() {
          var t4 = document.createElement("table");
          return t4.classList.add("table", "table-bordered"), t4.style.width = "auto", t4.style.maxWidth = "none", t4;
        } }, { key: "addInputError", value: function(t4, e4) {
          t4.controlgroup ? (t4.controlgroup.classList.add("has-error"), t4.errmsg ? t4.errmsg.style.display = "" : (t4.errmsg = document.createElement("p"), t4.errmsg.classList.add("help-block", "errormsg"), t4.controlgroup.appendChild(t4.errmsg)), t4.errmsg.textContent = e4) : this.queuedInputErrorText = e4;
        } }, { key: "removeInputError", value: function(t4) {
          t4.controlgroup || delete this.queuedInputErrorText, t4.errmsg && (t4.errmsg.style.display = "none", t4.controlgroup.classList.remove("has-error"));
        } }, { key: "getTabHolder", value: function(t4) {
          var e4 = void 0 === t4 ? "" : t4, r3 = document.createElement("div");
          return r3.innerHTML = "<ul class='col-md-2 nav nav-pills nav-stacked' id='".concat(e4, "' role='tablist'></ul><div class='col-md-10 tab-content active well well-small'  id='").concat(e4, "'></div>"), r3;
        } }, { key: "getTopTabHolder", value: function(t4) {
          var e4 = void 0 === t4 ? "" : t4, r3 = document.createElement("div");
          return r3.innerHTML = "<ul class='nav nav-tabs' id='".concat(e4, "' role='tablist'></ul><div class='tab-content active well well-small'  id='").concat(e4, "'></div>"), r3;
        } }, { key: "getTab", value: function(t4, e4) {
          var r3 = document.createElement("li");
          r3.setAttribute("role", "presentation");
          var n3 = document.createElement("a");
          return n3.setAttribute("href", "#".concat(e4)), n3.appendChild(t4), n3.setAttribute("aria-controls", e4), n3.setAttribute("role", "tab"), n3.setAttribute("data-toggle", "tab"), r3.appendChild(n3), r3;
        } }, { key: "getTopTab", value: function(t4, e4) {
          var r3 = document.createElement("li");
          r3.setAttribute("role", "presentation");
          var n3 = document.createElement("a");
          return n3.setAttribute("href", "#".concat(e4)), n3.appendChild(t4), n3.setAttribute("aria-controls", e4), n3.setAttribute("role", "tab"), n3.setAttribute("data-toggle", "tab"), r3.appendChild(n3), r3;
        } }, { key: "getTabContent", value: function() {
          var t4 = document.createElement("div");
          return t4.classList.add("tab-pane"), t4.setAttribute("role", "tabpanel"), t4;
        } }, { key: "getTopTabContent", value: function() {
          var t4 = document.createElement("div");
          return t4.classList.add("tab-pane"), t4.setAttribute("role", "tabpanel"), t4;
        } }, { key: "markTabActive", value: function(t4) {
          t4.tab.classList.add("active"), void 0 !== t4.rowPane ? t4.rowPane.classList.add("active") : t4.container.classList.add("active");
        } }, { key: "markTabInactive", value: function(t4) {
          t4.tab.classList.remove("active"), void 0 !== t4.rowPane ? t4.rowPane.classList.remove("active") : t4.container.classList.remove("active");
        } }, { key: "getProgressBar", value: function() {
          var t4 = document.createElement("div");
          t4.classList.add("progress");
          var e4 = document.createElement("div");
          return e4.classList.add("progress-bar"), e4.setAttribute("role", "progressbar"), e4.setAttribute("aria-valuenow", 0), e4.setAttribute("aria-valuemin", 0), e4.setAttribute("aria-valuenax", 100), e4.innerHTML = "".concat(0, "%"), t4.appendChild(e4), t4;
        } }, { key: "updateProgressBar", value: function(t4, e4) {
          if (t4) {
            var r3 = t4.firstChild, n3 = "".concat(e4, "%");
            r3.setAttribute("aria-valuenow", e4), r3.style.width = n3, r3.innerHTML = n3;
          }
        } }, { key: "updateProgressBarUnknown", value: function(t4) {
          if (t4) {
            var e4 = t4.firstChild;
            t4.classList.add("progress", "progress-striped", "active"), e4.removeAttribute("aria-valuenow"), e4.style.width = "100%", e4.innerHTML = "";
          }
        } }, { key: "getInputGroup", value: function(t4, e4) {
          if (t4) {
            var r3 = document.createElement("div");
            r3.classList.add("input-group"), r3.appendChild(t4);
            var n3 = document.createElement("div");
            n3.classList.add("input-group-btn"), r3.appendChild(n3);
            for (var i3 = 0; i3 < e4.length; i3++)
              n3.appendChild(e4[i3]);
            return r3;
          }
        } }]) && fo(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), a2;
      }(oo);
      function go(t3) {
        return go = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, go(t3);
      }
      function wo(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== go(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== go(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === go(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      function _o() {
        return _o = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t3, e3, r2) {
          var n2 = function(t4, e4) {
            for (; !Object.prototype.hasOwnProperty.call(t4, e4) && null !== (t4 = jo(t4)); )
              ;
            return t4;
          }(t3, e3);
          if (n2) {
            var i2 = Object.getOwnPropertyDescriptor(n2, e3);
            return i2.get ? i2.get.call(arguments.length < 3 ? t3 : r2) : i2.value;
          }
        }, _o.apply(this, arguments);
      }
      function ko(t3, e3) {
        return ko = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, ko(t3, e3);
      }
      function jo(t3) {
        return jo = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, jo(t3);
      }
      bo.rules = {}, r(3843);
      var Oo = { disable_theme_rules: false, input_size: "normal", custom_forms: false, object_indent: true, object_background: "bg-light", object_text: "", table_border: false, table_zebrastyle: false, tooltip: "bootstrap" }, xo = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && ko(t4, e4);
        }(a2, t3);
        var e3, r2, n2, i2, o2 = (n2 = a2, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = jo(n2);
          if (i2) {
            var r3 = jo(this).constructor;
            t4 = Reflect.construct(e4, arguments, r3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === go(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function a2(t4) {
          return function(t5, e4) {
            if (!(t5 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), o2.call(this, t4, Oo);
        }
        return e3 = a2, (r2 = [{ key: "getSelectInput", value: function(t4, e4) {
          var r3 = _o(jo(a2.prototype), "getSelectInput", this).call(this, t4);
          return r3.classList.add("form-control"), false === this.options.custom_forms ? ("small" === this.options.input_size && r3.classList.add("form-control-sm"), "large" === this.options.input_size && r3.classList.add("form-control-lg")) : (r3.classList.remove("form-control"), r3.classList.add("custom-select"), "small" === this.options.input_size && r3.classList.add("custom-select-sm"), "large" === this.options.input_size && r3.classList.add("custom-select-lg")), r3;
        } }, { key: "getContainer", value: function() {
          var t4 = document.createElement("div");
          return this.options.object_indent || t4.classList.add("je-noindent"), t4;
        } }, { key: "setGridColumnSize", value: function(t4, e4, r3) {
          t4.classList.add("col-md-".concat(e4)), r3 && t4.classList.add("offset-md-".concat(r3));
        } }, { key: "afterInputReady", value: function(t4) {
          if (!t4.controlgroup) {
            var e4 = t4.name;
            t4.id = e4;
            var r3 = t4.parentNode.parentNode.getElementsByTagName("label")[0];
            r3 && (r3.htmlFor = e4), t4.controlgroup = this.closest(t4, ".form-group");
          }
        } }, { key: "getTextareaInput", value: function() {
          var t4 = document.createElement("textarea");
          return t4.classList.add("form-control"), "small" === this.options.input_size && t4.classList.add("form-control-sm"), "large" === this.options.input_size && t4.classList.add("form-control-lg"), t4;
        } }, { key: "getRangeInput", value: function(t4, e4, r3) {
          var n3 = _o(jo(a2.prototype), "getRangeInput", this).call(this, t4, e4, r3);
          return true === this.options.custom_forms && (n3.classList.remove("form-control"), n3.classList.add("custom-range")), n3;
        } }, { key: "getStepperButtons", value: function(t4) {
          var e4 = document.createElement("div"), r3 = document.createElement("div"), n3 = document.createElement("div"), i3 = document.createElement("button");
          i3.setAttribute("type", "button");
          var o3 = document.createElement("button");
          o3.setAttribute("type", "button"), e4.appendChild(r3), e4.appendChild(t4), e4.appendChild(n3), r3.appendChild(i3), n3.appendChild(o3), e4.classList.add("input-group"), r3.classList.add("input-group-prepend"), n3.classList.add("input-group-append"), i3.classList.add("btn"), i3.classList.add("btn-secondary"), i3.classList.add("stepper-down"), o3.classList.add("btn"), o3.classList.add("btn-secondary"), o3.classList.add("stepper-up"), t4.getAttribute("readonly") && (i3.setAttribute("disabled", true), o3.setAttribute("disabled", true)), i3.textContent = "-", o3.textContent = "+";
          var a3 = function(t5, e5) {
            t5.value = Number(e5 || t5.value), t5.setAttribute("initialized", "1");
          }, s2 = t4.getAttribute("min"), l2 = t4.getAttribute("max");
          return t4.addEventListener("change", function() {
            t4.getAttribute("initialized") || t4.setAttribute("initialized", "1");
          }), i3.addEventListener("click", function() {
            t4.getAttribute("initialized") ? s2 ? Number(t4.value) > Number(s2) && t4.stepDown() : t4.stepDown() : a3(t4, s2), c2(t4, "change");
          }), o3.addEventListener("click", function() {
            t4.getAttribute("initialized") ? l2 ? Number(t4.value) < Number(l2) && t4.stepUp() : t4.stepUp() : a3(t4, s2), c2(t4, "change");
          }), e4;
        } }, { key: "getFormInputField", value: function(t4) {
          var e4 = _o(jo(a2.prototype), "getFormInputField", this).call(this, t4);
          return "checkbox" !== t4 && "radio" !== t4 && "file" !== t4 && (e4.classList.add("form-control"), "small" === this.options.input_size && e4.classList.add("form-control-sm"), "large" === this.options.input_size && e4.classList.add("form-control-lg")), "file" === t4 && e4.classList.add("form-control-file"), e4;
        } }, { key: "getFormControl", value: function(t4, e4, r3, n3) {
          var i3 = document.createElement("div");
          if (i3.classList.add("form-group"), !t4 || "checkbox" !== e4.type && "radio" !== e4.type)
            t4 && (i3.appendChild(t4), n3 && i3.appendChild(n3)), i3.appendChild(e4);
          else {
            var o3 = document.createElement("div");
            false === this.options.custom_forms ? (o3.classList.add("form-check"), e4.classList.add("form-check-input"), t4.classList.add("form-check-label")) : (o3.classList.add("custom-control"), e4.classList.add("custom-control-input"), t4.classList.add("custom-control-label"), "checkbox" === e4.type ? o3.classList.add("custom-checkbox") : o3.classList.add("custom-radio"));
            var a3 = (Date.now() * Math.random()).toFixed(0);
            e4.setAttribute("id", a3), t4.setAttribute("for", a3), o3.appendChild(e4), o3.appendChild(t4), n3 && o3.appendChild(n3), i3.appendChild(o3);
          }
          return r3 && i3.appendChild(r3), i3;
        } }, { key: "getInfoButton", value: function(t4) {
          var e4 = document.createElement("button");
          e4.type = "button", e4.classList.add("ml-3", "jsoneditor-twbs4-text-button"), e4.setAttribute("data-toggle", "tooltip"), e4.setAttribute("data-placement", "auto"), e4.title = t4;
          var r3 = document.createTextNode("ⓘ");
          return e4.appendChild(r3), "bootstrap" === this.options.tooltip ? window.jQuery && window.jQuery().tooltip ? window.jQuery(e4).tooltip() : console.warn("Could not find popper jQuery plugin of Bootstrap.") : "css" === this.options.tooltip && e4.classList.add("je-tooltip"), e4;
        } }, { key: "getCheckbox", value: function() {
          return this.getFormInputField("checkbox");
        } }, { key: "getMultiCheckboxHolder", value: function(t4, e4, r3, n3) {
          var i3 = document.createElement("div");
          i3.classList.add("form-group"), e4 && (i3.appendChild(e4), n3 && e4.appendChild(n3));
          var o3 = document.createElement("div");
          return Object.values(t4).forEach(function(t5) {
            var e5 = t5.firstChild;
            o3.appendChild(e5);
          }), i3.appendChild(o3), r3 && i3.appendChild(r3), i3;
        } }, { key: "getFormRadio", value: function(t4) {
          var e4 = this.getFormInputField("radio");
          for (var r3 in t4)
            e4.setAttribute(r3, t4[r3]);
          return false === this.options.custom_forms ? e4.classList.add("form-check-input") : e4.classList.add("custom-control-input"), e4;
        } }, { key: "getFormRadioLabel", value: function(t4, e4) {
          var r3 = document.createElement("label");
          return false === this.options.custom_forms ? r3.classList.add("form-check-label") : r3.classList.add("custom-control-label"), r3.appendChild(document.createTextNode(t4)), r3;
        } }, { key: "getFormRadioControl", value: function(t4, e4, r3) {
          var n3 = document.createElement("div");
          return false === this.options.custom_forms ? n3.classList.add("form-check") : n3.classList.add("custom-control", "custom-radio"), n3.appendChild(e4), n3.appendChild(t4), r3 && (false === this.options.custom_forms ? n3.classList.add("form-check-inline") : n3.classList.add("custom-control-inline")), n3;
        } }, { key: "getIndentedPanel", value: function() {
          var t4 = document.createElement("div");
          return t4.classList.add("card", "card-body", "mb-3"), this.options.object_background && t4.classList.add(this.options.object_background), this.options.object_text && t4.classList.add(this.options.object_text), t4;
        } }, { key: "getFormInputDescription", value: function(t4) {
          var e4 = document.createElement("small");
          return e4.classList.add("form-text"), window.DOMPurify ? e4.innerHTML = window.DOMPurify.sanitize(t4) : e4.textContent = this.cleanText(t4), e4;
        } }, { key: "getHeader", value: function(t4, e4) {
          var r3 = document.createElement("h3");
          return r3.classList.add("card-title"), r3.classList.add("level-" + e4), "string" == typeof t4 ? r3.textContent = t4 : r3.appendChild(t4), r3.style.display = "inline-block", r3;
        } }, { key: "getHeaderButtonHolder", value: function() {
          return this.getButtonHolder();
        } }, { key: "getButtonHolder", value: function() {
          var t4 = document.createElement("span");
          return t4.classList.add("btn-group"), t4;
        } }, { key: "getFormButtonHolder", value: function(t4) {
          var e4 = this.getButtonHolder();
          return e4.classList.add("d-block"), "center" === t4 ? e4.classList.add("text-center") : "right" === t4 && e4.classList.add("text-right"), e4;
        } }, { key: "getButton", value: function(t4, e4, r3) {
          var n3 = _o(jo(a2.prototype), "getButton", this).call(this, t4, e4, r3);
          return n3.classList.add("btn", "btn-secondary", "btn-sm"), n3;
        } }, { key: "getTable", value: function() {
          var t4 = document.createElement("table");
          return t4.classList.add("table", "table-sm"), this.options.table_border && t4.classList.add("table-bordered"), this.options.table_zebrastyle && t4.classList.add("table-striped"), t4;
        } }, { key: "getErrorMessage", value: function(t4) {
          var e4 = document.createElement("div");
          return e4.classList.add("alert", "alert-danger"), e4.setAttribute("role", "alert"), e4.appendChild(document.createTextNode(t4)), e4;
        } }, { key: "addInputError", value: function(t4, e4) {
          t4.controlgroup && (t4.controlgroup.classList.add("is-invalid"), t4.errmsg || (t4.errmsg = document.createElement("p"), t4.errmsg.classList.add("invalid-feedback"), t4.controlgroup.appendChild(t4.errmsg), t4.errmsg.style.display = "block"), t4.errmsg.style.display = "block", t4.errmsg.textContent = e4);
        } }, { key: "removeInputError", value: function(t4) {
          t4.errmsg && (t4.errmsg.style.display = "none", t4.controlgroup.classList.remove("is-invalid"));
        } }, { key: "getTabHolder", value: function(t4) {
          var e4 = document.createElement("div"), r3 = void 0 === t4 ? "" : t4;
          return e4.innerHTML = "<div class='col-md-2' id='".concat(r3, "'><ul class='nav flex-column nav-pills'></ul></div><div class='col-md-10'><div class='tab-content' id='").concat(r3, "'></div></div>"), e4.classList.add("row"), e4;
        } }, { key: "addTab", value: function(t4, e4) {
          t4.children[0].children[0].appendChild(e4);
        } }, { key: "getTabContentHolder", value: function(t4) {
          return t4.children[1].children[0];
        } }, { key: "getTopTabHolder", value: function(t4) {
          var e4 = void 0 === t4 ? "" : t4, r3 = document.createElement("div");
          return r3.classList.add("card"), r3.innerHTML = "<div class='card-header'><ul class='nav nav-tabs card-header-tabs' id='".concat(e4, "'></ul></div><div class='card-body'><div class='tab-content' id='").concat(e4, "'></div></div>"), r3;
        } }, { key: "getTab", value: function(t4, e4) {
          var r3 = document.createElement("li");
          r3.classList.add("nav-item");
          var n3 = document.createElement("a");
          return n3.classList.add("nav-link"), n3.setAttribute("href", "#".concat(e4)), n3.setAttribute("data-toggle", "tab"), n3.appendChild(t4), r3.appendChild(n3), r3;
        } }, { key: "getTopTab", value: function(t4, e4) {
          var r3 = document.createElement("li");
          r3.classList.add("nav-item");
          var n3 = document.createElement("a");
          return n3.classList.add("nav-link"), n3.setAttribute("href", "#".concat(e4)), n3.setAttribute("data-toggle", "tab"), n3.appendChild(t4), r3.appendChild(n3), r3;
        } }, { key: "getTabContent", value: function() {
          var t4 = document.createElement("div");
          return t4.classList.add("tab-pane"), t4.setAttribute("role", "tabpanel"), t4;
        } }, { key: "getTopTabContent", value: function() {
          var t4 = document.createElement("div");
          return t4.classList.add("tab-pane"), t4.setAttribute("role", "tabpanel"), t4;
        } }, { key: "markTabActive", value: function(t4) {
          t4.tab.firstChild.classList.add("active"), void 0 !== t4.rowPane ? t4.rowPane.classList.add("active") : t4.container.classList.add("active");
        } }, { key: "markTabInactive", value: function(t4) {
          t4.tab.firstChild.classList.remove("active"), void 0 !== t4.rowPane ? t4.rowPane.classList.remove("active") : t4.container.classList.remove("active");
        } }, { key: "insertBasicTopTab", value: function(t4, e4) {
          e4.children[0].children[0].insertBefore(t4, e4.children[0].children[0].firstChild);
        } }, { key: "addTopTab", value: function(t4, e4) {
          t4.children[0].children[0].appendChild(e4);
        } }, { key: "getTopTabContentHolder", value: function(t4) {
          return t4.children[1].children[0];
        } }, { key: "getFirstTab", value: function(t4) {
          return t4.firstChild.firstChild.firstChild;
        } }, { key: "getProgressBar", value: function() {
          var t4 = document.createElement("div");
          t4.classList.add("progress");
          var e4 = document.createElement("div");
          return e4.classList.add("progress-bar"), e4.setAttribute("role", "progressbar"), e4.setAttribute("aria-valuenow", 0), e4.setAttribute("aria-valuemin", 0), e4.setAttribute("aria-valuenax", 100), e4.innerHTML = "".concat(0, "%"), t4.appendChild(e4), t4;
        } }, { key: "updateProgressBar", value: function(t4, e4) {
          if (t4) {
            var r3 = t4.firstChild, n3 = "".concat(e4, "%");
            r3.setAttribute("aria-valuenow", e4), r3.style.width = n3, r3.innerHTML = n3;
          }
        } }, { key: "updateProgressBarUnknown", value: function(t4) {
          if (t4) {
            var e4 = t4.firstChild;
            t4.classList.add("progress", "progress-striped", "active"), e4.removeAttribute("aria-valuenow"), e4.style.width = "100%", e4.innerHTML = "";
          }
        } }, { key: "getBlockLink", value: function() {
          var t4 = document.createElement("a");
          return t4.classList.add("mb-3", "d-inline-block"), t4;
        } }, { key: "getLinksHolder", value: function() {
          return document.createElement("div");
        } }, { key: "getInputGroup", value: function(t4, e4) {
          if (t4) {
            var r3 = document.createElement("div");
            r3.classList.add("input-group"), r3.appendChild(t4);
            var n3 = document.createElement("div");
            n3.classList.add("input-group-append"), r3.appendChild(n3);
            for (var i3 = 0; i3 < e4.length; i3++)
              e4[i3].classList.remove("mr-2", "btn-secondary"), e4[i3].classList.add("btn-outline-secondary"), n3.appendChild(e4[i3]);
            return r3;
          }
        } }]) && wo(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), a2;
      }(oo);
      function Co(t3) {
        return Co = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, Co(t3);
      }
      function Eo(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== Co(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== Co(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === Co(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      function So() {
        return So = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t3, e3, r2) {
          var n2 = function(t4, e4) {
            for (; !Object.prototype.hasOwnProperty.call(t4, e4) && null !== (t4 = To(t4)); )
              ;
            return t4;
          }(t3, e3);
          if (n2) {
            var i2 = Object.getOwnPropertyDescriptor(n2, e3);
            return i2.get ? i2.get.call(arguments.length < 3 ? t3 : r2) : i2.value;
          }
        }, So.apply(this, arguments);
      }
      function Po(t3, e3) {
        return Po = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, Po(t3, e3);
      }
      function To(t3) {
        return To = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, To(t3);
      }
      xo.rules = { ".jsoneditor-twbs4-text-button": "background:none;padding:0;border:0;color:currentColor", "td > .form-group": "margin-bottom:0", ".json-editor-btn-upload": "margin-top:1rem", ".je-noindent .card": "padding:0;border:0", ".je-tooltip:hover::before": "display:block;position:absolute;font-size:0.8em;color:%23fff;border-radius:0.2em;content:attr(title);background-color:%23000;margin-top:-2.5em;padding:0.3em", ".je-tooltip:hover::after": "display:block;position:absolute;font-size:0.8em;color:%23fff", ".select2-container--default .select2-selection--single": "height:calc(1.5em%20%2B%200.75rem%20%2B%202px)", ".select2-container--default   .select2-selection--single   .select2-selection__arrow": "height:calc(1.5em%20%2B%200.75rem%20%2B%202px)", ".select2-container--default   .select2-selection--single   .select2-selection__rendered": "line-height:calc(1.5em%20%2B%200.75rem%20%2B%202px)", ".selectize-control.form-control": "padding:0", ".selectize-dropdown.form-control": "padding:0;height:auto", ".je-upload-preview img": "float:left;margin:0%200.5rem%200.5rem%200;max-width:100%25;max-height:5rem", ".je-dropzone": "position:relative;margin:0.5rem%200;border:2px%20dashed%20black;width:100%25;height:60px;background:teal;transition:all%200.5s", ".je-dropzone:before": "position:absolute;content:attr(data-text);color:rgba(0%2C%200%2C%200%2C%200.6);left:50%25;top:50%25;transform:translate(-50%25%2C%20-50%25)", ".je-dropzone.valid-dropzone": "background:green", ".je-dropzone.invalid-dropzone": "background:red" };
      var Lo = { disable_theme_rules: false, input_size: "normal", object_indent: true, object_background: "bg-light", object_text: "", table_border: false, table_zebrastyle: false, tooltip: "bootstrap" }, Ro = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && Po(t4, e4);
        }(a2, t3);
        var e3, r2, n2, i2, o2 = (n2 = a2, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = To(n2);
          if (i2) {
            var r3 = To(this).constructor;
            t4 = Reflect.construct(e4, arguments, r3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === Co(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function a2(t4) {
          return function(t5, e4) {
            if (!(t5 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), o2.call(this, t4, Lo);
        }
        return e3 = a2, (r2 = [{ key: "getSelectInput", value: function(t4, e4) {
          var r3 = So(To(a2.prototype), "getSelectInput", this).call(this, t4);
          return r3.classList.add("form-control"), r3.classList.add("form-select"), "small" === this.options.input_size && r3.classList.add("form-control-sm"), "large" === this.options.input_size && r3.classList.add("form-control-lg"), r3;
        } }, { key: "getContainer", value: function() {
          var t4 = document.createElement("div");
          return this.options.object_indent || t4.classList.add("je-noindent"), t4;
        } }, { key: "setGridColumnSize", value: function(t4, e4, r3) {
          t4.classList.add("col-md-".concat(e4)), r3 && t4.classList.add("offset-md-".concat(r3));
        } }, { key: "afterInputReady", value: function(t4) {
          if (!t4.controlgroup) {
            var e4 = t4.name;
            t4.id = e4;
            var r3 = t4.parentNode.parentNode.getElementsByTagName("label")[0];
            r3 && (r3.classList.add("form-label"), r3.htmlFor = e4), t4.controlgroup = this.closest(t4, ".form-group");
          }
        } }, { key: "getTextareaInput", value: function() {
          var t4 = document.createElement("textarea");
          return t4.classList.add("form-control"), "small" === this.options.input_size && t4.classList.add("form-control-sm"), "large" === this.options.input_size && t4.classList.add("form-control-lg"), t4;
        } }, { key: "getRangeInput", value: function(t4, e4, r3) {
          var n3 = So(To(a2.prototype), "getRangeInput", this).call(this, t4, e4, r3);
          return n3.classList.remove("form-control"), n3.classList.add("form-range"), n3;
        } }, { key: "getStepperButtons", value: function(t4) {
          var e4 = document.createElement("div"), r3 = document.createElement("button");
          r3.setAttribute("type", "button");
          var n3 = document.createElement("button");
          n3.setAttribute("type", "button"), e4.appendChild(r3), e4.appendChild(t4), e4.appendChild(n3), e4.classList.add("input-group"), r3.classList.add("btn"), r3.classList.add("btn-secondary"), r3.classList.add("stepper-down"), n3.classList.add("btn"), n3.classList.add("btn-secondary"), n3.classList.add("stepper-up"), t4.getAttribute("readonly") && (r3.setAttribute("disabled", true), n3.setAttribute("disabled", true)), r3.textContent = "-", n3.textContent = "+";
          var i3 = function(t5, e5) {
            t5.value = Number(e5 || t5.value), t5.setAttribute("initialized", "1");
          }, o3 = t4.getAttribute("min"), a3 = t4.getAttribute("max");
          return t4.addEventListener("change", function() {
            t4.getAttribute("initialized") || t4.setAttribute("initialized", "1");
          }), r3.addEventListener("click", function() {
            t4.getAttribute("initialized") ? o3 ? Number(t4.value) > Number(o3) && t4.stepDown() : t4.stepDown() : i3(t4, o3), c2(t4, "change");
          }), n3.addEventListener("click", function() {
            t4.getAttribute("initialized") ? a3 ? Number(t4.value) < Number(a3) && t4.stepUp() : t4.stepUp() : i3(t4, o3), c2(t4, "change");
          }), e4;
        } }, { key: "getFormInputField", value: function(t4) {
          var e4 = So(To(a2.prototype), "getFormInputField", this).call(this, t4);
          return "checkbox" !== t4 && "radio" !== t4 && (e4.classList.add("form-control"), "small" === this.options.input_size && e4.classList.add("form-control-sm"), "large" === this.options.input_size && e4.classList.add("form-control-lg")), e4;
        } }, { key: "getFormControl", value: function(t4, e4, r3, n3) {
          var i3 = document.createElement("div");
          if (i3.classList.add("form-group"), !t4 || "checkbox" !== e4.type && "radio" !== e4.type)
            t4 && (t4.classList.add("form-label"), i3.appendChild(t4), n3 && i3.appendChild(n3)), i3.appendChild(e4);
          else {
            var o3 = document.createElement("div");
            o3.classList.add("form-check"), e4.classList.add("form-check-input"), t4.classList.add("form-check-label");
            var a3 = (Date.now() * Math.random()).toFixed(0);
            e4.setAttribute("id", a3), t4.setAttribute("for", a3), o3.appendChild(e4), o3.appendChild(t4), n3 && o3.appendChild(n3), i3.appendChild(o3);
          }
          return r3 && i3.appendChild(r3), i3;
        } }, { key: "getInfoButton", value: function(t4) {
          var e4 = document.createElement("button");
          e4.type = "button", e4.classList.add("ms-3", "jsoneditor-twbs5-text-button"), e4.setAttribute("data-toggle", "tooltip"), e4.setAttribute("data-placement", "auto"), e4.title = t4;
          var r3 = document.createTextNode("ⓘ");
          return e4.appendChild(r3), "bootstrap" === this.options.tooltip ? window.jQuery && window.jQuery().tooltip ? window.jQuery(e4).tooltip() : console.warn("Could not find popper jQuery plugin of Bootstrap.") : "css" === this.options.tooltip && e4.classList.add("je-tooltip"), e4;
        } }, { key: "getCheckbox", value: function() {
          return this.getFormInputField("checkbox");
        } }, { key: "getMultiCheckboxHolder", value: function(t4, e4, r3, n3) {
          var i3 = document.createElement("div");
          i3.classList.add("form-group"), e4 && (i3.appendChild(e4), n3 && e4.appendChild(n3));
          var o3 = document.createElement("div");
          return Object.values(t4).forEach(function(t5) {
            var e5 = t5.firstChild;
            o3.appendChild(e5);
          }), i3.appendChild(o3), r3 && i3.appendChild(r3), i3;
        } }, { key: "getFormRadio", value: function(t4) {
          var e4 = this.getFormInputField("radio");
          for (var r3 in t4)
            e4.setAttribute(r3, t4[r3]);
          return e4.classList.add("form-check-input"), e4;
        } }, { key: "getFormRadioLabel", value: function(t4, e4) {
          var r3 = document.createElement("label");
          return r3.classList.add("form-check-label"), r3.appendChild(document.createTextNode(t4)), r3;
        } }, { key: "getFormRadioControl", value: function(t4, e4, r3) {
          var n3 = document.createElement("div");
          return n3.classList.add("form-check"), n3.appendChild(e4), n3.appendChild(t4), r3 && n3.classList.add("form-check-inline"), n3;
        } }, { key: "getIndentedPanel", value: function() {
          var t4 = document.createElement("div");
          return t4.classList.add("card", "card-body", "my-3"), this.options.object_background && t4.classList.add(this.options.object_background), this.options.object_text && t4.classList.add(this.options.object_text), t4;
        } }, { key: "getFormInputDescription", value: function(t4) {
          var e4 = document.createElement("small");
          return e4.classList.add("form-text"), e4.classList.add("d-block"), window.DOMPurify ? e4.innerHTML = window.DOMPurify.sanitize(t4) : e4.textContent = this.cleanText(t4), e4;
        } }, { key: "getHeader", value: function(t4, e4) {
          var r3 = document.createElement("h3");
          return r3.classList.add("card-title"), r3.classList.add("level-" + e4), "string" == typeof t4 ? r3.textContent = t4 : r3.appendChild(t4), r3.style.display = "inline-block", r3;
        } }, { key: "getHeaderButtonHolder", value: function() {
          return this.getButtonHolder();
        } }, { key: "getButtonHolder", value: function() {
          var t4 = document.createElement("span");
          return t4.classList.add("btn-group"), t4;
        } }, { key: "getFormButtonHolder", value: function(t4) {
          var e4 = this.getButtonHolder();
          return e4.classList.add("d-block"), "center" === t4 ? e4.classList.add("text-center") : "right" === t4 && e4.classList.add("text-end"), e4;
        } }, { key: "getButton", value: function(t4, e4, r3) {
          var n3 = So(To(a2.prototype), "getButton", this).call(this, t4, e4, r3);
          return n3.classList.add("btn", "btn-secondary", "btn-sm"), n3;
        } }, { key: "getTable", value: function() {
          var t4 = document.createElement("table");
          return t4.classList.add("table", "table-sm"), this.options.table_border && t4.classList.add("table-bordered"), this.options.table_zebrastyle && t4.classList.add("table-striped"), t4;
        } }, { key: "getErrorMessage", value: function(t4) {
          var e4 = document.createElement("div");
          return e4.classList.add("alert", "alert-danger"), e4.setAttribute("role", "alert"), e4.appendChild(document.createTextNode(t4)), e4;
        } }, { key: "addInputError", value: function(t4, e4) {
          t4.controlgroup && (t4.controlgroup.classList.add("is-invalid"), t4.errmsg || (t4.errmsg = document.createElement("p"), t4.errmsg.classList.add("invalid-feedback"), t4.controlgroup.appendChild(t4.errmsg), t4.errmsg.style.display = "block"), t4.errmsg.style.display = "block", t4.errmsg.textContent = e4);
        } }, { key: "removeInputError", value: function(t4) {
          t4.errmsg && (t4.errmsg.style.display = "none", t4.controlgroup.classList.remove("is-invalid"));
        } }, { key: "getTabHolder", value: function(t4) {
          var e4 = document.createElement("div"), r3 = void 0 === t4 ? "" : t4;
          return e4.innerHTML = "<div class='col-md-2' id='".concat(r3, "'><ul class='nav flex-column nav-pills'></ul></div><div class='col-md-10'><div class='tab-content' id='").concat(r3, "'></div></div>"), e4.classList.add("row"), e4;
        } }, { key: "addTab", value: function(t4, e4) {
          t4.children[0].children[0].appendChild(e4);
        } }, { key: "getTabContentHolder", value: function(t4) {
          return t4.children[1].children[0];
        } }, { key: "getTopTabHolder", value: function(t4) {
          var e4 = void 0 === t4 ? "" : t4, r3 = document.createElement("div");
          return r3.classList.add("card"), r3.innerHTML = "<div class='card-header'><ul class='nav nav-tabs card-header-tabs' id='".concat(e4, "'></ul></div><div class='card-body'><div class='tab-content' id='").concat(e4, "'></div></div>"), r3;
        } }, { key: "getTab", value: function(t4, e4) {
          var r3 = document.createElement("li");
          r3.classList.add("nav-item");
          var n3 = document.createElement("a");
          return n3.classList.add("nav-link"), n3.setAttribute("href", "#".concat(e4)), n3.setAttribute("data-toggle", "tab"), n3.appendChild(t4), r3.appendChild(n3), r3;
        } }, { key: "getTopTab", value: function(t4, e4) {
          var r3 = document.createElement("li");
          r3.classList.add("nav-item");
          var n3 = document.createElement("a");
          return n3.classList.add("nav-link"), n3.setAttribute("href", "#".concat(e4)), n3.setAttribute("data-toggle", "tab"), n3.appendChild(t4), r3.appendChild(n3), r3;
        } }, { key: "getTabContent", value: function() {
          var t4 = document.createElement("div");
          return t4.classList.add("tab-pane"), t4.setAttribute("role", "tabpanel"), t4;
        } }, { key: "getTopTabContent", value: function() {
          var t4 = document.createElement("div");
          return t4.classList.add("tab-pane"), t4.setAttribute("role", "tabpanel"), t4;
        } }, { key: "markTabActive", value: function(t4) {
          t4.tab.firstChild.classList.add("active"), void 0 !== t4.rowPane ? t4.rowPane.classList.add("active") : t4.container.classList.add("active");
        } }, { key: "markTabInactive", value: function(t4) {
          t4.tab.firstChild.classList.remove("active"), void 0 !== t4.rowPane ? t4.rowPane.classList.remove("active") : t4.container.classList.remove("active");
        } }, { key: "insertBasicTopTab", value: function(t4, e4) {
          e4.children[0].children[0].insertBefore(t4, e4.children[0].children[0].firstChild);
        } }, { key: "addTopTab", value: function(t4, e4) {
          t4.children[0].children[0].appendChild(e4);
        } }, { key: "getTopTabContentHolder", value: function(t4) {
          return t4.children[1].children[0];
        } }, { key: "getFirstTab", value: function(t4) {
          return t4.firstChild.firstChild.firstChild;
        } }, { key: "getProgressBar", value: function() {
          var t4 = document.createElement("div");
          t4.classList.add("progress");
          var e4 = document.createElement("div");
          return e4.classList.add("progress-bar"), e4.setAttribute("role", "progressbar"), e4.setAttribute("aria-valuenow", 0), e4.setAttribute("aria-valuemin", 0), e4.setAttribute("aria-valuenax", 100), e4.innerHTML = "".concat(0, "%"), t4.appendChild(e4), t4;
        } }, { key: "updateProgressBar", value: function(t4, e4) {
          if (t4) {
            var r3 = t4.firstChild, n3 = "".concat(e4, "%");
            r3.setAttribute("aria-valuenow", e4), r3.style.width = n3, r3.innerHTML = n3;
          }
        } }, { key: "updateProgressBarUnknown", value: function(t4) {
          if (t4) {
            var e4 = t4.firstChild;
            t4.classList.add("progress", "progress-striped", "active"), e4.removeAttribute("aria-valuenow"), e4.style.width = "100%", e4.innerHTML = "";
          }
        } }, { key: "getBlockLink", value: function() {
          var t4 = document.createElement("a");
          return t4.classList.add("mb-3", "d-inline-block"), t4;
        } }, { key: "getLinksHolder", value: function() {
          return document.createElement("div");
        } }, { key: "getInputGroup", value: function(t4, e4) {
          if (t4) {
            var r3 = document.createElement("div");
            r3.classList.add("input-group"), r3.appendChild(t4);
            for (var n3 = 0; n3 < e4.length; n3++)
              e4[n3].classList.remove("me-2", "btn-secondary"), e4[n3].classList.add("btn-outline-secondary"), r3.appendChild(e4[n3]);
            return r3;
          }
        } }]) && Eo(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), a2;
      }(oo);
      function Ao(t3) {
        return Ao = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, Ao(t3);
      }
      function Io(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== Ao(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== Ao(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === Ao(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      function Bo() {
        return Bo = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t3, e3, r2) {
          var n2 = function(t4, e4) {
            for (; !Object.prototype.hasOwnProperty.call(t4, e4) && null !== (t4 = Do(t4)); )
              ;
            return t4;
          }(t3, e3);
          if (n2) {
            var i2 = Object.getOwnPropertyDescriptor(n2, e3);
            return i2.get ? i2.get.call(arguments.length < 3 ? t3 : r2) : i2.value;
          }
        }, Bo.apply(this, arguments);
      }
      function No(t3, e3) {
        return No = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, No(t3, e3);
      }
      function Do(t3) {
        return Do = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, Do(t3);
      }
      Ro.rules = { ".form-group": "margin-bottom:1rem", ".form-text": "display:block", ".jsoneditor-twbs5-text-button": "background:none;padding:0;border:0;color:currentColor", "td > .form-group": "margin-bottom:0", ".json-editor-btn-upload": "margin-top:1rem", ".je-noindent .card": "padding:0;border:0", ".je-tooltip:hover::before": "display:block;position:absolute;font-size:0.8em;color:%23fff;border-radius:0.2em;content:attr(title);background-color:%23000;margin-top:-2.5em;padding:0.3em", ".je-tooltip:hover::after": "display:block;position:absolute;font-size:0.8em;color:%23fff", ".select2-container--default .select2-selection--single": "height:calc(1.5em%20%2B%200.75rem%20%2B%202px)", ".select2-container--default   .select2-selection--single   .select2-selection__arrow": "height:calc(1.5em%20%2B%200.75rem%20%2B%202px)", ".select2-container--default   .select2-selection--single   .select2-selection__rendered": "line-height:calc(1.5em%20%2B%200.75rem%20%2B%202px)", ".selectize-control.form-control": "padding:0", ".selectize-dropdown.form-control": "padding:0;height:auto", ".je-upload-preview img": "float:left;margin:0%200.5rem%200.5rem%200;max-width:100%25;max-height:5rem", ".je-dropzone": "position:relative;margin:0.5rem%200;border:2px%20dashed%20black;width:100%25;height:60px;background:teal;transition:all%200.5s", ".je-dropzone:before": "position:absolute;content:attr(data-text);color:rgba(0%2C%200%2C%200%2C%200.6);left:50%25;top:50%25;transform:translate(-50%25%2C%20-50%25)", ".je-dropzone.valid-dropzone": "background:green", ".je-dropzone.invalid-dropzone": "background:red" };
      var Fo = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && No(t4, e4);
        }(a2, t3);
        var e3, r2, n2, i2, o2 = (n2 = a2, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = Do(n2);
          if (i2) {
            var r3 = Do(this).constructor;
            t4 = Reflect.construct(e4, arguments, r3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === Ao(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function a2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), o2.apply(this, arguments);
        }
        return e3 = a2, (r2 = [{ key: "getTable", value: function() {
          var t4 = Bo(Do(a2.prototype), "getTable", this).call(this);
          return t4.setAttribute("cellpadding", 5), t4.setAttribute("cellspacing", 0), t4;
        } }, { key: "getTableHeaderCell", value: function(t4) {
          var e4 = Bo(Do(a2.prototype), "getTableHeaderCell", this).call(this, t4);
          return e4.classList.add("ui-state-active"), e4.style.fontWeight = "bold", e4;
        } }, { key: "getTableCell", value: function() {
          var t4 = Bo(Do(a2.prototype), "getTableCell", this).call(this);
          return t4.classList.add("ui-widget-content"), t4;
        } }, { key: "getHeaderButtonHolder", value: function() {
          var t4 = this.getButtonHolder();
          return t4.style.marginLeft = "10px", t4.style.fontSize = ".6em", t4.style.display = "inline-block", t4;
        } }, { key: "getFormInputDescription", value: function(t4) {
          var e4 = this.getDescription(t4);
          return e4.style.marginLeft = "10px", e4.style.display = "inline-block", e4;
        } }, { key: "getFormControl", value: function(t4, e4, r3, n3) {
          var i3 = Bo(Do(a2.prototype), "getFormControl", this).call(this, t4, e4, r3, n3);
          return "checkbox" === e4.type ? (i3.style.lineHeight = "25px", i3.style.padding = "3px 0") : i3.style.padding = "4px 0 8px 0", i3;
        } }, { key: "getDescription", value: function(t4) {
          var e4 = document.createElement("span");
          return e4.style.fontSize = ".8em", e4.style.fontStyle = "italic", window.DOMPurify ? e4.innerHTML = window.DOMPurify.sanitize(t4) : e4.textContent = this.cleanText(t4), e4;
        } }, { key: "getButtonHolder", value: function() {
          var t4 = document.createElement("div");
          return t4.classList.add("ui-buttonset"), t4.style.fontSize = ".7em", t4;
        } }, { key: "getFormInputLabel", value: function(t4, e4) {
          var r3 = document.createElement("label");
          return r3.style.fontWeight = "bold", r3.style.display = "block", r3.textContent = t4, e4 && r3.classList.add("required"), r3;
        } }, { key: "getButton", value: function(t4, e4, r3) {
          var n3 = document.createElement("button");
          n3.classList.add("ui-button", "ui-widget", "ui-state-default", "ui-corner-all"), e4 && !t4 ? (n3.classList.add("ui-button-icon-only"), e4.classList.add("ui-button-icon-primary", "ui-icon-primary"), n3.appendChild(e4)) : e4 ? (n3.classList.add("ui-button-text-icon-primary"), e4.classList.add("ui-button-icon-primary", "ui-icon-primary"), n3.appendChild(e4)) : n3.classList.add("ui-button-text-only");
          var i3 = document.createElement("span");
          return i3.classList.add("ui-button-text"), i3.textContent = t4 || r3 || ".", n3.appendChild(i3), n3.setAttribute("title", r3), n3;
        } }, { key: "setButtonText", value: function(t4, e4, r3, n3) {
          t4.innerHTML = "", t4.classList.add("ui-button", "ui-widget", "ui-state-default", "ui-corner-all"), r3 && !e4 ? (t4.classList.add("ui-button-icon-only"), r3.classList.add("ui-button-icon-primary", "ui-icon-primary"), t4.appendChild(r3)) : r3 ? (t4.classList.add("ui-button-text-icon-primary"), r3.classList.add("ui-button-icon-primary", "ui-icon-primary"), t4.appendChild(r3)) : t4.classList.add("ui-button-text-only");
          var i3 = document.createElement("span");
          i3.classList.add("ui-button-text"), i3.textContent = e4 || n3 || ".", t4.appendChild(i3), t4.setAttribute("title", n3);
        } }, { key: "getIndentedPanel", value: function() {
          var t4 = document.createElement("div");
          return t4.classList.add("ui-widget-content", "ui-corner-all"), t4.style.padding = "1em 1.4em", t4.style.marginBottom = "20px", t4;
        } }, { key: "afterInputReady", value: function(t4) {
          if (!t4.controls && (t4.controls = this.closest(t4, ".form-control"), this.queuedInputErrorText)) {
            var e4 = this.queuedInputErrorText;
            delete this.queuedInputErrorText, this.addInputError(t4, e4);
          }
        } }, { key: "addInputError", value: function(t4, e4) {
          t4.controls ? (t4.errmsg ? t4.errmsg.style.display = "" : (t4.errmsg = document.createElement("div"), t4.errmsg.classList.add("ui-state-error"), t4.controls.appendChild(t4.errmsg)), t4.errmsg.textContent = e4) : this.queuedInputErrorText = e4;
        } }, { key: "removeInputError", value: function(t4) {
          t4.controls || delete this.queuedInputErrorText, t4.errmsg && (t4.errmsg.style.display = "none");
        } }, { key: "markTabActive", value: function(t4) {
          t4.tab.classList.remove("ui-widget-header"), t4.tab.classList.add("ui-state-active"), void 0 !== t4.rowPane ? t4.rowPane.style.display = "" : t4.container.style.display = "";
        } }, { key: "markTabInactive", value: function(t4) {
          t4.tab.classList.add("ui-widget-header"), t4.tab.classList.remove("ui-state-active"), void 0 !== t4.rowPane ? t4.rowPane.style.display = "none" : t4.container.style.display = "none";
        } }]) && Io(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), a2;
      }(oo);
      function Vo(t3) {
        return Vo = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, Vo(t3);
      }
      function zo(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== Vo(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== Vo(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === Vo(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      function Ho(t3, e3) {
        return Ho = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, Ho(t3, e3);
      }
      function Mo(t3) {
        return Mo = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, Mo(t3);
      }
      Fo.rules = { 'div[data-schemaid="root"]:after': 'position:relative;color:red;margin:10px 0;font-weight:600;display:block;width:100%;text-align:center;content:"This is an old JSON-Editor 1.x Theme and might not display elements correctly when used with the 2.x version"' };
      var qo = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && Ho(t4, e4);
        }(a2, t3);
        var e3, r2, n2, i2, o2 = (n2 = a2, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = Mo(n2);
          if (i2) {
            var r3 = Mo(this).constructor;
            t4 = Reflect.construct(e4, arguments, r3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === Vo(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function a2() {
          return function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), o2.apply(this, arguments);
        }
        return e3 = a2, (r2 = [{ key: "addInputError", value: function(t4, e4) {
          if (t4.errmsg)
            t4.errmsg.style.display = "block";
          else {
            var r3 = this.closest(t4, ".form-control");
            t4.errmsg = document.createElement("div"), t4.errmsg.setAttribute("class", "errmsg"), r3.nodeName && r3.appendChild(t4.errmsg);
          }
          t4.errmsg.innerHTML = "", t4.errmsg.appendChild(document.createTextNode(e4));
        } }, { key: "removeInputError", value: function(t4) {
          t4.style && (t4.style.borderColor = ""), t4.errmsg && (t4.errmsg.style.display = "none");
        } }]) && zo(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), a2;
      }(oo);
      function Go(t3) {
        return Go = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, Go(t3);
      }
      function Uo(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== Go(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== Go(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === Go(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      function $o() {
        return $o = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t3, e3, r2) {
          var n2 = function(t4, e4) {
            for (; !Object.prototype.hasOwnProperty.call(t4, e4) && null !== (t4 = Wo(t4)); )
              ;
            return t4;
          }(t3, e3);
          if (n2) {
            var i2 = Object.getOwnPropertyDescriptor(n2, e3);
            return i2.get ? i2.get.call(arguments.length < 3 ? t3 : r2) : i2.value;
          }
        }, $o.apply(this, arguments);
      }
      function Jo(t3, e3) {
        return Jo = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, Jo(t3, e3);
      }
      function Wo(t3) {
        return Wo = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, Wo(t3);
      }
      qo.rules = { ".je-upload-preview img": "float:left;margin:0%200.5rem%200.5rem%200;max-width:100%25;max-height:5rem", ".je-dropzone": "position:relative;margin:0.5rem%200;border:2px%20dashed%20black;width:100%25;height:60px;background:teal;transition:all%200.5s", ".je-dropzone:before": "position:absolute;content:attr(data-text);color:rgba(0%2C%200%2C%200%2C%200.6);left:50%25;top:50%25;transform:translate(-50%25%2C%20-50%25)", ".je-dropzone.valid-dropzone": "background:green", ".je-dropzone.invalid-dropzone": "background:red" };
      var Zo = { disable_theme_rules: false, label_bold: true, align_bottom: false, object_indent: false, object_border: false, table_border: false, table_zebrastyle: false, input_size: "normal" }, Yo = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && Jo(t4, e4);
        }(a2, t3);
        var e3, r2, n2, i2, o2 = (n2 = a2, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = Wo(n2);
          if (i2) {
            var r3 = Wo(this).constructor;
            t4 = Reflect.construct(e4, arguments, r3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === Go(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function a2(t4) {
          return function(t5, e4) {
            if (!(t5 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), o2.call(this, t4, Zo);
        }
        return e3 = a2, (r2 = [{ key: "setGridColumnSize", value: function(t4, e4, r3) {
          t4.classList.add("col-".concat(e4)), r3 && t4.classList.add("col-mx-auto");
        } }, { key: "getGridContainer", value: function() {
          var t4 = document.createElement("div");
          return t4.classList.add("container"), this.options.object_indent || t4.classList.add("je-noindent"), t4;
        } }, { key: "getGridRow", value: function() {
          var t4 = document.createElement("div");
          return t4.classList.add("columns"), t4;
        } }, { key: "getGridColumn", value: function() {
          var t4 = document.createElement("div");
          return t4.classList.add("column"), this.options.align_bottom && t4.classList.add("je-align-bottom"), t4;
        } }, { key: "getIndentedPanel", value: function() {
          var t4 = document.createElement("div");
          return t4.classList.add("je-panel"), this.options.object_border && t4.classList.add("je-border"), t4;
        } }, { key: "getTopIndentedPanel", value: function() {
          var t4 = document.createElement("div");
          return t4.classList.add("je-panel-top"), this.options.object_border && t4.classList.add("je-border"), t4;
        } }, { key: "getHeaderButtonHolder", value: function() {
          return this.getButtonHolder();
        } }, { key: "getButtonHolder", value: function() {
          var t4 = $o(Wo(a2.prototype), "getButtonHolder", this).call(this);
          return t4.classList.add("btn-group"), t4;
        } }, { key: "getFormButtonHolder", value: function(t4) {
          var e4 = $o(Wo(a2.prototype), "getFormButtonHolder", this).call(this);
          return e4.classList.remove("btn-group"), e4.classList.add("d-block"), "center" === t4 ? e4.classList.add("text-center") : "right" === t4 ? e4.classList.add("text-right") : e4.classList.add("text-left"), e4;
        } }, { key: "getFormButton", value: function(t4, e4, r3) {
          var n3 = $o(Wo(a2.prototype), "getFormButton", this).call(this, t4, e4, r3);
          return n3.classList.add("btn", "btn-primary", "mx-2", "my-1"), "small" !== this.options.input_size && n3.classList.remove("btn-sm"), "large" === this.options.input_size && n3.classList.add("btn-lg"), n3;
        } }, { key: "getButton", value: function(t4, e4, r3) {
          var n3 = $o(Wo(a2.prototype), "getButton", this).call(this, t4, e4, r3);
          return n3.classList.add("btn", "btn-sm", "btn-primary", "mr-2", "my-1"), n3;
        } }, { key: "getHeader", value: function(t4, e4) {
          var r3 = document.createElement("h4");
          return "string" == typeof t4 ? r3.textContent = t4 : r3.appendChild(t4), r3.style.display = "inline-block", r3;
        } }, { key: "getFormInputDescription", value: function(t4) {
          var e4 = $o(Wo(a2.prototype), "getFormInputDescription", this).call(this, t4);
          return e4.classList.add("je-desc", "hide-sm"), e4;
        } }, { key: "getFormInputLabel", value: function(t4, e4) {
          var r3 = $o(Wo(a2.prototype), "getFormInputLabel", this).call(this, t4, e4);
          return this.options.label_bold && r3.classList.add("je-label"), r3;
        } }, { key: "getCheckbox", value: function() {
          return this.getFormInputField("checkbox");
        } }, { key: "getCheckboxLabel", value: function(t4, e4) {
          var r3 = $o(Wo(a2.prototype), "getCheckboxLabel", this).call(this, t4, e4), n3 = document.createElement("i");
          return n3.classList.add("form-icon"), r3.classList.add("form-checkbox", "pr-0"), r3.insertBefore(n3, r3.firstChild), r3;
        } }, { key: "getFormCheckboxControl", value: function(t4, e4, r3) {
          return t4.insertBefore(e4, t4.firstChild), r3 && t4.classList.add("form-inline"), t4;
        } }, { key: "getMultiCheckboxHolder", value: function(t4, e4, r3, n3) {
          return $o(Wo(a2.prototype), "getMultiCheckboxHolder", this).call(this, t4, e4, r3, n3);
        } }, { key: "getFormRadio", value: function(t4) {
          var e4 = this.getFormInputField("radio");
          for (var r3 in t4)
            e4.setAttribute(r3, t4[r3]);
          return e4;
        } }, { key: "getFormRadioLabel", value: function(t4, e4) {
          var r3 = $o(Wo(a2.prototype), "getFormRadioLabel", this).call(this, t4, e4), n3 = document.createElement("i");
          return n3.classList.add("form-icon"), r3.classList.add("form-radio"), r3.insertBefore(n3, r3.firstChild), r3;
        } }, { key: "getFormRadioControl", value: function(t4, e4, r3) {
          return t4.insertBefore(e4, t4.firstChild), r3 && t4.classList.add("form-inline"), t4;
        } }, { key: "getFormInputField", value: function(t4) {
          var e4 = $o(Wo(a2.prototype), "getFormInputField", this).call(this, t4);
          return ["checkbox", "radio"].includes(t4) || e4.classList.add("form-input"), e4;
        } }, { key: "getRangeInput", value: function(t4, e4, r3) {
          var n3 = this.getFormInputField("range");
          return n3.classList.add("slider"), n3.classList.remove("form-input"), n3.setAttribute("oninput", 'this.setAttribute("value", this.value)'), n3.setAttribute("min", t4), n3.setAttribute("max", e4), n3.setAttribute("step", r3), n3;
        } }, { key: "getRangeControl", value: function(t4, e4) {
          var r3 = $o(Wo(a2.prototype), "getRangeControl", this).call(this, t4, e4);
          return r3.classList.add("text-center"), r3;
        } }, { key: "getSelectInput", value: function(t4, e4) {
          var r3 = $o(Wo(a2.prototype), "getSelectInput", this).call(this, t4);
          return r3.classList.add("form-select"), r3;
        } }, { key: "getTextareaInput", value: function() {
          var t4 = document.createElement("textarea");
          return t4.classList.add("form-input"), t4;
        } }, { key: "getFormControl", value: function(t4, e4, r3, n3) {
          var i3 = document.createElement("div");
          return i3.classList.add("form-group"), !t4 || "checkbox" !== e4.type && "radio" !== e4.type ? (t4 && (t4.classList.add("form-label"), i3.appendChild(t4), n3 && t4.appendChild(n3)), i3.appendChild(e4)) : (i3.classList.add(e4.type), n3 && t4.appendChild(n3), t4.insertBefore(e4, t4.firstChild), i3.appendChild(t4)), "small" === this.options.input_size ? e4.classList.add("input-sm", "select-sm") : "large" === this.options.input_size && e4.classList.add("input-lg", "select-lg"), "checkbox" !== e4.type && i3.appendChild(e4), r3 && i3.appendChild(r3), i3;
        } }, { key: "getInputGroup", value: function(t4, e4) {
          if (t4) {
            var r3 = document.createElement("div");
            r3.classList.add("input-group"), r3.appendChild(t4);
            for (var n3 = 0; n3 < e4.length; n3++)
              e4[n3].classList.add("input-group-btn"), e4[n3].classList.remove("btn-sm", "mr-2", "my-1"), r3.appendChild(e4[n3]);
            return r3;
          }
        } }, { key: "getInfoButton", value: function(t4) {
          var e4 = document.createElement("div");
          e4.classList.add("popover", "popover-left", "float-right");
          var r3 = document.createElement("button");
          r3.classList.add("btn", "btn-secondary", "btn-info", "btn-action", "s-circle"), r3.setAttribute("tabindex", "-1"), e4.appendChild(r3);
          var n3 = document.createTextNode("I");
          r3.appendChild(n3);
          var i3 = document.createElement("div");
          i3.classList.add("popover-container"), e4.appendChild(i3);
          var o3 = document.createElement("div");
          o3.classList.add("card"), i3.appendChild(o3);
          var a3 = document.createElement("div");
          return a3.classList.add("card-body"), a3.innerHTML = t4, o3.appendChild(a3), e4;
        } }, { key: "getTable", value: function() {
          var t4 = $o(Wo(a2.prototype), "getTable", this).call(this);
          return t4.classList.add("table", "table-scroll"), this.options.table_border && t4.classList.add("je-table-border"), this.options.table_zebrastyle && t4.classList.add("table-striped"), t4;
        } }, { key: "getProgressBar", value: function() {
          var t4 = $o(Wo(a2.prototype), "getProgressBar", this).call(this);
          return t4.classList.add("progress"), t4;
        } }, { key: "getTabHolder", value: function(t4) {
          var e4 = void 0 === t4 ? "" : t4, r3 = document.createElement("div");
          return r3.classList.add("columns"), r3.innerHTML = '<div class="column col-2"></div><div class="column col-10 content" id="'.concat(e4, '"></div>'), r3;
        } }, { key: "getTopTabHolder", value: function(t4) {
          var e4 = void 0 === t4 ? "" : t4, r3 = document.createElement("div");
          return r3.innerHTML = '<ul class="tab"></ul><div class="content" id="'.concat(e4, '"></div>'), r3;
        } }, { key: "getTab", value: function(t4, e4) {
          var r3 = document.createElement("a");
          return r3.classList.add("btn", "btn-secondary", "btn-block"), r3.setAttribute("href", "#".concat(e4)), r3.appendChild(t4), r3;
        } }, { key: "getTopTab", value: function(t4, e4) {
          var r3 = document.createElement("li");
          r3.id = e4, r3.classList.add("tab-item");
          var n3 = document.createElement("a");
          return n3.setAttribute("href", "#".concat(e4)), n3.appendChild(t4), r3.appendChild(n3), r3;
        } }, { key: "markTabActive", value: function(t4) {
          t4.tab.classList.add("active"), void 0 !== t4.rowPane ? t4.rowPane.style.display = "" : t4.container.style.display = "";
        } }, { key: "markTabInactive", value: function(t4) {
          t4.tab.classList.remove("active"), void 0 !== t4.rowPane ? t4.rowPane.style.display = "none" : t4.container.style.display = "none";
        } }, { key: "afterInputReady", value: function(t4) {
          if ("select" === t4.localName) {
            if (t4.classList.contains("selectized")) {
              var e4 = t4.nextSibling;
              e4 && (e4.classList.remove("form-select"), Array.from(e4.querySelectorAll(".form-select")).forEach(function(t5) {
                t5.classList.remove("form-select");
              }));
            } else if (t4.classList.contains("select2-hidden-accessible")) {
              var r3 = t4.nextSibling;
              r3 && r3.querySelector(".select2-selection--single") && r3.classList.add("form-select");
            }
          }
          t4.controlgroup || (t4.controlgroup = this.closest(t4, ".form-group"), this.closest(t4, ".compact") && (t4.controlgroup.style.marginBottom = 0));
        } }, { key: "addInputError", value: function(t4, e4) {
          t4.controlgroup && (t4.controlgroup.classList.add("has-error"), t4.errmsg || (t4.errmsg = document.createElement("p"), t4.errmsg.classList.add("form-input-hint"), t4.controlgroup.appendChild(t4.errmsg)), t4.errmsg.classList.remove("d-hide"), t4.errmsg.textContent = e4);
        } }, { key: "removeInputError", value: function(t4) {
          t4.errmsg && (t4.errmsg.classList.add("d-hide"), t4.controlgroup.classList.remove("has-error"));
        } }]) && Uo(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), a2;
      }(oo);
      function Qo(t3) {
        return Qo = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, Qo(t3);
      }
      function Ko(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== Qo(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== Qo(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === Qo(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      function Xo() {
        return Xo = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t3, e3, r2) {
          var n2 = function(t4, e4) {
            for (; !Object.prototype.hasOwnProperty.call(t4, e4) && null !== (t4 = ea(t4)); )
              ;
            return t4;
          }(t3, e3);
          if (n2) {
            var i2 = Object.getOwnPropertyDescriptor(n2, e3);
            return i2.get ? i2.get.call(arguments.length < 3 ? t3 : r2) : i2.value;
          }
        }, Xo.apply(this, arguments);
      }
      function ta(t3, e3) {
        return ta = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
          return t4.__proto__ = e4, t4;
        }, ta(t3, e3);
      }
      function ea(t3) {
        return ea = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, ea(t3);
      }
      Yo.rules = { "*": "--primary-color:%235755d9;--gray-color:%23bcc3ce;--light-color:%23fff", ".slider:focus": "box-shadow:none", "h4 > label + .btn-group": "margin-left:1rem", ".text-right > button": "margin-right:0%20!important", ".text-left > button": "margin-left:0%20!important", ".property-selector": "font-size:0.7rem;font-weight:normal;max-height:260px%20!important;width:395px%20!important", ".property-selector .form-checkbox": "margin:0", textarea: "width:100%25;min-height:2rem;resize:vertical", table: "border-collapse:collapse", ".table td": "padding:0.4rem%200.4rem", ".mr-5": "margin-right:1rem%20!important", "div[data-schematype]:not([data-schematype='object'])": "transition:0.5s", "div[data-schematype]:not([data-schematype='object']):hover": "background-color:%23eee", ".je-table-border td": "border:0.05rem%20solid%20%23dadee4%20!important", ".btn-info": "font-size:0.5rem;font-weight:bold;height:0.8rem;padding:0.15rem%200;line-height:0.8;margin:0.3rem%200%200.3rem%200.1rem", ".je-label + select": "min-width:5rem", ".je-label": "font-weight:600", ".btn-action.btn-info": "width:0.8rem", ".je-border": "border:0.05rem%20solid%20%23dadee4", ".je-panel": "padding:0.2rem;margin:0.2rem;background-color:rgba(218%2C%20222%2C%20228%2C%200.1)", ".je-panel-top": "padding:0.2rem;margin:0.2rem;background-color:rgba(218%2C%20222%2C%20228%2C%200.1)", ".required:after": "content:%22%20*%22;color:red;font:inherit", ".je-align-bottom": "margin-top:auto", ".je-desc": "font-size:smaller;margin:0.2rem%200", ".je-upload-preview img": "float:left;margin:0%200.5rem%200.5rem%200;max-width:100%25;max-height:5rem;border:3px%20solid%20white;box-shadow:0px%200px%208px%20rgba(0%2C%200%2C%200%2C%200.3);box-sizing:border-box", ".je-dropzone": "position:relative;margin:0.5rem%200;border:2px%20dashed%20black;width:100%25;height:60px;background:teal;transition:all%200.5s", ".je-dropzone:before": "position:absolute;content:attr(data-text);color:rgba(0%2C%200%2C%200%2C%200.6);left:50%25;top:50%25;transform:translate(-50%25%2C%20-50%25)", ".je-dropzone.valid-dropzone": "background:green", ".je-dropzone.invalid-dropzone": "background:red", ".columns .container.je-noindent": "padding-left:0;padding-right:0", ".selectize-control.multi .item": "background:var(--primary-color)%20!important", ".select2-container--default   .select2-selection--single   .select2-selection__arrow": "display:none", ".select2-container--default .select2-selection--single": "border:none", ".select2-container .select2-selection--single .select2-selection__rendered": "padding:0", ".select2-container .select2-search--inline .select2-search__field": "margin-top:0", ".select2-container--default.select2-container--focus   .select2-selection--multiple": "border:0.05rem%20solid%20var(--gray-color)", ".select2-container--default   .select2-selection--multiple   .select2-selection__choice": "margin:0.4rem%200.2rem%200.2rem%200;padding:2px%205px;background-color:var(--primary-color);color:var(--light-color)", ".select2-container--default .select2-search--inline .select2-search__field": "line-height:normal", ".choices": "margin-bottom:auto", ".choices__list--multiple .choices__item": "border:none;background-color:var(--primary-color);color:var(--light-color)", ".choices[data-type*='select-multiple'] .choices__button": "border-left:0.05rem%20solid%20%232826a6", ".choices__inner": "font-size:inherit;min-height:20px;padding:4px%207.5px%204px%203.75px", ".choices[data-type*='select-one'] .choices__inner": "padding-bottom:4px", ".choices__list--dropdown .choices__item": "font-size:inherit" };
      var ra = { disable_theme_rules: false, label_bold: false, object_panel_default: true, object_indent: true, object_border: false, table_border: false, table_hdiv: false, table_zebrastyle: false, input_size: "small", enable_compact: false }, na = function(t3) {
        !function(t4, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && ta(t4, e4);
        }(a2, t3);
        var e3, r2, n2, i2, o2 = (n2 = a2, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t4) {
            return false;
          }
        }(), function() {
          var t4, e4 = ea(n2);
          if (i2) {
            var r3 = ea(this).constructor;
            t4 = Reflect.construct(e4, arguments, r3);
          } else
            t4 = e4.apply(this, arguments);
          return function(t5, e5) {
            if (e5 && ("object" === Qo(e5) || "function" == typeof e5))
              return e5;
            if (void 0 !== e5)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t6) {
              if (void 0 === t6)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t6;
            }(t5);
          }(this, t4);
        });
        function a2(t4) {
          return function(t5, e4) {
            if (!(t5 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, a2), o2.call(this, t4, ra);
        }
        return e3 = a2, (r2 = [{ key: "getGridContainer", value: function() {
          var t4 = document.createElement("div");
          return t4.classList.add("flex", "flex-col", "w-full"), this.options.object_indent || t4.classList.add("je-noindent"), t4;
        } }, { key: "getGridRow", value: function() {
          var t4 = document.createElement("div");
          return t4.classList.add("flex", "flex-wrap", "w-full"), t4;
        } }, { key: "getGridColumn", value: function() {
          var t4 = document.createElement("div");
          return t4.classList.add("flex", "flex-col"), t4;
        } }, { key: "setGridColumnSize", value: function(t4, e4, r3) {
          e4 > 0 && e4 < 12 ? t4.classList.add("w-".concat(e4, "/12"), "px-1") : t4.classList.add("w-full", "px-1"), r3 && (t4.style.marginLeft = "".concat(100 / 12 * r3, "%"));
        } }, { key: "getIndentedPanel", value: function() {
          var t4 = document.createElement("div");
          return this.options.object_panel_default ? t4.classList.add("w-full", "p-1") : t4.classList.add("relative", "flex", "flex-col", "rounded", "break-words", "border", "bg-white", "border-0", "border-blue-400", "p-1", "shadow-md"), this.options.object_border && t4.classList.add("je-border"), t4;
        } }, { key: "getTopIndentedPanel", value: function() {
          var t4 = document.createElement("div");
          return this.options.object_panel_default ? t4.classList.add("w-full", "m-2") : t4.classList.add("relative", "flex", "flex-col", "rounded", "break-words", "border", "bg-white", "border-0", "border-blue-400", "p-1", "shadow-md"), this.options.object_border && t4.classList.add("je-border"), t4;
        } }, { key: "getTitle", value: function() {
          return this.translateProperty(this.schema.title);
        } }, { key: "getSelectInput", value: function(t4, e4) {
          var r3 = Xo(ea(a2.prototype), "getSelectInput", this).call(this, t4);
          return e4 ? r3.classList.add("form-multiselect", "block", "py-0", "h-auto", "w-full", "px-1", "text-sm", "text-black", "leading-normal", "bg-white", "border", "border-grey", "rounded") : r3.classList.add("form-select", "block", "py-0", "h-6", "w-full", "px-1", "text-sm", "text-black", "leading-normal", "bg-white", "border", "border-grey", "rounded"), this.options.enable_compact && r3.classList.add("compact"), r3;
        } }, { key: "afterInputReady", value: function(t4) {
          t4.controlgroup || (t4.controlgroup = this.closest(t4, ".form-group"), this.closest(t4, ".compact") && (t4.controlgroup.style.marginBottom = 0));
        } }, { key: "getTextareaInput", value: function() {
          var t4 = Xo(ea(a2.prototype), "getTextareaInput", this).call(this);
          return t4.classList.add("block", "w-full", "px-1", "text-sm", "leading-normal", "bg-white", "text-black", "border", "border-grey", "rounded"), this.options.enable_compact && t4.classList.add("compact"), t4.style.height = 0, t4;
        } }, { key: "getRangeInput", value: function(t4, e4, r3) {
          var n3 = this.getFormInputField("range");
          return n3.classList.add("slider"), this.options.enable_compact && n3.classList.add("compact"), n3.setAttribute("oninput", 'this.setAttribute("value", this.value)'), n3.setAttribute("min", t4), n3.setAttribute("max", e4), n3.setAttribute("step", r3), n3;
        } }, { key: "getRangeControl", value: function(t4, e4) {
          var r3 = Xo(ea(a2.prototype), "getRangeControl", this).call(this, t4, e4);
          return r3.classList.add("text-center", "text-black"), r3;
        } }, { key: "getCheckbox", value: function() {
          var t4 = this.getFormInputField("checkbox");
          return t4.classList.add("form-checkbox", "text-red-600"), t4;
        } }, { key: "getCheckboxLabel", value: function(t4, e4) {
          var r3 = Xo(ea(a2.prototype), "getCheckboxLabel", this).call(this, t4, e4);
          return r3.classList.add("inline-flex", "items-center"), r3;
        } }, { key: "getFormCheckboxControl", value: function(t4, e4, r3) {
          return t4.insertBefore(e4, t4.firstChild), r3 && t4.classList.add("inline-flex flex-row"), t4;
        } }, { key: "getMultiCheckboxHolder", value: function(t4, e4, r3, n3) {
          var i3 = Xo(ea(a2.prototype), "getMultiCheckboxHolder", this).call(this, t4, e4, r3, n3);
          return i3.classList.add("inline-flex", "flex-col"), i3;
        } }, { key: "getFormRadio", value: function(t4) {
          var e4 = this.getFormInputField("radio");
          for (var r3 in e4.classList.add("form-radio", "text-red-600"), t4)
            e4.setAttribute(r3, t4[r3]);
          return e4;
        } }, { key: "getFormRadioLabel", value: function(t4, e4) {
          var r3 = Xo(ea(a2.prototype), "getFormRadioLabel", this).call(this, t4, e4);
          return r3.classList.add("inline-flex", "items-center", "mr-2"), r3;
        } }, { key: "getFormRadioControl", value: function(t4, e4, r3) {
          return t4.insertBefore(e4, t4.firstChild), r3 && t4.classList.add("form-radio"), t4;
        } }, { key: "getRadioHolder", value: function(t4, e4, r3, n3, i3) {
          var o3 = Xo(ea(a2.prototype), "getRadioHolder", this).call(this, e4, r3, n3, i3);
          return "h" === t4.options.layout ? o3.classList.add("inline-flex", "flex-row") : o3.classList.add("inline-flex", "flex-col"), o3;
        } }, { key: "getFormInputLabel", value: function(t4, e4) {
          var r3 = Xo(ea(a2.prototype), "getFormInputLabel", this).call(this, t4, e4);
          return this.options.label_bold ? r3.classList.add("font-bold") : r3.classList.add("required"), r3;
        } }, { key: "getFormInputField", value: function(t4) {
          var e4 = Xo(ea(a2.prototype), "getFormInputField", this).call(this, t4);
          return ["checkbox", "radio"].includes(t4) || e4.classList.add("block", "w-full", "px-1", "text-black", "text-sm", "leading-normal", "bg-white", "border", "border-grey", "rounded"), this.options.enable_compact && e4.classList.add("compact"), e4;
        } }, { key: "getFormInputDescription", value: function(t4) {
          var e4 = document.createElement("p");
          return e4.classList.add("block", "mt-1", "text-xs"), window.DOMPurify ? e4.innerHTML = window.DOMPurify.sanitize(t4) : e4.textContent = this.cleanText(t4), e4;
        } }, { key: "getFormControl", value: function(t4, e4, r3, n3) {
          var i3 = document.createElement("div");
          return i3.classList.add("form-group", "mb-1", "w-full"), t4 && (t4.classList.add("text-xs"), "checkbox" === e4.type && (e4.classList.add("form-checkbox", "text-xs", "text-red-600", "mr-1"), t4.classList.add("items-center", "flex"), t4 = this.getFormCheckboxControl(t4, e4, false, n3)), "radio" === e4.type && (e4.classList.add("form-radio", "text-red-600", "mr-1"), t4.classList.add("items-center", "flex"), t4 = this.getFormRadioControl(t4, e4, false, n3)), i3.appendChild(t4), !["checkbox", "radio"].includes(e4.type) && n3 && i3.appendChild(n3)), ["checkbox", "radio"].includes(e4.type) || ("small" === this.options.input_size ? e4.classList.add("text-xs") : "normal" === this.options.input_size ? e4.classList.add("text-base") : "large" === this.options.input_size && e4.classList.add("text-xl"), i3.appendChild(e4)), r3 && i3.appendChild(r3), i3;
        } }, { key: "getHeaderButtonHolder", value: function() {
          var t4 = this.getButtonHolder();
          return t4.classList.add("text-sm"), t4;
        } }, { key: "getButtonHolder", value: function() {
          var t4 = document.createElement("div");
          return t4.classList.add("flex", "relative", "inline-flex", "align-middle"), t4;
        } }, { key: "getButton", value: function(t4, e4, r3) {
          var n3 = Xo(ea(a2.prototype), "getButton", this).call(this, t4, e4, r3);
          return n3.classList.add("inline-block", "align-middle", "text-center", "text-sm", "bg-blue-700", "text-white", "py-1", "pr-1", "m-2", "shadow", "select-none", "whitespace-no-wrap", "rounded"), n3;
        } }, { key: "getInfoButton", value: function(t4) {
          var e4 = document.createElement("a");
          e4.classList.add("tooltips", "float-right"), e4.innerHTML = "ⓘ";
          var r3 = document.createElement("span");
          return r3.innerHTML = t4, e4.appendChild(r3), e4;
        } }, { key: "getTable", value: function() {
          var t4 = Xo(ea(a2.prototype), "getTable", this).call(this);
          return this.options.table_border ? t4.classList.add("je-table-border") : t4.classList.add("table", "border", "p-0"), t4;
        } }, { key: "getTableRow", value: function() {
          var t4 = Xo(ea(a2.prototype), "getTableRow", this).call(this);
          return this.options.table_border && t4.classList.add("je-table-border"), this.options.table_zebrastyle && t4.classList.add("je-table-zebra"), t4;
        } }, { key: "getTableHeaderCell", value: function(t4) {
          var e4 = Xo(ea(a2.prototype), "getTableHeaderCell", this).call(this, t4);
          return this.options.table_border ? e4.classList.add("je-table-border") : this.options.table_hdiv ? e4.classList.add("je-table-hdiv") : e4.classList.add("text-xs", "border", "p-0", "m-0"), e4;
        } }, { key: "getTableCell", value: function() {
          var t4 = Xo(ea(a2.prototype), "getTableCell", this).call(this);
          return this.options.table_border ? t4.classList.add("je-table-border") : this.options.table_hdiv ? t4.classList.add("je-table-hdiv") : t4.classList.add("border-0", "p-0", "m-0"), t4;
        } }, { key: "addInputError", value: function(t4, e4) {
          t4.controlgroup && (t4.controlgroup.classList.add("has-error"), t4.controlgroup.classList.add("text-red-600"), t4.errmsg ? t4.errmsg.style.display = "" : (t4.errmsg = document.createElement("p"), t4.errmsg.classList.add("block", "mt-1", "text-xs", "text-red"), t4.controlgroup.appendChild(t4.errmsg)), t4.errmsg.textContent = e4);
        } }, { key: "removeInputError", value: function(t4) {
          t4.errmsg && (t4.errmsg.style.display = "none", t4.controlgroup.classList.remove("text-red-600"), t4.controlgroup.classList.remove("has-error"));
        } }, { key: "getTabHolder", value: function(t4) {
          var e4 = document.createElement("div"), r3 = void 0 === t4 ? "" : t4;
          return e4.innerHTML = "<div class='w-2/12' id='".concat(r3, "'><ul class='list-reset pl-0 mb-0'></ul></div><div class='w-10/12' id='").concat(r3, "'></div>"), e4.classList.add("flex"), e4;
        } }, { key: "addTab", value: function(t4, e4) {
          t4.children[0].children[0].appendChild(e4);
        } }, { key: "getTopTabHolder", value: function(t4) {
          var e4 = void 0 === t4 ? "" : t4, r3 = document.createElement("div");
          return r3.innerHTML = "<ul class='nav-tabs flex list-reset pl-0 mb-0 border-b border-grey-light' id='".concat(e4, "'></ul><div class='p-6 block' id='").concat(e4, "'></div>"), r3;
        } }, { key: "getTab", value: function(t4, e4) {
          var r3 = document.createElement("li");
          r3.classList.add("nav-item", "flex-col", "text-center", "text-white", "bg-blue-500", "shadow-md", "border", "p-2", "mb-2", "mr-2", "hover:bg-blue-400", "rounded");
          var n3 = document.createElement("a");
          return n3.classList.add("nav-link", "text-center"), n3.setAttribute("href", "#".concat(e4)), n3.setAttribute("data-toggle", "tab"), n3.appendChild(t4), r3.appendChild(n3), r3;
        } }, { key: "getTopTab", value: function(t4, e4) {
          var r3 = document.createElement("li");
          r3.classList.add("nav-item", "flex", "border-l", "border-t", "border-r");
          var n3 = document.createElement("a");
          return n3.classList.add("nav-link", "-mb-px", "flex-row", "text-center", "bg-white", "p-2", "hover:bg-blue-400", "rounded-t"), n3.setAttribute("href", "#".concat(e4)), n3.setAttribute("data-toggle", "tab"), n3.appendChild(t4), r3.appendChild(n3), r3;
        } }, { key: "getTabContent", value: function() {
          var t4 = document.createElement("div");
          return t4.setAttribute("role", "tabpanel"), t4;
        } }, { key: "getTopTabContent", value: function() {
          var t4 = document.createElement("div");
          return t4.setAttribute("role", "tabpanel"), t4;
        } }, { key: "markTabActive", value: function(t4) {
          t4.tab.firstChild.classList.add("block"), true === t4.tab.firstChild.classList.contains("border-b") ? (t4.tab.firstChild.classList.add("border-b-0"), t4.tab.firstChild.classList.remove("border-b")) : t4.tab.firstChild.classList.add("border-b-0"), true === t4.container.classList.contains("hidden") ? (t4.container.classList.remove("hidden"), t4.container.classList.add("block")) : t4.container.classList.add("block");
        } }, { key: "markTabInactive", value: function(t4) {
          true === t4.tab.firstChild.classList.contains("border-b-0") ? (t4.tab.firstChild.classList.add("border-b"), t4.tab.firstChild.classList.remove("border-b-0")) : t4.tab.firstChild.classList.add("border-b"), true === t4.container.classList.contains("block") && (t4.container.classList.remove("block"), t4.container.classList.add("hidden"));
        } }, { key: "getProgressBar", value: function() {
          var t4 = document.createElement("div");
          t4.classList.add("progress");
          var e4 = document.createElement("div");
          return e4.classList.add("bg-blue", "leading-none", "py-1", "text-xs", "text-center", "text-white"), e4.setAttribute("role", "progressbar"), e4.setAttribute("aria-valuenow", 0), e4.setAttribute("aria-valuemin", 0), e4.setAttribute("aria-valuenax", 100), e4.innerHTML = "".concat(0, "%"), t4.appendChild(e4), t4;
        } }, { key: "updateProgressBar", value: function(t4, e4) {
          if (t4) {
            var r3 = t4.firstChild, n3 = "".concat(e4, "%");
            r3.setAttribute("aria-valuenow", e4), r3.style.width = n3, r3.innerHTML = n3;
          }
        } }, { key: "updateProgressBarUnknown", value: function(t4) {
          if (t4) {
            var e4 = t4.firstChild;
            t4.classList.add("progress", "bg-blue", "leading-none", "py-1", "text-xs", "text-center", "text-white", "block"), e4.removeAttribute("aria-valuenow"), e4.classList.add("w-full"), e4.innerHTML = "";
          }
        } }, { key: "getInputGroup", value: function(t4, e4) {
          if (t4) {
            var r3 = document.createElement("div");
            r3.classList.add("relative", "items-stretch", "w-full"), r3.appendChild(t4);
            var n3 = document.createElement("div");
            n3.classList.add("-mr-1"), r3.appendChild(n3);
            for (var i3 = 0; i3 < e4.length; i3++)
              n3.appendChild(e4[i3]);
            return r3;
          }
        } }]) && Ko(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), a2;
      }(oo);
      na.rules = { ".slider": "-webkit-appearance:none;-moz-appearance:none;appearance:none;background:transparent;display:block;border:none;height:1.2rem;width:100%25", ".slider:focus": "box-shadow:0%200%200%200%20rgba(87%2C%2085%2C%20217%2C%200.2);outline:none", ".slider.tooltip:not([data-tooltip])::after": "content:attr(value)", ".slider::-webkit-slider-thumb": "-webkit-appearance:none;background:%23f17405;border-radius:100%25;height:0.6rem;margin-top:-0.25rem;transition:transform%200.2s;width:0.6rem", ".slider:active::-webkit-slider-thumb": "transform:scale(1.25);outline:none", ".slider::-webkit-slider-runnable-track": "background:%23b2b4b6;border-radius:0.1rem;height:0.1rem;width:100%25", "a.tooltips": "position:relative;display:inline", "a.tooltips span": "position:absolute;white-space:nowrap;width:auto;padding-left:1rem;padding-right:1rem;color:%23ffffff;background:rgba(56%2C%2056%2C%2056%2C%200.85);height:1.5rem;line-height:1.5rem;text-align:center;visibility:hidden;border-radius:3px", "a.tooltips span:after": "content:%22%22;position:absolute;top:50%25;left:100%25;margin-top:-5px;width:0;height:0;border-left:5px%20solid%20rgba(56%2C%2056%2C%2056%2C%200.85);border-top:5px%20solid%20transparent;border-bottom:5px%20solid%20transparent", "a:hover.tooltips span": "visibility:visible;opacity:0.9;font-size:0.8rem;right:100%25;top:50%25;margin-top:-12px;margin-right:10px;z-index:999", ".json-editor-btntype-properties + div": "font-size:0.8rem;font-weight:normal", textarea: "width:100%25;min-height:2rem;resize:vertical", table: "width:100%25;border-collapse:collapse", ".table td": "padding:0rem%200rem", "div[data-schematype]:not([data-schematype='object'])": "transition:0.5s", "div[data-schematype]:not([data-schematype='object']):hover": "background-color:%23e6f4fe", "div[data-schemaid='root']": "position:relative;width:inherit;display:inherit;overflow-x:hidden;z-index:10", "select[multiple]": "height:auto", "select[multiple].from-select": "height:auto", ".je-table-zebra:nth-child(even)": "background-color:%23f2f2f2", ".je-table-border": "border:0.5px%20solid%20black", ".je-table-hdiv": "border-bottom:1px%20solid%20black", ".je-border": "border:0.05rem%20solid%20%233182ce", ".je-panel": "width:inherit;padding:0.2rem;margin:0.2rem;background-color:rgba(218%2C%20222%2C%20228%2C%200.1)", ".je-panel-top": "width:100%25;padding:0.2rem;margin:0.2rem;background-color:rgba(218%2C%20222%2C%20228%2C%200.1)", ".required:after": "content:%22%20*%22;color:red;font:inherit;font-weight:bold", ".je-desc": "font-size:smaller;margin:0.2rem%200", ".container-xl.je-noindent": "padding-left:0;padding-right:0", ".json-editor-btntype-add": "color:white;margin:0.3rem;padding:0.3rem%200.8rem;background-color:%234299e1;box-shadow:3px%203px%205px%201px%20rgba(4%2C%204%2C%204%2C%200.2);-webkit-box-shadow:3px%203px%205px%201px%20rgba(4%2C%204%2C%204%2C%200.2);-moz-box-shadow:3px%203px%205px%201px%20rgba(4%2C%204%2C%204%2C%200.2)", ".json-editor-btntype-deletelast": "color:white;margin:0.3rem;padding:0.3rem%200.8rem;background-color:%23e53e3e;box-shadow:3px%203px%205px%201px%20rgba(4%2C%204%2C%204%2C%200.2);-webkit-box-shadow:3px%203px%205px%201px%20rgba(4%2C%204%2C%204%2C%200.2);-moz-box-shadow:3px%203px%205px%201px%20rgba(4%2C%204%2C%204%2C%200.2)", ".json-editor-btntype-deleteall": "color:white;margin:0.3rem;padding:0.3rem%200.8rem;background-color:%23000000;box-shadow:3px%203px%205px%201px%20rgba(4%2C%204%2C%204%2C%200.2);-webkit-box-shadow:3px%203px%205px%201px%20rgba(4%2C%204%2C%204%2C%200.2);-moz-box-shadow:3px%203px%205px%201px%20rgba(4%2C%204%2C%204%2C%200.2)", ".json-editor-btn-save": "float:right;color:white;margin:0.3rem;padding:0.3rem%200.8rem;background-color:%232b6cb0;box-shadow:3px%203px%205px%201px%20rgba(4%2C%204%2C%204%2C%200.2);-webkit-box-shadow:3px%203px%205px%201px%20rgba(4%2C%204%2C%204%2C%200.2);-moz-box-shadow:3px%203px%205px%201px%20rgba(4%2C%204%2C%204%2C%200.2)", ".json-editor-btn-back": "color:white;margin:0.3rem;padding:0.3rem%200.8rem;background-color:%232b6cb0;box-shadow:3px%203px%205px%201px%20rgba(4%2C%204%2C%204%2C%200.2);-webkit-box-shadow:3px%203px%205px%201px%20rgba(4%2C%204%2C%204%2C%200.2);-moz-box-shadow:3px%203px%205px%201px%20rgba(4%2C%204%2C%204%2C%200.2)", ".json-editor-btntype-delete": "color:%23e53e3e;background-color:rgba(218%2C%20222%2C%20228%2C%200.1);margin:0.03rem;padding:0.1rem", ".json-editor-btntype-move": "color:%23000000;background-color:rgba(218%2C%20222%2C%20228%2C%200.1);margin:0.03rem;padding:0.1rem", ".json-editor-btn-collapse": "padding:0em%200.8rem;font-size:1.3rem;color:%23e53e3e;background-color:rgba(218%2C%20222%2C%20228%2C%200.1)", ".je-upload-preview img": "float:left;margin:0%200.5rem%200.5rem%200;max-width:100%25;max-height:5rem", ".je-dropzone": "position:relative;margin:0.5rem%200;border:2px%20dashed%20black;width:100%25;height:60px;background:teal;transition:all%200.5s", ".je-dropzone:before": "position:absolute;content:attr(data-text);color:rgba(0%2C%200%2C%200%2C%200.6);left:50%25;top:50%25;transform:translate(-50%25%2C%20-50%25)", ".je-dropzone.valid-dropzone": "background:green", ".je-dropzone.invalid-dropzone": "background:red" };
      var ia = { html: ho, bootstrap3: bo, bootstrap4: xo, bootstrap5: Ro, jqueryui: Fo, barebones: qo, spectre: Yo, tailwind: na };
      const oa = { ".je-float-right-linkholder": "float:right;margin-left:10px", ".je-modal": "background-color:white;border:1px%20solid%20black;box-shadow:3px%203px%20black;position:absolute;z-index:10", ".je-infobutton-icon": "font-size:16px;font-weight:bold;padding:0.25rem;position:relative;display:inline-block", ".je-infobutton-tooltip": "font-size:12px;font-weight:normal;font-family:sans-serif;visibility:hidden;background-color:rgba(50%2C%2050%2C%2050%2C%200.75);margin:0%200.25rem;color:%23fafafa;padding:0.5rem%201rem;border-radius:0.25rem;width:20rem;position:absolute", ".je-not-loaded": "pointer-events:none", ".je-header": "display:inline-block", ".je-upload-preview img": "float:left;margin:0%200.5rem%200.5rem%200;max-width:100%25;max-height:5rem", ".je-checkbox": "display:inline-block;width:auto", ".je-checkbox-control--compact": "display:inline-block;margin-right:1rem", ".je-radio": "display:inline-block;width:auto", ".je-radio-control--compact": "display:inline-block;margin-right:1rem", ".je-switcher": "background-color:transparent;display:inline-block;font-style:italic;font-weight:normal;height:auto;width:auto;margin-bottom:0;margin-left:5px;padding:0%200%200%203px", ".je-textarea": "width:100%25;height:300px;box-sizing:border-box", ".je-range-control": "text-align:center", ".je-indented-panel": "padding-left:10px;margin-left:10px;border-left:1px%20solid%20%23ccc", ".je-indented-panel--top": "padding-left:10px;margin-left:10px", ".je-tabholder": "float:left;width:130px", ".je-tabholder .content": "margin-left:120px", ".je-tabholder--top": "margin-left:10px", ".je-tabholder--clear": "clear:both", ".je-tab": "border:1px%20solid%20%23ccc;border-width:1px%200%201px%201px;text-align:center;line-height:30px;border-radius:5px;border-bottom-right-radius:0;border-top-right-radius:0;font-weight:bold;cursor:pointer", ".je-tab--top": "float:left;border:1px%20solid%20%23ccc;border-width:1px%201px%200px%201px;text-align:center;line-height:30px;border-radius:5px;padding-left:5px;padding-right:5px;border-bottom-right-radius:0;border-bottom-left-radius:0;font-weight:bold;cursor:pointer", ".je-block-link": "display:block", ".je-media": "width:100%25" };
      function aa(t3) {
        return aa = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, aa(t3);
      }
      function sa(t3, e3) {
        (null == e3 || e3 > t3.length) && (e3 = t3.length);
        for (var r2 = 0, n2 = new Array(e3); r2 < e3; r2++)
          n2[r2] = t3[r2];
        return n2;
      }
      function la() {
        la = function() {
          return t3;
        };
        var t3 = {}, e3 = Object.prototype, r2 = e3.hasOwnProperty, n2 = Object.defineProperty || function(t4, e4, r3) {
          t4[e4] = r3.value;
        }, i2 = "function" == typeof Symbol ? Symbol : {}, o2 = i2.iterator || "@@iterator", a2 = i2.asyncIterator || "@@asyncIterator", s2 = i2.toStringTag || "@@toStringTag";
        function l2(t4, e4, r3) {
          return Object.defineProperty(t4, e4, { value: r3, enumerable: true, configurable: true, writable: true }), t4[e4];
        }
        try {
          l2({}, "");
        } catch (t4) {
          l2 = function(t5, e4, r3) {
            return t5[e4] = r3;
          };
        }
        function c3(t4, e4, r3, i3) {
          var o3 = e4 && e4.prototype instanceof p3 ? e4 : p3, a3 = Object.create(o3.prototype), s3 = new x3(i3 || []);
          return n2(a3, "_invoke", { value: _3(t4, r3, s3) }), a3;
        }
        function u2(t4, e4, r3) {
          try {
            return { type: "normal", arg: t4.call(e4, r3) };
          } catch (t5) {
            return { type: "throw", arg: t5 };
          }
        }
        t3.wrap = c3;
        var h3 = {};
        function p3() {
        }
        function d2() {
        }
        function f3() {
        }
        var y3 = {};
        l2(y3, o2, function() {
          return this;
        });
        var m2 = Object.getPrototypeOf, v3 = m2 && m2(m2(C3([])));
        v3 && v3 !== e3 && r2.call(v3, o2) && (y3 = v3);
        var b3 = f3.prototype = p3.prototype = Object.create(y3);
        function g3(t4) {
          ["next", "throw", "return"].forEach(function(e4) {
            l2(t4, e4, function(t5) {
              return this._invoke(e4, t5);
            });
          });
        }
        function w3(t4, e4) {
          function i3(n3, o4, a3, s3) {
            var l3 = u2(t4[n3], t4, o4);
            if ("throw" !== l3.type) {
              var c4 = l3.arg, h4 = c4.value;
              return h4 && "object" == aa(h4) && r2.call(h4, "__await") ? e4.resolve(h4.__await).then(function(t5) {
                i3("next", t5, a3, s3);
              }, function(t5) {
                i3("throw", t5, a3, s3);
              }) : e4.resolve(h4).then(function(t5) {
                c4.value = t5, a3(c4);
              }, function(t5) {
                return i3("throw", t5, a3, s3);
              });
            }
            s3(l3.arg);
          }
          var o3;
          n2(this, "_invoke", { value: function(t5, r3) {
            function n3() {
              return new e4(function(e5, n4) {
                i3(t5, r3, e5, n4);
              });
            }
            return o3 = o3 ? o3.then(n3, n3) : n3();
          } });
        }
        function _3(t4, e4, r3) {
          var n3 = "suspendedStart";
          return function(i3, o3) {
            if ("executing" === n3)
              throw new Error("Generator is already running");
            if ("completed" === n3) {
              if ("throw" === i3)
                throw o3;
              return { value: void 0, done: true };
            }
            for (r3.method = i3, r3.arg = o3; ; ) {
              var a3 = r3.delegate;
              if (a3) {
                var s3 = k3(a3, r3);
                if (s3) {
                  if (s3 === h3)
                    continue;
                  return s3;
                }
              }
              if ("next" === r3.method)
                r3.sent = r3._sent = r3.arg;
              else if ("throw" === r3.method) {
                if ("suspendedStart" === n3)
                  throw n3 = "completed", r3.arg;
                r3.dispatchException(r3.arg);
              } else
                "return" === r3.method && r3.abrupt("return", r3.arg);
              n3 = "executing";
              var l3 = u2(t4, e4, r3);
              if ("normal" === l3.type) {
                if (n3 = r3.done ? "completed" : "suspendedYield", l3.arg === h3)
                  continue;
                return { value: l3.arg, done: r3.done };
              }
              "throw" === l3.type && (n3 = "completed", r3.method = "throw", r3.arg = l3.arg);
            }
          };
        }
        function k3(t4, e4) {
          var r3 = e4.method, n3 = t4.iterator[r3];
          if (void 0 === n3)
            return e4.delegate = null, "throw" === r3 && t4.iterator.return && (e4.method = "return", e4.arg = void 0, k3(t4, e4), "throw" === e4.method) || "return" !== r3 && (e4.method = "throw", e4.arg = new TypeError("The iterator does not provide a '" + r3 + "' method")), h3;
          var i3 = u2(n3, t4.iterator, e4.arg);
          if ("throw" === i3.type)
            return e4.method = "throw", e4.arg = i3.arg, e4.delegate = null, h3;
          var o3 = i3.arg;
          return o3 ? o3.done ? (e4[t4.resultName] = o3.value, e4.next = t4.nextLoc, "return" !== e4.method && (e4.method = "next", e4.arg = void 0), e4.delegate = null, h3) : o3 : (e4.method = "throw", e4.arg = new TypeError("iterator result is not an object"), e4.delegate = null, h3);
        }
        function j3(t4) {
          var e4 = { tryLoc: t4[0] };
          1 in t4 && (e4.catchLoc = t4[1]), 2 in t4 && (e4.finallyLoc = t4[2], e4.afterLoc = t4[3]), this.tryEntries.push(e4);
        }
        function O3(t4) {
          var e4 = t4.completion || {};
          e4.type = "normal", delete e4.arg, t4.completion = e4;
        }
        function x3(t4) {
          this.tryEntries = [{ tryLoc: "root" }], t4.forEach(j3, this), this.reset(true);
        }
        function C3(t4) {
          if (t4) {
            var e4 = t4[o2];
            if (e4)
              return e4.call(t4);
            if ("function" == typeof t4.next)
              return t4;
            if (!isNaN(t4.length)) {
              var n3 = -1, i3 = function e5() {
                for (; ++n3 < t4.length; )
                  if (r2.call(t4, n3))
                    return e5.value = t4[n3], e5.done = false, e5;
                return e5.value = void 0, e5.done = true, e5;
              };
              return i3.next = i3;
            }
          }
          return { next: E3 };
        }
        function E3() {
          return { value: void 0, done: true };
        }
        return d2.prototype = f3, n2(b3, "constructor", { value: f3, configurable: true }), n2(f3, "constructor", { value: d2, configurable: true }), d2.displayName = l2(f3, s2, "GeneratorFunction"), t3.isGeneratorFunction = function(t4) {
          var e4 = "function" == typeof t4 && t4.constructor;
          return !!e4 && (e4 === d2 || "GeneratorFunction" === (e4.displayName || e4.name));
        }, t3.mark = function(t4) {
          return Object.setPrototypeOf ? Object.setPrototypeOf(t4, f3) : (t4.__proto__ = f3, l2(t4, s2, "GeneratorFunction")), t4.prototype = Object.create(b3), t4;
        }, t3.awrap = function(t4) {
          return { __await: t4 };
        }, g3(w3.prototype), l2(w3.prototype, a2, function() {
          return this;
        }), t3.AsyncIterator = w3, t3.async = function(e4, r3, n3, i3, o3) {
          void 0 === o3 && (o3 = Promise);
          var a3 = new w3(c3(e4, r3, n3, i3), o3);
          return t3.isGeneratorFunction(r3) ? a3 : a3.next().then(function(t4) {
            return t4.done ? t4.value : a3.next();
          });
        }, g3(b3), l2(b3, s2, "Generator"), l2(b3, o2, function() {
          return this;
        }), l2(b3, "toString", function() {
          return "[object Generator]";
        }), t3.keys = function(t4) {
          var e4 = Object(t4), r3 = [];
          for (var n3 in e4)
            r3.push(n3);
          return r3.reverse(), function t5() {
            for (; r3.length; ) {
              var n4 = r3.pop();
              if (n4 in e4)
                return t5.value = n4, t5.done = false, t5;
            }
            return t5.done = true, t5;
          };
        }, t3.values = C3, x3.prototype = { constructor: x3, reset: function(t4) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(O3), !t4)
            for (var e4 in this)
              "t" === e4.charAt(0) && r2.call(this, e4) && !isNaN(+e4.slice(1)) && (this[e4] = void 0);
        }, stop: function() {
          this.done = true;
          var t4 = this.tryEntries[0].completion;
          if ("throw" === t4.type)
            throw t4.arg;
          return this.rval;
        }, dispatchException: function(t4) {
          if (this.done)
            throw t4;
          var e4 = this;
          function n3(r3, n4) {
            return a3.type = "throw", a3.arg = t4, e4.next = r3, n4 && (e4.method = "next", e4.arg = void 0), !!n4;
          }
          for (var i3 = this.tryEntries.length - 1; i3 >= 0; --i3) {
            var o3 = this.tryEntries[i3], a3 = o3.completion;
            if ("root" === o3.tryLoc)
              return n3("end");
            if (o3.tryLoc <= this.prev) {
              var s3 = r2.call(o3, "catchLoc"), l3 = r2.call(o3, "finallyLoc");
              if (s3 && l3) {
                if (this.prev < o3.catchLoc)
                  return n3(o3.catchLoc, true);
                if (this.prev < o3.finallyLoc)
                  return n3(o3.finallyLoc);
              } else if (s3) {
                if (this.prev < o3.catchLoc)
                  return n3(o3.catchLoc, true);
              } else {
                if (!l3)
                  throw new Error("try statement without catch or finally");
                if (this.prev < o3.finallyLoc)
                  return n3(o3.finallyLoc);
              }
            }
          }
        }, abrupt: function(t4, e4) {
          for (var n3 = this.tryEntries.length - 1; n3 >= 0; --n3) {
            var i3 = this.tryEntries[n3];
            if (i3.tryLoc <= this.prev && r2.call(i3, "finallyLoc") && this.prev < i3.finallyLoc) {
              var o3 = i3;
              break;
            }
          }
          o3 && ("break" === t4 || "continue" === t4) && o3.tryLoc <= e4 && e4 <= o3.finallyLoc && (o3 = null);
          var a3 = o3 ? o3.completion : {};
          return a3.type = t4, a3.arg = e4, o3 ? (this.method = "next", this.next = o3.finallyLoc, h3) : this.complete(a3);
        }, complete: function(t4, e4) {
          if ("throw" === t4.type)
            throw t4.arg;
          return "break" === t4.type || "continue" === t4.type ? this.next = t4.arg : "return" === t4.type ? (this.rval = this.arg = t4.arg, this.method = "return", this.next = "end") : "normal" === t4.type && e4 && (this.next = e4), h3;
        }, finish: function(t4) {
          for (var e4 = this.tryEntries.length - 1; e4 >= 0; --e4) {
            var r3 = this.tryEntries[e4];
            if (r3.finallyLoc === t4)
              return this.complete(r3.completion, r3.afterLoc), O3(r3), h3;
          }
        }, catch: function(t4) {
          for (var e4 = this.tryEntries.length - 1; e4 >= 0; --e4) {
            var r3 = this.tryEntries[e4];
            if (r3.tryLoc === t4) {
              var n3 = r3.completion;
              if ("throw" === n3.type) {
                var i3 = n3.arg;
                O3(r3);
              }
              return i3;
            }
          }
          throw new Error("illegal catch attempt");
        }, delegateYield: function(t4, e4, r3) {
          return this.delegate = { iterator: C3(t4), resultName: e4, nextLoc: r3 }, "next" === this.method && (this.arg = void 0), h3;
        } }, t3;
      }
      function ca(t3, e3, r2, n2, i2, o2, a2) {
        try {
          var s2 = t3[o2](a2), l2 = s2.value;
        } catch (t4) {
          return void r2(t4);
        }
        s2.done ? e3(l2) : Promise.resolve(l2).then(n2, i2);
      }
      function ua(t3, e3) {
        for (var r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, (i2 = function(t4, e4) {
            if ("object" !== aa(t4) || null === t4)
              return t4;
            var r3 = t4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n3 = r3.call(t4, "string");
              if ("object" !== aa(n3))
                return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t4);
          }(n2.key), "symbol" === aa(i2) ? i2 : String(i2)), n2);
        }
        var i2;
      }
      var ha = function() {
        function t3(e4) {
          var r3 = this, n3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          if (function(t4, e5) {
            if (!(t4 instanceof e5))
              throw new TypeError("Cannot call a class as a function");
          }(this, t3), !(e4 instanceof Element))
            throw new Error("element should be an instance of Element");
          this.element = e4, this.options = l({}, t3.defaults.options, n3), this.ready = false, this.copyClipboard = null, this.schema = this.options.schema, this.template = this.options.template, this.translate = this.options.translate || t3.defaults.translate, this.translateProperty = this.options.translateProperty || t3.defaults.translateProperty, this.uuid = 0, this.__data = {};
          var i3 = this.options.theme || t3.defaults.theme, o2 = t3.defaults.themes[i3];
          if (!o2)
            throw new Error("Unknown theme ".concat(i3));
          this.element.setAttribute("data-theme", i3), this.element.classList.add("je-not-loaded"), this.element.classList.remove("je-ready"), this.theme = new o2(this);
          var a2 = l(oa, this.getEditorsRules()), s2 = function(t4, e5, n4) {
            return n4 ? r3.addNewStyleRulesToShadowRoot(t4, e5, n4) : r3.addNewStyleRules(t4, e5);
          };
          if (!this.theme.options.disable_theme_rules) {
            var c3 = u(this.element);
            s2("default", a2, c3), void 0 !== o2.rules && s2(i3, o2.rules, c3);
          }
          var h3 = t3.defaults.iconlibs[this.options.iconlib || t3.defaults.iconlib];
          h3 && (this.iconlib = new h3()), this.root_container = this.theme.getContainer(), this.element.appendChild(this.root_container), this.promise = this.load();
        }
        var e3, r2, n2, i2;
        return e3 = t3, r2 = [{ key: "load", value: (n2 = la().mark(function e4() {
          var r3, n3, i3, o2, a2, s2, l2 = this;
          return la().wrap(function(e5) {
            for (; ; )
              switch (e5.prev = e5.next) {
                case 0:
                  return r3 = document.location.origin + document.location.pathname.toString(), n3 = new ei(this.options), this.expandSchema = function(t4) {
                    return n3.expandSchema(t4);
                  }, this.expandRefs = function(t4, e6) {
                    return n3.expandRefs(t4, e6);
                  }, i3 = document.location.toString(), e5.next = 7, n3.load(this.schema, r3, i3);
                case 7:
                  o2 = e5.sent, a2 = this.options.custom_validators ? { custom_validators: this.options.custom_validators } : {}, this.validator = new nr(this, null, a2, t3.defaults), s2 = this.getEditorClass(o2), this.root = this.createEditor(s2, { jsoneditor: this, schema: o2, required: true, container: this.root_container }), this.root.preBuild(), this.root.build(), this.root.postBuild(), h2(this.options, "startval") && this.root.setValue(this.options.startval), this.validation_results = this.validator.validate(this.root.getValue()), this.root.showValidationErrors(this.validation_results), this.ready = true, this.element.classList.remove("je-not-loaded"), this.element.classList.add("je-ready"), window.requestAnimationFrame(function() {
                    l2.ready && (l2.validation_results = l2.validator.validate(l2.root.getValue()), l2.root.showValidationErrors(l2.validation_results), l2.trigger("ready"), l2.trigger("change"));
                  });
                case 22:
                case "end":
                  return e5.stop();
              }
          }, e4, this);
        }), i2 = function() {
          var t4 = this, e4 = arguments;
          return new Promise(function(r3, i3) {
            var o2 = n2.apply(t4, e4);
            function a2(t5) {
              ca(o2, r3, i3, a2, s2, "next", t5);
            }
            function s2(t5) {
              ca(o2, r3, i3, a2, s2, "throw", t5);
            }
            a2(void 0);
          });
        }, function() {
          return i2.apply(this, arguments);
        }) }, { key: "getValue", value: function() {
          if (!this.ready)
            throw new Error("JSON Editor not ready yet. Make sure the load method is complete");
          return this.root.getValue();
        } }, { key: "setValue", value: function(t4) {
          if (!this.ready)
            throw new Error("JSON Editor not ready yet. Make sure the load method is complete");
          return this.root.setValue(t4), this;
        } }, { key: "validate", value: function(t4) {
          if (!this.ready)
            throw new Error("JSON Editor not ready yet. Make sure the load method is complete");
          return 1 === arguments.length ? this.validator.validate(t4) : this.validation_results;
        } }, { key: "destroy", value: function() {
          this.destroyed || this.ready && (this.schema = null, this.options = null, this.root.destroy(), this.root = null, this.root_container = null, this.validator = null, this.validation_results = null, this.theme = null, this.iconlib = null, this.template = null, this.__data = null, this.ready = false, this.element.innerHTML = "", this.element.removeAttribute("data-theme"), this.destroyed = true);
        } }, { key: "on", value: function(t4, e4) {
          return this.callbacks = this.callbacks || {}, this.callbacks[t4] = this.callbacks[t4] || [], this.callbacks[t4].push(e4), this;
        } }, { key: "off", value: function(t4, e4) {
          if (t4 && e4) {
            this.callbacks = this.callbacks || {}, this.callbacks[t4] = this.callbacks[t4] || [];
            for (var r3 = [], n3 = 0; n3 < this.callbacks[t4].length; n3++)
              this.callbacks[t4][n3] !== e4 && r3.push(this.callbacks[t4][n3]);
            this.callbacks[t4] = r3;
          } else
            t4 ? (this.callbacks = this.callbacks || {}, this.callbacks[t4] = []) : this.callbacks = {};
          return this;
        } }, { key: "trigger", value: function(t4, e4) {
          if (this.callbacks && this.callbacks[t4] && this.callbacks[t4].length)
            for (var r3 = 0; r3 < this.callbacks[t4].length; r3++)
              this.callbacks[t4][r3].apply(this, [e4]);
          return this;
        } }, { key: "setOption", value: function(t4, e4) {
          if ("show_errors" !== t4)
            throw new Error("Option ".concat(t4, " must be set during instantiation and cannot be changed later"));
          return this.options.show_errors = e4, this.onChange(), this;
        } }, { key: "getEditorsRules", value: function() {
          return Object.values(t3.defaults.editors).reduce(function(t4, e4) {
            return e4.rules ? l(t4, e4.rules) : t4;
          }, {});
        } }, { key: "getEditorClass", value: function(e4) {
          var r3;
          if (e4 = this.expandSchema(e4), t3.defaults.resolvers.find(function(n3) {
            return (r3 = n3(e4)) && t3.defaults.editors[r3];
          }), !r3)
            throw new Error("Unknown editor for schema ".concat(JSON.stringify(e4)));
          if (!t3.defaults.editors[r3])
            throw new Error("Unknown editor ".concat(r3));
          return t3.defaults.editors[r3];
        } }, { key: "createEditor", value: function(e4, r3) {
          var n3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
          return new e4(r3 = l({}, e4.options || {}, r3), t3.defaults, n3);
        } }, { key: "onChange", value: function() {
          var t4 = this;
          if (this.ready && !this.firing_change)
            return this.firing_change = true, window.requestAnimationFrame(function() {
              t4.firing_change = false, t4.ready && (t4.validation_results = t4.validator.validate(t4.root.getValue()), "never" !== t4.options.show_errors ? t4.root.showValidationErrors(t4.validation_results) : t4.root.showValidationErrors([]), t4.trigger("change"));
            }), this;
        } }, { key: "compileTemplate", value: function(e4) {
          var r3, n3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t3.defaults.template;
          if ("string" == typeof n3) {
            if (!t3.defaults.templates[n3])
              throw new Error("Unknown template engine ".concat(n3));
            if (!(r3 = t3.defaults.templates[n3]()))
              throw new Error("Template engine ".concat(n3, " missing required library."));
          } else
            r3 = n3;
          if (!r3)
            throw new Error("No template engine set");
          if (!r3.compile)
            throw new Error("Invalid template engine set");
          return r3.compile(e4);
        } }, { key: "_data", value: function(t4, e4, r3) {
          if (3 !== arguments.length)
            return t4.hasAttribute("data-jsoneditor-".concat(e4)) ? this.__data[t4.getAttribute("data-jsoneditor-".concat(e4))] : null;
          var n3;
          t4.hasAttribute("data-jsoneditor-".concat(e4)) ? n3 = t4.getAttribute("data-jsoneditor-".concat(e4)) : (n3 = this.uuid++, t4.setAttribute("data-jsoneditor-".concat(e4), n3)), this.__data[n3] = r3;
        } }, { key: "registerEditor", value: function(t4) {
          return this.editors = this.editors || {}, this.editors[t4.path] = t4, this;
        } }, { key: "unregisterEditor", value: function(t4) {
          return this.editors = this.editors || {}, this.editors[t4.path] = null, this;
        } }, { key: "getEditor", value: function(t4) {
          if (this.editors)
            return this.editors[t4];
        } }, { key: "watch", value: function(t4, e4) {
          return this.watchlist = this.watchlist || {}, this.watchlist[t4] = this.watchlist[t4] || [], this.watchlist[t4].push(e4), this;
        } }, { key: "unwatch", value: function(t4, e4) {
          if (!this.watchlist || !this.watchlist[t4])
            return this;
          if (!e4)
            return this.watchlist[t4] = null, this;
          for (var r3 = [], n3 = 0; n3 < this.watchlist[t4].length; n3++)
            this.watchlist[t4][n3] !== e4 && r3.push(this.watchlist[t4][n3]);
          return this.watchlist[t4] = r3.length ? r3 : null, this;
        } }, { key: "notifyWatchers", value: function(t4) {
          if (!this.watchlist || !this.watchlist[t4])
            return this;
          for (var e4 = 0; e4 < this.watchlist[t4].length; e4++)
            this.watchlist[t4][e4]();
        } }, { key: "isEnabled", value: function() {
          return !this.root || this.root.isEnabled();
        } }, { key: "enable", value: function() {
          this.root.enable();
        } }, { key: "disable", value: function() {
          this.root.disable();
        } }, { key: "setCopyClipboardContents", value: function(t4) {
          this.copyClipboard = t4;
        } }, { key: "getCopyClipboardContents", value: function() {
          return this.copyClipboard;
        } }, { key: "addNewStyleRules", value: function(t4, e4) {
          var r3 = document.querySelector("#theme-".concat(t4));
          r3 || ((r3 = document.createElement("style")).setAttribute("id", "theme-".concat(t4)), r3.appendChild(document.createTextNode("")), document.head.appendChild(r3));
          for (var n3 = r3.sheet ? r3.sheet : r3.styleSheet, i3 = this.element.nodeName.toLowerCase(); n3.cssRules.length > 0; )
            n3.deleteRule(0);
          Object.keys(e4).forEach(function(r4) {
            var o2 = "default" === t4 ? r4 : "".concat(i3, '[data-theme="').concat(t4, '"] ').concat(r4);
            n3.insertRule ? n3.insertRule(o2 + " {" + decodeURIComponent(e4[r4]) + "}", 0) : n3.addRule && n3.addRule(o2, decodeURIComponent(e4[r4]), 0);
          });
        } }, { key: "addNewStyleRulesToShadowRoot", value: function(t4, e4, r3) {
          var n3 = this.element.nodeName.toLowerCase(), i3 = "";
          Object.keys(e4).forEach(function(r4) {
            var o3 = "default" === t4 ? r4 : "".concat(n3, '[data-theme="').concat(t4, '"] ').concat(r4);
            i3 += o3 + " {" + decodeURIComponent(e4[r4]) + "}\n";
          });
          var o2, a2 = new CSSStyleSheet();
          a2.replaceSync(i3), r3.adoptedStyleSheets = [].concat(function(t5) {
            if (Array.isArray(t5))
              return sa(t5);
          }(o2 = r3.adoptedStyleSheets) || function(t5) {
            if ("undefined" != typeof Symbol && null != t5[Symbol.iterator] || null != t5["@@iterator"])
              return Array.from(t5);
          }(o2) || function(t5, e5) {
            if (t5) {
              if ("string" == typeof t5)
                return sa(t5, e5);
              var r4 = Object.prototype.toString.call(t5).slice(8, -1);
              return "Object" === r4 && t5.constructor && (r4 = t5.constructor.name), "Map" === r4 || "Set" === r4 ? Array.from(t5) : "Arguments" === r4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r4) ? sa(t5, e5) : void 0;
            }
          }(o2) || function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }(), [a2]);
        } }], r2 && ua(e3.prototype, r2), Object.defineProperty(e3, "prototype", { writable: false }), t3;
      }();
      ha.defaults = Jn, ha.AbstractEditor = w2, ha.AbstractTheme = oo, ha.AbstractIconLib = si, Object.assign(ha.defaults.themes, ia), Object.assign(ha.defaults.editors, Mn), Object.assign(ha.defaults.templates, ri), Object.assign(ha.defaults.iconlibs, eo);
    })(), n;
  })());
})(jsoneditor);
const style2 = "";
function p(t, e) {
  var i = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(t);
    e && (n = n.filter(function(e2) {
      return Object.getOwnPropertyDescriptor(t, e2).enumerable;
    })), i.push.apply(i, n);
  }
  return i;
}
function g(t) {
  for (var e = 1; e < arguments.length; e++) {
    var i = null != arguments[e] ? arguments[e] : {};
    e % 2 ? p(Object(i), true).forEach(function(e2) {
      f(t, e2, i[e2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(i)) : p(Object(i)).forEach(function(e2) {
      Object.defineProperty(t, e2, Object.getOwnPropertyDescriptor(i, e2));
    });
  }
  return t;
}
function f(t, e, i) {
  return e in t ? Object.defineProperty(t, e, { value: i, enumerable: true, configurable: true, writable: true }) : t[e] = i, t;
}
function v(t, e) {
  if (null == t)
    return {};
  var i, n, s = function(t2, e2) {
    if (null == t2)
      return {};
    var i2, n2, s2 = {}, o2 = Object.keys(t2);
    for (n2 = 0; n2 < o2.length; n2++)
      i2 = o2[n2], e2.indexOf(i2) >= 0 || (s2[i2] = t2[i2]);
    return s2;
  }(t, e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    for (n = 0; n < o.length; n++)
      i = o[n], e.indexOf(i) >= 0 || Object.prototype.propertyIsEnumerable.call(t, i) && (s[i] = t[i]);
  }
  return s;
}
function b(t) {
  return function(t2) {
    if (Array.isArray(t2))
      return w(t2);
  }(t) || function(t2) {
    if ("undefined" != typeof Symbol && null != t2[Symbol.iterator] || null != t2["@@iterator"])
      return Array.from(t2);
  }(t) || function(t2, e) {
    if (!t2)
      return;
    if ("string" == typeof t2)
      return w(t2, e);
    var i = Object.prototype.toString.call(t2).slice(8, -1);
    "Object" === i && t2.constructor && (i = t2.constructor.name);
    if ("Map" === i || "Set" === i)
      return Array.from(t2);
    if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))
      return w(t2, e);
  }(t) || function() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }();
}
function w(t, e) {
  (null == e || e > t.length) && (e = t.length);
  for (var i = 0, n = new Array(e); i < e; i++)
    n[i] = t[i];
  return n;
}
var y, z, R, A = (y = function(t) {
  /*!
    Copyright (c) 2018 Jed Watson.
    Licensed under the MIT License (MIT), see
    http://jedwatson.github.io/classnames
  */
  !function() {
    var e = {}.hasOwnProperty;
    function i() {
      for (var t2 = [], n = 0; n < arguments.length; n++) {
        var s = arguments[n];
        if (s) {
          var o = typeof s;
          if ("string" === o || "number" === o)
            t2.push(s);
          else if (Array.isArray(s)) {
            if (s.length) {
              var r = i.apply(null, s);
              r && t2.push(r);
            }
          } else if ("object" === o)
            if (s.toString === Object.prototype.toString)
              for (var a in s)
                e.call(s, a) && s[a] && t2.push(a);
            else
              t2.push(s.toString());
        }
      }
      return t2.join(" ");
    }
    t.exports ? (i.default = i, t.exports = i) : window.classNames = i;
  }();
}, y(R = { path: z, exports: {}, require: function(t, e) {
  return function() {
    throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
  }(null == e && R.path);
} }, R.exports), R.exports), M = function(t) {
  return function(e, i) {
    if (!e)
      return t;
    var n;
    "string" == typeof e ? n = e : i = e;
    var s = t;
    return n && (s += "__" + n), s + (i ? Object.keys(i).reduce(function(t2, e2) {
      var n2 = i[e2];
      return n2 && (t2 += " " + ("boolean" == typeof n2 ? s + "--" + e2 : s + "--" + e2 + "_" + n2)), t2;
    }, "") : "");
  };
};
function S(t, e, i) {
  var n, s, o, r, a;
  function h2() {
    var c3 = Date.now() - r;
    c3 < e && c3 >= 0 ? n = setTimeout(h2, e - c3) : (n = null, i || (a = t.apply(o, s), o = s = null));
  }
  null == e && (e = 100);
  var c2 = function() {
    o = this, s = arguments, r = Date.now();
    var c3 = i && !n;
    return n || (n = setTimeout(h2, e)), c3 && (a = t.apply(o, s), o = s = null), a;
  };
  return c2.clear = function() {
    n && (clearTimeout(n), n = null);
  }, c2.flush = function() {
    n && (a = t.apply(o, s), o = s = null, clearTimeout(n), n = null);
  }, c2;
}
S.debounce = S;
var x = S, C = function() {
  return C = Object.assign || function(t) {
    for (var e, i = 1, n = arguments.length; i < n; i++)
      for (var s in e = arguments[i])
        Object.prototype.hasOwnProperty.call(e, s) && (t[s] = e[s]);
    return t;
  }, C.apply(this, arguments);
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function E(t, e) {
  var i, n;
  return t && e ? (i = "" + t + e[0].toUpperCase() + e.slice(1), n = t + "-" + e) : (i = t || e, n = t || e), { name: i, classname: n };
}
function W(t) {
  return /^blob:/.test(t);
}
function T(t) {
  return W(t) || function(t2) {
    return /^data:/.test(t2);
  }(t);
}
function O(t) {
  return !!(t && t.constructor && t.call && t.apply);
}
function D(t) {
  return void 0 === t;
}
function H(t) {
  return "object" == typeof t && null !== t;
}
function j(t, e, i) {
  var n = {};
  return H(t) ? (Object.keys(e).forEach(function(s) {
    D(t[s]) ? n[s] = e[s] : H(e[s]) ? H(t[s]) ? n[s] = j(t[s], e[s], i[s]) : n[s] = t[s] ? e[s] : i[s] : true === e[s] || false === e[s] ? n[s] = Boolean(t[s]) : n[s] = t[s];
  }), n) : t ? e : i;
}
function L(t) {
  var e = Number(t);
  return Number.isNaN(e) ? t : e;
}
function P(t) {
  return typeof ("number" == t || function(t2) {
    return "object" == typeof t2 && null !== t2;
  }(t) && "[object Number]" == toString.call(t)) && !$(t);
}
function $(t) {
  return t != t;
}
function I(t, e) {
  return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2));
}
var B = function(t, e) {
  void 0 === t && (t = {}), void 0 === e && (e = {}), this.type = "manipulateImage", this.move = t, this.scale = e;
}, X = function(t, e) {
  void 0 === e && (e = {}), this.type = "resize", this.directions = t, this.params = e;
}, Y = function(t) {
  this.type = "move", this.directions = t;
}, k = function() {
  function t(t2, e, i, n, s) {
    this.type = "drag", this.nativeEvent = t2, this.position = i, this.previousPosition = n, this.element = e, this.anchor = s;
  }
  return t.prototype.shift = function() {
    var t2 = this, e = t2.element, i = t2.anchor, n = t2.position;
    if (e) {
      var s = e.getBoundingClientRect(), o = s.left, r = s.top;
      return { left: n.left - o - i.left, top: n.top - r - i.top };
    }
    return { left: 0, top: 0 };
  }, t;
}(), F = { name: "DraggableElement", props: { classname: { type: String } }, beforeMount: function() {
  window.addEventListener("mouseup", this.onMouseUp, { passive: false }), window.addEventListener("mousemove", this.onMouseMove, { passive: false }), window.addEventListener("touchmove", this.onTouchMove, { passive: false }), window.addEventListener("touchend", this.onTouchEnd, { passive: false });
}, beforeUnmount: function() {
  window.removeEventListener("mouseup", this.onMouseUp), window.removeEventListener("mousemove", this.onMouseMove), window.removeEventListener("touchmove", this.onTouchMove), window.removeEventListener("touchend", this.onTouchEnd);
}, mounted: function() {
  if (!this.$refs.draggable)
    throw new Error('You should add ref "draggable" to your root element to use draggable mixin');
  this.touches = [], this.hovered = false;
}, methods: { onMouseOver: function() {
  this.hovered || (this.hovered = true, this.$emit("enter"));
}, onMouseLeave: function() {
  this.hovered && !this.touches.length && (this.hovered = false, this.$emit("leave"));
}, onTouchStart: function(t) {
  t.cancelable && !this.disabled && 1 === t.touches.length && (this.touches = b(t.touches), this.hovered || (this.$emit("enter"), this.hovered = true), t.touches.length && this.initAnchor(this.touches.reduce(function(e, i) {
    return { clientX: e.clientX + i.clientX / t.touches.length, clientY: e.clientY + i.clientY / t.touches.length };
  }, { clientX: 0, clientY: 0 })), t.preventDefault && t.preventDefault(), t.stopPropagation());
}, onTouchEnd: function() {
  this.processEnd();
}, onTouchMove: function(t) {
  this.touches.length && (this.processMove(t, t.touches), t.preventDefault && t.preventDefault(), t.stopPropagation && t.stopPropagation());
}, onMouseDown: function(t) {
  if (!this.disabled) {
    var e = { fake: true, clientX: t.clientX, clientY: t.clientY };
    this.touches = [e], this.initAnchor(e), t.stopPropagation();
  }
}, onMouseMove: function(t) {
  this.touches.length && (this.processMove(t, [{ fake: true, clientX: t.clientX, clientY: t.clientY }]), t.preventDefault && t.preventDefault());
}, onMouseUp: function() {
  this.processEnd();
}, initAnchor: function(t) {
  var e = this.$refs.draggable.getBoundingClientRect(), i = e.left, n = e.right, s = e.bottom, o = e.top;
  this.anchor = { left: t.clientX - i, top: t.clientY - o, bottom: s - t.clientY, right: n - t.clientX };
}, processMove: function(t, e) {
  var i = b(e);
  if (this.touches.length) {
    if (1 === this.touches.length && 1 === i.length) {
      var n = this.$refs.draggable;
      this.$emit("drag", new k(t, n, { left: i[0].clientX, top: i[0].clientY }, { left: this.touches[0].clientX, top: this.touches[0].clientY }, this.anchor));
    }
    this.touches = i;
  }
}, processEnd: function() {
  this.touches.length && this.$emit("drag-end"), this.hovered && (this.$emit("leave"), this.hovered = false), this.touches = [];
} }, emits: ["drag", "drag-end", "leave", "enter"] };
F.render = function(n, s, o, r, a, h2) {
  return openBlock(), createBlock("div", { ref: "draggable", class: o.classname, onTouchstart: s[1] || (s[1] = function() {
    return h2.onTouchStart && h2.onTouchStart.apply(h2, arguments);
  }), onMousedown: s[2] || (s[2] = function() {
    return h2.onMouseDown && h2.onMouseDown.apply(h2, arguments);
  }), onMouseover: s[3] || (s[3] = function() {
    return h2.onMouseOver && h2.onMouseOver.apply(h2, arguments);
  }), onMouseleave: s[4] || (s[4] = function() {
    return h2.onMouseLeave && h2.onMouseLeave.apply(h2, arguments);
  }) }, [renderSlot(n.$slots, "default")], 34);
};
var U = M("vue-handler-wrapper"), N = { name: "HandlerWrapper", components: { DraggableElement: F }, props: { horizontalPosition: { type: String }, verticalPosition: { type: String }, disabled: { type: Boolean, default: false } }, computed: { classes: function() {
  var t;
  if (this.horizontalPosition || this.verticalPosition) {
    var e, i = E(this.horizontalPosition, this.verticalPosition);
    t = U((f(e = {}, i.classname, true), f(e, "disabled", this.disabled), e));
  } else
    t = U({ disabled: this.disabled });
  return { root: t, draggable: U("draggable") };
} }, emits: ["leave", "enter", "drag", "drag-end"] };
N.render = function(r, a, h2, c2, l, u) {
  var d = resolveComponent("DraggableElement");
  return openBlock(), createBlock("div", { class: u.classes.root }, [createVNode(d, { class: u.classes.draggable, onDrag: a[1] || (a[1] = function(t) {
    return r.$emit("drag", t);
  }), onDragEnd: a[2] || (a[2] = function(t) {
    return r.$emit("drag-end");
  }), onLeave: a[3] || (a[3] = function(t) {
    return r.$emit("leave");
  }), onEnter: a[4] || (a[4] = function(t) {
    return r.$emit("enter");
  }) }, { default: withCtx(function() {
    return [renderSlot(r.$slots, "default")];
  }), _: 3 }, 8, ["class"])], 2);
};
var Z = M("vue-line-wrapper"), q = { name: "LineWrapper", components: { DraggableElement: F }, props: { position: { type: String, required: true }, disabled: { type: Boolean, default: false } }, computed: { classname: function() {
  var t;
  return Z((f(t = {}, this.position, true), f(t, "disabled", this.disabled), t));
} }, emits: ["leave", "enter", "drag", "drag-end"] };
q.render = function(s, r, a, h2, c2, l) {
  var u = resolveComponent("DraggableElement");
  return openBlock(), createBlock(u, { class: l.classname, onDrag: r[1] || (r[1] = function(t) {
    return s.$emit("drag", t);
  }), onDragEnd: r[2] || (r[2] = function(t) {
    return s.$emit("drag-end");
  }), onLeave: r[3] || (r[3] = function(t) {
    return s.$emit("leave");
  }), onEnter: r[4] || (r[4] = function(t) {
    return s.$emit("enter");
  }) }, { default: withCtx(function() {
    return [renderSlot(s.$slots, "default")];
  }), _: 3 }, 8, ["class"]);
};
var V = ["left", "right", "top", "bottom"], _ = ["left", "right"], G = ["top", "bottom"], Q = ["left", "top"], K = ["fill-area", "fit-area", "stencil", "none"], J = { left: 0, top: 0, width: 0, height: 0 };
function tt(t, e, i) {
  return !(i = i || ["width", "height", "left", "top"]).some(function(i2) {
    return t[i2] !== e[i2];
  });
}
function et(t) {
  return { left: t.left, top: t.top, right: t.left + t.width, bottom: t.top + t.height };
}
function it(t, e) {
  return { left: t.left - e.left, top: t.top - e.top };
}
function nt(t) {
  return { left: t.left + t.width / 2, top: t.top + t.height / 2 };
}
function st(t, e) {
  var i = { left: 0, top: 0, right: 0, bottom: 0 };
  return V.forEach(function(n) {
    var s = e[n], o = et(t)[n];
    i[n] = void 0 !== s && void 0 !== o ? "left" === n || "top" === n ? Math.max(0, s - o) : Math.max(0, o - s) : 0;
  }), i;
}
function ot(t, e) {
  return { left: t.left - e.left, top: t.top - e.top, width: t.width + e.left + e.right, height: t.height + e.top + e.bottom };
}
function rt(t) {
  return { left: -t.left, top: -t.top };
}
function at(t, e) {
  return C(C({}, t), { left: t.left + e.left, top: t.top + e.top });
}
function ht(t, e, i, n) {
  if (1 !== e) {
    if (i) {
      var s = nt(t);
      return { width: t.width * e, height: t.height * e, left: t.left + t.width * (1 - e) / 2 + (i.left - s.left) * (n || 1 - e), top: t.top + t.height * (1 - e) / 2 + (i.top - s.top) * (n || 1 - e) };
    }
    return { width: t.width * e, height: t.height * e, left: t.left + t.width * (1 - e) / 2, top: t.top + t.height * (1 - e) / 2 };
  }
  return t;
}
function ct(t) {
  return t.width / t.height;
}
function lt(t, e) {
  return Math.min(void 0 !== e.right && void 0 !== e.left ? (e.right - e.left) / t.width : 1 / 0, void 0 !== e.bottom && void 0 !== e.top ? (e.bottom - e.top) / t.height : 1 / 0);
}
function ut(t, e) {
  var i = { left: 0, top: 0 }, n = st(t, e);
  return n.left && n.left > 0 ? i.left = n.left : n.right && n.right > 0 && (i.left = -n.right), n.top && n.top > 0 ? i.top = n.top : n.bottom && n.bottom > 0 && (i.top = -n.bottom), i;
}
function dt(t, e) {
  var i;
  return e.minimum && t < e.minimum ? i = e.minimum : e.maximum && t > e.maximum && (i = e.maximum), i;
}
function mt(t, e) {
  var i = ct(t), n = ct(e);
  return e.width < 1 / 0 && e.height < 1 / 0 ? i > n ? { width: e.width, height: e.width / i } : { width: e.height * i, height: e.height } : e.width < 1 / 0 ? { width: e.width, height: e.width / i } : e.height < 1 / 0 ? { width: e.height * i, height: e.height } : t;
}
function pt(t, e) {
  var i = e * Math.PI / 180;
  return { width: Math.abs(t.width * Math.cos(i)) + Math.abs(t.height * Math.sin(i)), height: Math.abs(t.width * Math.sin(i)) + Math.abs(t.height * Math.cos(i)) };
}
function gt(t, e) {
  var i = e * Math.PI / 180;
  return { left: t.left * Math.cos(i) - t.top * Math.sin(i), top: t.left * Math.sin(i) + t.top * Math.cos(i) };
}
function ft(t, e) {
  var i = st(vt(t, e), e);
  return i.left + i.right + i.top + i.bottom ? i.left + i.right > i.top + i.bottom ? Math.min((t.width + i.left + i.right) / t.width, lt(t, e)) : Math.min((t.height + i.top + i.bottom) / t.height, lt(t, e)) : 1;
}
function vt(t, e, i) {
  void 0 === i && (i = false);
  var n = ut(t, e);
  return at(t, i ? rt(n) : n);
}
function bt(t) {
  return { width: void 0 !== t.right && void 0 !== t.left ? t.right - t.left : 1 / 0, height: void 0 !== t.bottom && void 0 !== t.top ? t.bottom - t.top : 1 / 0 };
}
function wt(t, e) {
  return C(C({}, t), { minWidth: Math.min(e.width, t.minWidth), minHeight: Math.min(e.height, t.minHeight), maxWidth: Math.min(e.width, t.maxWidth), maxHeight: Math.min(e.height, t.maxHeight) });
}
function yt(t, e, i) {
  void 0 === i && (i = true);
  var n = {};
  return V.forEach(function(s) {
    var o = t[s], r = e[s];
    void 0 !== o && void 0 !== r ? n[s] = "left" === s || "top" === s ? i ? Math.max(o, r) : Math.min(o, r) : i ? Math.min(o, r) : Math.max(o, r) : void 0 !== r ? n[s] = r : void 0 !== o && (n[s] = o);
  }), n;
}
function zt(t, e) {
  return yt(t, e, true);
}
function Rt(t) {
  var e = t.size, i = t.aspectRatio, n = t.ignoreMinimum, s = t.sizeRestrictions;
  return Boolean((e.correctRatio || ct(e) >= i.minimum && ct(e) <= i.maximum) && e.height <= s.maxHeight && e.width <= s.maxWidth && e.width && e.height && (n || e.height >= s.minHeight && e.width >= s.minWidth));
}
function At(t, e) {
  return Math.pow(t.width - e.width, 2) + Math.pow(t.height - e.height, 2);
}
function Mt(t) {
  var e = t.width, i = t.height, n = t.sizeRestrictions, s = { minimum: t.aspectRatio && t.aspectRatio.minimum || 0, maximum: t.aspectRatio && t.aspectRatio.maximum || 1 / 0 }, o = { width: Math.max(n.minWidth, Math.min(n.maxWidth, e)), height: Math.max(n.minHeight, Math.min(n.maxHeight, i)) };
  function r(t2, o2) {
    return void 0 === o2 && (o2 = false), t2.reduce(function(t3, r2) {
      return Rt({ size: r2, aspectRatio: s, sizeRestrictions: n, ignoreMinimum: o2 }) && (!t3 || At(r2, { width: e, height: i }) < At(t3, { width: e, height: i })) ? r2 : t3;
    }, null);
  }
  var a = [];
  s && [s.minimum, s.maximum].forEach(function(t2) {
    t2 && a.push({ width: o.width, height: o.width / t2, correctRatio: true }, { width: o.height * t2, height: o.height, correctRatio: true });
  }), Rt({ size: o, aspectRatio: s, sizeRestrictions: n }) && a.push(o);
  var h2 = r(a) || r(a, true);
  return h2 && { width: h2.width, height: h2.height };
}
function St(t) {
  var e = t.event, i = t.coordinates, n = t.positionRestrictions, s = void 0 === n ? {} : n, o = at(i, e.directions);
  return at(o, ut(o, s));
}
function xt(t) {
  var e = t.coordinates, i = t.transform, n = t.imageSize, s = t.sizeRestrictions, o = t.positionRestrictions, r = t.aspectRatio, a = t.visibleArea, h2 = function(t2, e2) {
    return St({ coordinates: t2, positionRestrictions: o, event: new Y({ left: e2.left - t2.left, top: e2.top - t2.top }) });
  }, c2 = C({}, e);
  return (Array.isArray(i) ? i : [i]).forEach(function(t2) {
    var e2 = {};
    D((e2 = "function" == typeof t2 ? t2({ coordinates: c2, imageSize: n, visibleArea: a }) : t2).width) && D(e2.height) || (c2 = function(t3, e3) {
      var i2 = C(C(C({}, t3), Mt({ width: e3.width, height: e3.height, sizeRestrictions: s, aspectRatio: r })), { left: 0, top: 0 });
      return h2(i2, { left: t3.left, top: t3.top });
    }(c2, C(C({}, c2), e2))), D(e2.left) && D(e2.top) || (c2 = h2(c2, C(C({}, c2), e2)));
  }), c2;
}
function Ct(t) {
  t.event;
  var e = t.getAreaRestrictions, i = t.boundaries, n = t.coordinates, s = t.visibleArea;
  t.aspectRatio;
  var o = t.stencilSize, r = t.sizeRestrictions, a = t.positionRestrictions;
  t.stencilReference;
  var h2, c2, l, u = C({}, n), d = C({}, s), m = C({}, o);
  h2 = ct(m), c2 = ct(u), void 0 === l && (l = 1e-3), (0 === h2 || 0 === c2 ? Math.abs(c2 - h2) < l : Math.abs(c2 / h2) < 1 + l && Math.abs(c2 / h2) > 1 - l) || (u = C(C({}, u), Mt({ sizeRestrictions: r, width: u.width, height: u.height, aspectRatio: { minimum: ct(m), maximum: ct(m) } })));
  var p2 = ft(d = ht(d, u.width * i.width / (d.width * m.width)), e({ visibleArea: d, type: "resize" }));
  return 1 !== p2 && (d = ht(d, p2), u = ht(u, p2)), d = vt(d = at(d, it(nt(u), nt(d))), e({ visibleArea: d, type: "move" })), { coordinates: u = vt(u, zt(et(d), a)), visibleArea: d };
}
function Et(t) {
  var e = t.event, i = t.getAreaRestrictions, n = t.boundaries, s = t.coordinates, o = t.visibleArea;
  t.aspectRatio, t.stencilSize, t.sizeRestrictions;
  var r = t.positionRestrictions;
  t.stencilReference;
  var a = C({}, s), h2 = C({}, o);
  if (s && o && "manipulateImage" !== e.type) {
    var c2 = { width: 0, height: 0 };
    h2.width, n.width, ct(n) > ct(a) ? (c2.height = 0.8 * n.height, c2.width = c2.height * ct(a)) : (c2.width = 0.8 * n.width, c2.height = c2.width * ct(a));
    var l = ft(h2 = ht(h2, a.width * n.width / (h2.width * c2.width)), i({ visibleArea: h2, type: "resize" }));
    h2 = ht(h2, l), 1 !== l && (c2.height /= l, c2.width /= l), h2 = vt(h2 = at(h2, it(nt(a), nt(h2))), i({ visibleArea: h2, type: "move" })), a = vt(a, zt(et(h2), r));
  }
  return { coordinates: a, visibleArea: h2 };
}
function Wt(t) {
  var e = t.event, i = t.coordinates, n = t.visibleArea, s = t.getAreaRestrictions, o = C({}, n), r = C({}, i);
  if ("setCoordinates" === e.type) {
    var a = Math.max(0, r.width - o.width), h2 = Math.max(0, r.height - o.height);
    a > h2 ? o = ht(o, Math.min(r.width / o.width, lt(o, s({ visibleArea: o, type: "resize" })))) : h2 > a && (o = ht(o, Math.min(r.height / o.height, lt(o, s({ visibleArea: o, type: "resize" }))))), o = vt(o = at(o, rt(ut(r, et(o)))), s({ visibleArea: o, type: "move" }));
  }
  return { visibleArea: o, coordinates: r };
}
function Tt(t) {
  var e = t.imageSize, i = t.visibleArea, n = t.coordinates, s = i || e;
  return { left: (i ? i.left : 0) + s.width / 2 - n.width / 2, top: (i ? i.top : 0) + s.height / 2 - n.height / 2 };
}
function Ot(t) {
  var e = t.imageSize, i = t.visibleArea, n = t.aspectRatio, s = t.sizeRestrictions, o = i || e, r = Math.min(n.maximum || 1 / 0, Math.max(n.minimum || 0, ct(o))), a = o.width < o.height ? { width: 0.8 * o.width, height: 0.8 * o.width / r } : { height: 0.8 * o.height, width: 0.8 * o.height * r };
  return Mt(C(C({}, a), { aspectRatio: n, sizeRestrictions: s }));
}
function Dt(t) {
  var e, i, n = t.imageSize, s = t.visibleArea, o = t.boundaries, r = t.aspectRatio, a = t.sizeRestrictions, h2 = t.stencilSize, c2 = s || n;
  return ct(c2) > ct(o) ? i = (e = h2.height * c2.height / o.height) * ct(h2) : e = (i = h2.width * c2.width / o.width) / ct(h2), Mt({ width: i, height: e, aspectRatio: r, sizeRestrictions: a });
}
function Ht(t) {
  var e = t.getAreaRestrictions, i = t.coordinates, n = t.imageSize, s = ct(t.boundaries);
  if (i) {
    var o = { height: Math.max(i.height, n.height), width: Math.max(i.width, n.width) }, r = mt({ width: ct(o) > s ? o.width : o.height * s, height: ct(o) > s ? o.width / s : o.height }, bt(e())), a = { left: i.left + i.width / 2 - r.width / 2, top: i.top + i.height / 2 - r.height / 2, width: r.width, height: r.height }, h2 = st(i, et(C({ left: 0, top: 0 }, n))), c2 = {};
    return !h2.left && !h2.right && a.width <= n.width && (c2.left = 0, c2.right = n.width), !h2.top && !h2.bottom && a.height <= n.height && (c2.top = 0, c2.bottom = n.height), vt(a, c2);
  }
  var l = ct(n);
  r = { height: l > s ? n.height : n.width / s, width: l > s ? n.height * s : n.width };
  return { left: n.width / 2 - r.width / 2, top: n.height / 2 - r.height / 2, width: r.width, height: r.height };
}
function jt(t, e) {
  return yt(t, et(e));
}
function Lt(t) {
  var e = t.event, i = t.coordinates, n = t.visibleArea, s = t.sizeRestrictions, o = t.getAreaRestrictions, r = t.positionRestrictions, a = t.adjustStencil, h2 = e.scale, c2 = e.move, l = C({}, n), u = C({}, i), d = 1, m = 1, p2 = h2.factor && Math.abs(h2.factor - 1) > 1e-3;
  l = at(l, { left: c2.left || 0, top: c2.top || 0 });
  var g2 = { stencil: { minimum: Math.max(s.minWidth ? s.minWidth / u.width : 0, s.minHeight ? s.minHeight / u.height : 0), maximum: Math.min(s.maxWidth ? s.maxWidth / u.width : 1 / 0, s.maxHeight ? s.maxHeight / u.height : 1 / 0, lt(u, r)) }, area: { maximum: lt(l, o({ visibleArea: l, type: "resize" })) } };
  h2.factor && p2 && (h2.factor < 1 ? (m = Math.max(h2.factor, g2.stencil.minimum)) > 1 && (m = 1) : h2.factor > 1 && (m = Math.min(h2.factor, Math.min(g2.area.maximum, g2.stencil.maximum))) < 1 && (m = 1)), m && (l = ht(l, m, h2.center));
  var f2 = i.left - n.left, v2 = n.width + n.left - (i.width + i.left), b2 = i.top - n.top, w2 = n.height + n.top - (i.height + i.top);
  return l = vt(l = at(l, ut(l, { left: void 0 !== r.left ? r.left - f2 * m : void 0, top: void 0 !== r.top ? r.top - b2 * m : void 0, bottom: void 0 !== r.bottom ? r.bottom + w2 * m : void 0, right: void 0 !== r.right ? r.right + v2 * m : void 0 })), o({ visibleArea: l, type: "move" })), u.width = u.width * m, u.height = u.height * m, u.left = l.left + f2 * m, u.top = l.top + b2 * m, u = vt(u, zt(et(l), r)), h2.factor && p2 && a && (h2.factor > 1 ? d = Math.min(g2.area.maximum, h2.factor) / m : h2.factor < 1 && (d = Math.max(u.height / l.height, u.width / l.width, h2.factor / m)), 1 !== d && (l = at(l = vt(l = ht(l, d, h2.factor > 1 ? h2.center : nt(u)), o({ visibleArea: l, type: "move" })), rt(ut(u, et(l)))))), { coordinates: u, visibleArea: l };
}
function Pt(t) {
  var e = t.aspectRatio, i = t.getAreaRestrictions, n = t.coordinates, s = t.visibleArea, o = t.sizeRestrictions, r = t.positionRestrictions, a = t.imageSize, h2 = t.previousImageSize, c2 = t.angle, l = C({}, n), u = C({}, s), d = gt(nt(C({ left: 0, top: 0 }, h2)), c2);
  return (l = C(C({}, Mt({ sizeRestrictions: o, aspectRatio: e, width: l.width, height: l.height })), gt(nt(l), c2))).left -= d.left - a.width / 2 + l.width / 2, l.top -= d.top - a.height / 2 + l.height / 2, u = ht(u, ft(u, i({ visibleArea: u, type: "resize" }))), { coordinates: l = vt(l, r), visibleArea: u = vt(u = at(u, it(nt(l), nt(n))), i({ visibleArea: u, type: "move" })) };
}
function $t(t) {
  var e = t.flip, i = t.previousFlip, n = t.rotate;
  t.aspectRatio;
  var s = t.getAreaRestrictions, o = t.coordinates, r = t.visibleArea, a = t.imageSize, h2 = C({}, o), c2 = C({}, r), l = i.horizontal !== e.horizontal, u = i.vertical !== e.vertical;
  if (l || u) {
    var d = gt({ left: a.width / 2, top: a.height / 2 }, -n), m = gt(nt(h2), -n), p2 = gt({ left: l ? d.left - (m.left - d.left) : m.left, top: u ? d.top - (m.top - d.top) : m.top }, n);
    h2 = at(h2, it(p2, nt(h2))), m = gt(nt(c2), -n), c2 = vt(c2 = at(c2, it(p2 = gt({ left: l ? d.left - (m.left - d.left) : m.left, top: u ? d.top - (m.top - d.top) : m.top }, n), nt(c2))), s({ visibleArea: c2, type: "move" }));
  }
  return { coordinates: h2, visibleArea: c2 };
}
function It(t) {
  var e = t.directions, i = t.coordinates, n = t.positionRestrictions, s = void 0 === n ? {} : n, o = t.sizeRestrictions, r = t.preserveRatio, a = t.compensate, h2 = C({}, e), c2 = ot(i, h2).width, l = ot(i, h2).height;
  c2 < 0 && (h2.left < 0 && h2.right < 0 ? (h2.left = -(i.width - o.minWidth) / (h2.left / h2.right), h2.right = -(i.width - o.minWidth) / (h2.right / h2.left)) : h2.left < 0 ? h2.left = -(i.width - o.minWidth) : h2.right < 0 && (h2.right = -(i.width - o.minWidth))), l < 0 && (h2.top < 0 && h2.bottom < 0 ? (h2.top = -(i.height - o.minHeight) / (h2.top / h2.bottom), h2.bottom = -(i.height - o.minHeight) / (h2.bottom / h2.top)) : h2.top < 0 ? h2.top = -(i.height - o.minHeight) : h2.bottom < 0 && (h2.bottom = -(i.height - o.minHeight)));
  var u = st(ot(i, h2), s);
  a && (u.left && u.left > 0 && 0 === u.right ? (h2.right += u.left, h2.left -= u.left) : u.right && u.right > 0 && 0 === u.left && (h2.left += u.right, h2.right -= u.right), u.top && u.top > 0 && 0 === u.bottom ? (h2.bottom += u.top, h2.top -= u.top) : u.bottom && u.bottom > 0 && 0 === u.top && (h2.top += u.bottom, h2.bottom -= u.bottom), u = st(ot(i, h2), s));
  var d = { width: 1 / 0, height: 1 / 0, left: 1 / 0, right: 1 / 0, top: 1 / 0, bottom: 1 / 0 };
  if (V.forEach(function(t2) {
    var e2 = u[t2];
    e2 && h2[t2] && (d[t2] = Math.max(0, 1 - e2 / h2[t2]));
  }), r) {
    var m = Math.min.apply(null, V.map(function(t2) {
      return d[t2];
    }));
    m !== 1 / 0 && V.forEach(function(t2) {
      h2[t2] *= m;
    });
  } else
    V.forEach(function(t2) {
      d[t2] !== 1 / 0 && (h2[t2] *= d[t2]);
    });
  if (c2 = ot(i, h2).width, l = ot(i, h2).height, h2.right + h2.left && (c2 > o.maxWidth ? d.width = (o.maxWidth - i.width) / (h2.right + h2.left) : c2 < o.minWidth && (d.width = (o.minWidth - i.width) / (h2.right + h2.left))), h2.bottom + h2.top && (l > o.maxHeight ? d.height = (o.maxHeight - i.height) / (h2.bottom + h2.top) : l < o.minHeight && (d.height = (o.minHeight - i.height) / (h2.bottom + h2.top))), r) {
    var p2 = Math.min(d.width, d.height);
    p2 !== 1 / 0 && V.forEach(function(t2) {
      h2[t2] *= p2;
    });
  } else
    d.width !== 1 / 0 && _.forEach(function(t2) {
      h2[t2] *= d.width;
    }), d.height !== 1 / 0 && G.forEach(function(t2) {
      h2[t2] *= d.height;
    });
  return h2;
}
function Bt(t, e, i) {
  return 0 == e && 0 == i ? t / 2 : 0 == e ? 0 : 0 == i ? t : t * Math.abs(e / (e + i));
}
var Xt = M("vue-simple-handler"), Yt = M("vue-simple-handler-wrapper"), kt = { name: "SimpleHandler", components: { HandlerWrapper: N }, props: { defaultClass: { type: String }, hoverClass: { type: String }, wrapperClass: { type: String }, horizontalPosition: { type: String }, verticalPosition: { type: String }, disabled: { type: Boolean, default: false } }, data: function() {
  return { hover: false };
}, computed: { classes: function() {
  var t, e = (f(t = {}, this.horizontalPosition, Boolean(this.horizontalPosition)), f(t, this.verticalPosition, Boolean(this.verticalPosition)), f(t, "".concat(this.horizontalPosition, "-").concat(this.verticalPosition), Boolean(this.verticalPosition && this.horizontalPosition)), f(t, "hover", this.hover), t);
  return { default: A(Xt(e), this.defaultClass, this.hover && this.hoverClass), wrapper: A(Yt(e), this.wrapperClass) };
} }, methods: { onDrag: function(t) {
  this.$emit("drag", t);
}, onEnter: function() {
  this.hover = true;
}, onLeave: function() {
  this.hover = false;
}, onDragEnd: function() {
  this.$emit("drag-end");
} }, emits: ["drag", "drag-end"] };
kt.render = function(i, r, a, h2, c2, l) {
  var u = resolveComponent("HandlerWrapper");
  return openBlock(), createBlock(u, { class: l.classes.wrapper, "vertical-position": a.verticalPosition, "horizontal-position": a.horizontalPosition, disabled: a.disabled, onDrag: l.onDrag, onDragEnd: l.onDragEnd, onEnter: l.onEnter, onLeave: l.onLeave }, { default: withCtx(function() {
    return [createVNode("div", { class: l.classes.default }, null, 2)];
  }), _: 1 }, 8, ["class", "vertical-position", "horizontal-position", "disabled", "onDrag", "onDragEnd", "onEnter", "onLeave"]);
};
var Ft = M("vue-simple-line"), Ut = M("vue-simple-line-wrapper"), Nt = { name: "SimpleLine", components: { LineWrapper: q }, props: { defaultClass: { type: String }, hoverClass: { type: String }, wrapperClass: { type: String }, position: { type: String }, disabled: { type: Boolean, default: false } }, data: function() {
  return { hover: false };
}, computed: { classes: function() {
  return { root: A(Ft(f({}, this.position, true)), this.defaultClass, this.hover && this.hoverClass), wrapper: A(Ut(f({}, this.position, true)), this.wrapperClass) };
} }, methods: { onDrag: function(t) {
  this.$emit("drag", t);
}, onEnter: function() {
  this.hover = true;
}, onLeave: function() {
  this.hover = false;
}, onDragEnd: function() {
  this.$emit("drag-end");
} }, emits: ["drag", "drag-end"] };
Nt.render = function(i, r, a, h2, c2, l) {
  var u = resolveComponent("LineWrapper");
  return openBlock(), createBlock(u, { class: l.classes.wrapper, position: a.position, disabled: a.disabled, onDrag: l.onDrag, onDragEnd: l.onDragEnd, onEnter: l.onEnter, onLeave: l.onLeave }, { default: withCtx(function() {
    return [createVNode("div", { class: l.classes.root }, null, 2)];
  }), _: 1 }, 8, ["class", "position", "disabled", "onDrag", "onDragEnd", "onEnter", "onLeave"]);
};
var Zt = M("vue-bounding-box"), qt = ["east", "west", null], Vt = ["south", "north", null], _t = { name: "BoundingBox", props: { width: { type: Number }, height: { type: Number }, transitions: { type: Object }, handlers: { type: Object, default: function() {
  return { eastNorth: true, north: true, westNorth: true, west: true, westSouth: true, south: true, eastSouth: true, east: true };
} }, handlersComponent: { type: [Object, String], default: function() {
  return kt;
} }, handlersClasses: { type: Object, default: function() {
  return {};
} }, handlersWrappersClasses: { type: Object, default: function() {
  return {};
} }, lines: { type: Object, default: function() {
  return { west: true, north: true, east: true, south: true };
} }, linesComponent: { type: [Object, String], default: function() {
  return Nt;
} }, linesClasses: { type: Object, default: function() {
  return {};
} }, linesWrappersClasses: { type: Object, default: function() {
  return {};
} }, resizable: { type: Boolean, default: true } }, data: function() {
  var t = [];
  return qt.forEach(function(e) {
    Vt.forEach(function(i) {
      if (e !== i) {
        var n = E(e, i), s = n.name, o = n.classname;
        t.push({ name: s, classname: o, verticalDirection: i, horizontalDirection: e });
      }
    });
  }), { points: t };
}, computed: { style: function() {
  var t = {};
  return this.width && this.height && (t.width = "".concat(this.width, "px"), t.height = "".concat(this.height, "px"), this.transitions && this.transitions.enabled && (t.transition = "".concat(this.transitions.time, "ms ").concat(this.transitions.timingFunction))), t;
}, classes: function() {
  var t = this.handlersClasses, e = this.handlersWrappersClasses, i = this.linesClasses, n = this.linesWrappersClasses;
  return { root: Zt(), handlers: t, handlersWrappers: e, lines: i, linesWrappers: n };
}, lineNodes: function() {
  var t = this, e = [];
  return this.points.forEach(function(i) {
    i.horizontalDirection && i.verticalDirection || !t.lines[i.name] || e.push({ name: i.name, component: t.linesComponent, class: A(t.classes.lines.default, t.classes.lines[i.name], !t.resizable && t.classes.lines.disabled), wrapperClass: A(t.classes.linesWrappers.default, t.classes.linesWrappers[i.name], !t.resizable && t.classes.linesWrappers.disabled), hoverClass: t.classes.lines.hover, verticalDirection: i.verticalDirection, horizontalDirection: i.horizontalDirection, disabled: !t.resizable });
  }), e;
}, handlerNodes: function() {
  var t = this, e = [], i = this.width, n = this.height;
  return this.points.forEach(function(s) {
    if (t.handlers[s.name]) {
      var o = { name: s.name, component: t.handlersComponent, class: A(t.classes.handlers.default, t.classes.handlers[s.name]), wrapperClass: A(t.classes.handlersWrappers.default, t.classes.handlersWrappers[s.name]), hoverClass: t.classes.handlers.hover, verticalDirection: s.verticalDirection, horizontalDirection: s.horizontalDirection, disabled: !t.resizable };
      if (i && n) {
        var r = s.horizontalDirection, a = s.verticalDirection, h2 = "east" === r ? i : "west" === r ? 0 : i / 2, c2 = "south" === a ? n : "north" === a ? 0 : n / 2;
        o.wrapperClass = Zt("handler"), o.wrapperStyle = { transform: "translate(".concat(h2, "px, ").concat(c2, "px)") }, t.transitions && t.transitions.enabled && (o.wrapperStyle.transition = "".concat(t.transitions.time, "ms ").concat(t.transitions.timingFunction));
      } else
        o.wrapperClass = Zt("handler", f({}, s.classname, true));
      e.push(o);
    }
  }), e;
} }, beforeMount: function() {
  window.addEventListener("mouseup", this.onMouseUp, { passive: false }), window.addEventListener("mousemove", this.onMouseMove, { passive: false }), window.addEventListener("touchmove", this.onTouchMove, { passive: false }), window.addEventListener("touchend", this.onTouchEnd, { passive: false });
}, beforeUnmount: function() {
  window.removeEventListener("mouseup", this.onMouseUp), window.removeEventListener("mousemove", this.onMouseMove), window.removeEventListener("touchmove", this.onTouchMove), window.removeEventListener("touchend", this.onTouchEnd);
}, mounted: function() {
  this.touches = [];
}, methods: { onEnd: function() {
  this.$emit("resize-end");
}, onHandlerDrag: function(t, e, i) {
  var n, s = t.shift(), o = s.left, r = s.top, a = { left: 0, right: 0, top: 0, bottom: 0 };
  "west" === e ? a.left -= o : "east" === e && (a.right += o), "north" === i ? a.top -= r : "south" === i && (a.bottom += r), !i && e ? n = "width" : i && !e && (n = "height"), this.resizable && this.$emit("resize", new X(a, { allowedDirections: { left: "west" === e || !e, right: "east" === e || !e, bottom: "south" === i || !i, top: "north" === i || !i }, preserveAspectRatio: t.nativeEvent && t.nativeEvent.shiftKey, respectDirection: n }));
} }, emits: ["resize", "resize-end"] };
_t.render = function(n, o, c2, l, u, d) {
  return openBlock(), createBlock("div", { ref: "box", class: d.classes.root, style: d.style }, [renderSlot(n.$slots, "default"), createVNode("div", null, [(openBlock(true), createBlock(Fragment, null, renderList(d.lineNodes, function(i) {
    return openBlock(), createBlock(resolveDynamicComponent(i.component), { key: i.name, "default-class": i.class, "hover-class": i.hoverClass, "wrapper-class": i.wrapperClass, position: i.name, disabled: i.disabled, onDrag: function(t) {
      return d.onHandlerDrag(t, i.horizontalDirection, i.verticalDirection);
    }, onDragEnd: o[1] || (o[1] = function(t) {
      return d.onEnd();
    }) }, null, 8, ["default-class", "hover-class", "wrapper-class", "position", "disabled", "onDrag"]);
  }), 128))]), (openBlock(true), createBlock(Fragment, null, renderList(d.handlerNodes, function(i) {
    return openBlock(), createBlock("div", { key: i.name, style: i.wrapperStyle, class: i.wrapperClass }, [(openBlock(), createBlock(resolveDynamicComponent(i.component), { "default-class": i.class, "hover-class": i.hoverClass, "wrapper-class": i.wrapperClass, "horizontal-position": i.horizontalDirection, "vertical-position": i.verticalDirection, disabled: i.disabled, onDrag: function(t) {
      return d.onHandlerDrag(t, i.horizontalDirection, i.verticalDirection);
    }, onDragEnd: o[2] || (o[2] = function(t) {
      return d.onEnd();
    }) }, null, 8, ["default-class", "hover-class", "wrapper-class", "horizontal-position", "vertical-position", "disabled", "onDrag"]))], 6);
  }), 128))], 6);
};
var Gt = M("vue-draggable-area"), Qt = { name: "DraggableArea", props: { movable: { type: Boolean, default: true }, activationDistance: { type: Number, default: 20 } }, computed: { classnames: function() {
  return { default: Gt() };
} }, beforeMount: function() {
  window.addEventListener("mouseup", this.onMouseUp, { passive: false }), window.addEventListener("mousemove", this.onMouseMove, { passive: false }), window.addEventListener("touchmove", this.onTouchMove, { passive: false }), window.addEventListener("touchend", this.onTouchEnd, { passive: false });
}, beforeUnmount: function() {
  window.removeEventListener("mouseup", this.onMouseUp), window.removeEventListener("mousemove", this.onMouseMove), window.removeEventListener("touchmove", this.onTouchMove), window.removeEventListener("touchend", this.onTouchEnd);
}, mounted: function() {
  this.touches = [], this.touchStarted = false;
}, methods: { onTouchStart: function(t) {
  if (t.cancelable) {
    var e = this.movable && 1 === t.touches.length;
    e && (this.touches = b(t.touches)), (this.touchStarted || e) && (t.preventDefault(), t.stopPropagation());
  }
}, onTouchEnd: function() {
  this.touchStarted = false, this.processEnd();
}, onTouchMove: function(t) {
  this.touches.length >= 1 && (this.touchStarted ? (this.processMove(t, t.touches), t.preventDefault(), t.stopPropagation()) : I({ x: this.touches[0].clientX, y: this.touches[0].clientY }, { x: t.touches[0].clientX, y: t.touches[0].clientY }) > this.activationDistance && (this.initAnchor({ clientX: t.touches[0].clientX, clientY: t.touches[0].clientY }), this.touchStarted = true));
}, onMouseDown: function(t) {
  if (this.movable && 0 === t.button) {
    var e = { fake: true, clientX: t.clientX, clientY: t.clientY };
    this.touches = [e], this.initAnchor(e), t.stopPropagation();
  }
}, onMouseMove: function(t) {
  this.touches.length && (this.processMove(t, [{ fake: true, clientX: t.clientX, clientY: t.clientY }]), t.preventDefault && t.cancelable && t.preventDefault(), t.stopPropagation());
}, onMouseUp: function() {
  this.processEnd();
}, initAnchor: function(t) {
  var e = this.$refs.container.getBoundingClientRect(), i = e.left, n = e.top;
  this.anchor = { x: t.clientX - i, y: t.clientY - n };
}, processMove: function(t, e) {
  var i = b(e);
  if (this.touches.length) {
    var n = this.$refs.container.getBoundingClientRect(), s = n.left, o = n.top;
    1 === this.touches.length && 1 === i.length && this.$emit("move", new Y({ left: i[0].clientX - (s + this.anchor.x), top: i[0].clientY - (o + this.anchor.y) }));
  }
}, processEnd: function() {
  this.touches.length && this.$emit("move-end"), this.touches = [];
} }, emits: ["move", "move-end"] };
Qt.render = function(n, s, o, r, a, h2) {
  return openBlock(), createBlock("div", { ref: "container", onTouchstart: s[1] || (s[1] = function() {
    return h2.onTouchStart && h2.onTouchStart.apply(h2, arguments);
  }), onMousedown: s[2] || (s[2] = function() {
    return h2.onMouseDown && h2.onMouseDown.apply(h2, arguments);
  }) }, [renderSlot(n.$slots, "default")], 544);
};
function Kt(t) {
  var e, i;
  return { rotate: t.rotate || 0, flip: { horizontal: (null === (e = null == t ? void 0 : t.flip) || void 0 === e ? void 0 : e.horizontal) || false, vertical: (null === (i = null == t ? void 0 : t.flip) || void 0 === i ? void 0 : i.vertical) || false } };
}
function Jt(t) {
  return new Promise(function(e, i) {
    try {
      if (t)
        if (/^data:/i.test(t))
          e(function(t2) {
            t2 = t2.replace(/^data:([^;]+);base64,/gim, "");
            for (var e2 = atob(t2), i2 = e2.length, n2 = new ArrayBuffer(i2), s2 = new Uint8Array(n2), o2 = 0; o2 < i2; o2++)
              s2[o2] = e2.charCodeAt(o2);
            return n2;
          }(t));
        else if (/^blob:/i.test(t)) {
          var n = new FileReader();
          n.onload = function(t2) {
            e(t2.target.result);
          }, o = t, r = function(t2) {
            n.readAsArrayBuffer(t2);
          }, (a = new XMLHttpRequest()).open("GET", o, true), a.responseType = "blob", a.onload = function() {
            200 != this.status && 0 !== this.status || r(this.response);
          }, a.send();
        } else {
          var s = new XMLHttpRequest();
          s.onreadystatechange = function() {
            4 === s.readyState && (200 === s.status || 0 === s.status ? e(s.response) : i("Warning: could not load an image to parse its orientation"), s = null);
          }, s.onprogress = function() {
            "image/jpeg" !== s.getResponseHeader("content-type") && s.abort();
          }, s.withCredentials = false, s.open("GET", t, true), s.responseType = "arraybuffer", s.send(null);
        }
      else
        i("Error: the image is empty");
    } catch (t2) {
      i(t2);
    }
    var o, r, a;
  });
}
function te(t) {
  var e = t.rotate, i = t.flip, n = t.scaleX, s = t.scaleY, o = "";
  return o += " rotate(" + e + "deg) ", o += " scaleX(" + n * (i.horizontal ? -1 : 1) + ") ", o += " scaleY(" + s * (i.vertical ? -1 : 1) + ") ";
}
function ee(t) {
  try {
    var e, i = new DataView(t), n = void 0, s = void 0, o = void 0, r = void 0;
    if (255 === i.getUint8(0) && 216 === i.getUint8(1))
      for (var a = i.byteLength, h2 = 2; h2 + 1 < a; ) {
        if (255 === i.getUint8(h2) && 225 === i.getUint8(h2 + 1)) {
          o = h2;
          break;
        }
        h2++;
      }
    if (o && (n = o + 10, "Exif" === function(t2, e2, i2) {
      var n2, s2 = "";
      for (n2 = e2, i2 += e2; n2 < i2; n2++)
        s2 += String.fromCharCode(t2.getUint8(n2));
      return s2;
    }(i, o + 4, 4))) {
      var c2 = i.getUint16(n);
      if (((s = 18761 === c2) || 19789 === c2) && 42 === i.getUint16(n + 2, s)) {
        var l = i.getUint32(n + 4, s);
        l >= 8 && (r = n + l);
      }
    }
    if (r)
      for (var u = i.getUint16(r, s), d = 0; d < u; d++) {
        h2 = r + 12 * d + 2;
        if (274 === i.getUint16(h2, s)) {
          h2 += 8, e = i.getUint16(h2, s), i.setUint16(h2, 1, s);
          break;
        }
      }
    return e;
  } catch (t2) {
    return null;
  }
}
function se(t, e) {
  var i = e.getBoundingClientRect(), n = i.left, s = i.top, o = { left: 0, top: 0 }, r = 0;
  return t.forEach(function(e2) {
    o.left += (e2.clientX - n) / t.length, o.top += (e2.clientY - s) / t.length;
  }), t.forEach(function(t2) {
    r += I({ x: o.left, y: o.top }, { x: t2.clientX - n, y: t2.clientY - s });
  }), { centerMass: o, spread: r, count: t.length };
}
var oe = { props: { touchMove: { type: Boolean, required: true }, mouseMove: { type: Boolean, required: true }, touchResize: { type: Boolean, required: true }, wheelResize: { type: [Boolean, Object], required: true }, eventsFilter: { type: Function, required: false } }, beforeMount: function() {
  window.addEventListener("mouseup", this.onMouseUp, { passive: false }), window.addEventListener("mousemove", this.onMouseMove, { passive: false }), window.addEventListener("touchmove", this.onTouchMove, { passive: false }), window.addEventListener("touchend", this.onTouchEnd, { passive: false });
}, beforeUnmount: function() {
  window.removeEventListener("mouseup", this.onMouseUp), window.removeEventListener("mousemove", this.onMouseMove), window.removeEventListener("touchmove", this.onTouchMove), window.removeEventListener("touchend", this.onTouchEnd);
}, created: function() {
  this.transforming = false, this.debouncedProcessEnd = x(this.processEnd), this.touches = [];
}, methods: { processMove: function(t, e) {
  if (this.touches.length) {
    if (1 === this.touches.length && 1 === e.length)
      this.$emit("move", new B({ left: this.touches[0].clientX - e[0].clientX, top: this.touches[0].clientY - e[0].clientY }));
    else if (this.touches.length > 1 && this.touchResize) {
      var i = se(e, this.$refs.container), n = this.oldGeometricProperties;
      n.count === i.count && n.count > 1 && this.$emit("resize", new B({ left: n.centerMass.left - i.centerMass.left, top: n.centerMass.top - i.centerMass.top }, { factor: n.spread / i.spread, center: i.centerMass })), this.oldGeometricProperties = i;
    }
    this.touches = e;
  }
}, processEnd: function() {
  this.transforming && (this.transforming = false, this.$emit("transform-end"));
}, processStart: function() {
  this.transforming = true, this.debouncedProcessEnd.clear();
}, processEvent: function(t) {
  return this.eventsFilter ? false !== this.eventsFilter(t, this.transforming) : (t.preventDefault(), t.stopPropagation(), true);
}, onTouchStart: function(t) {
  if (t.cancelable && (this.touchMove || this.touchResize && t.touches.length > 1) && this.processEvent(t)) {
    var e = this.$refs.container, i = e.getBoundingClientRect(), n = i.left, s = i.top, o = i.bottom, r = i.right;
    this.touches = b(t.touches).filter(function(t2) {
      return t2.clientX > n && t2.clientX < r && t2.clientY > s && t2.clientY < o;
    }), this.oldGeometricProperties = se(this.touches, e);
  }
}, onTouchEnd: function(t) {
  0 === t.touches.length && (this.touches = [], this.processEnd());
}, onTouchMove: function(t) {
  var e = this;
  if (this.touches.length) {
    var i = b(t.touches).filter(function(t2) {
      return !t2.identifier || e.touches.find(function(e2) {
        return e2.identifier === t2.identifier;
      });
    });
    this.processEvent(t) && (this.processMove(t, i), this.processStart());
  }
}, onMouseDown: function(t) {
  if (this.mouseMove && "buttons" in t && 1 === t.buttons && this.processEvent(t)) {
    var e = { fake: true, clientX: t.clientX, clientY: t.clientY };
    this.touches = [e], this.processStart();
  }
}, onMouseMove: function(t) {
  this.touches.length && this.processEvent(t) && this.processMove(t, [{ clientX: t.clientX, clientY: t.clientY }]);
}, onMouseUp: function() {
  this.touches = [], this.processEnd();
}, onWheel: function(t) {
  if (this.wheelResize && this.processEvent(t)) {
    var e = this.$refs.container.getBoundingClientRect(), i = e.left, n = e.top, s = 1 + this.wheelResize.ratio * (r = t.deltaY || t.detail || t.wheelDelta, 0 === (a = +r) || $(a) ? a : a > 0 ? 1 : -1), o = { left: t.clientX - i, top: t.clientY - n };
    this.$emit("resize", new B({}, { factor: s, center: o })), this.touches.length || this.debouncedProcessEnd();
  }
  var r, a;
} }, emits: ["resize", "move", "transform-end"] };
oe.render = function(n, s, o, r, a, h2) {
  return openBlock(), createBlock("div", { ref: "container", onTouchstart: s[1] || (s[1] = function() {
    return h2.onTouchStart && h2.onTouchStart.apply(h2, arguments);
  }), onMousedown: s[2] || (s[2] = function() {
    return h2.onMouseDown && h2.onMouseDown.apply(h2, arguments);
  }), onWheel: s[3] || (s[3] = function() {
    return h2.onWheel && h2.onWheel.apply(h2, arguments);
  }) }, [renderSlot(n.$slots, "default")], 544);
};
var re = { components: { TransformableImage: oe }, props: { touchMove: { type: Boolean, required: true }, mouseMove: { type: Boolean, required: true }, touchResize: { type: Boolean, required: true }, wheelResize: { type: [Boolean, Object], required: true } }, emits: ["resize", "move"] };
re.render = function(s, r, a, h2, c2, l) {
  var u = resolveComponent("transformable-image");
  return openBlock(), createBlock(u, { "touch-move": a.touchMove, "touch-resize": a.touchResize, "mouse-move": a.mouseMove, "wheel-resize": a.wheelResize, onMove: r[1] || (r[1] = function(t) {
    return s.$emit("move", t);
  }), onResize: r[2] || (r[2] = function(t) {
    return s.$emit("resize", t);
  }) }, { default: withCtx(function() {
    return [renderSlot(s.$slots, "default")];
  }), _: 3 }, 8, ["touch-move", "touch-resize", "mouse-move", "wheel-resize"]);
};
var ae = M("vue-preview"), he = { props: { coordinates: { type: Object }, transitions: { type: Object }, image: { type: Object, default: function() {
  return {};
} }, imageClass: { type: String }, width: { type: Number }, height: { type: Number }, fill: { type: Boolean } }, data: function() {
  return { calculatedImageSize: { width: 0, height: 0 }, calculatedSize: { width: 0, height: 0 } };
}, computed: { classes: function() {
  return { root: ae({ fill: this.fill }), wrapper: ae("wrapper"), imageWrapper: ae("image-wrapper"), image: A(ae("image"), this.imageClass) };
}, style: function() {
  if (this.fill)
    return {};
  var t = {};
  return this.width && (t.width = "".concat(this.size.width, "px")), this.height && (t.height = "".concat(this.size.height, "px")), this.transitions && this.transitions.enabled && (t.transition = "".concat(this.transitions.time, "ms ").concat(this.transitions.timingFunction)), t;
}, wrapperStyle: function() {
  var t = { width: "".concat(this.size.width, "px"), height: "".concat(this.size.height, "px"), left: "calc(50% - ".concat(this.size.width / 2, "px)"), top: "calc(50% - ".concat(this.size.height / 2, "px)") };
  return this.transitions && this.transitions.enabled && (t.transition = "".concat(this.transitions.time, "ms ").concat(this.transitions.timingFunction)), t;
}, imageStyle: function() {
  if (this.coordinates && this.image) {
    var t = this.coordinates.width / this.size.width, e = g(g({ rotate: 0, flip: { horizontal: false, vertical: false } }, this.image.transforms), {}, { scaleX: 1 / t, scaleY: 1 / t }), i = this.imageSize.width, n = this.imageSize.height, s = pt({ width: i, height: n }, e.rotate), o = { width: "".concat(i, "px"), height: "".concat(n, "px"), left: "0px", top: "0px" }, r = { rotate: { left: (i - s.width) * e.scaleX / 2, top: (n - s.height) * e.scaleY / 2 }, scale: { left: (1 - e.scaleX) * i / 2, top: (1 - e.scaleY) * n / 2 } };
    return o.transform = "translate(\n				".concat(-this.coordinates.left / t - r.rotate.left - r.scale.left, "px,").concat(-this.coordinates.top / t - r.rotate.top - r.scale.top, "px) ") + te(e), this.transitions && this.transitions.enabled && (o.transition = "".concat(this.transitions.time, "ms ").concat(this.transitions.timingFunction)), o;
  }
  return {};
}, size: function() {
  return { width: this.width || this.calculatedSize.width, height: this.height || this.calculatedSize.height };
}, imageSize: function() {
  return { width: this.image.width || this.calculatedImageSize.width, height: this.image.height || this.calculatedImageSize.height };
} }, watch: { image: function(t) {
  (t.width || t.height) && this.onChangeImage();
} }, mounted: function() {
  var t = this;
  this.onChangeImage(), this.$refs.image.addEventListener("load", function() {
    t.refreshImage();
  }), window.addEventListener("resize", this.refresh), window.addEventListener("orientationchange", this.refresh);
}, unmounted: function() {
  window.removeEventListener("resize", this.refresh), window.removeEventListener("orientationchange", this.refresh);
}, methods: { refreshImage: function() {
  var t = this.$refs.image;
  this.calculatedImageSize.height = t.naturalHeight, this.calculatedImageSize.width = t.naturalWidth;
}, refresh: function() {
  var t = this.$refs.root;
  this.width || (this.calculatedSize.width = t.clientWidth), this.height || (this.calculatedSize.height = t.clientHeight);
}, onChangeImage: function() {
  var t = this.$refs.image;
  t && t.complete && this.refreshImage(), this.refresh();
} } };
he.render = function(i, n, o, r, a, h2) {
  return openBlock(), createBlock("div", { ref: "root", class: h2.classes.root, style: h2.style }, [createVNode("div", { ref: "wrapper", class: h2.classes.wrapper, style: h2.wrapperStyle }, [withDirectives(createVNode("img", { ref: "image", src: o.image && o.image.src, class: h2.classes.image, style: h2.imageStyle }, null, 14, ["src"]), [[vShow, o.image && o.image.src]])], 6)], 6);
};
var ce = { components: { Preview: he }, inheritAttrs: false };
ce.render = function(i, s, o, r, a, h2) {
  var c2 = resolveComponent("preview");
  return openBlock(), createBlock(c2, mergeProps(i.$attrs, { fill: true }), null, 16);
};
var le = M("vue-rectangle-stencil"), ue = { name: "RectangleStencil", components: { StencilPreview: ce, BoundingBox: _t, DraggableArea: Qt }, props: { image: { type: Object }, coordinates: { type: Object }, stencilCoordinates: { type: Object }, handlers: { type: Object }, handlersComponent: { type: [Object, String], default: function() {
  return kt;
} }, lines: { type: Object }, linesComponent: { type: [Object, String], default: function() {
  return Nt;
} }, aspectRatio: { type: [Number, String] }, minAspectRatio: { type: [Number, String] }, maxAspectRatio: { type: [Number, String] }, movable: { type: Boolean, default: true }, resizable: { type: Boolean, default: true }, transitions: { type: Object }, movingClass: { type: String }, resizingClass: { type: String }, previewClass: { type: String }, boundingBoxClass: { type: String }, linesClasses: { type: Object, default: function() {
  return {};
} }, linesWrappersClasses: { type: Object, default: function() {
  return {};
} }, handlersClasses: { type: Object, default: function() {
  return {};
} }, handlersWrappersClasses: { type: Object, default: function() {
  return {};
} } }, data: function() {
  return { moving: false, resizing: false };
}, computed: { classes: function() {
  return { stencil: A(le({ movable: this.movable, moving: this.moving, resizing: this.resizing }), this.moving && this.movingClass, this.resizing && this.resizingClass), preview: A(le("preview"), this.previewClass), boundingBox: A(le("bounding-box"), this.boundingBoxClass) };
}, style: function() {
  var t = this.stencilCoordinates, e = t.height, i = t.width, n = t.left, s = t.top, o = { width: "".concat(i, "px"), height: "".concat(e, "px"), transform: "translate(".concat(n, "px, ").concat(s, "px)") };
  return this.transitions && this.transitions.enabled && (o.transition = "".concat(this.transitions.time, "ms ").concat(this.transitions.timingFunction)), o;
} }, methods: { onMove: function(t) {
  this.$emit("move", t), this.moving = true;
}, onMoveEnd: function() {
  this.$emit("move-end"), this.moving = false;
}, onResize: function(t) {
  this.$emit("resize", t), this.resizing = true;
}, onResizeEnd: function() {
  this.$emit("resize-end"), this.resizing = false;
}, aspectRatios: function() {
  return { minimum: this.aspectRatio || this.minAspectRatio, maximum: this.aspectRatio || this.maxAspectRatio };
} }, emits: ["resize", "resize-end", "move", "move-end"] };
ue.render = function(i, r, a, h2, c2, l) {
  var u = resolveComponent("stencil-preview"), d = resolveComponent("draggable-area"), m = resolveComponent("bounding-box");
  return openBlock(), createBlock("div", { class: l.classes.stencil, style: l.style }, [createVNode(m, { width: a.stencilCoordinates.width, height: a.stencilCoordinates.height, transitions: a.transitions, class: l.classes.boundingBox, handlers: a.handlers, "handlers-component": a.handlersComponent, "handlers-classes": a.handlersClasses, "handlers-wrappers-classes": a.handlersWrappersClasses, lines: a.lines, "lines-component": a.linesComponent, "lines-classes": a.linesClasses, "lines-wrappers-classes": a.linesWrappersClasses, resizable: a.resizable, onResize: l.onResize, onResizeEnd: l.onResizeEnd }, { default: withCtx(function() {
    return [createVNode(d, { movable: a.movable, onMove: l.onMove, onMoveEnd: l.onMoveEnd }, { default: withCtx(function() {
      return [createVNode(u, { image: a.image, coordinates: a.coordinates, width: a.stencilCoordinates.width, height: a.stencilCoordinates.height, class: l.classes.preview, transitions: a.transitions }, null, 8, ["image", "coordinates", "width", "height", "class", "transitions"])];
    }), _: 1 }, 8, ["movable", "onMove", "onMoveEnd"])];
  }), _: 1 }, 8, ["width", "height", "transitions", "class", "handlers", "handlers-component", "handlers-classes", "handlers-wrappers-classes", "lines", "lines-component", "lines-classes", "lines-wrappers-classes", "resizable", "onResize", "onResizeEnd"])], 6);
};
var pe = ["transitions"], ge = M("vue-advanced-cropper"), fe = { name: "Cropper", components: { BackgroundWrapper: re }, props: { src: { type: String, default: null }, stencilComponent: { type: [Object, String], default: function() {
  return ue;
} }, backgroundWrapperComponent: { type: [Object, String], default: function() {
  return re;
} }, stencilProps: { type: Object, default: function() {
  return {};
} }, autoZoom: { type: Boolean, default: false }, imageClass: { type: String }, boundariesClass: { type: String }, backgroundClass: { type: String }, foregroundClass: { type: String }, minWidth: { type: [Number, String] }, minHeight: { type: [Number, String] }, maxWidth: { type: [Number, String] }, maxHeight: { type: [Number, String] }, debounce: { type: [Boolean, Number], default: 500 }, transitions: { type: Boolean, default: true }, checkOrientation: { type: Boolean, default: true }, canvas: { type: [Object, Boolean], default: true }, crossOrigin: { type: [Boolean, String], default: void 0 }, transitionTime: { type: Number, default: 300 }, imageRestriction: { type: String, default: "fit-area", validator: function(t) {
  return -1 !== K.indexOf(t);
} }, roundResult: { type: Boolean, default: true }, defaultSize: { type: [Function, Object] }, defaultPosition: { type: [Function, Object] }, defaultVisibleArea: { type: [Function, Object] }, defaultTransforms: { type: [Function, Object] }, defaultBoundaries: { type: [Function, String], validator: function(t) {
  return !("string" == typeof t && "fill" !== t && "fit" !== t);
} }, priority: { type: String, default: "coordinates" }, stencilSize: { type: [Object, Function] }, resizeImage: { type: [Boolean, Object], default: true }, moveImage: { type: [Boolean, Object], default: true }, autoZoomAlgorithm: { type: Function }, resizeAlgorithm: { type: Function, default: function(t) {
  var e = t.event, i = t.coordinates, n = t.aspectRatio, s = t.positionRestrictions, o = t.sizeRestrictions, r = C(C({}, i), { right: i.left + i.width, bottom: i.top + i.height }), a = e.params || {}, h2 = C({}, e.directions), c2 = a.allowedDirections || { left: true, right: true, bottom: true, top: true };
  o.widthFrozen && (h2.left = 0, h2.right = 0), o.heightFrozen && (h2.top = 0, h2.bottom = 0), V.forEach(function(t2) {
    c2[t2] || (h2[t2] = 0);
  });
  var l = ot(r, h2 = It({ coordinates: r, directions: h2, sizeRestrictions: o, positionRestrictions: s })).width, u = ot(r, h2).height, d = a.preserveRatio ? ct(r) : dt(l / u, n);
  if (d) {
    var m = a.respectDirection;
    if (m || (m = r.width >= r.height || 1 === d ? "width" : "height"), "width" === m) {
      var p2 = l / d - r.height;
      if (c2.top && c2.bottom) {
        var g2 = h2.top, f2 = h2.bottom;
        h2.bottom = Bt(p2, f2, g2), h2.top = Bt(p2, g2, f2);
      } else
        c2.bottom ? h2.bottom = p2 : c2.top ? h2.top = p2 : c2.right ? h2.right = 0 : c2.left && (h2.left = 0);
    } else if ("height" === m) {
      var v2 = r.width - u * d;
      if (c2.left && c2.right) {
        var b2 = h2.left, w2 = h2.right;
        h2.left = -Bt(v2, b2, w2), h2.right = -Bt(v2, w2, b2);
      } else
        c2.left ? h2.left = -v2 : c2.right ? h2.right = -v2 : c2.top ? h2.top = 0 : c2.bottom && (h2.bottom = 0);
    }
    h2 = It({ directions: h2, coordinates: r, sizeRestrictions: o, positionRestrictions: s, preserveRatio: true, compensate: a.compensate });
  }
  return l = ot(r, h2).width, u = ot(r, h2).height, (d = a.preserveRatio ? ct(r) : dt(l / u, n)) && Math.abs(d - l / u) > 1e-3 && V.forEach(function(t2) {
    c2[t2] || (h2[t2] = 0);
  }), St({ event: new Y({ left: -h2.left, top: -h2.top }), coordinates: { width: i.width + h2.right + h2.left, height: i.height + h2.top + h2.bottom, left: i.left, top: i.top }, positionRestrictions: s });
} }, moveAlgorithm: { type: Function, default: St }, initStretcher: { type: Function, default: function(t) {
  var e = t.stretcher, i = t.imageSize, n = ct(i);
  e.style.width = i.width + "px", e.style.height = e.clientWidth / n + "px", e.style.width = e.clientWidth + "px";
} }, fitCoordinates: { type: Function, default: function(t) {
  var e = t.visibleArea, i = t.coordinates, n = t.aspectRatio, s = t.sizeRestrictions, o = t.positionRestrictions, r = C(C({}, i), Mt({ width: i.width, height: i.height, aspectRatio: n, sizeRestrictions: { maxWidth: e.width, maxHeight: e.height, minHeight: Math.min(e.height, s.minHeight), minWidth: Math.min(e.width, s.minWidth) } }));
  return r = vt(r = at(r, it(nt(i), nt(r))), zt(et(e), o));
} }, fitVisibleArea: { type: Function, default: function(t) {
  var e = t.visibleArea, i = t.boundaries, n = t.getAreaRestrictions, s = t.coordinates, o = C({}, e);
  o.height = o.width / ct(i), o.top += (e.height - o.height) / 2, (s.height - o.height > 0 || s.width - o.width > 0) && (o = ht(o, Math.max(s.height / o.height, s.width / o.width)));
  var r = rt(ut(s, et(o = ht(o, ft(o, n({ visibleArea: o, type: "resize" }))))));
  return o.width < s.width && (r.left = 0), o.height < s.height && (r.top = 0), o = vt(o = at(o, r), n({ visibleArea: o, type: "move" }));
} }, areaRestrictionsAlgorithm: { type: Function, default: function(t) {
  var e = t.visibleArea, i = t.boundaries, n = t.imageSize, s = t.imageRestriction, o = t.type, r = {};
  return "fill-area" === s ? r = { left: 0, top: 0, right: n.width, bottom: n.height } : "fit-area" === s && (ct(i) > ct(n) ? (r = { top: 0, bottom: n.height }, e && "move" === o && (e.width > n.width ? (r.left = -(e.width - n.width) / 2, r.right = n.width - r.left) : (r.left = 0, r.right = n.width))) : (r = { left: 0, right: n.width }, e && "move" === o && (e.height > n.height ? (r.top = -(e.height - n.height) / 2, r.bottom = n.height - r.top) : (r.top = 0, r.bottom = n.height)))), r;
} }, sizeRestrictionsAlgorithm: { type: Function, default: function(t) {
  return { minWidth: t.minWidth, minHeight: t.minHeight, maxWidth: t.maxWidth, maxHeight: t.maxHeight };
} }, positionRestrictionsAlgorithm: { type: Function, default: function(t) {
  var e = t.imageSize, i = {};
  return "none" !== t.imageRestriction && (i = { left: 0, top: 0, right: e.width, bottom: e.height }), i;
} } }, data: function() {
  return { transitionsActive: false, imageLoaded: false, imageAttributes: { width: null, height: null, crossOrigin: null, src: null }, defaultImageTransforms: { rotate: 0, flip: { horizontal: false, vertical: false } }, appliedImageTransforms: { rotate: 0, flip: { horizontal: false, vertical: false } }, boundaries: { width: 0, height: 0 }, visibleArea: null, coordinates: g({}, J) };
}, computed: { image: function() {
  return { src: this.imageAttributes.src, width: this.imageAttributes.width, height: this.imageAttributes.height, transforms: this.imageTransforms };
}, imageTransforms: function() {
  return { rotate: this.appliedImageTransforms.rotate, flip: { horizontal: this.appliedImageTransforms.flip.horizontal, vertical: this.appliedImageTransforms.flip.vertical }, translateX: this.visibleArea ? this.visibleArea.left / this.coefficient : 0, translateY: this.visibleArea ? this.visibleArea.top / this.coefficient : 0, scaleX: 1 / this.coefficient, scaleY: 1 / this.coefficient };
}, imageSize: function() {
  var t = function(t2) {
    return t2 * Math.PI / 180;
  }(this.imageTransforms.rotate);
  return { width: Math.abs(this.imageAttributes.width * Math.cos(t)) + Math.abs(this.imageAttributes.height * Math.sin(t)), height: Math.abs(this.imageAttributes.width * Math.sin(t)) + Math.abs(this.imageAttributes.height * Math.cos(t)) };
}, initialized: function() {
  return Boolean(this.visibleArea && this.imageLoaded);
}, settings: function() {
  var t = j(this.resizeImage, { touch: true, wheel: { ratio: 0.1 }, adjustStencil: true }, { touch: false, wheel: false, adjustStencil: false });
  return { moveImage: j(this.moveImage, { touch: true, mouse: true }, { touch: false, mouse: false }), resizeImage: t };
}, coefficient: function() {
  return this.visibleArea ? this.visibleArea.width / this.boundaries.width : 0;
}, areaRestrictions: function() {
  return this.imageLoaded ? this.areaRestrictionsAlgorithm({ imageSize: this.imageSize, imageRestriction: this.imageRestriction, boundaries: this.boundaries }) : {};
}, transitionsOptions: function() {
  return { enabled: this.transitionsActive, timingFunction: "ease-in-out", time: 350 };
}, sizeRestrictions: function() {
  if (this.boundaries.width && this.boundaries.height && this.imageSize.width && this.imageSize.height) {
    var t = this.sizeRestrictionsAlgorithm({ imageSize: this.imageSize, minWidth: D(this.minWidth) ? 0 : L(this.minWidth), minHeight: D(this.minHeight) ? 0 : L(this.minHeight), maxWidth: D(this.maxWidth) ? 1 / 0 : L(this.maxWidth), maxHeight: D(this.maxHeight) ? 1 / 0 : L(this.maxHeight) });
    if (t = function(t2) {
      var e2 = t2.areaRestrictions, i2 = t2.sizeRestrictions;
      t2.imageSize;
      var n = t2.boundaries, s = t2.positionRestrictions;
      t2.imageRestriction;
      var o = C(C({}, i2), { minWidth: void 0 !== i2.minWidth ? i2.minWidth : 0, minHeight: void 0 !== i2.minHeight ? i2.minHeight : 0, maxWidth: void 0 !== i2.maxWidth ? i2.maxWidth : 1 / 0, maxHeight: void 0 !== i2.maxHeight ? i2.maxHeight : 1 / 0 });
      void 0 !== s.left && void 0 !== s.right && (o.maxWidth = Math.min(o.maxWidth, s.right - s.left)), void 0 !== s.bottom && void 0 !== s.top && (o.maxHeight = Math.min(o.maxHeight, s.bottom - s.top));
      var r = bt(e2), a = mt(n, r);
      return r.width < 1 / 0 && (!o.maxWidth || o.maxWidth > a.width) && (o.maxWidth = Math.min(o.maxWidth, a.width)), r.height < 1 / 0 && (!o.maxHeight || o.maxHeight > a.height) && (o.maxHeight = Math.min(o.maxHeight, a.height)), o.minWidth > o.maxWidth && (o.minWidth = o.maxWidth, o.widthFrozen = true), o.minHeight > o.maxHeight && (o.minHeight = o.maxHeight, o.heightFrozen = true), o;
    }({ sizeRestrictions: t, areaRestrictions: this.getAreaRestrictions({ visibleArea: this.visibleArea, type: "resize" }), imageSize: this.imageSize, boundaries: this.boundaries, positionRestrictions: this.positionRestrictions, imageRestriction: this.imageRestriction, visibleArea: this.visibleArea, stencilSize: this.getStencilSize() }), this.visibleArea && this.stencilSize) {
      var e = this.getStencilSize(), i = bt(this.getAreaRestrictions({ visibleArea: this.visibleArea, type: "resize" }));
      t.maxWidth = Math.min(t.maxWidth, i.width * e.width / this.boundaries.width), t.maxHeight = Math.min(t.maxHeight, i.height * e.height / this.boundaries.height), t.maxWidth < t.minWidth && (t.minWidth = t.maxWidth), t.maxHeight < t.minHeight && (t.minHeight = t.maxHeight);
    }
    return t;
  }
  return { minWidth: 0, minHeight: 0, maxWidth: 0, maxHeight: 0 };
}, positionRestrictions: function() {
  return this.positionRestrictionsAlgorithm({ imageSize: this.imageSize, imageRestriction: this.imageRestriction });
}, classes: function() {
  return { cropper: ge(), image: A(ge("image"), this.imageClass), stencil: ge("stencil"), boundaries: A(ge("boundaries"), this.boundariesClass), stretcher: A(ge("stretcher")), background: A(ge("background"), this.backgroundClass), foreground: A(ge("foreground"), this.foregroundClass), imageWrapper: A(ge("image-wrapper")), cropperWrapper: A(ge("cropper-wrapper")) };
}, stencilCoordinates: function() {
  if (this.initialized) {
    var t = this.coordinates, e = t.width, i = t.height, n = t.left, s = t.top;
    return { width: e / this.coefficient, height: i / this.coefficient, left: (n - this.visibleArea.left) / this.coefficient, top: (s - this.visibleArea.top) / this.coefficient };
  }
  return this.defaultCoordinates();
}, boundariesStyle: function() {
  var t = { width: this.boundaries.width ? "".concat(Math.round(this.boundaries.width), "px") : "auto", height: this.boundaries.height ? "".concat(Math.round(this.boundaries.height), "px") : "auto", transition: "opacity ".concat(this.transitionTime, "ms"), pointerEvents: this.imageLoaded ? "all" : "none" };
  return this.imageLoaded || (t.opacity = "0"), t;
}, imageStyle: function() {
  var t = this.imageAttributes.width > this.imageAttributes.height ? { width: Math.min(1024, this.imageAttributes.width), height: Math.min(1024, this.imageAttributes.width) / (this.imageAttributes.width / this.imageAttributes.height) } : { height: Math.min(1024, this.imageAttributes.height), width: Math.min(1024, this.imageAttributes.height) * (this.imageAttributes.width / this.imageAttributes.height) }, e = { left: (t.width - this.imageSize.width) / (2 * this.coefficient), top: (t.height - this.imageSize.height) / (2 * this.coefficient) }, i = { left: (1 - 1 / this.coefficient) * t.width / 2, top: (1 - 1 / this.coefficient) * t.height / 2 }, n = g(g({}, this.imageTransforms), {}, { scaleX: this.imageTransforms.scaleX * (this.imageAttributes.width / t.width), scaleY: this.imageTransforms.scaleY * (this.imageAttributes.height / t.height) }), s = { width: "".concat(t.width, "px"), height: "".concat(t.height, "px"), left: "0px", top: "0px", transform: "translate(".concat(-e.left - i.left - this.imageTransforms.translateX, "px, ").concat(-e.top - i.top - this.imageTransforms.translateY, "px)") + te(n) };
  return this.transitionsOptions.enabled && (s.transition = "".concat(this.transitionsOptions.time, "ms ").concat(this.transitionsOptions.timingFunction)), s;
} }, watch: { src: function() {
  this.onChangeImage();
}, stencilComponent: function() {
  var t = this;
  this.$nextTick(function() {
    t.resetCoordinates(), t.runAutoZoom("setCoordinates"), t.onChange();
  });
}, minWidth: function() {
  this.onPropsChange();
}, maxWidth: function() {
  this.onPropsChange();
}, minHeight: function() {
  this.onPropsChange();
}, maxHeight: function() {
  this.onPropsChange();
}, imageRestriction: function() {
  this.reset();
}, stencilProps: function(t, e) {
  ["aspectRatio", "minAspectRatio", "maxAspectRatio"].find(function(i) {
    return t[i] !== e[i];
  }) && this.$nextTick(this.onPropsChange);
} }, created: function() {
  this.debouncedUpdate = x(this.update, this.debounce), this.debouncedDisableTransitions = x(this.disableTransitions, this.transitionsOptions.time), this.awaiting = false;
}, mounted: function() {
  this.$refs.image.addEventListener("load", this.onSuccessLoadImage), this.$refs.image.addEventListener("error", this.onFailLoadImage), this.onChangeImage(), window.addEventListener("resize", this.refresh), window.addEventListener("orientationchange", this.refresh);
}, unmounted: function() {
  window.removeEventListener("resize", this.refresh), window.removeEventListener("orientationchange", this.refresh), this.imageAttributes.revoke && this.imageAttributes.src && URL.revokeObjectURL(this.imageAttributes.src), this.debouncedUpdate.clear(), this.debouncedDisableTransitions.clear();
}, methods: { getResult: function() {
  var t = this.initialized ? this.prepareResult(g({}, this.coordinates)) : this.defaultCoordinates(), e = { rotate: this.imageTransforms.rotate % 360, flip: g({}, this.imageTransforms.flip) };
  if (this.src && this.imageLoaded) {
    var i = this;
    return { image: this.image, coordinates: t, visibleArea: this.visibleArea ? g({}, this.visibleArea) : null, imageTransforms: e, get canvas() {
      return i.canvas ? i.getCanvas() : void 0;
    } };
  }
  return { image: this.image, coordinates: t, visibleArea: this.visibleArea ? g({}, this.visibleArea) : null, canvas: void 0, imageTransforms: e };
}, zoom: function(t, e) {
  var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, n = i.transitions, s = void 0 === n || n;
  this.onManipulateImage(new B({}, { factor: 1 / t, center: e }), { normalize: false, transitions: s });
}, move: function(t, e) {
  var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, n = i.transitions, s = void 0 === n || n;
  this.onManipulateImage(new B({ left: t || 0, top: e || 0 }), { normalize: false, transitions: s });
}, setCoordinates: function(t) {
  var e = this, i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = i.autoZoom, s = void 0 === n || n, o = i.transitions, r = void 0 === o || o;
  this.$nextTick(function() {
    e.imageLoaded ? (e.transitionsActive || (r && e.enableTransitions(), e.coordinates = e.applyTransform(t), s && e.runAutoZoom("setCoordinates"), r && e.debouncedDisableTransitions()), e.onChange()) : e.delayedTransforms = t;
  });
}, refresh: function() {
  var t = this, e = this.$refs.image;
  if (this.src && e)
    return this.initialized ? this.updateVisibleArea().then(function() {
      t.onChange();
    }) : this.resetVisibleArea().then(function() {
      t.onChange();
    });
}, reset: function() {
  var t = this;
  return this.resetVisibleArea().then(function() {
    t.onChange(false);
  });
}, awaitRender: function(t) {
  var e = this;
  this.awaiting || (this.awaiting = true, this.$nextTick(function() {
    t(), e.awaiting = false;
  }));
}, prepareResult: function(t) {
  return this.roundResult ? function(t2) {
    var e = t2.coordinates, i = t2.sizeRestrictions, n = t2.positionRestrictions, s = { width: Math.round(e.width), height: Math.round(e.height), left: Math.round(e.left), top: Math.round(e.top) };
    return s.width > i.maxWidth ? s.width = Math.floor(e.width) : s.width < i.minWidth && (s.width = Math.ceil(e.width)), s.height > i.maxHeight ? s.height = Math.floor(e.height) : s.height < i.minHeight && (s.height = Math.ceil(e.height)), vt(s, n);
  }(g(g({}, this.getPublicProperties()), {}, { positionRestrictions: jt(this.positionRestrictions, this.visibleArea), coordinates: t })) : t;
}, processAutoZoom: function(t, e, i, n) {
  var s = this.autoZoomAlgorithm;
  s || (s = this.stencilSize ? Ct : this.autoZoom ? Et : Wt);
  var o = s({ event: { type: t, params: n }, visibleArea: e, coordinates: i, boundaries: this.boundaries, aspectRatio: this.getAspectRatio(), positionRestrictions: this.positionRestrictions, getAreaRestrictions: this.getAreaRestrictions, sizeRestrictions: this.sizeRestrictions, stencilSize: this.getStencilSize() });
  return g(g({}, o), {}, { changed: !tt(o.visibleArea, e) || !tt(o.coordinates, i) });
}, runAutoZoom: function(t) {
  var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, i = e.transitions, n = void 0 !== i && i, s = v(e, pe), o = this.processAutoZoom(t, this.visibleArea, this.coordinates, s), r = o.visibleArea, a = o.coordinates, h2 = o.changed;
  n && h2 && this.enableTransitions(), this.visibleArea = r, this.coordinates = a, n && h2 && this.debouncedDisableTransitions();
}, normalizeEvent: function(t) {
  return function(t2) {
    var e = t2.event, i = t2.visibleArea, n = t2.coefficient;
    if ("manipulateImage" === e.type)
      return C(C({}, e), { move: { left: e.move && e.move.left ? n * e.move.left : 0, top: e.move && e.move.top ? n * e.move.top : 0 }, scale: { factor: e.scale && e.scale.factor ? e.scale.factor : 1, center: e.scale && e.scale.center ? { left: e.scale.center.left * n + i.left, top: e.scale.center.top * n + i.top } : null } });
    if ("resize" === e.type) {
      var s = C(C({}, e), { directions: C({}, e.directions) });
      return V.forEach(function(t3) {
        s.directions[t3] *= n;
      }), s;
    }
    if ("move" === e.type) {
      var o = C(C({}, e), { directions: C({}, e.directions) });
      return Q.forEach(function(t3) {
        o.directions[t3] *= n;
      }), o;
    }
    return e;
  }(g(g({}, this.getPublicProperties()), {}, { event: t }));
}, getCanvas: function() {
  if (this.$refs.canvas) {
    var t = this.$refs.canvas, e = this.$refs.image, i = 0 !== this.imageTransforms.rotate || this.imageTransforms.flip.horizontal || this.imageTransforms.flip.vertical ? function(t2, e2, i2) {
      var n2 = i2.rotate, s2 = i2.flip, o2 = { width: e2.naturalWidth, height: e2.naturalHeight }, r2 = pt(o2, n2), a = t2.getContext("2d");
      t2.height = r2.height, t2.width = r2.width, a.save();
      var h2 = gt(nt(C({ left: 0, top: 0 }, o2)), n2);
      return a.translate(-(h2.left - r2.width / 2), -(h2.top - r2.height / 2)), a.rotate(n2 * Math.PI / 180), a.translate(s2.horizontal ? o2.width : 0, s2.vertical ? o2.height : 0), a.scale(s2.horizontal ? -1 : 1, s2.vertical ? -1 : 1), a.drawImage(e2, 0, 0, o2.width, o2.height), a.restore(), t2;
    }(this.$refs.sourceCanvas, e, this.imageTransforms) : e, n = g({ minWidth: 0, minHeight: 0, maxWidth: 1 / 0, maxHeight: 1 / 0, maxArea: this.maxCanvasSize, imageSmoothingEnabled: true, imageSmoothingQuality: "high", fillColor: "transparent" }, this.canvas), s = function(t2) {
      return t2.find(function(t3) {
        return e2 = t3, !Number.isNaN(parseFloat(e2)) && isFinite(e2);
        var e2;
      });
    }, o = Mt({ sizeRestrictions: { minWidth: s([n.width, n.minWidth]) || 0, minHeight: s([n.height, n.minHeight]) || 0, maxWidth: s([n.width, n.maxWidth]) || 1 / 0, maxHeight: s([n.height, n.maxHeight]) || 1 / 0 }, width: this.coordinates.width, height: this.coordinates.height, aspectRatio: { minimum: this.coordinates.width / this.coordinates.height, maximum: this.coordinates.width / this.coordinates.height } });
    if (n.maxArea && o.width * o.height > n.maxArea) {
      var r = Math.sqrt(n.maxArea / (o.width * o.height));
      o = { width: Math.round(r * o.width), height: Math.round(r * o.height) };
    }
    return function(t2, e2, i2, n2, s2) {
      t2.width = n2 ? n2.width : i2.width, t2.height = n2 ? n2.height : i2.height;
      var o2 = t2.getContext("2d");
      o2.clearRect(0, 0, t2.width, t2.height), s2 && (s2.imageSmoothingEnabled && (o2.imageSmoothingEnabled = s2.imageSmoothingEnabled), s2.imageSmoothingQuality && (o2.imageSmoothingQuality = s2.imageSmoothingQuality), s2.fillColor && (o2.fillStyle = s2.fillColor, o2.fillRect(0, 0, t2.width, t2.height), o2.save()));
      var r2 = i2.left < 0 ? -i2.left : 0, a = i2.top < 0 ? -i2.top : 0;
      o2.drawImage(e2, i2.left + r2, i2.top + a, i2.width, i2.height, r2, a, t2.width, t2.height);
    }(t, i, this.coordinates, o, n), t;
  }
}, update: function() {
  this.$emit("change", this.getResult());
}, applyTransform: function(t) {
  var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], i = this.visibleArea && e ? wt(this.sizeRestrictions, this.visibleArea) : this.sizeRestrictions, n = this.visibleArea && e ? jt(this.positionRestrictions, this.visibleArea) : this.positionRestrictions;
  return xt({ transform: t, coordinates: this.coordinates, imageSize: this.imageSize, sizeRestrictions: i, positionRestrictions: n, aspectRatio: this.getAspectRatio(), visibleArea: this.visibleArea });
}, resetCoordinates: function() {
  var t = this;
  if (this.$refs.image) {
    this.$refs.cropper, this.$refs.image;
    var e = this.defaultSize;
    e || (e = this.stencilSize ? Dt : Ot);
    var i = this.sizeRestrictions;
    i.minWidth, i.minHeight, i.maxWidth, i.maxHeight;
    var n = O(e) ? e({ boundaries: this.boundaries, imageSize: this.imageSize, aspectRatio: this.getAspectRatio(), sizeRestrictions: this.sizeRestrictions, stencilSize: this.getStencilSize(), visibleArea: this.visibleArea }) : e, s = this.defaultPosition || Tt, o = [n, function(e2) {
      var i2 = e2.coordinates;
      return g({}, O(s) ? s({ coordinates: i2, imageSize: t.imageSize, visibleArea: t.visibleArea }) : t.defaultPosition);
    }];
    this.delayedTransforms && o.push.apply(o, b(Array.isArray(this.delayedTransforms) ? this.delayedTransforms : [this.delayedTransforms])), this.coordinates = this.applyTransform(o, true), this.delayedTransforms = null;
  }
}, clearImage: function() {
  var t = this;
  this.imageLoaded = false, setTimeout(function() {
    var e = t.$refs.stretcher;
    e && (e.style.height = "auto", e.style.width = "auto"), t.coordinates = t.defaultCoordinates(), t.boundaries = { width: 0, height: 0 };
  }, this.transitionTime);
}, enableTransitions: function() {
  this.transitions && (this.transitionsActive = true);
}, disableTransitions: function() {
  this.transitionsActive = false;
}, updateBoundaries: function() {
  var t = this, e = this.$refs.stretcher, i = this.$refs.cropper;
  return this.initStretcher({ cropper: i, stretcher: e, imageSize: this.imageSize }), this.$nextTick().then(function() {
    var e2 = { cropper: i, imageSize: t.imageSize };
    if (O(t.defaultBoundaries) ? t.boundaries = t.defaultBoundaries(e2) : "fit" === t.defaultBoundaries ? t.boundaries = function(t2) {
      var e3 = t2.cropper, i2 = t2.imageSize, n = e3.clientHeight, s = e3.clientWidth, o = n, r = i2.width * n / i2.height;
      return r > s && (r = s, o = i2.height * s / i2.width), { width: r, height: o };
    }(e2) : t.boundaries = function(t2) {
      var e3 = t2.cropper;
      return { width: e3.clientWidth, height: e3.clientHeight };
    }(e2), !t.boundaries.width || !t.boundaries.height)
      throw new Error("It's impossible to fit the cropper in the current container");
  });
}, resetVisibleArea: function() {
  var t = this;
  return this.appliedImageTransforms = g(g({}, this.defaultImageTransforms), {}, { flip: g({}, this.defaultImageTransforms.flip) }), this.updateBoundaries().then(function() {
    "visible-area" !== t.priority && (t.visibleArea = null, t.resetCoordinates());
    var e, i, n, s, o, r, a = t.defaultVisibleArea || Ht;
    t.visibleArea = O(a) ? a({ imageSize: t.imageSize, boundaries: t.boundaries, coordinates: "visible-area" !== t.priority ? t.coordinates : null, getAreaRestrictions: t.getAreaRestrictions, stencilSize: t.getStencilSize() }) : t.defaultVisibleArea, t.visibleArea = (e = { visibleArea: t.visibleArea, boundaries: t.boundaries, getAreaRestrictions: t.getAreaRestrictions }, i = e.visibleArea, n = e.boundaries, s = e.getAreaRestrictions, o = C({}, i), r = ct(n), o.width / o.height !== r && (o.height = o.width / r), vt(o, s({ visibleArea: o, type: "move" }))), "visible-area" === t.priority ? t.resetCoordinates() : t.coordinates = t.fitCoordinates({ visibleArea: t.visibleArea, coordinates: t.coordinates, aspectRatio: t.getAspectRatio(), positionRestrictions: t.positionRestrictions, sizeRestrictions: t.sizeRestrictions }), t.runAutoZoom("resetVisibleArea");
  }).catch(function() {
    t.visibleArea = null;
  });
}, updateVisibleArea: function() {
  var t = this;
  return this.updateBoundaries().then(function() {
    t.visibleArea = t.fitVisibleArea({ imageSize: t.imageSize, boundaries: t.boundaries, visibleArea: t.visibleArea, coordinates: t.coordinates, getAreaRestrictions: t.getAreaRestrictions }), t.coordinates = t.fitCoordinates({ visibleArea: t.visibleArea, coordinates: t.coordinates, aspectRatio: t.getAspectRatio(), positionRestrictions: t.positionRestrictions, sizeRestrictions: t.sizeRestrictions }), t.runAutoZoom("updateVisibleArea");
  }).catch(function() {
    t.visibleArea = null;
  });
}, onChange: function() {
  var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
  t && this.debounce ? this.debouncedUpdate() : this.update();
}, onChangeImage: function() {
  var t, e = this;
  if (this.imageLoaded = false, this.delayedTransforms = null, this.src) {
    if (function(t2) {
      if (T(t2))
        return false;
      var e2 = window.location, i2 = /(\w+:)?(?:\/\/)([\w.-]+)?(?::(\d+))?\/?/.exec(t2) || [], n2 = { protocol: i2[1] || "", host: i2[2] || "", port: i2[3] || "" }, s = function(t3) {
        return t3.port || ("http" === (t3.protocol || e2.protocol) ? 80 : 433);
      };
      return !(!n2.protocol && !n2.host && !n2.port || Boolean(n2.protocol && n2.protocol == e2.protocol && n2.host && n2.host == e2.host && n2.host && s(n2) == s(e2)));
    }(this.src)) {
      var i = D(this.crossOrigin) ? this.canvas : this.crossOrigin;
      true === i && (i = "anonymous"), this.imageAttributes.crossOrigin = i || null;
    }
    if (this.checkOrientation) {
      var n = (t = this.src, new Promise(function(e2) {
        Jt(t).then(function(i2) {
          var n2 = ee(i2);
          e2(i2 ? { source: t, arrayBuffer: i2, orientation: n2 } : { source: t, arrayBuffer: null, orientation: null });
        }).catch(function(i2) {
          console.warn(i2), e2({ source: t, arrayBuffer: null, orientation: null });
        });
      }));
      setTimeout(function() {
        n.then(e.onParseImage);
      }, this.transitionTime);
    } else
      setTimeout(function() {
        e.onParseImage({ source: e.src });
      }, this.transitionTime);
  } else
    this.clearImage();
}, onFailLoadImage: function() {
  this.imageAttributes.src && (this.clearImage(), this.$emit("error"));
}, onSuccessLoadImage: function() {
  var t = this, e = this.$refs.image;
  e && !this.imageLoaded && (this.imageAttributes.height = e.naturalHeight, this.imageAttributes.width = e.naturalWidth, this.imageLoaded = true, this.resetVisibleArea().then(function() {
    t.$emit("ready"), t.onChange(false);
  }));
}, onParseImage: function(t) {
  var e = this, i = t.source, n = t.arrayBuffer, s = t.orientation;
  this.imageAttributes.revoke && this.imageAttributes.src && URL.revokeObjectURL(this.imageAttributes.src), this.imageAttributes.revoke = false, n && s && s > 1 ? W(i) || !T(i) ? (this.imageAttributes.src = URL.createObjectURL(new Blob([n])), this.imageAttributes.revoke = true) : this.imageAttributes.src = function(t2) {
    for (var e2 = [], i2 = new Uint8Array(t2); i2.length > 0; ) {
      var n2 = i2.subarray(0, 8192);
      e2.push(String.fromCharCode.apply(null, Array.from ? Array.from(n2) : n2.slice())), i2 = i2.subarray(8192);
    }
    return "data:image/jpeg;base64," + btoa(e2.join(""));
  }(n) : this.imageAttributes.src = i, O(this.defaultTransforms) ? this.appliedImageTransforms = Kt(this.defaultTransforms()) : H(this.defaultTransforms) ? this.appliedImageTransforms = Kt(this.defaultTransforms) : this.appliedImageTransforms = function(t2) {
    var e2 = Kt({});
    if (t2)
      switch (t2) {
        case 2:
          e2.flip.horizontal = true;
          break;
        case 3:
          e2.rotate = -180;
          break;
        case 4:
          e2.flip.vertical = true;
          break;
        case 5:
          e2.rotate = 90, e2.flip.vertical = true;
          break;
        case 6:
          e2.rotate = 90;
          break;
        case 7:
          e2.rotate = 90, e2.flip.horizontal = true;
          break;
        case 8:
          e2.rotate = -90;
      }
    return e2;
  }(s), this.defaultImageTransforms = g(g({}, this.appliedImageTransforms), {}, { flip: g({}, this.appliedImageTransforms.flip) }), this.$nextTick(function() {
    var t2 = e.$refs.image;
    t2 && t2.complete && (!function(t3) {
      return Boolean(t3.naturalWidth);
    }(t2) ? e.onFailLoadImage() : e.onSuccessLoadImage());
  });
}, onResizeEnd: function() {
  this.runAutoZoom("resize", { transitions: true });
}, onMoveEnd: function() {
  this.runAutoZoom("move", { transitions: true });
}, onMove: function(t) {
  var e = this;
  this.transitionsOptions.enabled || this.awaitRender(function() {
    e.coordinates = e.moveAlgorithm(g(g({}, e.getPublicProperties()), {}, { positionRestrictions: jt(e.positionRestrictions, e.visibleArea), coordinates: e.coordinates, event: e.normalizeEvent(t) })), e.onChange();
  });
}, onResize: function(t) {
  var e = this;
  this.transitionsOptions.enabled || this.stencilSize && !this.autoZoom || this.awaitRender(function() {
    var i = e.sizeRestrictions, n = Math.min(e.coordinates.width, e.coordinates.height, 20 * e.coefficient);
    e.coordinates = e.resizeAlgorithm(g(g({}, e.getPublicProperties()), {}, { positionRestrictions: jt(e.positionRestrictions, e.visibleArea), sizeRestrictions: { maxWidth: Math.min(i.maxWidth, e.visibleArea.width), maxHeight: Math.min(i.maxHeight, e.visibleArea.height), minWidth: Math.max(i.minWidth, n), minHeight: Math.max(i.minHeight, n) }, event: e.normalizeEvent(t) })), e.onChange(), e.ticking = false;
  });
}, onManipulateImage: function(t) {
  var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
  if (!this.transitionsOptions.enabled) {
    var i = e.transitions, n = void 0 !== i && i, s = e.normalize, o = void 0 === s || s;
    n && this.enableTransitions();
    var r = Lt(g(g({}, this.getPublicProperties()), {}, { event: o ? this.normalizeEvent(t) : t, getAreaRestrictions: this.getAreaRestrictions, imageRestriction: this.imageRestriction, adjustStencil: !this.stencilSize && this.settings.resizeImage.adjustStencil })), a = r.visibleArea, h2 = r.coordinates;
    this.visibleArea = a, this.coordinates = h2, this.runAutoZoom("manipulateImage"), this.onChange(), n && this.debouncedDisableTransitions();
  }
}, onPropsChange: function() {
  this.coordinates = this.applyTransform(this.coordinates, true), this.onChange(false);
}, getAreaRestrictions: function() {
  var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, e = t.visibleArea, i = t.type, n = void 0 === i ? "move" : i;
  return this.areaRestrictionsAlgorithm({ boundaries: this.boundaries, imageSize: this.imageSize, imageRestriction: this.imageRestriction, visibleArea: e, type: n });
}, getAspectRatio: function(t) {
  var e, i, n = this.stencilProps, s = n.aspectRatio, o = n.minAspectRatio, r = n.maxAspectRatio;
  if (this.$refs.stencil && this.$refs.stencil.aspectRatios) {
    var a = this.$refs.stencil.aspectRatios();
    e = a.minimum, i = a.maximum;
  }
  if (D(e) && (e = D(s) ? o : s), D(i) && (i = D(s) ? r : s), !t && (D(e) || D(i))) {
    var h2 = this.getStencilSize(), c2 = h2 ? ct(h2) : null;
    D(e) && (e = P(c2) ? c2 : void 0), D(i) && (i = P(c2) ? c2 : void 0);
  }
  return { minimum: e, maximum: i };
}, getStencilSize: function() {
  if (this.stencilSize)
    return t = { currentStencilSize: { width: this.stencilCoordinates.width, height: this.stencilCoordinates.height }, stencilSize: this.stencilSize, boundaries: this.boundaries, coefficient: this.coefficient, coordinates: this.coordinates, aspectRatio: this.getAspectRatio(true) }, e = t.boundaries, i = t.stencilSize, n = t.aspectRatio, dt(ct(s = O(i) ? i({ boundaries: e, aspectRatio: n }) : i), n) && (s = Mt({ sizeRestrictions: { maxWidth: e.width, maxHeight: e.height, minWidth: 0, minHeight: 0 }, width: s.width, height: s.height, aspectRatio: { minimum: n.minimum, maximum: n.maximum } })), (s.width > e.width || s.height > e.height) && (s = Mt({ sizeRestrictions: { maxWidth: e.width, maxHeight: e.height, minWidth: 0, minHeight: 0 }, width: s.width, height: s.height, aspectRatio: { minimum: ct(s), maximum: ct(s) } })), s;
  var t, e, i, n, s;
}, getPublicProperties: function() {
  return { coefficient: this.coefficient, visibleArea: this.visibleArea, coordinates: this.coordinates, boundaries: this.boundaries, sizeRestrictions: this.sizeRestrictions, positionRestrictions: this.positionRestrictions, aspectRatio: this.getAspectRatio(), imageRestriction: this.imageRestriction };
}, defaultCoordinates: function() {
  return g({}, J);
}, flip: function(t, e) {
  var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, n = i.transitions, s = void 0 === n || n;
  if (!this.transitionsActive) {
    s && this.enableTransitions();
    var o = g({}, this.imageTransforms.flip), r = $t({ flip: { horizontal: t ? !o.horizontal : o.horizontal, vertical: e ? !o.vertical : o.vertical }, previousFlip: o, rotate: this.imageTransforms.rotate, visibleArea: this.visibleArea, coordinates: this.coordinates, imageSize: this.imageSize, positionRestrictions: this.positionRestrictions, sizeRestrictions: this.sizeRestrictions, getAreaRestrictions: this.getAreaRestrictions, aspectRatio: this.getAspectRatio() }), a = r.visibleArea, h2 = r.coordinates;
    t && (this.appliedImageTransforms.flip.horizontal = !this.appliedImageTransforms.flip.horizontal), e && (this.appliedImageTransforms.flip.vertical = !this.appliedImageTransforms.flip.vertical), this.visibleArea = a, this.coordinates = h2, this.onChange(), s && this.debouncedDisableTransitions();
  }
}, rotate: function(t) {
  var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, i = e.transitions, n = void 0 === i || i;
  if (!this.transitionsActive) {
    n && this.enableTransitions();
    var s = g({}, this.imageSize);
    this.appliedImageTransforms.rotate += t;
    var o = Pt({ visibleArea: this.visibleArea, coordinates: this.coordinates, previousImageSize: s, imageSize: this.imageSize, angle: t, positionRestrictions: this.positionRestrictions, sizeRestrictions: this.sizeRestrictions, getAreaRestrictions: this.getAreaRestrictions, aspectRatio: this.getAspectRatio() }), r = o.visibleArea, a = o.coordinates, h2 = this.processAutoZoom("rotateImage", r, a);
    r = h2.visibleArea, a = h2.coordinates, this.visibleArea = r, this.coordinates = a, this.onChange(), n && this.debouncedDisableTransitions();
  }
} }, emits: ["change", "error", "ready"] }, ve = { key: 0, ref: "canvas", style: { display: "none" } }, be = { key: 1, ref: "sourceCanvas", style: { display: "none" } };
fe.render = function(i, n, r, a, p2, g2) {
  return openBlock(), createBlock("div", { ref: "cropper", class: g2.classes.cropper }, [createVNode("div", { ref: "stretcher", class: g2.classes.stretcher }, null, 2), createVNode("div", { class: g2.classes.boundaries, style: g2.boundariesStyle }, [(openBlock(), createBlock(resolveDynamicComponent(r.backgroundWrapperComponent), { class: g2.classes.cropperWrapper, "wheel-resize": g2.settings.resizeImage.wheel, "touch-resize": g2.settings.resizeImage.touch, "touch-move": g2.settings.moveImage.touch, "mouse-move": g2.settings.moveImage.mouse, onMove: g2.onManipulateImage, onResize: g2.onManipulateImage }, { default: withCtx(function() {
    return [createVNode("div", { class: g2.classes.background, style: g2.boundariesStyle }, null, 6), createVNode("div", { class: g2.classes.imageWrapper }, [createVNode("img", { ref: "image", crossorigin: p2.imageAttributes.crossOrigin, src: p2.imageAttributes.src, class: g2.classes.image, style: g2.imageStyle, onMousedown: n[1] || (n[1] = withModifiers(function() {
    }, ["prevent"])) }, null, 46, ["crossorigin", "src"])], 2), createVNode("div", { class: g2.classes.foreground, style: g2.boundariesStyle }, null, 6), withDirectives((openBlock(), createBlock(resolveDynamicComponent(r.stencilComponent), mergeProps({ ref: "stencil", image: g2.image, coordinates: p2.coordinates, "stencil-coordinates": g2.stencilCoordinates, transitions: g2.transitionsOptions }, r.stencilProps, { onResize: g2.onResize, onResizeEnd: g2.onResizeEnd, onMove: g2.onMove, onMoveEnd: g2.onMoveEnd }), null, 16, ["image", "coordinates", "stencil-coordinates", "transitions", "onResize", "onResizeEnd", "onMove", "onMoveEnd"])), [[vShow, p2.imageLoaded]]), r.canvas ? (openBlock(), createBlock("canvas", ve, null, 512)) : createCommentVNode("", true), r.canvas ? (openBlock(), createBlock("canvas", be, null, 512)) : createCommentVNode("", true)];
  }), _: 1 }, 8, ["class", "wheel-resize", "touch-resize", "touch-move", "mouse-move", "onMove", "onResize"]))], 6)], 2);
};
export {
  VForm as $,
  popScopeId as A,
  fuzzysort as B,
  resolveDirective as C,
  withDirectives as D,
  Emitter as E,
  Fragment as F,
  VCardTitle as G,
  VTextField as H,
  VList as I,
  VListItem as J,
  VListItemTitle as K,
  VCard as L,
  vShow as M,
  resolveComponent as N,
  VToolbarTitle as O,
  VSpacer as P,
  VToolbar as Q,
  mustache as R,
  sift as S,
  qs as T,
  lib as U,
  VBtn as V,
  withModifiers as W,
  VTooltip as X,
  normalizeProps as Y,
  guardReactiveProps as Z,
  _$1 as _,
  components as a,
  pAll$1 as a0,
  VApp as a1,
  VScrollYTransition as a2,
  VSnackbar as a3,
  VThemeProvider as a4,
  vModelText as a5,
  VAvatar as a6,
  VChip as a7,
  resolveDynamicComponent as a8,
  VChipGroup as a9,
  VFileInput as aa,
  vModelSelect as ab,
  lodashExports as ac,
  normalizeStyle as ad,
  createRouter as ae,
  createWebHashHistory as af,
  createApp as ag,
  plugin as ah,
  VueShortkey as ai,
  install as aj,
  h as ak,
  axios$2 as b,
  createVuetify as c,
  directives as d,
  axios as e,
  _export_sfc as f,
  createElementBlock as g,
  createBaseVNode as h,
  createCommentVNode as i,
  autoBind$1 as j,
  dayjs as k,
  relativeTime as l,
  createBlock as m,
  normalizeClass as n,
  openBlock as o,
  createVNode as p,
  mergeProps as q,
  renderList as r,
  VIcon as s,
  toDisplayString as t,
  createTextVNode as u,
  VDivider as v,
  withCtx as w,
  VMenu as x,
  VProgressLinear as y,
  pushScopeId as z
};
